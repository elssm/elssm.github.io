<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ELSSM</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="elssm.github.io/"/>
  <updated>2021-04-19T12:37:47.975Z</updated>
  <id>elssm.github.io/</id>
  
  <author>
    <name>elssm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自编码器生成MNIST(Pytorch)</title>
    <link href="elssm.github.io/2021/04/19/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8%E7%94%9F%E6%88%90MNIST-Pytorch/"/>
    <id>elssm.github.io/2021/04/19/自编码器生成MNIST-Pytorch/</id>
    <published>2021-04-19T11:32:18.000Z</published>
    <updated>2021-04-19T12:37:47.975Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自编码器介绍"><a href="#自编码器介绍" class="headerlink" title="自编码器介绍"></a>自编码器介绍</h4><p>自编码器主要是由编码器(Encoder)和解码器(Decoder)组成，它是一个试图去还原原始输入的一个系统。在深度学习中，自编码器是一种无监督的神经网络模型。它可以学习到输入数据的隐含特征，同时通过学习到的特征可以重构出原始数据。它类似于PCA，可以起到特征提取器的功能。</p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/1.png" alt="1"></p><h4 id="自编码器生成MNIST"><a href="#自编码器生成MNIST" class="headerlink" title="自编码器生成MNIST"></a>自编码器生成MNIST</h4><h5 id="导入相关模块"><a href="#导入相关模块" class="headerlink" title="导入相关模块"></a>导入相关模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> data</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br></pre></td></tr></table></figure><h5 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">epochs = <span class="number">10</span></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">device = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h5 id="建立文件夹保存数据"><a href="#建立文件夹保存数据" class="headerlink" title="建立文件夹保存数据"></a>建立文件夹保存数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"ae_img"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"ae_img"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"test_ae_img"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"test_ae_img"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"params"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"params"</span>)</span><br></pre></td></tr></table></figure><h5 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydataset = MNIST(root=<span class="string">"./mnist_data/"</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">dataloader = data.DataLoader(dataset=mydataset,shuffle=<span class="literal">True</span>,batch_size=batch_size)</span><br><span class="line">test_data = MNIST(root=<span class="string">"./mnist_data/"</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transforms)</span><br><span class="line">test_loader = data.DataLoader(dataset=test_data, shuffle=<span class="literal">True</span>, batch_size=batch_size)</span><br></pre></td></tr></table></figure><h5 id="定义编码器网络"><a href="#定义编码器网络" class="headerlink" title="定义编码器网络"></a>定义编码器网络</h5><p>在这里编码器网络采用两个卷积层和一个全连接层。并进行了归一化处理，激活函数使用<code>ReLU</code>激活函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(EncoderNet,self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">3</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">        )<span class="comment">#N,3,14,14</span></span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">6</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">        )<span class="comment">#N,6,7,7</span></span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">6</span>*<span class="number">7</span>*<span class="number">7</span>,<span class="number">128</span>),</span><br><span class="line">        )<span class="comment">#N,128</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        y1 = self.conv1(x)</span><br><span class="line">        y2 = self.conv2(y1)</span><br><span class="line">        <span class="comment"># print("encoder_y2",y2.shape) #[100, 6, 7, 7]</span></span><br><span class="line">        y2 = torch.reshape(y2,[y2.size(<span class="number">0</span>),<span class="number">-1</span>]) <span class="comment">#要经过全连接层，将4维转为2维,[100,294]</span></span><br><span class="line">        out = self.fc(y2)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h5 id="定义解码器网络"><a href="#定义解码器网络" class="headerlink" title="定义解码器网络"></a>定义解码器网络</h5><p>解码器网络和编码器网络相反，拿到编码器的输出，通过一个全连接层放大维度，之后是通过两个逆卷积层扩大图像的尺寸，扩大到<code>28*28</code>和MNIST原始数据集尺寸大小相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoderNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(DecoderNet,self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">128</span>,<span class="number">6</span>*<span class="number">7</span>*<span class="number">7</span>),</span><br><span class="line">            nn.BatchNorm1d(<span class="number">6</span>*<span class="number">7</span>*<span class="number">7</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )<span class="comment">#7,7</span></span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">6</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,output_padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">3</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )<span class="comment">#14,14</span></span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,output_padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )<span class="comment">#28,28</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        y1 = self.fc(x) <span class="comment">#[100,294]</span></span><br><span class="line">        <span class="comment"># print("decoder_y1", y1.shape)</span></span><br><span class="line">        y1 = torch.reshape(y1,[y1.size(<span class="number">0</span>),<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>]) <span class="comment">#全连接之后，从二维转为四维</span></span><br><span class="line">        y2 = self.conv1(y1)</span><br><span class="line">        out = self.conv2(y2)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h5 id="定义自编码器网络"><a href="#定义自编码器网络" class="headerlink" title="定义自编码器网络"></a>定义自编码器网络</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.encoder = EncoderNet()</span><br><span class="line">        self.decoder = DecoderNet()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        encoder_out = self.encoder(x)</span><br><span class="line">        decoder_out = self.decoder(encoder_out)</span><br><span class="line">        <span class="keyword">return</span> decoder_out</span><br></pre></td></tr></table></figure><h5 id="实例化模型"><a href="#实例化模型" class="headerlink" title="实例化模型"></a>实例化模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = Net()</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure><h5 id="定义优化器和损失函数"><a href="#定义优化器和损失函数" class="headerlink" title="定义优化器和损失函数"></a>定义优化器和损失函数</h5><p>损失函数我们这里使用的是均方损失函数，因为这里我们衡量的是真实图片和自编码器生成的图片的损失，采用均方差计算损失会好一些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.Adam(model.parameters(),<span class="number">0.001</span>)</span><br><span class="line">criterion = nn.MSELoss()</span><br></pre></td></tr></table></figure><h5 id="定义训练函数"><a href="#定义训练函数" class="headerlink" title="定义训练函数"></a>定义训练函数</h5><p>在每一轮训练中加载训练数据集，并计算真实数据和生成数据的损失，之后进行梯度优化。并将真实图片和生成的图片保存在文件夹中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,num_epochs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> i, (data, label) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">            img = data.to(device)</span><br><span class="line">            out_img = model(img)</span><br><span class="line">            loss = criterion(out_img, img)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"epoch:&#123;&#125;,iteration:&#123;&#125;/&#123;&#125;,loss:&#123;:.3f&#125;"</span>.format(epoch, i, len(dataloader), loss.float()))</span><br><span class="line">            fake_image = out_img.cpu().data</span><br><span class="line">            real_image = img.cpu().data</span><br><span class="line">            save_image(fake_image, <span class="string">"./ae_img/epoch-&#123;&#125;-fake_img.jpg"</span>.format(epoch), nrow=<span class="number">10</span>)</span><br><span class="line">            save_image(real_image, <span class="string">"./ae_img/epoch-&#123;&#125;-real_img.jpg"</span>.format(epoch), nrow=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h5 id="保存训练模型"><a href="#保存训练模型" class="headerlink" title="保存训练模型"></a>保存训练模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">"./params/model.pth"</span>)</span><br></pre></td></tr></table></figure><h5 id="定义测试函数"><a href="#定义测试函数" class="headerlink" title="定义测试函数"></a>定义测试函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader,num_epochs)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> i, (img, label) <span class="keyword">in</span> enumerate(test_loader):</span><br><span class="line">            img = img.to(device)</span><br><span class="line">            out_img = model(img)</span><br><span class="line">            loss = criterion(out_img, img)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"epoch:&#123;&#125;,loss:&#123;:.3f&#125;"</span>.format(epoch, loss.float()))</span><br><span class="line">            fake_image = out_img.cpu().data</span><br><span class="line">            real_image = img.cpu().data</span><br><span class="line">            save_image(fake_image, <span class="string">"./test_ae_img/epoch-&#123;&#125;-fake_img.jpg"</span>.format(epoch), nrow=<span class="number">10</span>)</span><br><span class="line">            save_image(real_image, <span class="string">"./test_ae_img/epoch-&#123;&#125;-real_img.jpg"</span>.format(epoch), nrow=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h5 id="模型测试"><a href="#模型测试" class="headerlink" title="模型测试"></a>模型测试</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    train_model(model,dataloader,optimizer,epochs)</span><br><span class="line">    test_model(model,test_loader,epochs)</span><br></pre></td></tr></table></figure><h5 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h5><p>训练数据</p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/2.png" alt="2"></p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/3.png" alt="3"></p><p>测试数据</p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/4.png" alt="4"></p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/5.png" alt="5"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;自编码器介绍&quot;&gt;&lt;a href=&quot;#自编码器介绍&quot; class=&quot;headerlink&quot; title=&quot;自编码器介绍&quot;&gt;&lt;/a&gt;自编码器介绍&lt;/h4&gt;&lt;p&gt;自编码器主要是由编码器(Encoder)和解码器(Decoder)组成，它是一个试图去还原原始输入的一个系统
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SVHN数据集识别(Pytorch)</title>
    <link href="elssm.github.io/2021/04/09/SVHN%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB-Pytorch/"/>
    <id>elssm.github.io/2021/04/09/SVHN数据集识别-Pytorch/</id>
    <published>2021-04-09T09:42:03.000Z</published>
    <updated>2021-04-19T14:25:03.598Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SVHN数据集介绍"><a href="#SVHN数据集介绍" class="headerlink" title="SVHN数据集介绍"></a>SVHN数据集介绍</h4><p>SVHN数据集是摘自Google街景图像中的门牌号，其风格与MNIST相似。其中包含了10个类别，数字1～9对应标签1～9，而“0”的标签则为10。其中训练集有73257张图像，测试集有26032张图像。</p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/1.png" alt="1"></p><h4 id="Pytorch识别SVHN数据集"><a href="#Pytorch识别SVHN数据集" class="headerlink" title="Pytorch识别SVHN数据集"></a>Pytorch识别SVHN数据集</h4><h5 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br></pre></td></tr></table></figure><h5 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h5><p>其中<code>Resize</code>是对图像大小重新设定，<code>ColorJitter</code>可以改变图像的属性，例如亮度、对比度、饱和度和色调，<code>RandomRotation</code>可以使得图像在设定的角度范围内随机旋转。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">epochs = <span class="number">5</span></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">128</span>,<span class="number">128</span>)), </span><br><span class="line">    transforms.ColorJitter(<span class="number">0.3</span>,<span class="number">0.3</span>,<span class="number">0.2</span>),</span><br><span class="line">    transforms.RandomRotation(<span class="number">5</span>), </span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize([<span class="number">0.485</span>,<span class="number">0.465</span>,<span class="number">0.406</span>],[<span class="number">0.229</span>,<span class="number">0.224</span>,<span class="number">0.225</span>])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h5 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_set = datasets.SVHN(<span class="string">"data_svhn"</span>,<span class="string">"train"</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">test_set = datasets.SVHN(<span class="string">"data_svhn"</span>,<span class="string">"test"</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h5 id="网络定义"><a href="#网络定义" class="headerlink" title="网络定义"></a>网络定义</h5><p> 卷就完事了！4这里我采用了3个卷积层，激活函数使用的是Relu，还加入了池化操作，用了一个全连接层。在进行<code>nn.Linear</code>操作之前要使用<code>view</code>将四维拉成二维，因为全连接层的输入与输出都是二维张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVHN_Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SVHN_Net,self).__init__()</span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">64</span>,<span class="number">3</span>,<span class="number">2</span>), <span class="comment">#64*63*63</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#64*31*31</span></span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">64</span>,<span class="number">3</span>), <span class="comment">#64 * 29 * 29</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#64*14*14</span></span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">32</span>,<span class="number">2</span>), <span class="comment">#32 * 13 * 13</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>) <span class="comment">#32 * 6 * 6</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">32</span>*<span class="number">6</span>*<span class="number">6</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        cnn_res = self.cnn(x)</span><br><span class="line">        cnn_res = cnn_res.view(cnn_res.size(<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        f1 = self.fc1(cnn_res)</span><br><span class="line">        <span class="keyword">return</span> f1</span><br></pre></td></tr></table></figure><h5 id="实例化模型和优化器"><a href="#实例化模型和优化器" class="headerlink" title="实例化模型和优化器"></a>实例化模型和优化器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = SVHN_Net()</span><br><span class="line">optimizer = optim.Adam(model.parameters(),<span class="number">0.001</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure><h5 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,epoch)</span>:</span></span><br><span class="line">    <span class="comment">#模型训练</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_index,(data,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = criterion(output,target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_index % <span class="number">200</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epoch,loss.item()))</span><br></pre></td></tr></table></figure><h5 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> test_loader:</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(test_loader.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(test_loader.dataset)))</span><br></pre></td></tr></table></figure><h5 id="调用训练和测试模型"><a href="#调用训练和测试模型" class="headerlink" title="调用训练和测试模型"></a>调用训练和测试模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs+<span class="number">1</span>):</span><br><span class="line">    train_model(model,train_loader,optimizer,epoch)</span><br><span class="line">    test_model(model,test_loader)</span><br></pre></td></tr></table></figure><h5 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h5><p>….好家伙这也太低了</p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/2.png" alt="2"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/3.png" alt="3"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/4.png" alt="4"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/5.png" alt="5"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/6.png" alt="6"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/7.png" alt="7"></p><h4 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVHN_Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SVHN_Net,self).__init__()</span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">16</span>,<span class="number">3</span>,<span class="number">2</span>), <span class="comment">#64*63*63</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#64*31*31</span></span><br><span class="line">            nn.Conv2d(<span class="number">16</span>,<span class="number">32</span>,<span class="number">3</span>), <span class="comment">#64 * 29 * 29</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#64*14*14</span></span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">2</span>), <span class="comment">#64 * 13 * 13</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">2</span>), <span class="comment">#128 * 12 * 12</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#128 * 6 * 6</span></span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">128</span>,<span class="number">3</span>), <span class="comment">#128 *4 *4</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#128 *2 *2</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">128</span> *<span class="number">2</span> *<span class="number">2</span>,<span class="number">128</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">128</span>,<span class="number">11</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        cnn_res = self.cnn(x)</span><br><span class="line">        cnn_res = cnn_res.view(cnn_res.size(<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        f1 = self.fc1(cnn_res)</span><br><span class="line">        f1 = self.fc2(f1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f1</span><br></pre></td></tr></table></figure><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/8.png" alt="8"></p><h4 id="再次优化"><a href="#再次优化" class="headerlink" title="再次优化"></a>再次优化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#准确率达93.4%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ColorJitter(<span class="number">0.3</span>,<span class="number">0.3</span>,<span class="number">0.2</span>),</span><br><span class="line">    transforms.RandomRotation(<span class="number">5</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize([<span class="number">0.485</span>,<span class="number">0.465</span>,<span class="number">0.406</span>],[<span class="number">0.229</span>,<span class="number">0.224</span>,<span class="number">0.225</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = datasets.SVHN(<span class="string">"data_svhn"</span>,<span class="string">"train"</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">test_set = datasets.SVHN(<span class="string">"data_svhn"</span>,<span class="string">"test"</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"下载完成"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVHN_Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SVHN_Net,self).__init__()</span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">32</span>,<span class="number">3</span>), <span class="comment">#32*30*30</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>), <span class="comment">#32 * 28 * 28</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#32*14*14</span></span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">3</span>), <span class="comment">#64 * 12 * 12</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">3</span>), <span class="comment">#128 * 10 * 10</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#128*5*5</span></span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">128</span>,<span class="number">3</span>), <span class="comment">#128 *3 *3</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#128 *1 *1</span></span><br><span class="line">            nn.Dropout(<span class="number">0.4</span>),</span><br><span class="line">            <span class="comment"># nn.Conv2d(128,64,2), #64 *1 *1</span></span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">128</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="comment"># print(x.shape)</span></span><br><span class="line">        cnn_res = self.cnn(x)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #32 * 128 *1 *1</span></span><br><span class="line">        cnn_res = cnn_res.view(cnn_res.size(<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #16*96</span></span><br><span class="line">        f1 = self.fc1(cnn_res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f1</span><br><span class="line"></span><br><span class="line">model = SVHN_Net()</span><br><span class="line">model = model.to(device)</span><br><span class="line">optimizer = optim.Adam(model.parameters(),<span class="number">0.0001</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,epoch)</span>:</span></span><br><span class="line">    <span class="comment">#模型训练</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_index,(data,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        data,target = data.to(device),target.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = criterion(output,target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_index % <span class="number">400</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epoch,loss.item()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> test_loader:</span><br><span class="line">            data,target = data.to(device),target.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(test_loader.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(test_loader.dataset)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs+<span class="number">1</span>):</span><br><span class="line">    train_model(model,train_loader,optimizer,epoch)</span><br><span class="line">    test_model(model,test_loader)</span><br></pre></td></tr></table></figure><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/9.png" alt="9"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;SVHN数据集介绍&quot;&gt;&lt;a href=&quot;#SVHN数据集介绍&quot; class=&quot;headerlink&quot; title=&quot;SVHN数据集介绍&quot;&gt;&lt;/a&gt;SVHN数据集介绍&lt;/h4&gt;&lt;p&gt;SVHN数据集是摘自Google街景图像中的门牌号，其风格与MNIST相似。其中包含
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>区块链笔记</title>
    <link href="elssm.github.io/2021/04/02/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2021/04/02/区块链笔记/</id>
    <published>2021-04-02T12:43:39.000Z</published>
    <updated>2021-04-16T04:12:58.668Z</updated>
    
    <content type="html"><![CDATA[<h4 id="区块链产生"><a href="#区块链产生" class="headerlink" title="区块链产生"></a>区块链产生</h4><ul><li>密码朋克：通过匿名性来保护隐私安全</li><li>不可篡改文件记录：加时间戳到文件内容中，证实数据真实存在</li><li>数字现金</li></ul><h4 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h4><ul><li>2009年，比特币诞生1.0</li><li>2014年，以太坊诞生2.0</li><li>2018年中期，EOS主网上线3.0</li><li>Fabric</li></ul><h4 id="区块链场景概念"><a href="#区块链场景概念" class="headerlink" title="区块链场景概念"></a>区块链场景概念</h4><ul><li>数字货币：可以与现金流进行等价交换，拥有现有现金流的属性和功能</li><li>ICO：众筹</li><li>电子钱包：在电商购物中的支付工具</li></ul><h4 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h4><ul><li>区块链是一种集成了点对点传输协议，现代密码学，共识算法，分布数据存储的新型应用模型</li></ul><h4 id="区块链特点"><a href="#区块链特点" class="headerlink" title="区块链特点"></a>区块链特点</h4><ul><li>可追溯</li><li>不可篡改</li><li>去中心化</li><li>完整备份</li><li>历史记录</li><li>交易广播</li></ul><h4 id="区块链加密货币特点"><a href="#区块链加密货币特点" class="headerlink" title="区块链加密货币特点"></a>区块链加密货币特点</h4><ul><li>独立性：所有货币都是独立存在的</li><li>唯一性：地址、交易都具有不重复的唯一性</li><li>匿名性：账户信息和个人信息没有关联，整个交易过程全程加密</li><li>不可伪造</li></ul><h4 id="区块链核心技术"><a href="#区块链核心技术" class="headerlink" title="区块链核心技术"></a>区块链核心技术</h4><ul><li>点对点传输协议：在网络中的数据流通方式</li><li>现代密码学：在区块链中的应用：公私钥签名，哈希算法</li><li>共识算法：数据一致性</li><li>分布式数据存储：实现去中心化的重要技术依据</li></ul><h4 id="区块链核心概念"><a href="#区块链核心概念" class="headerlink" title="区块链核心概念"></a>区块链核心概念</h4><ul><li><p>区块链</p><ul><li>本质：一个分布式账本，通过共识算法来决定谁能抢到当前的记账权。区块链以区块为单位，以区块产生的时间顺序去进行连接。</li></ul></li><li><p>区块</p><ul><li>概念：区块链的基本组成单位</li><li>区块头<ul><li>时间戳</li><li>当前区块哈希</li><li>父区块哈希</li><li>随机数</li><li>Merkle树</li><li>区块号码</li></ul></li><li>区块体：交易数据</li></ul></li><li><p>分布式数据库：区块链中的区块数据都会存储在每一个节点中，所有的节点组成一个分布式数据库。</p></li><li><p>节点</p><ul><li>可以理解称为一个运行区块软件的计算机</li><li>分类<ul><li>全节点：保存了完整的区块链的副本，安全性极高，效率不高</li><li>轻节点：不保存所有的区块，需要依赖全节点进行验证，效率更高，安全不如全节点</li><li>挖矿节点：带有挖矿功能的全节点，专门处理交易验证</li></ul></li></ul></li><li><p>挖矿</p><ul><li>对交易进行验证处理(记账)，区块就是通过挖矿产生的</li><li>穷举随机数算法，生成哈希，与目标哈希进行比较，成功则说明挖矿成功</li></ul></li><li><p>分叉</p><ul><li><p>升级分叉</p><p>矿工遵从不同的机制(规则)导致分叉</p><p>硬分叉：如果区块链共识规则改变之后，不允许前向兼容，旧节点没有办法认可新节点产生的区块</p><p>软分叉：如果区块链共识规则改变之后，允许前向兼容，旧节点可以兼容新节点产生的区块</p></li><li><p>挖矿分叉</p><p>现象：两个或者多个矿工，同时完成了工作量证明，就会产生两个新的区块，形成分叉</p><p>解决方案：不同矿工跟随了不同的区块，但是不同链算力会有区别，矿工的数量一样，链的增长速度就不会相同，最终会出现一条链更长，这条就会变成主链。</p></li></ul></li><li><p>交易</p><ul><li>概念：一笔资产在参与者之间的转移</li><li>内容<ul><li>金额</li><li>发送者</li><li>接受者</li><li>交易ID(HASH)</li></ul></li></ul></li><li><p>双花</p><ul><li><p>概念：复用数字货币的数字特性，可以完成两次或者多次支付</p></li><li><p>传统的虚拟货币之所以可以避免双花是因为有可依赖的第三方机构提供保证</p></li><li><p>区块链中需要达成只通过分布式节点之间的相互校验与共识来避免双花，同时完成价值转移</p></li></ul></li><li><p>UTXO(unspent transaction output)交易模式</p><ul><li>是比特币独有的交易模式，比特币交易过程中的基本单位，主要就是为了避免双花</li></ul></li><li><p>哈希</p><ul><li>将任意的原始数据(交易记录)通过指定哈希函数，编码为特定长度的字符串</li><li>在区块链中的使用：生成地址，交易验证</li><li>特点<ul><li>不可逆</li><li>随机性</li><li>时间正相关：输入的源数据越长，哈希的处理时间就越长</li></ul></li></ul></li><li><p>加密算法</p><ul><li>对称加密：加密与解密都是用相同的密钥</li><li>非对称加密<ul><li>采用公钥和私钥进行加密</li><li>无法用公钥反推私钥</li></ul></li></ul></li><li><p>数字签名</p></li><li><p>Merkle树</p><ul><li>Merkle树可以是二叉树，也可以是多叉树，它具有树的所有特点</li><li>在区块链中的作用：快速校验、归纳交易完整性</li><li>在区块链中，Merkle树可以极大的提高查询效率，区块头只需要保存一个Merkle根的hash</li><li>Merkle支持SPV</li></ul></li><li><p>P2P</p><ul><li>通过对等网络来分配工作任务的分布式应用架构</li><li>由于在P2P中，所有网络节点的地位是对等的，不存在任何一个中心化节点，也不存在所谓的层级结构，所以每个节点都需要承担验证区块数据等功能</li></ul></li></ul><h4 id="区块链的分类"><a href="#区块链的分类" class="headerlink" title="区块链的分类"></a>区块链的分类</h4><ul><li>公有链：真正意义上的去中心化分布式区块链，任何一个节点都可以随时加入/退出网络中</li><li>私有链：部分中心化的区块链，具有一定的分布式特点，但是有一个中心节点，可以指定参与者</li><li>联盟链：部分去中心化的区块链，拥有权限控制的功能<ul><li>代表：Fabric</li></ul></li></ul><h4 id="区块链架构特点"><a href="#区块链架构特点" class="headerlink" title="区块链架构特点"></a>区块链架构特点</h4><ul><li>去中心化：基于分布式系统，整个网络总没有中心机构存在</li><li>可靠数据库：分布式存储，参与系统的节点越多，数据库的安全性就越高</li><li>开源可编程：区块链提供了灵活的脚本系统甚至于完善的开发平台，支持用户创建更加高级的应用</li><li>集体维护：区块链中的数据由整个系统中所有具有记账功能的节点进行维护</li><li>安全可信：通过现代密码学实现</li><li>准匿名性：采用与身份信息无关的hash作为身份地址与交易ID</li></ul><h4 id="应用分析"><a href="#应用分析" class="headerlink" title="应用分析"></a>应用分析</h4><ul><li><p>比特币</p><p>架构</p><ul><li><p>前端</p><p>钱包：保存用户私钥，管理用户余额，提供比特币交易</p><p>钱包分类</p><ul><li><p>决定性钱包：所有的私钥都由一个私钥种子通过单向哈希算法生成</p><p>普通决定性钱包：由私钥种子一次性生成所有私钥</p><p>层级决定性钱包：由私钥种子生成父私钥，父私钥生成种子私钥</p></li><li><p>非决定性钱包：直接保存私钥，私钥直接放在DB</p></li></ul><p>展示方式的分类</p><p>​    桌面钱包</p><p>​        1.厚钱包：下载整条区块链，可以完整交易，安全性高，验证成本高</p><p>​        2.薄钱包：不会下载整条区块链，采用部分存储+节点请求验证的方式</p><p>​        3.离线钱包：USB设备，纸钱包，可以有效防范网络攻击</p><p>​    HTTP/JSON RPC API</p><p>​        1.比特币提供的接口，可以使外部通过该接口访问或者控制比特币</p><p>​    命令行接口</p><p>​        1.通过命令行的方式实现类似钱包的功能</p><p>​    浏览器</p><p>​        1.访问区块链的区块数据等信息</p><p>​    节点后台：负责参与比特币网络的通信，区块链的维护，验证，交易</p><p>​    比特币地址</p><p>​        1.基本概念：由哈希生成</p><p>​        2.生成过程：</p><p>​            1.随机数生成私钥</p><p>​            2.采用Secp256k1椭圆加密算法生成公钥</p><p>​        3.生成地址</p><p>​            1.以公钥作为输入，进行SHA256，再进行RIPEMD160，最后通过base58编码生成比特币地址</p><p>​    比特币区块校验：确保确实完成了工作量证明 </p><p>​            1.校验内容：格式、难度、时间戳、大小、交易</p><p>​    比特币交易</p><p>​        1.交易结构</p><p>​            1.输入(input)</p><p>​            2.输出(output)</p><p>​            3.交易ID(HASH)</p><p>​        2.说明</p><p>​            1.每一笔交易的输入来自于前面交易的输出</p><p>​        3.UTXO数据库：专门用来存储当前比特币中未被花费的输出</p></li></ul></li></ul><h4 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h4><ul><li>一个用于开发去中心化DAPP的分布式平台</li><li>智能合约：一个拥有自我校验与自我执行的协议</li><li>以太坊提供了非常方便的应用开发平台，对底层做了完善的封装，让开发者只需要关注与上层应用</li><li>共识：POW(ETHASH)</li></ul><h4 id="EOS"><a href="#EOS" class="headerlink" title="EOS"></a>EOS</h4><ul><li><p>一个用于开发去中心化DAPP的分布式平台</p></li><li><p>TPS有了极大的提高，能够达到百万级的TPS处理量</p></li><li><p>以太坊本身是一条公链，其中每个DAPP会消耗整条链上的资源</p></li><li><p>EOS本身不再是一条单纯的公链，它是一个区块链的基础架构，开发者可以自由再EOS上创建公链，链与</p><p>链之间不会影响彼此的资源使用，因此，不会出现单个应用占用的资源太多使得整个网络拥堵</p></li><li><p>共识算法：DPOS</p></li><li><p>EOS上的智能合约调用不需要手续费</p></li></ul><h4 id="Fabric-联盟链"><a href="#Fabric-联盟链" class="headerlink" title="Fabric(联盟链)"></a>Fabric(联盟链)</h4><ul><li>联盟链代表，与公链最大的区别在于不发行虚拟货币。</li><li>目标：实现一个通过权限管理区块链的底层基础框架。</li></ul><h4 id="比特币交易原理"><a href="#比特币交易原理" class="headerlink" title="比特币交易原理"></a>比特币交易原理</h4><ul><li><p>传统的web交易</p><p>账户<br>余额<br>参与者<br>货币</p></li><li><p>基本概念</p><ul><li>比特币系统中的交易没有余额的概念，它使用的是UTXO交易模型，在传统交易过程中所说的交易余额实际上指的是一个比特币钱包地址的UTXO集合</li></ul></li><li><p>交易组成</p><ul><li>在比特币中，交易主要由输入，输出，ID，交易时间组成</li></ul></li><li><p>UTXO交易模型</p><ul><li>比特币专有的交易模型</li><li>在比特币中，交易实际上就是不但查找指定钱包地址的UTXO集合，然后进行修改的过程</li><li>UTXO是比特币交易中最基本的单元，是不可拆分的</li></ul></li><li><p>交易过程</p><p>coinbase：挖矿奖励的比特币，没有发送者，由系统提供，所以不包含input</p><p>普通转账：正常的转账交易，有发送者参与，所以包含input</p></li></ul><h4 id="密码学回顾"><a href="#密码学回顾" class="headerlink" title="密码学回顾"></a>密码学回顾</h4><ul><li><p>在区块链中的用途</p><ul><li>地址生成</li><li>交易签名</li></ul></li><li><p>base64编码</p><ul><li>概念：用一种由64个字符来表示二进制数据的方法</li><li>作用：通常用于在HTTP中传递比较长的信息的处理方法</li><li>编码原理<ul><li>将给定的字符串进行整合，由3个8位转换为4个6位，在6位前面补0，对于要编码的数据(由字符串转换为二进制数据)如果不是3的倍数，最后余数只会是1或者2，Base64在末尾用\x00补足，而在编码展示的末尾，添加1个或者两个“=”，等号的个数代表补足的字节数，在解码的时候，自动将等号去掉。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/base64"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">s := <span class="string">"elssm"</span></span><br><span class="line">encode := base64.StdEncoding.EncodeToString([]<span class="keyword">byte</span>(s))</span><br><span class="line">fmt.Println(encode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/02/区块链笔记/2.png" alt="2"></p></li><li><p>base58编码</p><p>为什么需要base58编码</p><ul><li>在base64的基础上去掉了6个字符（0,O,大写I,小写l,+,/）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/big"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b58Alphabet = []<span class="keyword">byte</span>(<span class="string">""</span>+<span class="string">"123456789"</span>+<span class="string">"abcdefghijkmnopqrstuvwxyz"</span>+<span class="string">"ABCDEFGHJKLMNPQRSTUVWXYZ"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编码函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Base58Encode</span><span class="params">(input []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">//byte字节数组转换为big.int</span></span><br><span class="line">x := big.NewInt(<span class="number">0</span>).SetBytes(input)</span><br><span class="line"><span class="comment">//求余的基本长度</span></span><br><span class="line">base := big.NewInt(<span class="keyword">int64</span>(<span class="built_in">len</span>(b58Alphabet)))</span><br><span class="line"><span class="comment">//求余数和商</span></span><br><span class="line"><span class="comment">//判断条件，除掉的最终结果是否为0</span></span><br><span class="line">zero := big.NewInt(<span class="number">0</span>)</span><br><span class="line"><span class="comment">//设置余数，代表base58基数表的索引位置</span></span><br><span class="line">mod := &amp;big.Int&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> x.Cmp(zero) != <span class="number">0</span> &#123;</span><br><span class="line">x.DivMod(x,base,mod)</span><br><span class="line">result = <span class="built_in">append</span>(result,b58Alphabet[mod.Int64()])</span><br><span class="line">&#125;</span><br><span class="line">Reverse(result)</span><br><span class="line">result = <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;b58Alphabet[<span class="number">0</span>]&#125;,result...)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i,j :=<span class="number">0</span>,<span class="built_in">len</span>(data)<span class="number">-1</span>;i&lt;j;i,j = i+<span class="number">1</span>,j<span class="number">-1</span> &#123;</span><br><span class="line">data[i],data[j] = data[j],data[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Base58Decode</span><span class="params">(input []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">fmt.Println(input)</span><br><span class="line">result := big.NewInt(<span class="number">0</span>)</span><br><span class="line">zeroBytes := <span class="number">1</span></span><br><span class="line"><span class="comment">//去掉前缀</span></span><br><span class="line">data := input[zeroBytes:]</span><br><span class="line">fmt.Println(data)</span><br><span class="line"><span class="keyword">for</span> _,b := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="comment">//查找input中指定数字/字符在基数表中出现的索引(mod)</span></span><br><span class="line">charIndex := bytes.IndexByte(b58Alphabet,b)</span><br><span class="line"><span class="comment">//余数*58</span></span><br><span class="line">result.Mul(result,big.NewInt(<span class="number">58</span>))</span><br><span class="line"><span class="comment">//乘积结果+mod(索引)</span></span><br><span class="line">result.Add(result,big.NewInt(<span class="keyword">int64</span>(charIndex)))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line"><span class="comment">//转换为byte字节数组</span></span><br><span class="line">decoded := result.Bytes()</span><br><span class="line">fmt.Println(decoded)</span><br><span class="line"><span class="keyword">return</span> decoded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">result := Base58Encode([]<span class="keyword">byte</span>(<span class="string">"elssm"</span>))</span><br><span class="line">fmt.Printf(<span class="string">"result : %s\n"</span>,result)</span><br><span class="line">decodeResult := Base58Decode([]<span class="keyword">byte</span>(<span class="string">"1crFth1D"</span>))</span><br><span class="line">fmt.Printf(<span class="string">"decode Result : %s\n"</span>,decodeResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Go语言区块链简单实现"><a href="#Go语言区块链简单实现" class="headerlink" title="Go语言区块链简单实现"></a>Go语言区块链简单实现</h4><p>创建一个<code>Block.go</code>文件，定义一个最基本的区块结构,这个结构包含了区块最基本的一些东西。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">TimeStamp <span class="keyword">int64</span> <span class="comment">//区块时间戳</span></span><br><span class="line">Hash []<span class="keyword">byte</span> <span class="comment">//当前区块哈希</span></span><br><span class="line">PrevBlochHash []<span class="keyword">byte</span> <span class="comment">//前区块哈希</span></span><br><span class="line">Height <span class="keyword">int64</span> <span class="comment">//区块高度</span></span><br><span class="line">Data []<span class="keyword">byte</span> <span class="comment">//交易数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着实现一个建立区块的函数,这个函数就是对区块结构进行一些初始化。对于区块的hash我们单独实现一个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(height <span class="keyword">int64</span>,prevBlockHash []<span class="keyword">byte</span>,data []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> block Block</span><br><span class="line"></span><br><span class="line">block = Block&#123;</span><br><span class="line">TimeStamp: time.Now().Unix(),</span><br><span class="line">Hash: <span class="literal">nil</span>,</span><br><span class="line">PrevBlochHash: prevBlockHash,</span><br><span class="line">Height: height,</span><br><span class="line">Data: data,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成哈希</span></span><br><span class="line">block.SetHash()</span><br><span class="line"><span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区块哈希实现,因为在区块结构中区块高度和时间戳都是<code>int</code>型，因此我们要将<code>int</code>转为<code>[]byte</code>，转换可以通过go语言中的encoding/binary包实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(data <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">buffer := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">err := binary.Write(buffer,binary.BigEndian,data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">"int transact to []byte failed! %v\n"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buffer.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">SetHash</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//调用sha256实现哈希生成</span></span><br><span class="line"><span class="comment">//实现int-&gt;hash</span></span><br><span class="line">timeStampBytes := IntToHex(b.TimeStamp)</span><br><span class="line">heightBytes := IntToHex(b.Height)</span><br><span class="line">blockBytes := bytes.Join([][]<span class="keyword">byte</span>&#123;</span><br><span class="line">heightBytes,</span><br><span class="line">timeStampBytes,</span><br><span class="line">b.PrevBlochHash,</span><br><span class="line">b.Data,</span><br><span class="line">&#125;,[]<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">hash := sha256.Sum256(blockBytes)</span><br><span class="line">b.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个生成创世区块的函数，在函数内部调用生成区块的函数实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateGenesisBlock</span><span class="params">(data []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewBlock(<span class="number">1</span>,<span class="literal">nil</span>,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>BlockChain.go</code>文件，首先定义区块链的基本结构，因为区块链他是一种链式的，所有我们用切片这种数据结构来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">Blocks []*Block <span class="comment">//区块的切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化区块链</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockChainWithGenesisBlock</span><span class="params">()</span> *<span class="title">BlockChain</span></span> &#123;</span><br><span class="line"><span class="comment">//生成创世区块</span></span><br><span class="line">block := CreateGenesisBlock([]<span class="keyword">byte</span>(<span class="string">"init blockchain"</span>))</span><br><span class="line"><span class="keyword">return</span> &amp;BlockChain&#123;[]*Block&#123;block&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加区块到区块链中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">AddBlock</span><span class="params">(height <span class="keyword">int64</span>,prevBlockHash []<span class="keyword">byte</span>,data []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">newBlock := NewBlock(height,prevBlockHash,data)</span><br><span class="line">bc.Blocks = <span class="built_in">append</span>(bc.Blocks,newBlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>main.go</code>文件，进行一个简单的测试。首先创建一个创世区块，并添加两条新链，最后通过hash来判断是否上链成功。结果如下图，除了第一个创世区块没有prevhash值以外，后面的区块的prevhash值都是前一个区块的currenthash值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">bc := BLC.CreateBlockChainWithGenesisBlock()</span><br><span class="line"><span class="comment">//上链</span></span><br><span class="line">bc.AddBlock(bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Heigth+<span class="number">1</span>,bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Hash,[]<span class="keyword">byte</span>(<span class="string">"alice send 10 btc to bob"</span>))</span><br><span class="line">bc.AddBlock(bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Heigth+<span class="number">1</span>,bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Hash,[]<span class="keyword">byte</span>(<span class="string">"bob send 5 btc to troytan"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,block := <span class="keyword">range</span> bc.Blocks &#123;</span><br><span class="line">fmt.Printf(<span class="string">"prevBlockHash : %x , currentHash : %x\n"</span>,block.PrevBlochHash,block.Hash)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/02/区块链笔记/1.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;区块链产生&quot;&gt;&lt;a href=&quot;#区块链产生&quot; class=&quot;headerlink&quot; title=&quot;区块链产生&quot;&gt;&lt;/a&gt;区块链产生&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;密码朋克：通过匿名性来保护隐私安全&lt;/li&gt;
&lt;li&gt;不可篡改文件记录：加时间戳到文件内容中，证实数据真
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>AdvGAN学习</title>
    <link href="elssm.github.io/2021/04/01/AdvGAN%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/04/01/AdvGAN学习/</id>
    <published>2021-04-01T01:35:04.000Z</published>
    <updated>2021-04-01T05:27:40.111Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Generating-Adversarial-Examples-with-Adversarial-Networks"><a href="#Generating-Adversarial-Examples-with-Adversarial-Networks" class="headerlink" title="Generating Adversarial Examples with Adversarial Networks"></a>Generating Adversarial Examples with Adversarial Networks</h4><p><strong>论文链接：</strong><a href="https://arxiv.org/abs/1801.02610" target="_blank" rel="noopener">https://arxiv.org/abs/</a><a href="https://arxiv.org/abs/1801.02610" target="_blank" rel="noopener">1801.02610</a><br><strong>代码链接：</strong><a href="https://github.com/mathcbc/advGAN_pytorch" target="_blank" rel="noopener">https://github.com/mathcbc/advGAN_pytorch</a></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>为了更有效地生成感知真实的对抗性样本，本文提出一种基于GAN的方式来产生对抗样本。</p><p>1.训练一个产生扰动的前馈网络来产生不同的对抗性样本。</p><p>2.训练一判别网络来确保生成的样本是真实的。</p><p>3.应用了GAN网络在半白盒和黑盒设置中产生对抗性样本。</p><p>4.借助了CGAN的思想利用相似的范例生成高质量的图片。</p><h4 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h4><ul><li>训练了一个条件对抗性网络，直接生成对抗性实例，不仅可以生成感知逼真的实例，对不同目标模型的攻击成功率最高，而且生成过程更高效。</li><li>证明了AdvGAN可以通过训练一个提取的模型来攻击黑盒模型。我们提出用查询信息动态训练提取的模型，实现高黑盒攻击成功率和有针对性的黑盒攻击。</li><li>使用最先进的防御方法来抵御对抗性示例，并表明AdvGAN在当前防御下实现了更高的攻击成功率。</li></ul><h4 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h4><p>回顾了之前的一些对抗性例子和生成对抗网络。总结来看，对抗样本的生成方式无非是以下三种。</p><ul><li>基于梯度的生成方式（FGSM和PGD）</li><li>基于优化的生成方式（CW和JSMA）</li><li>基于GAN的生成方式</li></ul><p>作者提出了基于梯度和基于优化方式产生对抗样本的一些局限性。对于基于梯度来讲，在白盒攻击下攻击者需要完全清楚模型的参数。对于基于优化来讲，存在优化过程慢，只能优化每个特定实例的扰动等问题。相比之下，使用GAN来生成对抗样本，能够在不同防御下实现更高的攻击成功率。</p><h4 id="AdvGAN框架"><a href="#AdvGAN框架" class="headerlink" title="AdvGAN框架"></a>AdvGAN框架</h4><p><img src="/2021/04/01/AdvGAN学习/1.png" alt="1"></p><p>AdvGAN的整体框架如上图所示，主要包含三个部分。一个生成器G，一个判别器D和一个目标攻击网络模型f。从左边开始分析，生成器G会接受一张原始图像输入x，通过生成器G之后会生成一个微小的扰动G(x)，接着扰动实例x+G(x)会被分别送入判别器D和目标攻击网络模型f，判别器的任务是分辨生成数据和原始数据，判别器的作用是引导生成数据与原始类别数据不可区分。在目标攻击网络模型f中，扰动实例x+G(x)会作为输入参数，为了欺骗学习模型，作者先进行了白盒攻击，在白盒攻击下经过f输出对抗损失，对抗损失表示预测类别和要攻击到其错误分类类别的距离或者是与真实类别标签相反的距离。</p><p>其中在2014年Goodfellow提出的对抗损失可以被定义如下：</p><p><img src="/2021/04/01/AdvGAN学习/2.png" alt="2"></p><p>在这里判别器D的目标是分辨带有扰动的数据x+G(x)和原始数据x，其中真实数据是从真实类别中被采样的，目的是为了使得生成的数据尽可能的接近原始数据。</p><p>目标攻击网络模型f的损失被定义如下：</p><p><img src="/2021/04/01/AdvGAN学习/3.png" alt="3"></p><p>其中t是目标标签，$l_f$表示损失函数，在文中使用的是交叉熵损失来训练原始模型f。$L^f_{adv}$损失函数引导带有扰动的图像被错误分类成目标类别t。</p><p>为了限制扰动的大小，作者在L2 norm的基础上加了一个hinge loss，损失被定义如下：</p><p><img src="/2021/04/01/AdvGAN学习/4.png" alt="4"></p><p>这里c代表一个用户所定义的最大边界，可以稳定GAN的训练。</p><p>最终目标函数被表示为：</p><p><img src="/2021/04/01/AdvGAN学习/5.png" alt="5"></p><p>其中$\alpha$和$\beta$用来控制每个损失函数之间的相对重要程度$L^f_{adv}$用来生成对抗样本，$L_{GAN}$是为了使带有扰动的数据与原始数据相似，$L_{hinge}$用来限制perturbation的大小。</p><h4 id="生成对抗网络进行黑盒攻击"><a href="#生成对抗网络进行黑盒攻击" class="headerlink" title="生成对抗网络进行黑盒攻击"></a>生成对抗网络进行黑盒攻击</h4><h5 id="静态蒸馏"><a href="#静态蒸馏" class="headerlink" title="静态蒸馏"></a>静态蒸馏</h5><p>对于黑盒攻击，我们假设攻击者对于训练数据和需要攻击的模型没有先验知识。在我们进行的实验中，因为我们假设攻击者对于训练数据和模型没有先验知识，因此我们随机选取与原始训练数据不相交的图像数据去进行模型蒸馏。为了实现黑盒攻击，我们首先基于黑盒模型b的输出构建了一个蒸馏网络f。一旦我们获得了经过蒸馏的网络f，我们就会执行与白盒设置中描述的相同的攻击策略。蒸馏网络目标函数定义如下：</p><p><img src="/2021/04/01/AdvGAN学习/6.png" alt="6"></p><p>其中f(x)和b(x)分别表示蒸馏模型和黑盒模型的输出，H表示交叉熵损失函数，通过使用所有的训练图像去优化上面的目标函数，我们可以获得效果接近于黑盒模型b的蒸馏模型f。然后我们可以在这个蒸馏网络上进行我们的攻击策略。</p><p>不同于训练判别器D，在训练判别器D的过程中，我们只使用来自原始类别的真实数据去引导生成的对抗样本实例尽可能地接近它的原始类别。在这里我们训练蒸馏模型使用的是来自所有类别的全部数据。</p><h5 id="动态蒸馏"><a href="#动态蒸馏" class="headerlink" title="动态蒸馏"></a>动态蒸馏</h5><p>仅仅用所有原始的训练数据训练经过提炼的模型是不够的，因为我们不清楚黑盒和经过提炼的模型在生成的对抗样本上的表现有多接近，而这些样本在之前的训练集中没有出现过。在这里作者提出一种代替最小化方法去动态查询和联合训练蒸馏模型f和生成器G 。在每一次迭代中执行下面两个步骤：</p><p><img src="/2021/04/01/AdvGAN学习/7.png" alt="7"></p><p>1.对于给定的蒸馏网络$f_{i-1}$更新$G_i$：根据白盒攻击的算法步骤，利用前一个蒸馏网络$f_{i-1}$去训练生成器和判别器，初始化$G_i$的权重为$G_{i-1}$的权重，$G_i,D_i=arg\underset{G}{min}\underset{D}{max}L^{f_{i-1}}_{adv}+\alpha L_{GAN}+\beta L_{hinge}$</p><p>2.对于给定的生成器$G_{i-1}$更新$f_i$：首先我们使用$f_{i-1}$的权重初始化$f_i$的权重，然后对于给定的从$G_i$生成的对抗样本x+G(x)，蒸馏模型$f_i$会根据最新的在黑盒模型上对抗样本的查询结果和原始数据进行参数更新。$f_i=arg\underset{f}{min}E_xH(f(x),b(x))+E_xH(f(x+G_i(x)),b(x+G_i(x)))$这里我们使用原始图像x和生成的对抗样本x+$sG_i(x)$去更新蒸馏网络。</p><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>这一章节，我们首先评估AdvGAN在半白盒和黑盒情景下对于MNIST和CIFAR-10的效果。我们也在ImageNet上进行的半白盒攻击的测试。接着我们应用AdvGAN在不同的目标模型上生成对抗样本和在目前最好的防御方法下测试其攻击成功率，结果显示我们的方法与其他目前存在的方法相比能实现更高的攻击成功率。为了保证比较的公平性，我们利用各种攻击方法生成的对抗样本都是在相同的无穷范式的约束下（在MNIST是0.3，在CIFAR-10是8）。大致来看，AdvGAN对比其他白盒攻击和黑盒攻击的方法体现出了几点优势。</p><p><img src="/2021/04/01/AdvGAN学习/8.png" alt="8"></p><p>就计算效率来讲，AdvGAN执行速度更快甚至比高效的FGSM方法快，即使AdvGAN需要额外的训练时间去训练生成器。我们这里对比的所有攻击策略除了基于迁移性攻击策略，其他都可以进行目标攻击。除此之外，FGSM和基于优化的方法只能进行白盒攻击，但是AdvGAN可以在半白盒的情景下进行攻击。</p><h5 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h5><p>采用与image-to-image转换文献类似的生成器和鉴别器结构，采用C&amp;W方法中提出的损失函数作为损失函数。在黑盒攻击的情景下表示蒸馏网络。我们设置信度为0，优化方法使用Adam，批大小为128，学习率为0.001。对于生成式对抗网络的学习，我们使用最小平方目标函数，因为它有更好更稳定的结果。</p><h5 id="半白盒攻击下的AdvGAN"><a href="#半白盒攻击下的AdvGAN" class="headerlink" title="半白盒攻击下的AdvGAN"></a>半白盒攻击下的AdvGAN</h5><p>我们用不同的模型结构来评估AdvGAN在MNIST和CIFAR-10数据集上的表现。我们首先应用AdvGAN来执行针对MNIST的不同模型的半白盒攻击。可以看出AdvGAN能够生成对抗实例以高攻击成功率攻击所有模型。我们还从相同的原始实例x生成对抗样本，攻击到其他不同的类别，在MNIST的半白盒情景中，我们可以看到生成的不同模型的对抗样本看起来与原始图像十分接近。此外，我们还分析了基于不同损失函数的MNIST攻击成功率。在相同的perturbation下，如果我们把上面定义的完整的损失函数代替成Baluja和Fischer使用的损失函数，攻击成功率为86.2%。如果把损失函数替代为$L=L_{hinge}+L^f_{adv}$，攻击成功率为91.1%，AdvGAN的成功率为98.3%。</p><p><img src="/2021/04/01/AdvGAN学习/10.png" alt="10"></p><h5 id="黑盒攻击下的AdvGAN"><a href="#黑盒攻击下的AdvGAN" class="headerlink" title="黑盒攻击下的AdvGAN"></a>黑盒攻击下的AdvGAN</h5><p>黑盒攻击基于动态蒸馏策略，构造一个本地模型去蒸馏我们需要攻击的模型f。我们选择模型C作为我们本地模型的架构。注意的是我们随机选取与原始训练数据不同的图像实例子集去训练本地模型。我们假设攻击者对于训练数据和模型没有任何的先验了解。通过动态蒸馏策略，由AdvGAN产生的对抗样本实现了在MNIST数据集上超过90%的攻击成功率和在CIFAR-10上超过80%的攻击成功率。与此同时静态蒸馏在两个数据集上分别达到了30%和10%的攻击成功率。<br>我们使用AdvGAN在MNIST上生成能被错误分类到特定类别的对抗样本。通过对比生成的对抗样本和原图，我们可以看到对抗样本可以实现和原图一样高的视觉质量。特别地，原始图像被对抗噪声强调的部分暗含着视觉现实的操作。图3显示了在CIFAR-10上产生的对抗样本结果。这些对抗样本实例和原始图像相比具有照片的真实性。</p><p><img src="/2021/04/01/AdvGAN学习/11.png" alt="11"></p><h5 id="在防御算法下的攻击效果"><a href="#在防御算法下的攻击效果" class="headerlink" title="在防御算法下的攻击效果"></a>在防御算法下的攻击效果</h5><p>AdvGAN尝试生成隐含在真实数据分布中的对抗样本实例，它与其他攻击策略相比能在本质上产生更加真实的对抗扰动。因此AdvGAN有更高的概率能产生能抵抗不同防御方法的对抗样本。在</p><h5 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h5><p>大多数现在的防御策略在它们受到攻击时，并不表现得那么鲁棒。这里我们考虑一个较弱的威胁模型，当对手不知道防御方法，并直接尝试攻击原始的学习模型，这也是C&amp;W分析的第一个威胁模型。在这种场景下，假设攻击者依然能够成功地攻击模型，这表明攻击策略是具有鲁棒性的。在这种场景下，我们首先应用不同的攻击算法在不知道被攻击的模型使用了什么防御算法的前提下，去产生对抗样本。然后我们使用不同的防御机制直接对这些产生的对抗样本进行防御。</p><h5 id="半白盒攻击"><a href="#半白盒攻击" class="headerlink" title="半白盒攻击"></a>半白盒攻击</h5><p>在半白盒攻击下，攻击者对模型结构和参数能进行白盒式访问。我们将图1中的f替换成我们的威胁模型A,B,C。我们分别使用标准的FGSM对抗训练，集成对抗训练，迭代对抗训练这三种对抗训练算法去针对不同的模型架构去训练防御模型。我们通过攻击这些防御模型来评估攻击的有效性。我们的实验结果显示使用AdvGAN生成的对抗样本的攻击成功率比FGSM和Opt都高。如下图表3所示：</p><p><img src="/2021/04/01/AdvGAN学习/12.png" alt="12"></p><h5 id="黑盒攻击"><a href="#黑盒攻击" class="headerlink" title="黑盒攻击"></a>黑盒攻击</h5><p>对于AdvGAN，我们使用模型B作为黑盒攻击的模型，训练一个蒸馏模型进行黑盒攻击，攻击成功率在表4。</p><p><img src="/2021/04/01/AdvGAN学习/13.png" alt="13"></p><p>我们采用基于迁移性进行攻击的FGSM和Opt。我们使用FGSM和Opt在MNIST上攻击模型A，然后我们使用这些对抗样本去攻击模型B，显示对应分类的正确率。我们可以看到由AdvGAN生成的对抗样本的攻击成功率始终比其他攻击方法的高。对于CIFAR-10数据集，我们使用ResNet作为黑盒攻击模型，并且训练一个蒸馏模型对它进行黑盒攻击。为了与基于优化的黑盒攻击方法和FGSM进行对比，我们使用对Wide ResNet进行攻击生成的对抗样本在ResNet上测试。另外我们使用AdvGAN在MNIST挑战上，在表5上显示了几乎所有的标准攻击方法，其中AdvGAN实现了88.93%的攻击成功率在白盒攻击下。在与已经发表的黑盒攻击算法对比，AdvGAN实现了92.76%的攻击成功率，超过了所有其他在挑战中提交的最好的攻击策略。</p><p><img src="/2021/04/01/AdvGAN学习/14.png" alt="14"></p><p>在图4中，我们展示了随机挑选的由AdvGAN生成的原始图像数据和对抗样本。</p><p><img src="/2021/04/01/AdvGAN学习/15.png" alt="15"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>提出了一种基于生成式对抗网络的网络架构AdvGAN去生成对抗样本。在我们的网络架构中，前馈的生成器一旦训练完成，我们可以高效地生成对抗扰动。这种对抗样本在半白盒攻击和黑盒攻击下都能达到很高的成功率。另外，当我们使用AdvGAN去针对不同的未知防御方法的被攻击模型生成对抗样本时，生成的对抗样本可以保持高分辨率和高的视觉质量。能以高的攻击率成功攻击目前最好的防御方法。这个属性让AdvGAN成为有保障的提高对抗训练的途径。</p><h4 id="复现代码分析"><a href="#复现代码分析" class="headerlink" title="复现代码分析"></a>复现代码分析</h4><p>复现代码链接：<a href="https://github.com/mathcbc/advGAN_pytorch" target="_blank" rel="noopener">https://github.com/mathcbc/advGAN_pytorch</a></p><h5 id="training-the-target-model"><a href="#training-the-target-model" class="headerlink" title="training the target model"></a>training the target model</h5><p><code>train_target_model.py</code>的代码结构如下</p><p><img src="/2021/04/01/AdvGAN学习/16.png" alt="16"></p><p>模型定义在<code>model.py</code>文件中。模型采用了四个卷积层和三个全连接层。在<code>forward</code>函数中采用relu激活函数和池化操作并开启了dropout。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNIST_target_net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MNIST_target_net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">32</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">        self.conv4 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">200</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        self.logits = nn.Linear(<span class="number">200</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = F.relu(self.conv1(x))</span><br><span class="line">        x = F.relu(self.conv2(x))</span><br><span class="line">        x = F.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = F.relu(self.conv3(x))</span><br><span class="line">        x = F.relu(self.conv4(x))</span><br><span class="line">        x = F.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.dropout(x, <span class="number">0.5</span>)</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.logits(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Generating-Adversarial-Examples-with-Adversarial-Networks&quot;&gt;&lt;a href=&quot;#Generating-Adversarial-Examples-with-Adversarial-Networks&quot; clas
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实现rpc和grpc</title>
    <link href="elssm.github.io/2021/03/29/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0rpc%E5%92%8Cgrpc/"/>
    <id>elssm.github.io/2021/03/29/Go语言实现rpc和grpc/</id>
    <published>2021-03-29T03:03:17.000Z</published>
    <updated>2021-03-30T12:23:49.719Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h4><p>RPC（Remote Procedure Call）是一种远程调用协议，能够使应用像调用本地方法一样调用远程的过程或服务。可以应用在分布式服务、分布式计算、远程调用等场景。</p><h4 id="Go实现rpc-server"><a href="#Go实现rpc-server" class="headerlink" title="Go实现rpc-server"></a>Go实现rpc-server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> World <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *World)</span> <span class="title">HelloWorld</span> <span class="params">(name <span class="keyword">string</span>,resp *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">*resp = name + <span class="string">" 你好!"</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//注册rpc服务</span></span><br><span class="line">err := rpc.RegisterName(<span class="string">"hello"</span>,<span class="built_in">new</span>(World))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"注册rpc服务失败！,err"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置监听</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8800"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line">fmt.Println(<span class="string">"开始监听...."</span>)</span><br><span class="line"><span class="comment">//建立链接</span></span><br><span class="line">conn,err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Accept() err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">fmt.Println(<span class="string">"链接成功..."</span>)</span><br><span class="line"><span class="comment">//绑定服务</span></span><br><span class="line">rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们要实定义类对象并绑定一个类方法。在<code>server</code>中的<code>main</code>函数中第一步需要实现的是注册RPC服务，绑定对象方法。<code>RegisterName</code>函数的第一个参数是服务名，是一个字符串类型。第二个参数对应rpc对象。方法必须是导出的，必须有两个参数，方法第二个参数必须是指针。方法只有一个error接口类型的返回值。第二步是设置监听，这里我们使用<code>net.listen</code>监听本地tcp下的<code>8800</code>端口。第三步是建立链接，使用<code>Accept</code>会返回一个用于通信的connect。最后绑定服务即可。这里注意对于listener和conn在使用完后一定要close。</p><h4 id="Go实现rpc-client"><a href="#Go实现rpc-client" class="headerlink" title="Go实现rpc-client"></a>Go实现rpc-client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main01</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//用rpc链接服务器</span></span><br><span class="line">conn,err := rpc.Dial(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8800"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Dial err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//调用远程函数</span></span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">string</span> </span><br><span class="line">err = conn.Call(<span class="string">"hello.HelloWorld"</span>,<span class="string">"elssm"</span>,&amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Call err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>client</code>端第一步先通过<code>Dial</code>链接服务器。链接成功之后通过<code>Call</code>调用远程函数，对于<code>Call</code>的第一个参数是服务名.方法名，第二个是传入参数，第三个是接收参数，因为在server端类方法的第二个参数是指针类型。所以这里<code>Call</code>的第三个参数要传地址用于接收函数返回值。</p><h4 id="Json-rpc"><a href="#Json-rpc" class="headerlink" title="Json-rpc"></a>Json-rpc</h4><p>使用<code>nc -l 127.0.0.1 8800</code>充当服务器发起通信产生乱码</p><p><img src="/2021/03/29/Go语言实现rpc和grpc/1.png" alt="1"></p><p>这是因为rpc使用了go语言特有的数据序列化gob，其他编程语言不能解析。因此我们可以使用通用的序列化，反序列化例如json、protobuf来解决。</p><p>修改上面<code>client</code>端的链接服务器代码如下即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn,err := jsonrpc.Dial(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8800"</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/2.png" alt="2"></p><h4 id="RPC封装"><a href="#RPC封装" class="headerlink" title="RPC封装"></a>RPC封装</h4><h5 id="服务端封装"><a href="#服务端封装" class="headerlink" title="服务端封装"></a>服务端封装</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建接口，在接口中定义方法原型</span></span><br><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">HelloWorld(<span class="keyword">string</span>,*<span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装注册服务方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(i MyInterface)</span></span>  &#123;</span><br><span class="line">rpc.RegisterName(<span class="string">"hello"</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端封装"><a href="#客户端封装" class="headerlink" title="客户端封装"></a>客户端封装</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="keyword">type</span> Myclient <span class="keyword">struct</span> &#123;</span><br><span class="line">c *rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitClient</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="title">Myclient</span></span> &#123;</span><br><span class="line">conn,_:= jsonrpc.Dial(<span class="string">"tcp"</span>,addr)</span><br><span class="line"><span class="keyword">return</span> Myclient&#123;c:conn&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定类方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Myclient)</span> <span class="title">HelloWorld</span><span class="params">(a <span class="keyword">string</span>,b *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> this.c.Call(<span class="string">"hello.HelloWorld"</span>,a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h4><p>protobuf是Google开发出来的一个语言无关、平台无关的数据序列化工具，在rpc或tcp通信等很多场景都可以使用。通俗来讲，如果客户端和服务端使用的是不同的语言，那么在服务端定义一个数据结构，通过protobuf转化为字节流，再传送到客户端解码，就可以得到对应的数据结构。如果实现rpc我们可以使用json进行序列化。如果使用protobuf做序列化就需要使用gRPC。</p><p>protobuf语法：<a href="https://www.bookstack.cn/read/topgoer/abb9896b6124ea54.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/topgoer/abb9896b6124ea54.md</a></p><h5 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h5><p>macos使用brew进行安装protobuf编译器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install protobuf</span><br></pre></td></tr></table></figure><h5 id="protobuf编写"><a href="#protobuf编写" class="headerlink" title="protobuf编写"></a>protobuf编写</h5><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是proto2</span></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定所在包名</span></span><br><span class="line"><span class="keyword">package</span> pb;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> </span>&#123;</span><br><span class="line">  Monday = <span class="number">0</span>;</span><br><span class="line">  Turesday = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义消息体</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> age = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  People p = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">int32</span> score = <span class="number">4</span>; <span class="comment">//数组</span></span><br><span class="line">  <span class="comment">//枚举</span></span><br><span class="line">  Week w = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">//联合体</span></span><br><span class="line">  <span class="keyword">oneof</span> data &#123;</span><br><span class="line">    <span class="built_in">string</span> teacher = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">string</span> class = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息体可以嵌套</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> weight = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编译protobuf"><a href="#编译protobuf" class="headerlink" title="编译protobuf"></a>编译protobuf</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=./ *.proto</span><br></pre></td></tr></table></figure><p>在当前目录下会生成<code>myproto.pb.go</code>文件</p><h4 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h4><p>Consul是一个服务网格解决方案，提供了一个功能齐全的控制平面，具有服务发现、配置和分段功能。 这些功能中的每一项都可以根据需要单独使用，也可以一起使用来构建一个完整的服务网格。 Consul需要一个数据平面，并支持代理和原生集成模型。</p><h5 id="安装consul"><a href="#安装consul" class="headerlink" title="安装consul"></a>安装consul</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install consul</span><br></pre></td></tr></table></figure><p>macos在/etc目录下创建<code>consul.d</code>文件夹，进入<code>consul.d</code>文件夹下。</p><h5 id="创建json文件"><a href="#创建json文件" class="headerlink" title="创建json文件"></a>创建json文件</h5><p><img src="/2021/03/29/Go语言实现rpc和grpc/6.png" alt="6"></p><h5 id="启动consul"><a href="#启动consul" class="headerlink" title="启动consul"></a>启动consul</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=127.0.0.1 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/3.png" alt="3"></p><h5 id="浏览器查看"><a href="#浏览器查看" class="headerlink" title="浏览器查看"></a>浏览器查看</h5><p>访问<code>127.0.0.1:8500</code>查看节点信息</p><p><img src="/2021/03/29/Go语言实现rpc和grpc/4.png" alt="4"></p><h5 id="命令行查看"><a href="#命令行查看" class="headerlink" title="命令行查看"></a>命令行查看</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s 127.0.0.1:8500/v1/catalog/service/bj38</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/5.png" alt="5"></p><h5 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/consul.d/web.json</span><br></pre></td></tr></table></figure><p>写入配置文件信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"service"</span>:&#123;</span><br><span class="line">                <span class="attr">"name"</span>:<span class="string">"bj38"</span>,</span><br><span class="line">                <span class="attr">"tags"</span>:[<span class="string">"itcast"</span>,<span class="string">"itheima"</span>],</span><br><span class="line">                <span class="attr">"port"</span>:<span class="number">8800</span>,</span><br><span class="line"><span class="attr">"check"</span>:&#123;</span><br><span class="line"><span class="attr">"id"</span>:<span class="string">"api"</span>,</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"itcast check"</span>,</span><br><span class="line"><span class="attr">"http"</span>:<span class="string">"http://127.0.0.1:8800"</span>,</span><br><span class="line"><span class="attr">"interval"</span>:<span class="string">"5s"</span>,</span><br><span class="line"><span class="attr">"timeout"</span>:<span class="string">"1s"</span></span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动consul-1"><a href="#启动consul-1" class="headerlink" title="启动consul"></a>启动consul</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=127.0.0.1 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/7.png" alt="7"></p><h4 id="gRPC介绍"><a href="#gRPC介绍" class="headerlink" title="gRPC介绍"></a>gRPC介绍</h4><p>官方中文文档：<a href="http://doc.oschina.net/grpc?t=58008" target="_blank" rel="noopener">http://doc.oschina.net/grpc?t=58008</a></p><h4 id="Go实现gRPC"><a href="#Go实现gRPC" class="headerlink" title="Go实现gRPC"></a>Go实现gRPC</h4><p>首先创建一个简单的go版本的protobuf文件，该文件在项目的pb文件夹中，命名为<code>person.proto</code>,项目名为<code>day02</code>。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//package pb;</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/;pb"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> age=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> sayHello(Person) <span class="keyword">returns</span> (Person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里遇到了一个很坑的问题，就是要将上面的<code>package pb;</code>改为<code>option go_package = &quot;/;pb&quot;;</code>，这个问题折磨了我有半个下午。大概报错如下图</p><p><img src="/2021/03/29/Go语言实现rpc和grpc/8.png" alt="8"></p><p>一开始根本不知道问题出在哪。baidu/google了很久都没有找到解决办法。我想这可能跟protoc-gen-go的版本有关。来来回回安装protoc-gen-go，无果。最后终于在github上找到了解决办法。</p><p><img src="/2021/03/29/Go语言实现rpc和grpc/9.png" alt="9"></p><h5 id="生成-go文件"><a href="#生成-go文件" class="headerlink" title="生成.go文件"></a>生成<code>.go</code>文件</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:./ *.proto</span><br></pre></td></tr></table></figure><h5 id="gRPC-server"><a href="#gRPC-server" class="headerlink" title="gRPC-server"></a>gRPC-server</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"day02/pb"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="keyword">type</span> Children <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定类方法，实现接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Children)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context,p *pb.Person)</span> <span class="params">(*pb.Person,error)</span></span> &#123;</span><br><span class="line">p.Name = <span class="string">"hello "</span> + p.Name</span><br><span class="line"><span class="keyword">return</span> p,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 初始化grpc对象</span></span><br><span class="line">grpcServer := grpc.NewServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册服务</span></span><br><span class="line">pb.RegisterHelloServer(grpcServer,<span class="built_in">new</span>(Children))</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置监听</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8800"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"开始监听...."</span>)</span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">grpcServer.Serve(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/10.png" alt="10"></p><h5 id="gRPC-client"><a href="#gRPC-client" class="headerlink" title="gRPC-client"></a>gRPC-client</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"day02/pb"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//链接服务</span></span><br><span class="line">grocConn,_ := grpc.Dial(<span class="string">"127.0.0.1:8800"</span>,grpc.WithInsecure())</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化grpc客户端</span></span><br><span class="line">grpcClient := pb.NewHelloClient(grocConn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person pb.Person</span><br><span class="line">person.Name = <span class="string">"elssm"</span></span><br><span class="line">person.Age = <span class="number">22</span></span><br><span class="line"><span class="comment">//调用远程函数</span></span><br><span class="line">p,err := grpcClient.SayHello(context.TODO(),&amp;person)</span><br><span class="line">fmt.Println(p,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/11.png" alt="11"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;RPC介绍&quot;&gt;&lt;a href=&quot;#RPC介绍&quot; class=&quot;headerlink&quot; title=&quot;RPC介绍&quot;&gt;&lt;/a&gt;RPC介绍&lt;/h4&gt;&lt;p&gt;RPC（Remote Procedure Call）是一种远程调用协议，能够使应用像调用本地方法一样调用远程的过程或
      
    
    </summary>
    
    
      <category term="代码" scheme="elssm.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>初学influxdb</title>
    <link href="elssm.github.io/2021/03/26/%E5%88%9D%E5%AD%A6influxdb/"/>
    <id>elssm.github.io/2021/03/26/初学influxdb/</id>
    <published>2021-03-26T00:35:45.000Z</published>
    <updated>2021-03-26T03:46:45.853Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>influxDB官网：<a href="https://www.influxdata.com/" target="_blank" rel="noopener">https://www.influxdata.com/</a></p><p>正如官网所介绍，influxDB是一个开源的时序型数据库。使用Go语言编写。主要用来查询和存储时序型数据。和Mysql和Nosql不同的是，influxDB被广泛用于存储系统的监控数据。并且可以配合一些图形化界面例如Grafana进行图形化展示。</p><p>与MYSQL的基础概念对比</p><div class="table-container"><table><thead><tr><th>概念</th><th>MYSQL</th><th>influxDB</th></tr></thead><tbody><tr><td>数据库</td><td>database</td><td>database</td></tr><tr><td>表</td><td>table</td><td>measurement</td></tr><tr><td>列</td><td>column</td><td>tag</td></tr></tbody></table></div><h4 id="下载安装influxDB"><a href="#下载安装influxDB" class="headerlink" title="下载安装influxDB"></a>下载安装influxDB</h4><p>目前官网的influxDB版本是V2版本，我下载的是V1版本。版本号是<code>1.7.11</code><br><a href="http://66-ai.com/download/influxdb/influxdb-1.8.3_darwin_amd64.tar.gz" target="_blank" rel="noopener">mac版influxdb下载</a><br>下载好之后对文件进行解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf influxdb-1.7.11_darwin_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压之后进入文件夹<code>/usr/bin</code>下启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./influxd</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/1.png" alt="1"></p><p>启动客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./influx</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/2.png" alt="2"></p><p>influxDB操作和mysql相似。通过查询数据表发现里面只存在一个默认数据库<code>_internal</code></p><p><img src="/2021/03/26/初学influxdb/3.png" alt="3"></p><h4 id="gopsutil学习"><a href="#gopsutil学习" class="headerlink" title="gopsutil学习"></a>gopsutil学习</h4><p>gopsutil是一个查询系统性能数据的模块，通过go语言实现。通过安装gopsutil模块就可以实现对本机的一些参数进行查询。<br>小试牛刀</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/shirou/gopsutil</span><br></pre></td></tr></table></figure><p>模块导入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/cpu"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/disk"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/host"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/load"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/mem"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/net"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查询cpu信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCpuInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">cpuInfos,err := cpu.Info()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get cpu info failed,err:%v\n"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,ci := <span class="keyword">range</span> cpuInfos &#123;</span><br><span class="line">fmt.Println(ci)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/4.png" alt="4"></p><p>查询cpu负载</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLoad</span><span class="params">()</span></span>  &#123;</span><br><span class="line">info,err := load.Avg()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"load.Avg() failed,err:%v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/5.png" alt="5"></p><p>查询内存信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHostInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">info,_ := host.Info()</span><br><span class="line">fmt.Printf(<span class="string">"host info:%v uptime:%v boottime:%v\n"</span>,info,info.Uptime,info.BootTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/7.png" alt="7"></p><p>查询磁盘信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDiskInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//获取所有分区信息</span></span><br><span class="line">parts,err := disk.Partitions(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get disk Partitions failed,err:%v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(parts)</span><br><span class="line"><span class="keyword">for</span> _,part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">partInfo,err := disk.Usage(part.Mountpoint)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get part stat failed,err:%v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(partInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//磁盘IO</span></span><br><span class="line">ioStat,_ := disk.IOCounters()</span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> ioStat &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v:%v\n"</span>,k,v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/8.png" alt="8"></p><p>查询网络信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNetInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">netIOs,err := net.IOCounters(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get net io counters failed,err:%v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,netIO := <span class="keyword">range</span> netIOs &#123;</span><br><span class="line">fmt.Println(netIO)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/9.png" alt="9"></p><h4 id="Go操作influxDB"><a href="#Go操作influxDB" class="headerlink" title="Go操作influxDB"></a>Go操作influxDB</h4><p>安装influxdb V1版本的模块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/influxdata/influxdb1-client/v2</span><br></pre></td></tr></table></figure><p>模块导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">client &quot;github.com/influxdata/influxdb1-client/v2&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>连接influxdb，V1版本端口默认为8086，V2版本端口默认为9999，用户名默认为admin，密码默认为空</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connInflux</span><span class="params">()</span> <span class="title">client</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line">cli,err := client.NewHTTPClient(client.HTTPConfig&#123;</span><br><span class="line">Addr: <span class="string">"http://127.0.0.1:8086"</span>,</span><br><span class="line">Username: <span class="string">"admin"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn err = "</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cli</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询操作</p><p>这里我们查询的是<code>test</code>数据库。因此我们需要在数据库中手动创建一个<code>test</code>数据库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryDB</span><span class="params">(cli client.Client,cmd <span class="keyword">string</span>)</span> <span class="params">(res []client.Result,err error)</span></span> &#123;</span><br><span class="line">   q := client.Query&#123;</span><br><span class="line">      Command: cmd,</span><br><span class="line">      Database: <span class="string">"test"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> response,err := cli.Query(q); err==<span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> response.Error() != <span class="literal">nil</span>&#123;</span><br><span class="line">         fmt.Println(<span class="string">"response error"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      res = response.Results</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res,err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/10.png" alt="10"></p><p>写入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writesPoints</span><span class="params">(cli client.Client)</span></span> &#123;</span><br><span class="line">bp, err := client.NewBatchPoints(client.BatchPointsConfig&#123;</span><br><span class="line">Database:  <span class="string">"test"</span>,</span><br><span class="line">Precision: <span class="string">"s"</span>, <span class="comment">//精度，默认ns</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">tags := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"cpu"</span>: <span class="string">"ih-cpu"</span>&#125;</span><br><span class="line">fields := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"idle"</span>:   <span class="number">201.1</span>,</span><br><span class="line"><span class="string">"system"</span>: <span class="number">43.3</span>,</span><br><span class="line"><span class="string">"user"</span>:   <span class="number">86.6</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pt, err := client.NewPoint(<span class="string">"cpu_usage"</span>, tags, fields, time.Now())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">bp.AddPoint(pt)</span><br><span class="line">err = cli.Write(bp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">"insert success"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入数据成功</p><p><img src="/2021/03/26/初学influxdb/11.png" alt="11"></p><h4 id="influxDB客户端查询"><a href="#influxDB客户端查询" class="headerlink" title="influxDB客户端查询"></a>influxDB客户端查询</h4><p><img src="/2021/03/26/初学influxdb/12.png" alt="12"></p><h4 id="Grafana实战"><a href="#Grafana实战" class="headerlink" title="Grafana实战"></a>Grafana实战</h4><p>grafna下载地址：<a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a></p><p>macos下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install grafana</span><br></pre></td></tr></table></figure><p>启动grafana，默认端口是3000，访问127.0.0.1:3000即可，默认用户名和密码为admin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start grafana</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/13.png" alt="13"></p><h4 id="Grafana配置influxDB"><a href="#Grafana配置influxDB" class="headerlink" title="Grafana配置influxDB"></a>Grafana配置influxDB</h4><p><img src="/2021/03/26/初学influxdb/14.png" alt="14"></p><h4 id="实时监控cpu状态并存储influxDB中"><a href="#实时监控cpu状态并存储influxDB中" class="headerlink" title="实时监控cpu状态并存储influxDB中"></a>实时监控cpu状态并存储influxDB中</h4><p>代码如下</p><p>首先在influxdb中创建新的数据库为monitor，之后运行如下代码可以每隔1s获取cpu使用信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">client <span class="string">"github.com/influxdata/influxdb1-client/v2"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/cpu"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cli client.Client</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConnInflux</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">cli,err = client.NewHTTPClient(client.HTTPConfig&#123;</span><br><span class="line">Addr: <span class="string">"http://127.0.0.1:8086"</span>,</span><br><span class="line">Username: <span class="string">"admin"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writesPoints</span><span class="params">(percent <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">bp, err := client.NewBatchPoints(client.BatchPointsConfig&#123;</span><br><span class="line">Database:  <span class="string">"monitor"</span>,</span><br><span class="line">Precision: <span class="string">"s"</span>, <span class="comment">//精度，默认ns</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">tags := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"cpu"</span>: <span class="string">"cpu0"</span>&#125;</span><br><span class="line">fields := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"cpu_percent"</span>: percent ,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pt, err := client.NewPoint(<span class="string">"cpu_percent"</span>, tags, fields, time.Now())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">bp.AddPoint(pt)</span><br><span class="line">err = cli.Write(bp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">"insert success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCpuInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//cpu使用率</span></span><br><span class="line">percent,_ := cpu.Percent(time.Second,<span class="literal">false</span>)</span><br><span class="line">fmt.Printf(<span class="string">"cpu percent:%v\n"</span>,percent)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入到influxdb中</span></span><br><span class="line">writesPoints(percent[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">err := initConnInflux()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"connect to influxdb failed,err:%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">getCpuInfo()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/15.png" alt="15"></p><h5 id="Grafana展示"><a href="#Grafana展示" class="headerlink" title="Grafana展示"></a>Grafana展示</h5><p>在dashboard中创建新的panel</p><p><img src="/2021/03/26/初学influxdb/16.png" alt="16"></p><p>相关配置选择如下</p><p><img src="/2021/03/26/初学influxdb/17.png" alt="17"></p><p>之后可以自定义面板，选择折线图或者柱状图等等，数据就会从influxdb中被展示到面板中。</p><p><img src="/2021/03/26/初学influxdb/18.png" alt="18"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;influxDB官网：&lt;a href=&quot;https://www.influxdata.com/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Docker&amp;Kubernetes学习</title>
    <link href="elssm.github.io/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/03/22/Docker-Kubernetes学习/</id>
    <published>2021-03-22T07:49:26.000Z</published>
    <updated>2021-03-22T07:50:07.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><p>Docker容器数据卷</p><p>需求：容器的持久化和同步操作，容器间也是可以数据共享的</p><p>容器之间可以有一个数据共享的技术，Docker容器中产生的数据同步到本地</p><p>将我们容器内的目录，挂载到linux上面</p></li><li><p>具名和匿名挂载</p><p>匿名：在<code>-v</code>只写了容器内的路径，没有写容器外的路径</p><p>具名：通过<code>-v</code>  卷名:容器内路径</p><p>指定路径挂载：<code>-v</code> /宿主机路径：容器内路径</p></li><li><p>DockerFile </p><p>用来构建docker镜像的构建文件，命令脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建dockerfile文件</span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME ["volume01","volume02"]</span><br><span class="line"></span><br><span class="line">CMD echo "----end----"</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>构建称为一个镜像</span><br><span class="line">docker build -f dockerfile -t elssm/centos .</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>运行镜像</span><br><span class="line">docker run</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>发布镜像</span><br><span class="line">docker push</span><br></pre></td></tr></table></figure><p>DockerFile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行</p><p>Docker容器：容器就是镜像运行起来提供服务的</p></li><li><p>DockerFile的指令解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM #基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER #镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN #镜像构建的时候需要运行的命令</span><br><span class="line">ADD #步骤，添加内容</span><br><span class="line">WORKDIR #镜像的工作目录</span><br><span class="line">VOLUME #挂载的目录</span><br><span class="line">EXPOSE #指定暴露端口</span><br><span class="line">CMD #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD #当构建一个被继承DockerFile这个时候就会运行ONBUILD的指令</span><br><span class="line">COPY：#类似ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENV #构建的时候设置环境变量</span><br></pre></td></tr></table></figure></li><li><p>创建一个自己的centos</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>编写Dockerfile的文件</span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER elssm&lt;329847986@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim </span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo "---end---"</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>通过这个文件构建镜像</span><br><span class="line">docker build -f dockerfile -t name:0.1 .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>测试运行</span><br><span class="line">docker run -it image</span><br></pre></td></tr></table></figure></li><li><p>实战Tomcat镜像</p><ul><li><p>准备镜像文件tomcat压缩包，jdk的压缩包</p></li><li><p>编写dockerfile文件</p></li></ul></li><li><p>数据卷容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>容器间数据同步</span><br><span class="line">-- volumes -from</span><br></pre></td></tr></table></figure></li><li><p>Docker网络</p><p>原理：我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是veth-pair技术</p></li><li><p>veth-pair：就是一对虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连，正因为有这个特性，veth-pair充当一个桥梁，连接各种虚拟 网络设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>查看docker下的所有network</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看详细信息</span><br><span class="line">docker network inspect bridge_ID</span><br></pre></td></tr></table></figure><p><code>--link</code>可以解决docker下网络联通问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>下载tomcat镜像</span><br><span class="line">docker pull tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>docker下启动两个tomcat</span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat02 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>启动tomcat03并绑定tomcat02</span><br><span class="line">docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>进入tomcat03并查看tomcat03配置文件</span><br><span class="line">docker exec -it tomcat03 cat /etc/hosts</span><br></pre></td></tr></table></figure></li><li><p>自定义网络</p><p>查看所有的docker网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p>网络模式</p><ul><li>bridge：桥接模式</li><li>none：不配置网络</li><li>host：和宿主机共享网络</li><li>container：容器内网络连通</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>我们可以自定义一个网络</span><br><span class="line"><span class="meta">#</span> --driver bridge</span><br><span class="line"><span class="meta">#</span> --subnet 192.168.0.0/16</span><br><span class="line"><span class="meta">#</span> --gateway 192.168.0.1</span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看自己创建的网络</span><br><span class="line">docker network inspect mynet</span><br></pre></td></tr></table></figure><p>自定义的网络docker都已经帮我们维护好了对应的关系</p><p>不同的集群使用不同的网络，保证集群是安全和健康的</p></li><li><p>网络连通</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>测试打通tomcat01 - mynet</span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>连通之后就是将tomcat01放到了mynet网络下</span><br><span class="line"><span class="meta">#</span>一个容器两个ip地址</span><br></pre></td></tr></table></figure></li></ul><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><ul><li><p>发展历程</p><p>Infrastructure as a Service（阿里云）</p><p>Platform as a service（新浪云）</p><p>Software as a Service（Office 365）</p></li><li><p>资源管理器</p><ul><li>Apache MESOS</li><li>docker SWARM</li><li>Kubernetes<ul><li>轻量级</li><li>开源</li><li>弹性伸缩</li><li>负载均衡</li></ul></li></ul></li><li><p>组件说明</p><ul><li>APISERVER：所有服务访问统一接口</li><li>ControllerManager：维护副本期望数据</li><li>Scheduler：负责介绍任务，选择合适的节点进行分配任务</li><li>ETCD：键值对数据库，存储K8S集群所有重要信息（持久化）</li><li>Kubelet：直接跟容器引擎交互实现容器的生命周期管理</li><li>Kube-proxy：负责写入规则至IPTABLES，IPVS实现服务映射访问</li><li>COREDNS：可以为集群中的SVC创建一个域名IP的对应关系解析</li><li>DASHBOARD：给K8S集群提供一个B/S结构访问体系</li><li>INGRESS CONTROLLER：官方只能实现四层代理，INGRESS可以实现七层代理</li><li>FEDERATION：提供一个可以跨集群中心多K8S统一管理功能</li><li>PROMETHEUS：提供K8S集群的监控能力</li><li>ELK：提供K8S集群日志统一分析接入平台</li></ul></li><li><p>Pod概念</p><ul><li><p>自主式Pod</p></li><li><p>控制器管理的Pod </p><p>ReplicationController：用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代，而如果异常多出来的容器也会自动回收。</p><p>ReplicaSet：和ReplicationController没有本质不同，支持集合式的selector</p><p>Deployment：自动管理ReplicaSet，支持滚动更新</p><p>Horizontal Pod Autoscaling：仅适用于Deployment和ReplicaSet</p><p>StatefullSet：为了解决有状态服务的问题，应用场景包括：</p><ul><li>稳定的持久化存储</li><li>稳定的网络标志</li><li>有序部署，有序扩展</li><li>有序收缩，有序删除</li></ul><p>DaemonSet：确保全部（或者一些）Node上运行一个Pod的副本，当有Node加入集群时，也会为他们新增一个Pod，当有Node从集群中移除时，这些Pod也会被回收，删除DaemonSet将会删除它创建的所有Pod，使用DaemonSet的一些典型用法：</p><ul><li>运行集群存储daemon，例如在每个Node上运行glusterd，ceph</li><li>在每个Node上运行日志收集daemon，例如fluentd，logstash</li><li>在每个Node上运行监控daemon，例如Prometheus，Node Exporter</li></ul><p>Job：负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</p><p>Cron Job：管理基于时间的Job，即在给定时间点只运行一次，周期性地在给定时间点运行</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Docker容器数据卷&lt;/p&gt;
&lt;p&gt;需求：容器的持久化和同步操作，容器间也是可以数据共享
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实现向kafka中发送数据</title>
    <link href="elssm.github.io/2021/03/21/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%90%91kafka%E4%B8%AD%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/"/>
    <id>elssm.github.io/2021/03/21/Go语言实现向kafka中发送数据/</id>
    <published>2021-03-21T09:31:02.000Z</published>
    <updated>2021-03-21T12:44:46.531Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>今天用go语言简单实现kafka发送文件示例。</p><h4 id="kafla和zookeeper搭建"><a href="#kafla和zookeeper搭建" class="headerlink" title="kafla和zookeeper搭建"></a>kafla和zookeeper搭建</h4><p>安装kafka之前首先要安装zookeeper。本次安装是在Mac os下实现，使用homebrew进行安装</p><h5 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zookeeper</span><br></pre></td></tr></table></figure><h5 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install kafka</span><br></pre></td></tr></table></figure><h4 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp;</span><br></pre></td></tr></table></figure><h4 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh kafka-server-start /usr/local/etc/kafka/server.properties &amp;</span><br></pre></td></tr></table></figure><h4 id="下载sarama"><a href="#下载sarama" class="headerlink" title="下载sarama"></a>下载sarama</h4><p>在下载sarama过程中遇到很多问题。使用go get命令会提示下面类似错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</span><br></pre></td></tr></table></figure><p>解决方法如下：</p><p>首先查看自己go的版本，我的是1.15，对于go版本1.13及以上采用如下两条命令</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> env -w GO!!!MODULE=on</span><br><span class="line"><span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.io,direct</span></span><br></pre></td></tr></table></figure><p>对于其他版本请参考如下链接：<a href="https://www.jianshu.com/p/9a476a40e16e" target="_blank" rel="noopener">https://www.jianshu.com/p/9a476a40e16e</a></p><h4 id="kafka实例"><a href="#kafka实例" class="headerlink" title="kafka实例"></a>kafka实例</h4><p>创建main.go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/Shopify/sarama"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//kafka client demo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//生产者配置</span></span><br><span class="line">config := sarama.NewConfig()</span><br><span class="line">config.Producer.RequiredAcks = sarama.WaitForAll <span class="comment">//ACK</span></span><br><span class="line">config.Producer.Partitioner = sarama.NewRandomPartitioner <span class="comment">//分区</span></span><br><span class="line">config.Producer.Return.Successes = <span class="literal">true</span> <span class="comment">//确认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接kafka</span></span><br><span class="line">client,err := sarama.NewSyncProducer([]<span class="keyword">string</span>&#123;<span class="string">"127.0.0.1:9092"</span>&#125;,config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"producer closed err :"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装消息</span></span><br><span class="line">msg := &amp;sarama.ProducerMessage&#123;&#125;</span><br><span class="line">msg.Topic = <span class="string">"shopping"</span></span><br><span class="line">msg.Value = sarama.StringEncoder(<span class="string">"this is a test log"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">pid,offset,err := client.SendMessage(msg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"send msg failed,err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"pid:%v offset:%v\n"</span>,pid,offset)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="文件打包"><a href="#文件打包" class="headerlink" title="文件打包"></a>文件打包</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>在打包过程中又遇到了一些问题，类似报错如下，大致原因就是因为我们上面采用了代理下载go包，开启了 GO111MODULE，导致包管理非官方所说的在GOPATH\src，而是去了GOPATH\src\pkg\目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot find module providing package github.com/xxx</span><br></pre></td></tr></table></figure><p>此时就需要用go mod引入这些包 require github.com/gin-gonic/gin@latest ，从而可以解决import获取不了包的问题。运行命令如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init gin</span><br><span class="line"><span class="keyword">go</span> mod edit -require github.com/gin-gonic/gin@latest</span><br></pre></td></tr></table></figure><p>成功打包之后执行命令</p><p><img src="/2021/03/21/Go语言实现向kafka中发送数据/1.png" alt="1"></p><h4 id="查看kafka日志"><a href="#查看kafka日志" class="headerlink" title="查看kafka日志"></a>查看kafka日志</h4><p>kafka日志文件在<code>/usr/local/var/lib/</code>目录下的<code>kafka-logs</code>中。<code>kafka-logs</code>文件夹下有一个<code>shopping-0</code>文件夹，这个就是我们在代码里设置的Topic，里面有四个文件，<code>.log</code>结尾的就是我们的日志文件。</p><p><img src="/2021/03/21/Go语言实现向kafka中发送数据/2.png" alt="2"></p><h4 id="消费者打印日志"><a href="#消费者打印日志" class="headerlink" title="消费者打印日志"></a>消费者打印日志</h4><h5 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh kafka-console-consumer --bootstrap-server localhost:<span class="number">9092</span> --topic shopping --from-beginning</span><br></pre></td></tr></table></figure><h5 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h5><p><img src="/2021/03/21/Go语言实现向kafka中发送数据/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;今天用go语言简单实现kafka发送文件示例。&lt;/p&gt;
&lt;h4 id=&quot;kafla和zookeeper搭建&quot;&gt;&lt;a href=&quot;#kafla
      
    
    </summary>
    
    
      <category term="代码" scheme="elssm.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Go实现聊天室</title>
    <link href="elssm.github.io/2021/03/17/Go%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>elssm.github.io/2021/03/17/Go实现聊天室/</id>
    <published>2021-03-17T11:17:00.000Z</published>
    <updated>2021-03-17T14:45:44.805Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>用Go语言简单实现一个网络聊天室，首先创建一个chatroom的文件夹，在文件夹下创建<code>chatroom.go</code>文件。</p><h4 id="建立tcp-socket连接"><a href="#建立tcp-socket连接" class="headerlink" title="建立tcp socket连接"></a>建立tcp socket连接</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有代码写在一个文件中，不做代码整理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">":8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"服务器启动成功!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"=======&gt;主go程监听中..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listener.Accept err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">fmt.Println(<span class="string">"建立连接成功！"</span>)</span><br><span class="line"><span class="comment">//启动处理业务的go程</span></span><br><span class="line"><span class="keyword">go</span> handler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"启动业务..."</span>)</span><br><span class="line"><span class="comment">//TODO //代表这里以后再实现</span></span><br><span class="line">buf :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取客户端发送过来的数据</span></span><br><span class="line">cnt,err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn.Read err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"服务器接受客户端发送过来的数据为："</span>,<span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]),<span class="string">",cnt: "</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run chatroom.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/1.png" alt="1"></p><p>nc连接</p><p><img src="/2021/03/17/Go实现聊天室/2.png" alt="2"></p><p><img src="/2021/03/17/Go实现聊天室/3.png" alt="3"></p><h4 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h4><p>我们程序中有一个主go程，负责监听。客户端以一种数据流的形式建立连接，这个时候服务器就会启动一个<code>handler()</code> go程，在<code>handler()</code> go程中可以接受来自客户端发送的消息。这个时候服务器就应该把消息告诉所有人，因此我们应该在<code>handler()</code>中创建一个通道，它要将消息写入到公共通道message中，这个时候会有另外一个go程，它负责监听message，当message中有数据时，它会将数据发送给所有的用户。对于user用户的创建我们需要在<code>handler()</code>中实现，并将user添加到map中，每个用户都有一个自己的msg管道，当需要发送消息给所有用户的时候，go程会遍历用户map，并将消息写入每个用户的管道中。这个时候，每个用户的管道里都会有来自公共管道的message。之后我们再启动一个go程。每个用户都会拥有这个go程，负责将用户自己的msg回写给终端。</p><h4 id="定义User和map结构"><a href="#定义User和map结构" class="headerlink" title="定义User和map结构"></a>定义User和map结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">id <span class="keyword">string</span></span><br><span class="line">msg <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个全局的map结构，用于保存所有的用户</span></span><br><span class="line"><span class="keyword">var</span> allUsers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]User)</span><br></pre></td></tr></table></figure><p>在handler中调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端与服务器建立连接的时候，会有ip和port，因此将port当成user id</span></span><br><span class="line"><span class="comment">//创建user</span></span><br><span class="line">clientAddr := conn.RemoteAddr().String()</span><br><span class="line"><span class="comment">//fmt.Println("chiientAddr: ",clientAddr[10:])</span></span><br><span class="line">newUser := User&#123;</span><br><span class="line">  name: <span class="string">"虎扑JR"</span>+clientAddr[<span class="number">10</span>:],<span class="comment">//可以修改，会提供rename命令修改</span></span><br><span class="line">  id: clientAddr, <span class="comment">//id不会修改，作为map中的key</span></span><br><span class="line">  msg: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>),<span class="comment">//注意要make空间，否则无法写数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加user到map结构</span></span><br><span class="line">allUsers[newUser.id] = newUser</span><br></pre></td></tr></table></figure><h4 id="定义message通道"><a href="#定义message通道" class="headerlink" title="定义message通道"></a>定义message通道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个message全局通道，用接收任何人发送过来的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="创建监听广播go程函数"><a href="#创建监听广播go程函数" class="headerlink" title="创建监听广播go程函数"></a>创建监听广播go程函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向所有的用户广播消息，启动一个全局唯一的go程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"广播go程启动成功..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.从message中读取数据</span></span><br><span class="line">info := &lt;- message</span><br><span class="line"><span class="comment">//2.将数据写入到每一个用户的msg管道中</span></span><br><span class="line"><span class="keyword">for</span> _,user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line">user.msg &lt;- info</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动广播go程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动全局唯一的go程，负责监听message通道，写给所有的用户</span></span><br><span class="line"><span class="keyword">go</span> broadcast()</span><br></pre></td></tr></table></figure><p>写入上线数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向message写入数据，当前用户上线的消息，用于通知所有人</span></span><br><span class="line">loginInfo := fmt.Sprintf(<span class="string">"[%s]:[%s] ===&gt; 上线了login！！"</span>,newUser.id,newUser.name)</span><br><span class="line">message &lt;- loginInfo</span><br></pre></td></tr></table></figure><p>当前完整代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有代码写在一个文件中，不做代码整理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">id <span class="keyword">string</span></span><br><span class="line">msg <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个全局的map结构，用于保存所有的用户</span></span><br><span class="line"><span class="keyword">var</span> allUsers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]User)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个message全局通道，用接收任何人发送过来的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">":8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动全局唯一的go程，负责监听message通道，写给所有的用户</span></span><br><span class="line"><span class="keyword">go</span> broadcast()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"服务器启动成功!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"=======&gt;主go程监听中..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listener.Accept err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">fmt.Println(<span class="string">"建立连接成功！"</span>)</span><br><span class="line"><span class="comment">//启动处理业务的go程</span></span><br><span class="line"><span class="keyword">go</span> handler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"启动业务..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端与服务器建立连接的时候，会有ip和port，因此将port当成user id</span></span><br><span class="line"><span class="comment">//创建user</span></span><br><span class="line">clientAddr := conn.RemoteAddr().String()</span><br><span class="line"><span class="comment">//fmt.Println("chiientAddr: ",clientAddr[10:])</span></span><br><span class="line">newUser := User&#123;</span><br><span class="line">name: <span class="string">"虎扑JR"</span>+clientAddr[<span class="number">10</span>:],<span class="comment">//可以修改，会提供rename命令修改</span></span><br><span class="line">id: clientAddr, <span class="comment">//id不会修改，作为map中的key</span></span><br><span class="line">msg: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>),<span class="comment">//注意要make空间，否则无法写数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加user到map结构</span></span><br><span class="line">allUsers[newUser.id] = newUser</span><br><span class="line"></span><br><span class="line"><span class="comment">//向message写入数据，当前用户上线的消息，用于通知所有人</span></span><br><span class="line">loginInfo := fmt.Sprintf(<span class="string">"[%s]:[%s] ===&gt; 上线了login！！"</span>,newUser.id,newUser.name)</span><br><span class="line">message &lt;- loginInfo</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取客户端发送过来的数据</span></span><br><span class="line">cnt,err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn.Read err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"服务器接受客户端发送过来的数据为："</span>,<span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]),<span class="string">",cnt: "</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向所有的用户广播消息，启动一个全局唯一的go程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"广播go程启动成功..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.从message中读取数据</span></span><br><span class="line">info := &lt;-message</span><br><span class="line">fmt.Println(<span class="string">"message接收到的消息："</span>, info)</span><br><span class="line"><span class="comment">//2.将数据写入到每一个用户的msg管道中</span></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line"><span class="comment">//如果msg是非缓冲的，那么会在这里阻塞</span></span><br><span class="line">user.msg &lt;- info</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/4.png" alt="4"></p><p><img src="/2021/03/17/Go实现聊天室/5.png" alt="5"></p><h4 id="User监听通道go程"><a href="#User监听通道go程" class="headerlink" title="User监听通道go程"></a>User监听通道go程</h4><p>每个用户应该还有一个用来监听自己msg管道的go程，负责将数据返回给客户端。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个用户应该还有一个用来监听自己msg管道的go程，负责将数据返回给客户端。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeBackToClient</span><span class="params">(user *User,conn net.Conn)</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user ： %s的go程正在监听自己的msg管道\n"</span>,user.name)</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> user.msg &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user:%s写回给客户端的数据为:%s\n"</span>,user.name,data)</span><br><span class="line">_,_ = conn.Write([]<span class="keyword">byte</span>(data+<span class="string">"\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前完整代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有代码写在一个文件中，不做代码整理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">id <span class="keyword">string</span></span><br><span class="line">msg <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个全局的map结构，用于保存所有的用户</span></span><br><span class="line"><span class="keyword">var</span> allUsers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]User)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个message全局通道，用接收任何人发送过来的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">":8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动全局唯一的go程，负责监听message通道，写给所有的用户</span></span><br><span class="line"><span class="keyword">go</span> broadcast()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"服务器启动成功!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"=======&gt;主go程监听中..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listener.Accept err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">fmt.Println(<span class="string">"建立连接成功！"</span>)</span><br><span class="line"><span class="comment">//启动处理业务的go程</span></span><br><span class="line"><span class="keyword">go</span> handler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"启动业务..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端与服务器建立连接的时候，会有ip和port，因此将port当成user id</span></span><br><span class="line"><span class="comment">//创建user</span></span><br><span class="line">clientAddr := conn.RemoteAddr().String()</span><br><span class="line"><span class="comment">//fmt.Println("chiientAddr: ",clientAddr[10:])</span></span><br><span class="line">newUser := User&#123;</span><br><span class="line">name: <span class="string">"虎扑JR"</span>+clientAddr[<span class="number">10</span>:],<span class="comment">//可以修改，会提供rename命令修改</span></span><br><span class="line">id: clientAddr, <span class="comment">//id不会修改，作为map中的key</span></span><br><span class="line">msg: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>),<span class="comment">//注意要make空间，否则无法写数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加user到map结构</span></span><br><span class="line">allUsers[newUser.id] = newUser</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动go程，负责将msg数据返回给客户端</span></span><br><span class="line"><span class="keyword">go</span> writeBackToClient(&amp;newUser,conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">//向message写入数据，当前用户上线的消息，用于通知所有人</span></span><br><span class="line">loginInfo := fmt.Sprintf(<span class="string">"[%s]:[%s] ===&gt; 上线了login！！"</span>,newUser.id,newUser.name)</span><br><span class="line">message &lt;- loginInfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//具体业务逻辑</span></span><br><span class="line">buf :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取客户端发送过来的数据</span></span><br><span class="line">cnt,err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn.Read err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"服务器接受客户端发送过来的数据为："</span>,<span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]),<span class="string">",cnt: "</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向所有的用户广播消息，启动一个全局唯一的go程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"广播go程启动成功..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.从message中读取数据</span></span><br><span class="line">info := &lt;-message</span><br><span class="line">fmt.Println(<span class="string">"message接收到的消息："</span>, info)</span><br><span class="line"><span class="comment">//2.将数据写入到每一个用户的msg管道中</span></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line"><span class="comment">//如果msg是非缓冲的，那么会在这里阻塞</span></span><br><span class="line">user.msg &lt;- info</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个用户应该还有一个用来监听自己msg管道的go程，负责将数据返回给客户端。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeBackToClient</span><span class="params">(user *User,conn net.Conn)</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user ： %s的go程正在监听自己的msg管道\n"</span>,user.name)</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> user.msg &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user:%s写回给客户端的数据为:%s\n"</span>,user.name,data)</span><br><span class="line">_,_ = conn.Write([]<span class="keyword">byte</span>(data+<span class="string">"\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/7.png" alt="7"></p><p><img src="/2021/03/17/Go实现聊天室/6.png" alt="6"></p><h4 id="增加功能"><a href="#增加功能" class="headerlink" title="增加功能"></a>增加功能</h4><h5 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h5><p>查询命令：who 将当前所有登陆的用户，展示出来，id，name返回给当前用户</p><p>在handler中处理业务逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.查询当前所有的用户 who</span></span><br><span class="line"><span class="comment">//判断接受的数据是不是who ==&gt; 长度&amp;字符串</span></span><br><span class="line">userInput := <span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]) <span class="comment">//这是用户输入的数据，最后一个是回车，去掉回车</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userInput)==<span class="number">3</span> &amp;&amp; userInput == <span class="string">"who"</span> &#123;</span><br><span class="line"><span class="comment">//遍历allUsers这个map：（key: userid value：user本身）</span></span><br><span class="line">fmt.Println(<span class="string">"用户即将查询所有用户信息！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个切片包含所有的用户信息</span></span><br><span class="line"><span class="keyword">var</span> userInfos []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line">userInfo := fmt.Sprintf(<span class="string">"userid:%s,username:%s"</span>,user.id,user.name)</span><br><span class="line">userInfos = <span class="built_in">append</span>(userInfos,userInfo )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终写到管道中，一定是一个字符串</span></span><br><span class="line">r := strings.Join(userInfos,<span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">//将数据返回给查询的客户端</span></span><br><span class="line">newUser.msg &lt;- r</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果用户输入的不是命令，只是普通的聊天信息，那么只需要写入到广播通道中，由其他的go程进行常规转发</span></span><br><span class="line">message &lt;- userInput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/8.png" alt="8"></p><h5 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(userInput) &gt;<span class="number">9</span> &amp;&amp; userInput[:<span class="number">7</span>]==<span class="string">"\\rename"</span> &#123;</span><br><span class="line"><span class="comment">//规则：rename|ddd</span></span><br><span class="line"><span class="comment">//读取数据判断长度，判断字符是rename</span></span><br><span class="line"><span class="comment">//使用|分割，获取|后面的内容，作为名字</span></span><br><span class="line"><span class="comment">//更新用户名字 newUser.name = ddd</span></span><br><span class="line">newUser.name = strings.Split(userInput,<span class="string">"|"</span>)[<span class="number">1</span>]</span><br><span class="line">allUsers[newUser.id] = newUser <span class="comment">//更新map中的user</span></span><br><span class="line"><span class="comment">//通知客户端，更新成功</span></span><br><span class="line">newUser.msg &lt;- <span class="string">"rename successfully!"</span></span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/9.png" alt="9"></p><h5 id="主动退出"><a href="#主动退出" class="headerlink" title="主动退出"></a>主动退出</h5><p>从map中删除，对应的conn要close</p><p>每个用户都有自己的watch go程，负责监听退出信号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动一个go程，负责监听退出信号，触发后进行清理工作：delete map，close conn都在这里处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(user *User,conn net.Conn,isQuit &lt;- <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"启动监听退出信号的go程..."</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"watch go程退出！"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- isQuit:</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s exit already!"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler函数中定义isQuit</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个退出信号，用户监听client退出</span></span><br><span class="line"><span class="keyword">var</span> isQuit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br></pre></td></tr></table></figure><p>在handler中启动go watch，同时传入相应信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动go程，负责监听退出信号</span></span><br><span class="line"><span class="keyword">go</span> watch(&amp;newUser,conn,isQuit)</span><br></pre></td></tr></table></figure><p>在<code>conn.Read(buf)</code>之后，通过读取的cnt判断用户退出，如果是ctrl+c主动退出，则触发isQuit</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cnt == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"客户端主动关闭ctrl+c，准备退出！"</span>)</span><br><span class="line"><span class="comment">//map删除用户，conn close</span></span><br><span class="line"><span class="comment">//服务器还可以主动的退出</span></span><br><span class="line"><span class="comment">//在这里不进行真正的退出动作，而是发送一个退出信号，统一做退出处理，可以使用新的管道做信号传递</span></span><br><span class="line">isQuit &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/10.png" alt="10"></p><p><img src="/2021/03/17/Go实现聊天室/11.png" alt="11"></p><h5 id="超时退出"><a href="#超时退出" class="headerlink" title="超时退出"></a>超时退出</h5><p>使用定时器来进行超时管理。如果60s内没有发送任何数据，那么直接将这个连接关闭掉</p><p>更新watch函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动一个go程，负责监听退出信号，触发后进行清理工作：delete map，close conn都在这里处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(user *User,conn net.Conn,isQuit &lt;- <span class="keyword">chan</span> <span class="keyword">bool</span>,restTimer &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"启动监听退出信号的go程..."</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"watch go程退出！"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- isQuit:</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s exit already!\n"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;- time.After(<span class="number">10</span>*time.Second):</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s timeout exit already!\n"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;- restTimer:</span><br><span class="line">fmt.Printf(<span class="string">"连接%s 重置计数器！\n"</span>,user.name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建并传入restTimer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个用于重置计数器的管道，用于告知watch函数，当前用户正在输入</span></span><br><span class="line"><span class="keyword">var</span> restTimer = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//启动go程，负责监听退出信号</span></span><br><span class="line"><span class="keyword">go</span> watch(&amp;newUser,conn,isQuit,restTimer)</span><br></pre></td></tr></table></figure><p>只要有数据写入，每次写入数据之后都要设置restTimer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restTimer &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="聊天室完整代码"><a href="#聊天室完整代码" class="headerlink" title="聊天室完整代码"></a>聊天室完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有代码写在一个文件中，不做代码整理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">id <span class="keyword">string</span></span><br><span class="line">msg <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个全局的map结构，用于保存所有的用户</span></span><br><span class="line"><span class="keyword">var</span> allUsers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]User)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个message全局通道，用接收任何人发送过来的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">":8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动全局唯一的go程，负责监听message通道，写给所有的用户</span></span><br><span class="line"><span class="keyword">go</span> broadcast()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"服务器启动成功!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"=======&gt;主go程监听中..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listener.Accept err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">fmt.Println(<span class="string">"建立连接成功！"</span>)</span><br><span class="line"><span class="comment">//启动处理业务的go程</span></span><br><span class="line"><span class="keyword">go</span> handler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"启动业务..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端与服务器建立连接的时候，会有ip和port，因此将port当成user id</span></span><br><span class="line"><span class="comment">//创建user</span></span><br><span class="line">clientAddr := conn.RemoteAddr().String()</span><br><span class="line"><span class="comment">//fmt.Println("chiientAddr: ",clientAddr[10:])</span></span><br><span class="line">newUser := User&#123;</span><br><span class="line">name: <span class="string">"虎扑JR"</span>+clientAddr[<span class="number">10</span>:],<span class="comment">//可以修改，会提供rename命令修改</span></span><br><span class="line">id: clientAddr, <span class="comment">//id不会修改，作为map中的key</span></span><br><span class="line">msg: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>),<span class="comment">//注意要make空间，否则无法写数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加user到map结构</span></span><br><span class="line">allUsers[newUser.id] = newUser</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个退出信号，用户监听client退出</span></span><br><span class="line"><span class="keyword">var</span> isQuit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//创建一个用于重置计数器的管道，用于告知watch函数，当前用户正在输入</span></span><br><span class="line"><span class="keyword">var</span> restTimer = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//启动go程，负责监听退出信号</span></span><br><span class="line"><span class="keyword">go</span> watch(&amp;newUser,conn,isQuit,restTimer)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动go程，负责将msg数据返回给客户端</span></span><br><span class="line"><span class="keyword">go</span> writeBackToClient(&amp;newUser,conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">//向message写入数据，当前用户上线的消息，用于通知所有人</span></span><br><span class="line">loginInfo := fmt.Sprintf(<span class="string">"[%s]:[%s] ===&gt; 上线了login！！\n"</span>,newUser.id,newUser.name)</span><br><span class="line">message &lt;- loginInfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//具体业务逻辑</span></span><br><span class="line">buf :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取客户端发送过来的数据</span></span><br><span class="line">cnt,err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> cnt == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"客户端主动关闭ctrl+c，准备退出！"</span>)</span><br><span class="line"><span class="comment">//map删除用户，conn close</span></span><br><span class="line"><span class="comment">//服务器还可以主动的退出</span></span><br><span class="line"><span class="comment">//在这里不进行真正的退出动作，而是发送一个退出信号，统一做退出处理，可以使用新的管道做信号传递</span></span><br><span class="line">isQuit &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn.Read err:"</span>,err,<span class="string">",cnt:"</span>,cnt)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"服务器接受客户端发送过来的数据为："</span>,<span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]),<span class="string">",cnt: "</span>,cnt)</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务逻辑处理 开始-----------</span></span><br><span class="line"><span class="comment">//1.查询当前所有的用户 who</span></span><br><span class="line"><span class="comment">//判断接受的数据是不是who ==&gt; 长度&amp;字符串</span></span><br><span class="line">userInput := <span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]) <span class="comment">//这是用户输入的数据，最后一个是回车，去掉回车</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userInput)==<span class="number">4</span> &amp;&amp; userInput == <span class="string">"\\who"</span> &#123;</span><br><span class="line"><span class="comment">//遍历allUsers这个map：（key: userid value：user本身）</span></span><br><span class="line">fmt.Println(<span class="string">"用户即将查询所有用户信息！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个切片包含所有的用户信息</span></span><br><span class="line"><span class="keyword">var</span> userInfos []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line">userInfo := fmt.Sprintf(<span class="string">"userid:%s,username:%s"</span>,user.id,user.name)</span><br><span class="line">userInfos = <span class="built_in">append</span>(userInfos,userInfo )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终写到管道中，一定是一个字符串</span></span><br><span class="line">r := strings.Join(userInfos,<span class="string">"\n"</span>) <span class="comment">//连接数字切片，生成字符串</span></span><br><span class="line"><span class="comment">//将数据返回给查询的客户端</span></span><br><span class="line">newUser.msg &lt;- r</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(userInput) &gt;<span class="number">9</span> &amp;&amp; userInput[:<span class="number">7</span>]==<span class="string">"\\rename"</span> &#123;</span><br><span class="line"><span class="comment">//规则：rename|ddd</span></span><br><span class="line"><span class="comment">//读取数据判断长度，判断字符是rename</span></span><br><span class="line"><span class="comment">//使用|分割，获取|后面的内容，作为名字</span></span><br><span class="line"><span class="comment">//更新用户名字 newUser.name = ddd</span></span><br><span class="line">newUser.name = strings.Split(userInput,<span class="string">"|"</span>)[<span class="number">1</span>]</span><br><span class="line">allUsers[newUser.id] = newUser <span class="comment">//更新map中的user</span></span><br><span class="line"><span class="comment">//通知客户端，更新成功</span></span><br><span class="line">newUser.msg &lt;- <span class="string">"rename successfully!"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果用户输入的不是命令，只是普通的聊天信息，那么只需要写入到广播通道中，由其他的go程进行常规转发</span></span><br><span class="line">message &lt;- userInput</span><br><span class="line">&#125;</span><br><span class="line">restTimer &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务逻辑处理 结束-----------</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向所有的用户广播消息，启动一个全局唯一的go程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"广播go程启动成功..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.从message中读取数据</span></span><br><span class="line">info := &lt;-message</span><br><span class="line">fmt.Println(<span class="string">"message接收到的消息："</span>, info)</span><br><span class="line"><span class="comment">//2.将数据写入到每一个用户的msg管道中</span></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line"><span class="comment">//如果msg是非缓冲的，那么会在这里阻塞</span></span><br><span class="line">user.msg &lt;- info</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个用户应该还有一个用来监听自己msg管道的go程，负责将数据返回给客户端。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeBackToClient</span><span class="params">(user *User,conn net.Conn)</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user ： %s的go程正在监听自己的msg管道\n"</span>,user.name)</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> user.msg &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user:%s写回给客户端的数据为:%s\n"</span>,user.name,data)</span><br><span class="line">_,_ = conn.Write([]<span class="keyword">byte</span>(data+<span class="string">"\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动一个go程，负责监听退出信号，触发后进行清理工作：delete map，close conn都在这里处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(user *User,conn net.Conn,isQuit &lt;- <span class="keyword">chan</span> <span class="keyword">bool</span>,restTimer &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"启动监听退出信号的go程..."</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"watch go程退出！"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- isQuit:</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s exit already!\n"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;- time.After(<span class="number">10</span>*time.Second):</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s timeout exit already!\n"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;- restTimer:</span><br><span class="line">fmt.Printf(<span class="string">"连接%s 重置计数器！\n"</span>,user.name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;用Go语言简单实现一个网络聊天室，首先创建一个chatroom的文件夹，在文件夹下创建&lt;code&gt;chatroom.go&lt;/code&gt;文件。
      
    
    </summary>
    
    
      <category term="代码" scheme="elssm.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>利用FGSM攻击MNIST数据集(Pytorch)</title>
    <link href="elssm.github.io/2021/03/15/%E5%88%A9%E7%94%A8FGSM%E6%94%BB%E5%87%BBMNIST%E6%95%B0%E6%8D%AE%E9%9B%86-Pytorch/"/>
    <id>elssm.github.io/2021/03/15/利用FGSM攻击MNIST数据集-Pytorch/</id>
    <published>2021-03-15T06:37:09.000Z</published>
    <updated>2021-03-15T08:38:03.939Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>FGSM的全称是Fast Gradient Sign Method(快速梯度下降法），在白盒环境下，通过求出模型对输入的导数，然后用符号函数得到其具体的梯度方向，接着乘以一个步长，得到的“扰动”加在原来的输入 上就得到了在FGSM攻击下的样本。本文将实现在Pytorch框架下使用FGSM攻击MNIST数据集</p><h4 id="训练模型的保存"><a href="#训练模型的保存" class="headerlink" title="训练模型的保存"></a>训练模型的保存</h4><p>通过之前MNIST识别的代码实现，我们就可以实现模型的保存。只需要在最后加上一行代码即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">"mnist_model.pth"</span>)</span><br></pre></td></tr></table></figure><p>save函数有两个参数，第一个参数是模型的状态。其中<code>model.state_dict()</code>只保存模型权重参数，不保存模型结构，而<code>model</code>则保存整个模型的状态。这里我们使用<code>model.state_dict()</code>，第二个参数是路径和保存的文件名。这里我们保存在同级目录下，文件名是<code>mnist_model.pth</code></p><p>训练模型完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">epochs = <span class="number">5</span></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">test_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">20</span>*<span class="number">10</span>*<span class="number">10</span>,<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">500</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        input_size = x.size(<span class="number">0</span>) <span class="comment">#获取batch_size</span></span><br><span class="line">        x = self.conv1(x) <span class="comment">#卷积</span></span><br><span class="line">        x = F.relu(x) <span class="comment">#激活</span></span><br><span class="line">        x = F.max_pool2d(x,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">#池化</span></span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)  <span class="comment"># 激活</span></span><br><span class="line">        x = x.view(input_size,<span class="number">-1</span>) <span class="comment">#拉平</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x,dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line">optimizer = optim.Adam(model.parameters())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,epoch)</span>:</span></span><br><span class="line">    <span class="comment">#模型训练</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_index,(data,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment">#梯度初始化为0</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment">#预测</span></span><br><span class="line">        output = model(data)</span><br><span class="line">        <span class="comment">#计算损失</span></span><br><span class="line">        loss = F.cross_entropy(output,target)</span><br><span class="line">        <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">        <span class="comment"># pred = output.max(1,keepdim=True)</span></span><br><span class="line">        <span class="comment">#反向传播</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_index % <span class="number">600</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epoch,loss.item()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader)</span>:</span></span><br><span class="line">    <span class="comment">#模型验证</span></span><br><span class="line">    model.eval()</span><br><span class="line">    <span class="comment">#正确率</span></span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">#测试损失</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():<span class="comment">#不会计算梯度也不会进行反向传播</span></span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> test_loader:</span><br><span class="line">            <span class="comment">#测试数据</span></span><br><span class="line">            output = model(data)</span><br><span class="line">            <span class="comment">#计算测试损失</span></span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>] <span class="comment">#值 索引</span></span><br><span class="line">            <span class="comment">#pred = torch.max(output,dim=1)</span></span><br><span class="line">            <span class="comment">#pred = output.argmax(dim=1)</span></span><br><span class="line">            <span class="comment">#累计正确率</span></span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(test_loader.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(test_loader.dataset)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>,epochs+<span class="number">1</span>):</span><br><span class="line">    train_model(model,train_loader,optimizer,epoch)</span><br><span class="line">    test_model(model,test_loader)</span><br><span class="line">torch.save(model.state_dict(), <span class="string">"mnist_model.pth"</span>)</span><br></pre></td></tr></table></figure><h4 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h4><h5 id="相关模块的导入"><a href="#相关模块的导入" class="headerlink" title="相关模块的导入"></a>相关模块的导入</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>可能遇到的错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OMP: Error <span class="comment">#15: Initializing libomp.dylib, but found libiomp5.dylib already initialized.</span></span><br><span class="line">OMP: Hint This means that multiple copies of the OpenMP runtime have been linked into the program. That <span class="keyword">is</span> dangerous, since it can degrade performance <span class="keyword">or</span> cause incorrect results. The best thing to do <span class="keyword">is</span> to ensure that only a single OpenMP runtime <span class="keyword">is</span> linked into the process, e.g. by avoiding static linking of the OpenMP runtime <span class="keyword">in</span> any library. As an unsafe, unsupported, undocumented workaround you can set the environment variable KMP_DUPLICATE_LIB_OK=TRUE to allow the program to <span class="keyword">continue</span> to execute, but that may cause crashes <span class="keyword">or</span> silently produce incorrect results. For more information, please see http://openmp.llvm.org/</span><br></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"KMP_DUPLICATE_LIB_OK"</span>]=<span class="string">"TRUE"</span></span><br></pre></td></tr></table></figure><h5 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h5><p>其中epsilons是FGSM攻击所加的扰动，值不超过1。pretrained_model是预训练模型，也就是我们上面保存的训练模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epsilons = [<span class="number">0</span>, <span class="number">.05</span>, <span class="number">.1</span>, <span class="number">.15</span>, <span class="number">.2</span>, <span class="number">.25</span>, <span class="number">.3</span>]</span><br><span class="line">pretrained_model = <span class="string">"mnist_model.pth"</span></span><br></pre></td></tr></table></figure><h5 id="定义受攻击的模型"><a href="#定义受攻击的模型" class="headerlink" title="定义受攻击的模型"></a>定义受攻击的模型</h5><p>这里的模型与我们上面MNIST识别所定义的模型相同。我们使用两个卷积层和两个全连接层，具体定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">20</span>*<span class="number">10</span>*<span class="number">10</span>,<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">500</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        input_size = x.size(<span class="number">0</span>) <span class="comment">#获取batch_size</span></span><br><span class="line">        x = self.conv1(x) <span class="comment">#卷积</span></span><br><span class="line">        x = F.relu(x) <span class="comment">#激活</span></span><br><span class="line">        x = F.max_pool2d(x,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">#池化</span></span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)  <span class="comment"># 激活</span></span><br><span class="line">        x = x.view(input_size,<span class="number">-1</span>) </span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x,dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h5 id="加载测试集"><a href="#加载测试集" class="headerlink" title="加载测试集"></a>加载测试集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_loader = DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">'data'</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            ])),</span><br><span class="line">        batch_size=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h5 id="实例化模型"><a href="#实例化模型" class="headerlink" title="实例化模型"></a>实例化模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = Net()</span><br></pre></td></tr></table></figure><h5 id="加载预训练模型"><a href="#加载预训练模型" class="headerlink" title="加载预训练模型"></a>加载预训练模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.load_state_dict(torch.load(pretrained_model))</span><br></pre></td></tr></table></figure><h5 id="定义模型的评估模式"><a href="#定义模型的评估模式" class="headerlink" title="定义模型的评估模式"></a>定义模型的评估模式</h5><p>这里设置eval进行训练默认不开启Dropout和BatchNormalization</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.eval()</span><br></pre></td></tr></table></figure><h5 id="定义FGSM攻击模型"><a href="#定义FGSM攻击模型" class="headerlink" title="定义FGSM攻击模型"></a>定义FGSM攻击模型</h5><p>在FGSM攻击模型函数中一共有3个参数，第一个参数是原始图片，第二个参数是攻击的扰动量，一般在0～1之间，第三个参数是图像关于求导之后的损失。最后由于对抗样本可能会在（0，1）范围之外，所以通过clamp函数将加扰动之后的图片限制在（0，1）之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fgsm_attack</span><span class="params">(image, epsilon, data_grad)</span>:</span></span><br><span class="line">    sign_data_grad = data_grad.sign()</span><br><span class="line">    perturbed_image = image + epsilon*sign_data_grad</span><br><span class="line">    perturbed_image = torch.clamp(perturbed_image, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> perturbed_image</span><br></pre></td></tr></table></figure><h5 id="定义测试函数"><a href="#定义测试函数" class="headerlink" title="定义测试函数"></a>定义测试函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">( model, test_loader, epsilon )</span>:</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    adv_examples = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data.requires_grad = <span class="literal">True</span> <span class="comment">#开启自动求导</span></span><br><span class="line">        output = model(data)</span><br><span class="line">        init_pred = output.max(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">        <span class="keyword">if</span> init_pred.item() != target.item():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        loss = F.nll_loss(output, target) <span class="comment">#计算损失</span></span><br><span class="line">        model.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line"></span><br><span class="line">        data_grad = data.grad.data</span><br><span class="line">        perturbed_data = fgsm_attack(data, epsilon, data_grad)</span><br><span class="line"></span><br><span class="line">        output = model(perturbed_data) <span class="comment">#对加扰后的图片进行重新分类</span></span><br><span class="line"></span><br><span class="line">        final_pred = output.max(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line">        <span class="keyword">if</span> final_pred.item() == target.item():</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">            <span class="comment">#添加当epsilon为0的时候的5个对抗案例</span></span><br><span class="line">            <span class="keyword">if</span> (epsilon == <span class="number">0</span>) <span class="keyword">and</span> (len(adv_examples) &lt; <span class="number">5</span>):</span><br><span class="line">                adv_ex = perturbed_data.squeeze().detach().cpu().numpy()</span><br><span class="line">                adv_examples.append( (init_pred.item(), final_pred.item(), adv_ex))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(adv_examples) &lt; <span class="number">5</span>:</span><br><span class="line">                adv_ex = perturbed_data.squeeze().detach().cpu().numpy()</span><br><span class="line">                adv_examples.append( (init_pred.item(), final_pred.item(), adv_ex))</span><br><span class="line"></span><br><span class="line">    final_acc = correct/float(len(test_loader))</span><br><span class="line">    print(<span class="string">"Epsilon: &#123;&#125;\tTest Accuracy = &#123;&#125; / &#123;&#125; = &#123;&#125;"</span>.format(epsilon, correct, len(test_loader), final_acc))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回最终准确率和对抗案例</span></span><br><span class="line">    <span class="keyword">return</span> final_acc, adv_examples</span><br></pre></td></tr></table></figure><h5 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">accuracies = [] <span class="comment">#记录准确率</span></span><br><span class="line">examples = [] <span class="comment">#记录对抗攻击实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#针对每一个对抗扰动值进行一次训练</span></span><br><span class="line"><span class="keyword">for</span> eps <span class="keyword">in</span> epsilons:</span><br><span class="line">    acc, ex = test(model, test_loader, eps)</span><br><span class="line">    accuracies.append(acc)</span><br><span class="line">    examples.append(ex)</span><br></pre></td></tr></table></figure><h5 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h5><p><img src="/2021/03/15/利用FGSM攻击MNIST数据集-Pytorch/1.png" alt="1"></p><p>画出随着扰动值变化的准确率图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.plot(epsilons, accuracies, <span class="string">"*-"</span>)</span><br><span class="line">plt.yticks(np.arange(<span class="number">0</span>, <span class="number">1.1</span>, step=<span class="number">0.1</span>))</span><br><span class="line">plt.xticks(np.arange(<span class="number">0</span>, <span class="number">.35</span>, step=<span class="number">0.05</span>))</span><br><span class="line">plt.title(<span class="string">"Accuracy vs Epsilon"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Epsilon"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Accuracy"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/03/15/利用FGSM攻击MNIST数据集-Pytorch/2.png" alt="2"></p><p>画出在不同扰动值下对抗实例图，每个扰动值对应5张照片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">0</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(epsilons)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(examples[i])):</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        plt.subplot(len(epsilons),len(examples[<span class="number">0</span>]),cnt)</span><br><span class="line">        plt.xticks([], [])</span><br><span class="line">        plt.yticks([], [])</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">            plt.ylabel(<span class="string">"Eps: &#123;&#125;"</span>.format(epsilons[i]), fontsize=<span class="number">14</span>)</span><br><span class="line">        orig,adv,ex = examples[i][j]</span><br><span class="line">        plt.title(<span class="string">"&#123;&#125; -&gt; &#123;&#125;"</span>.format(orig, adv))</span><br><span class="line">        plt.imshow(ex, cmap=<span class="string">"gray"</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/03/15/利用FGSM攻击MNIST数据集-Pytorch/3.png" alt="3"></p><h4 id="FGSM攻击MNIST完整代码"><a href="#FGSM攻击MNIST完整代码" class="headerlink" title="FGSM攻击MNIST完整代码"></a>FGSM攻击MNIST完整代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"KMP_DUPLICATE_LIB_OK"</span>]=<span class="string">"TRUE"</span></span><br><span class="line"></span><br><span class="line">epsilons = [<span class="number">0</span>, <span class="number">.05</span>, <span class="number">.1</span>, <span class="number">.15</span>, <span class="number">.2</span>, <span class="number">.25</span>, <span class="number">.3</span>]</span><br><span class="line">pretrained_model = <span class="string">"mnist_model.pth"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#CNN model defination</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">20</span>*<span class="number">10</span>*<span class="number">10</span>,<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">500</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        input_size = x.size(<span class="number">0</span>) <span class="comment">#获取batch_size</span></span><br><span class="line">        x = self.conv1(x) <span class="comment">#卷积</span></span><br><span class="line">        x = F.relu(x) <span class="comment">#激活</span></span><br><span class="line">        x = F.max_pool2d(x,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">#池化</span></span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)  <span class="comment"># 激活</span></span><br><span class="line">        x = x.view(input_size,<span class="number">-1</span>) <span class="comment">#拉平</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x,dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">test_loader = DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">'data'</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            ])),</span><br><span class="line">        batch_size=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line">model.load_state_dict(torch.load(pretrained_model))</span><br><span class="line">model.eval()</span><br><span class="line"></span><br><span class="line"><span class="comment"># FGSM attack code</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fgsm_attack</span><span class="params">(image, epsilon, data_grad)</span>:</span></span><br><span class="line">    sign_data_grad = data_grad.sign()</span><br><span class="line">    perturbed_image = image + epsilon*sign_data_grad</span><br><span class="line">    perturbed_image = torch.clamp(perturbed_image, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> perturbed_image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">( model, test_loader, epsilon )</span>:</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    adv_examples = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data.requires_grad = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        output = model(data)</span><br><span class="line">        init_pred = output.max(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> init_pred.item() != target.item():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        loss = F.nll_loss(output, target)</span><br><span class="line">        model.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line"></span><br><span class="line">        data_grad = data.grad.data</span><br><span class="line">        perturbed_data = fgsm_attack(data, epsilon, data_grad)</span><br><span class="line">        output = model(perturbed_data)</span><br><span class="line"></span><br><span class="line">        final_pred = output.max(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line">        <span class="keyword">if</span> final_pred.item() == target.item():</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (epsilon == <span class="number">0</span>) <span class="keyword">and</span> (len(adv_examples) &lt; <span class="number">5</span>):</span><br><span class="line">                adv_ex = perturbed_data.squeeze().detach().cpu().numpy()</span><br><span class="line">                adv_examples.append( (init_pred.item(), final_pred.item(), adv_ex))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(adv_examples) &lt; <span class="number">5</span>:</span><br><span class="line">                adv_ex = perturbed_data.squeeze().detach().cpu().numpy()</span><br><span class="line">                adv_examples.append( (init_pred.item(), final_pred.item(), adv_ex))</span><br><span class="line"></span><br><span class="line">    final_acc = correct/float(len(test_loader))</span><br><span class="line">    print(<span class="string">"Epsilon: &#123;&#125;\tTest Accuracy = &#123;&#125; / &#123;&#125; = &#123;&#125;"</span>.format(epsilon, correct, len(test_loader), final_acc))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> final_acc, adv_examples</span><br><span class="line"></span><br><span class="line">accuracies = []</span><br><span class="line">examples = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> eps <span class="keyword">in</span> epsilons:</span><br><span class="line">    acc, ex = test(model, test_loader, eps)</span><br><span class="line">    accuracies.append(acc)</span><br><span class="line">    examples.append(ex)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.plot(epsilons, accuracies, <span class="string">"*-"</span>)</span><br><span class="line">plt.yticks(np.arange(<span class="number">0</span>, <span class="number">1.1</span>, step=<span class="number">0.1</span>))</span><br><span class="line">plt.xticks(np.arange(<span class="number">0</span>, <span class="number">.35</span>, step=<span class="number">0.05</span>))</span><br><span class="line">plt.title(<span class="string">"Accuracy vs Epsilon"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Epsilon"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Accuracy"</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(epsilons)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(examples[i])):</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        plt.subplot(len(epsilons),len(examples[<span class="number">0</span>]),cnt)</span><br><span class="line">        plt.xticks([], [])</span><br><span class="line">        plt.yticks([], [])</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">            plt.ylabel(<span class="string">"Eps: &#123;&#125;"</span>.format(epsilons[i]), fontsize=<span class="number">14</span>)</span><br><span class="line">        orig,adv,ex = examples[i][j]</span><br><span class="line">        plt.title(<span class="string">"&#123;&#125; -&gt; &#123;&#125;"</span>.format(orig, adv))</span><br><span class="line">        plt.imshow(ex, cmap=<span class="string">"gray"</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;FGSM的全称是Fast Gradient Sign Method(快速梯度下降法），在白盒环境下，通过求出模型对输入的导数，然后用符号函数
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用GAN生成MNIST数据集(Pytorch)</title>
    <link href="elssm.github.io/2021/03/14/%E4%BD%BF%E7%94%A8GAN%E7%94%9F%E6%88%90MNIST%E6%95%B0%E6%8D%AE%E9%9B%86-Pytorch/"/>
    <id>elssm.github.io/2021/03/14/使用GAN生成MNIST数据集-Pytorch/</id>
    <published>2021-03-14T11:35:06.000Z</published>
    <updated>2021-03-14T14:24:33.803Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上一篇文章里实现了MNIST手写数据集的识别之后，趁热打铁，这一篇文章使用GAN来实现MNIST数据集的生成。2014年Ian Goodfellow的那篇GAN是我接触的第一篇有关机器学习的文章。那篇文章被称为GAN的开山之作，它提出了一种新的生成式框架，其中包括生成模型和鉴别模型。生成模型用于描述数据的分布，生成尽可能拟合真实数据的分布，而鉴别模型用于对生成模型各个迭代轮次产生的结果进行评估，其中利用到了一种博弈的思想。</p><p><img src="/2021/03/14/使用GAN生成MNIST数据集-Pytorch/1.png" alt="1"></p><p>在GAN模型的后面是大量的度量单位和公式推导，在这里我们不做详细说明。今天主要是通过GAN的方式利用两个模型（卷积网络和线性网络）实现MNIST数据集的生成。</p><h4 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h4><p>首先还是模块的导入，对应相关模块的功能在上一篇文章已做了相关说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br></pre></td></tr></table></figure><p>参数定义，其中<code>z_dimension</code>是随机生成噪声的维度，这里定义为100维，可以自定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">epochs = <span class="number">3</span></span><br><span class="line">z_dimension = <span class="number">100</span></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>数据集的加载，由于是生成MNIST数据集，所以这次不需要对测试集进行加载，通过训练集进行训练生成即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,transform=transforms,download=<span class="literal">True</span>)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>判别器的定义,采用三层的线性模型。Linear的两个参数分别是输出层和隐藏层。在第一层的输出层是784是因为MNIST图片大小是<code>1*28*28</code>，中间的隐藏层可以自定义，线性变换之后采用一个LeakyReLU的激活函数实现非线性映射,参数0.2是激活函数的斜率。最后使用Sigmoid函数实现概率值的映射，sigmoid常用作二分类问题。在这里使用sigmoid函数得到一个0到1的概率进行二分类。在forward函数中还采用了一个squeeze函数，这个函数主要对数据的维度进行压缩，去掉维数为1的的维度，默认是将a中所有为1的维度删掉。x.squeeze(-1)用于将二维压缩为一维。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.dis = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>,<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.dis(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>生成器的定义，生成器和判别器的定义相同，也是经过一个三层的线性模型，其中第一个Linear函数的第一个参数是100，这是在前面参数定义的z_dimension = 100也就是随机噪声的维度，在生成器中使用的激活函数是Relu激活函数，最后一层Linear函数的输出层是784维对应了MNIST数据的大小，之后使用Tanh激活函数是希望生成的假的图片数据分布能够在-1～1之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.gen = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">100</span>,<span class="number">256</span>), </span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">256</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">784</span>),</span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.gen(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>实例化生成器模型和判别器模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dis = Discriminator()</span><br><span class="line">Gen = Generator()</span><br></pre></td></tr></table></figure><p>定义损失函数和优化器，其中BCELoss是单目标二分类交叉熵函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.BCELoss()</span><br><span class="line">Dis_optimizer = torch.optim.Adam(Dis.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line">Gen_optimizer = torch.optim.Adam(Gen.parameters(),lr=<span class="number">0.0003</span>)</span><br></pre></td></tr></table></figure><p>开始训练。训练集中包含图片和标签数据。通过img.size(0)可以得到每一批数据的数量，也就是我们之前设定的batch_size大小，随后通过view函数将数据进行拉平成二维方便后续的处理，之后分别计算真实图片和假图片的损失并进行迭代训练，最后将生成的真实图片和假的图片保存在img文件夹下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (img,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        num_img = img.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#训练判别器</span></span><br><span class="line">        img = img.view(num_img,<span class="number">-1</span>) <span class="comment">#拉成64*784</span></span><br><span class="line">        real_img = Variable(img) <span class="comment">#将tensor变成Variable计算</span></span><br><span class="line">        real_label = Variable(torch.ones(num_img)) <span class="comment">#真图片label为1</span></span><br><span class="line">        fake_label = Variable(torch.zeros(num_img)) <span class="comment">#假图片label为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算真实图片的loss</span></span><br><span class="line">        real_out = Dis(real_img) <span class="comment">#图片放入判别器</span></span><br><span class="line">        d_loss_real = criterion(real_out,real_label) <span class="comment">#计算loss</span></span><br><span class="line">        real_scores = real_out</span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算假图片的loss</span></span><br><span class="line">        z = Variable(torch.randn(num_img,z_dimension)) <span class="comment">#随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        fake_out = Dis(fake_img)</span><br><span class="line">        d_loss_fake = criterion(fake_out,fake_label)</span><br><span class="line">        fake_scores = fake_out</span><br><span class="line"></span><br><span class="line">        d_loss = d_loss_real + d_loss_fake</span><br><span class="line">        Dis_optimizer.zero_grad()</span><br><span class="line">        d_loss.backward()</span><br><span class="line">        Dis_optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#训练生成器</span></span><br><span class="line">        z = Variable(torch.randn(num_img, z_dimension))  <span class="comment"># 随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        output = Dis(fake_img)</span><br><span class="line">        g_loss = criterion(output,real_label)</span><br><span class="line"></span><br><span class="line">        Gen_optimizer.zero_grad()</span><br><span class="line">        g_loss.backward()</span><br><span class="line">        Gen_optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> ==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch &#123;&#125;,d_loss: &#123;:.6f&#125;,g_loss: &#123;:.6f&#125;,D real: &#123;:.6f&#125;,D fake: &#123;:.6f&#125;'</span>.format(                epoch,d_loss.item(),g_loss.item(),real_scores.data.mean(),fake_scores.data.mean()</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">if</span> epoch == <span class="number">0</span>:</span><br><span class="line">            real_images = to_img(real_img.data)</span><br><span class="line">            save_image(real_images.data,<span class="string">'img/real_images.png'</span>)</span><br><span class="line">        fake_images = to_img(fake_img.data)</span><br><span class="line">        save_image(fake_images.data,<span class="string">"img/fake_images-&#123;&#125;.png"</span>.format(epoch))</span><br></pre></td></tr></table></figure><p>结果展示，下图是训练3轮次后生成的图像。因为代码是在自己电脑上跑的所以训练的次数比较少，生成的图片不太清晰。</p><p><img src="/2021/03/14/使用GAN生成MNIST数据集-Pytorch/2.png" alt="2"></p><p>训练20轮次的结果</p><p><img src="/2021/03/14/使用GAN生成MNIST数据集-Pytorch/3.png" alt="3"></p><p>训练50轮次的结果，怎么感觉越训练越差了。。。后面再看看具体调优的事。</p><p><img src="/2021/03/14/使用GAN生成MNIST数据集-Pytorch/4.png" alt="4"></p><h4 id="卷积模型"><a href="#卷积模型" class="headerlink" title="卷积模型"></a>卷积模型</h4><p>卷积模型和线性模型的代码主要是模型的定义处不太相同。</p><p>首先是判别器的定义，其中判别器采用的是两层的卷积模型和一层的全连接层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">32</span>,<span class="number">5</span>,padding=<span class="number">2</span>),<span class="comment">#32,28,28</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>),<span class="comment">#32,14,14</span></span><br><span class="line">        )</span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>), <span class="comment">#64,14,14</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>), <span class="comment">#64,7,7</span></span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">7</span>*<span class="number">7</span>,<span class="number">1024</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>,<span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>) <span class="comment">#将4维转为2维</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>) <span class="comment">#将2维转为1维</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>其次是生成器的定义，生成器首先是经过一个全连接层，其中input_size是100也就是随机噪声的维度，num_feature是我们定义的数值为3136，这个可以自定义，只要最后转为[batch,1,28,28]形式就行。其中 BatchNorm2d函数用来做归一化处理，这里我们只写入了BatchNorm2d的第一个参数，也就是输入图像的通道数，所以刚开始是1。后面的通道数随着卷积操作的改变而改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, num_feature)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(input_size, num_feature)  <span class="comment"># batch, 3136=1x56x56</span></span><br><span class="line">        self.br = nn.Sequential(</span><br><span class="line">            nn.BatchNorm2d(<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">50</span>, <span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>),  <span class="comment"># batch, 50, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">50</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">50</span>, <span class="number">25</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),  <span class="comment"># batch, 25, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">25</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">25</span>, <span class="number">1</span>, <span class="number">2</span>, stride=<span class="number">2</span>),  <span class="comment"># batch, 1, 28, 28</span></span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">56</span>, <span class="number">56</span>)</span><br><span class="line">        x = self.br(x)</span><br><span class="line">        x = self.downsample1(x)</span><br><span class="line">        x = self.downsample2(x)</span><br><span class="line">        x = self.downsample3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>实例化生成器和判别器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dis = Discriminator()</span><br><span class="line">Gen = Generator(z_dimension,<span class="number">3136</span>)</span><br></pre></td></tr></table></figure><p>进行训练，这里需要注意的是在训练的时候不需要使用view函数将img转为二维，这里直接对四维数据进行处理。剩下的操作和线性模型相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (img,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment">#训练判别器</span></span><br><span class="line">        <span class="comment"># img = img.view(num_img,-1) #拉成64*784</span></span><br><span class="line">        real_img = Variable(img) <span class="comment">#将tensor变成Variable计算</span></span><br><span class="line">        real_label = Variable(torch.ones(num_img)) <span class="comment">#真图片label为1</span></span><br><span class="line">        fake_label = Variable(torch.zeros(num_img)) <span class="comment">#假图片label为0</span></span><br></pre></td></tr></table></figure><h4 id="线性模型完整代码"><a href="#线性模型完整代码" class="headerlink" title="线性模型完整代码"></a>线性模型完整代码</h4><p>注意要在同级目录下创建一个img的文件夹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment">#用来还原真实数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_img</span><span class="params">(x)</span>:</span></span><br><span class="line">    out = <span class="number">0.5</span> * (x + <span class="number">1</span>)</span><br><span class="line">    out = out.clamp(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">#将随机变化的数值限制在一个给定的区间</span></span><br><span class="line">    out = out.view(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">epochs = <span class="number">50</span></span><br><span class="line">z_dimension = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,transform=transforms,download=<span class="literal">True</span>)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.dis = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>,<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.dis(x)</span><br><span class="line">        x = x.squeeze(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.gen = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">100</span>,<span class="number">256</span>), <span class="comment">#输入一个100维的0～1之间的高斯分布</span></span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">256</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">784</span>),</span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.gen(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">Dis = Discriminator()</span><br><span class="line">Gen = Generator()</span><br><span class="line"></span><br><span class="line">criterion = nn.BCELoss()</span><br><span class="line">Dis_optimizer = torch.optim.Adam(Dis.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line">Gen_optimizer = torch.optim.Adam(Gen.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (img,_) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        num_img = img.size(<span class="number">0</span>) <span class="comment">#获取图片大小 64</span></span><br><span class="line">        <span class="comment">#训练判别器</span></span><br><span class="line">        img = img.view(num_img,<span class="number">-1</span>) <span class="comment">#拉平成64*784</span></span><br><span class="line">        real_img = Variable(img) <span class="comment">#将tensor变成Variable计算</span></span><br><span class="line">        real_label = Variable(torch.ones(num_img)) <span class="comment">#真图片label为1</span></span><br><span class="line">        fake_label = Variable(torch.zeros(num_img)) <span class="comment">#假图片label为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算真实图片的loss</span></span><br><span class="line">        real_out = Dis(real_img) <span class="comment">#图片放入判别器</span></span><br><span class="line">        d_loss_real = criterion(real_out,real_label) <span class="comment">#计算loss</span></span><br><span class="line">        real_scores = real_out</span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算假图片的loss</span></span><br><span class="line">        z = Variable(torch.randn(num_img,z_dimension)) <span class="comment">#随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        fake_out = Dis(fake_img)</span><br><span class="line">        d_loss_fake = criterion(fake_out,fake_label)</span><br><span class="line">        fake_scores = fake_out</span><br><span class="line"></span><br><span class="line">        d_loss = d_loss_real + d_loss_fake</span><br><span class="line">        Dis_optimizer.zero_grad()</span><br><span class="line">        d_loss.backward()</span><br><span class="line">        Dis_optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#训练生成器</span></span><br><span class="line">        z = Variable(torch.randn(num_img, z_dimension))  <span class="comment"># 随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        output = Dis(fake_img)</span><br><span class="line">        g_loss = criterion(output,real_label)</span><br><span class="line"></span><br><span class="line">        Gen_optimizer.zero_grad()</span><br><span class="line">        g_loss.backward()</span><br><span class="line">        Gen_optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> ==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch &#123;&#125;,d_loss: &#123;:.6f&#125;,g_loss: &#123;:.6f&#125;,D real: &#123;:.6f&#125;,D fake: &#123;:.6f&#125;'</span>.format(</span><br><span class="line">                epoch,d_loss.item(),g_loss.item(),real_scores.data.mean(),fake_scores.data.mean()</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">if</span> epoch == <span class="number">0</span>:</span><br><span class="line">            real_images = to_img(real_img.data)</span><br><span class="line">            save_image(real_images.data,<span class="string">'img/real_images.png'</span>)</span><br><span class="line">        fake_images = to_img(fake_img.data)</span><br><span class="line">        save_image(fake_images.data,<span class="string">"img/fake_images-&#123;&#125;.png"</span>.format(epoch))</span><br></pre></td></tr></table></figure><h4 id="卷积模型完整代码"><a href="#卷积模型完整代码" class="headerlink" title="卷积模型完整代码"></a>卷积模型完整代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment">#还原真实数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_img</span><span class="params">(x)</span>:</span></span><br><span class="line">    out = <span class="number">0.5</span> * (x + <span class="number">1</span>)</span><br><span class="line">    out = out.clamp(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">#将随机变化的数值限制在一个给定的区间</span></span><br><span class="line">    out = out.view(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">epochs = <span class="number">3</span></span><br><span class="line">z_dimension = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,transform=transforms,download=<span class="literal">True</span>)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">32</span>,<span class="number">5</span>,padding=<span class="number">2</span>),<span class="comment">#32,28,28</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>),<span class="comment">#32,14,14</span></span><br><span class="line">        )</span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>), <span class="comment">#64,14,41</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>), <span class="comment">#64,7,7</span></span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">7</span>*<span class="number">7</span>,<span class="number">1024</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>,<span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, num_feature)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(input_size, num_feature)  <span class="comment"># batch, 3136=1x56x56</span></span><br><span class="line">        self.br = nn.Sequential(</span><br><span class="line">            nn.BatchNorm2d(<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">50</span>, <span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>),  <span class="comment"># batch, 50, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">50</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">50</span>, <span class="number">25</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),  <span class="comment"># batch, 25, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">25</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">25</span>, <span class="number">1</span>, <span class="number">2</span>, stride=<span class="number">2</span>),  <span class="comment"># batch, 1, 28, 28</span></span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">56</span>, <span class="number">56</span>)</span><br><span class="line">        x = self.br(x)</span><br><span class="line">        x = self.downsample1(x)</span><br><span class="line">        x = self.downsample2(x)</span><br><span class="line">        x = self.downsample3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dis = Discriminator()</span><br><span class="line">Gen = Generator(z_dimension,<span class="number">3136</span>)</span><br><span class="line"></span><br><span class="line">criterion = nn.BCELoss()</span><br><span class="line">Dis_optimizer = torch.optim.Adam(Dis.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line">Gen_optimizer = torch.optim.Adam(Gen.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (img,_) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment">#训练判别器</span></span><br><span class="line">        real_img = Variable(img) <span class="comment">#将tensor变成Variable计算</span></span><br><span class="line">        real_label = Variable(torch.ones(num_img)) <span class="comment">#真图片label为1</span></span><br><span class="line">        fake_label = Variable(torch.zeros(num_img)) <span class="comment">#假图片label为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算真实图片的loss</span></span><br><span class="line">        real_out = Dis(real_img) <span class="comment">#图片放入判别器</span></span><br><span class="line">        d_loss_real = criterion(real_out,real_label) <span class="comment">#计算loss</span></span><br><span class="line">        real_scores = real_out</span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算假图片的loss</span></span><br><span class="line">        z = Variable(torch.randn(num_img,z_dimension)) <span class="comment">#随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        fake_out = Dis(fake_img)</span><br><span class="line">        d_loss_fake = criterion(fake_out,fake_label)</span><br><span class="line">        fake_scores = fake_out</span><br><span class="line"></span><br><span class="line">        d_loss = d_loss_real + d_loss_fake</span><br><span class="line">        Dis_optimizer.zero_grad()</span><br><span class="line">        d_loss.backward()</span><br><span class="line">        Dis_optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#训练生成器</span></span><br><span class="line">        z = Variable(torch.randn(num_img, z_dimension))  <span class="comment"># 随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        output = Dis(fake_img)</span><br><span class="line">        g_loss = criterion(output,real_label)</span><br><span class="line"></span><br><span class="line">        Gen_optimizer.zero_grad()</span><br><span class="line">        g_loss.backward()</span><br><span class="line">        Gen_optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> ==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch &#123;&#125;,d_loss: &#123;:.6f&#125;,g_loss: &#123;:.6f&#125;,D real: &#123;:.6f&#125;,D fake: &#123;:.6f&#125;'</span>.format(</span><br><span class="line">                epoch,d_loss.item(),g_loss.item(),real_scores.data.mean(),fake_scores.data.mean()</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">if</span> epoch == <span class="number">0</span>:</span><br><span class="line">            real_images = to_img(real_img.data)</span><br><span class="line">            save_image(real_images.data,<span class="string">'img/real_images.png'</span>)</span><br><span class="line">        fake_images = to_img(fake_img.data)</span><br><span class="line">        save_image(fake_images.data,<span class="string">"img/fake_images-&#123;&#125;.png"</span>.format(epoch))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在上一篇文章里实现了MNIST手写数据集的识别之后，趁热打铁，这一篇文章使用GAN来实现MNIST数据集的生成。2014年Ian Goodf
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MNIST数据集识别(Pytorch)</title>
    <link href="elssm.github.io/2021/03/11/MNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB-Pytorch/"/>
    <id>elssm.github.io/2021/03/11/MNIST数据集识别-Pytorch/</id>
    <published>2021-03-11T02:11:37.000Z</published>
    <updated>2021-03-11T03:13:52.830Z</updated>
    
    <content type="html"><![CDATA[<p>入门机器学习的最简单案例就是对MNIST手写数据集的识别。本篇文章将会通过Pytorch框架完成对MNIST手写数据集识别。首先我们来简单了解一下MNIST。</p><h4 id="What-is-MNIST？"><a href="#What-is-MNIST？" class="headerlink" title="What is MNIST？"></a>What is MNIST？</h4><p>MNIST数据集是一个有名的手写数字数据集，该数据集包含60000个用于训练的示例和10000个用于测试的示例，这些数字已经经过尺寸标准化并位于图像中心，图像的固定大小是28*28像素，值为0到9。</p><h4 id="Pytorch识别MNIST"><a href="#Pytorch识别MNIST" class="headerlink" title="Pytorch识别MNIST"></a>Pytorch识别MNIST</h4><p>今天我们将通过Pytorch实现对MNIST的识别。对于Pytorch的安装这里不做介绍。</p><h4 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python==3.8</span><br><span class="line">torch==1.7.0</span><br></pre></td></tr></table></figure><p>本次代码利用pycharm进行编写，环境使用为<code>anaconda3</code>，使用cpu进行训练。</p><ul><li><h5 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h5><p>在使用Pytorch之前，我们要导入相关模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br></pre></td></tr></table></figure><p>其中，<code>datasets</code>用来导入MNIST数据集，<code>transforms</code>用于图像的转换处理，<code>DataLoader</code>用于加载数据集，<code>optim</code>用来加载优化器。</p></li><li><h5 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h5><p>在数据集识别中我们要定义比较多的参数和超参数，因为数据集比较大，如果一次训练太多的数据，效果不会很好，因此我们通常对数据集的训练数据进行分批训练，还有就是我们一般对一个数据集的所有数据不止训练一轮次，例如MNIST数据集，我们对它的60000张训练数据会进行多个轮次的训练，这样会产生更好的训练效果。具体定义如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">16</span> <span class="comment">#批次大小，一次训练16张数据</span></span><br><span class="line">epochs = <span class="number">5</span> <span class="comment">#对于60000张训练数据进行5轮训练</span></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(), <span class="comment">#将图片转换为张量</span></span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,)) <span class="comment">#进行归一化处理，参数默认使用官网给定值</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure></li><li><h5 id="数据集加载"><a href="#数据集加载" class="headerlink" title="数据集加载"></a>数据集加载</h5><p>定义好参数之后我们开始对数据集进行加载，利用<code>torchvision</code>中的<code>datasets</code>模块就可以导入MNIST数据集。之后再利用<code>DataLoader</code>对数据集进行加载即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">test_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>因为MNIST中分为训练数据和测试数据，因此我们需要进行两次导入和加载。其中<code>datasets.MNIST</code>的第一个参数是数据集导入的路径，这里使用<code>&quot;data&quot;</code>直接将数据集导入代码同级目录下，如果没有data目录会自动创建，在训练数据集的导入中，第二个参数<code>train</code>要设置为True，而在测试数据集中因为不需要进行训练，所以设置为False即可。后面的<code>transform</code>参数就是对图像进行一个处理，例如转换成张量和进行归一化处理，在<code>DataLoader</code>的参数中，<code>batch_size</code>就是每次训练的个数，<code>shuffle</code>参数的含义就是在每次训练的个数中进行一个随机打乱。这也算是处理过拟合现象的一种方式。</p></li><li><h5 id="模型的定义"><a href="#模型的定义" class="headerlink" title="模型的定义"></a>模型的定义</h5><p>在对数据集加载完成之后，我们开始定义自己的网络模型。我们使用了两个卷积层，之后使用了两个全连接层。在激活函数的选择上，我们使用relu作为激活函数，之后我们进行了一个2*2的池化操作，再对图像进行了一个拉平操作，最后我们采用<code>log_softmax</code>函数进行输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">20</span>*<span class="number">10</span>*<span class="number">10</span>,<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">500</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        input_size = x.size(<span class="number">0</span>) <span class="comment">#获取batch_size</span></span><br><span class="line">        x = self.conv1(x) <span class="comment">#卷积</span></span><br><span class="line">        x = F.relu(x) <span class="comment">#激活</span></span><br><span class="line">        x = F.max_pool2d(x,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">#池化</span></span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)  <span class="comment"># 激活</span></span><br><span class="line">        x = x.view(input_size,<span class="number">-1</span>) <span class="comment">#拉平</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x,dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></li><li><h5 id="模型的使用"><a href="#模型的使用" class="headerlink" title="模型的使用"></a>模型的使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = Net()</span><br><span class="line">optimizer = optim.Adam(model.parameters())</span><br></pre></td></tr></table></figure><p>第一行代码我们实例化了一个模型，第二行代码我们利用<code>optim</code>选择合适的优化器，这里我们使用了Adam优化器，你也可以根据需求采用其他优化器例如SGD。</p></li><li><h5 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,epoch)</span>:</span></span><br><span class="line">    <span class="comment">#模型训练</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_index,(data,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment">#梯度初始化为0</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment">#预测</span></span><br><span class="line">        output = model(data)</span><br><span class="line">        <span class="comment">#计算损失</span></span><br><span class="line">        loss = F.cross_entropy(output,target)</span><br><span class="line">        <span class="comment">#反向传播</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_index % <span class="number">600</span> == <span class="number">0</span>: <span class="comment">#每训练600次进行一次输出</span></span><br><span class="line">            print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epoch,loss.item()))</span><br></pre></td></tr></table></figure><p>在这里我们定义了一个训练函数，参数传递了定义的模型、训练的数据、优化器和训练轮次。在第二行代码中<code>model.train</code>的含义是在训练过程中采用Dropout和Normalization。这样有助于优化训练。之后我们对训练数据中的data和target进行提取。target相当于数据的标签。接下来我们对优化器的梯度进行初始化，如果不进行初始化梯度累加就会影响训练效果。计算损失这里采用交叉熵损失。接下来就是很重要的一步，进行反向传播。最后使用<code>optimizer.step()</code>对模型进行更新。</p></li><li><h5 id="测试集验证"><a href="#测试集验证" class="headerlink" title="测试集验证"></a>测试集验证</h5><p>测试集的验证和训练集差不多，不同的地方是在训练之前采用<code>model.eval()</code>，eval和train的区别在于，eval是不采用Dropout和Normalization。第二点就是在测试的时候不用计算梯度也不用进行反向传播。具体代码实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader)</span>:</span></span><br><span class="line">    <span class="comment">#模型验证</span></span><br><span class="line">    model.eval()</span><br><span class="line">    <span class="comment">#正确率</span></span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">#测试损失</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():<span class="comment">#不会计算梯度也不会进行反向传播</span></span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> test_loader:</span><br><span class="line">            <span class="comment"># data,target = data.to(device),target.to(device)</span></span><br><span class="line">            <span class="comment">#测试数据</span></span><br><span class="line">            output = model(data)</span><br><span class="line">            <span class="comment">#计算测试损失</span></span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>] <span class="comment">#值 索引</span></span><br><span class="line">            <span class="comment">#pred = torch.max(output,dim=1)</span></span><br><span class="line">            <span class="comment">#pred = output.argmax(dim=1)</span></span><br><span class="line">            <span class="comment">#累计正确率</span></span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(test_loader.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(test_loader.dataset)))</span><br></pre></td></tr></table></figure></li><li><h5 id="训练和测试结果展示"><a href="#训练和测试结果展示" class="headerlink" title="训练和测试结果展示"></a>训练和测试结果展示</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>,epochs+<span class="number">1</span>): <span class="comment">#进行5轮次训练</span></span><br><span class="line">    train_model(model,train_loader,optimizer,epoch)</span><br><span class="line">    test_model(model,test_loader)</span><br></pre></td></tr></table></figure><p><img src="/2021/03/11/MNIST数据集识别-Pytorch/1.png" alt="1"></p><p><img src="/2021/03/11/MNIST数据集识别-Pytorch/2.png" alt="2"></p><p>从图中我们可以看到训练效果并不随着训练轮次的增加而变得更好，在本次训练中，训练轮次为4的时候，准确率最高，达到了99.03%</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;入门机器学习的最简单案例就是对MNIST手写数据集的识别。本篇文章将会通过Pytorch框架完成对MNIST手写数据集识别。首先我们来简单了解一下MNIST。&lt;/p&gt;
&lt;h4 id=&quot;What-is-MNIST？&quot;&gt;&lt;a href=&quot;#What-is-MNIST？&quot; cla
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Hot100(Python)</title>
    <link href="elssm.github.io/2021/03/10/Leetcode-Hot100-Python/"/>
    <id>elssm.github.io/2021/03/10/Leetcode-Hot100-Python/</id>
    <published>2021-03-10T01:59:19.000Z</published>
    <updated>2021-04-19T15:07:17.566Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1-两数之和-easy"><a href="#1-两数之和-easy" class="headerlink" title="1.两数之和(easy)"></a>1.两数之和(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]==target:</span><br><span class="line">                    c.append(i)</span><br><span class="line">                    c.append(j)</span><br><span class="line">                    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></li><li><h4 id="2-两数相加-medium"><a href="#2-两数相加-medium" class="headerlink" title="2.两数相加(medium)"></a>2.两数相加(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c1=[]</span><br><span class="line">        c2=[]</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            c1.append(l1.val)</span><br><span class="line">            l1=l1.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            c2.append(l2.val)</span><br><span class="line">            l2=l2.next</span><br><span class="line">        j1=<span class="number">-1</span></span><br><span class="line">        j2=<span class="number">-1</span></span><br><span class="line">        sum1=<span class="number">0</span></span><br><span class="line">        sum2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c1)):</span><br><span class="line">            sum1=sum1*<span class="number">10</span>+c1[j1]</span><br><span class="line">            j1=j1<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c2)):</span><br><span class="line">            sum2=sum2*<span class="number">10</span>+c2[j2]</span><br><span class="line">            j2=j2<span class="number">-1</span></span><br><span class="line">        res=sum1+sum2</span><br><span class="line">        p=head=node=ListNode(<span class="literal">None</span>)</span><br><span class="line">        l=len(str(res))</span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            node=ListNode(res%<span class="number">10</span>)</span><br><span class="line">            p.next=node</span><br><span class="line">            p=node</span><br><span class="line">            res/=<span class="number">10</span></span><br><span class="line">            l-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></li><li><h4 id="3-无重复字符的最长子串-medium"><a href="#3-无重复字符的最长子串-medium" class="headerlink" title="3.无重复字符的最长子串(medium)"></a>3.无重复字符的最长子串(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        maxl=<span class="number">0</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">in</span> s[i:j]:</span><br><span class="line">                i = s[i:j].find(s[j])+i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j-i+<span class="number">1</span>&gt;maxl:</span><br><span class="line">                maxl=j-i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxl</span><br></pre></td></tr></table></figure></li><li><h4 id="4-寻找两个正序数组的中位数-hard"><a href="#4-寻找两个正序数组的中位数-hard" class="headerlink" title="4.寻找两个正序数组的中位数(hard)"></a>4.寻找两个正序数组的中位数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            nums1.append(i)</span><br><span class="line">        nums1 = sorted(nums1)</span><br><span class="line">        <span class="keyword">if</span> len(nums1)%<span class="number">2</span> !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[len(nums1)/<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums1[len(nums1)/<span class="number">2</span>]+nums1[len(nums1)/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span></span><br></pre></td></tr></table></figure></li><li><h4 id="11-盛最多水的容器-medium"><a href="#11-盛最多水的容器-medium" class="headerlink" title="11.盛最多水的容器(medium)"></a>11.盛最多水的容器(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(height)<span class="number">-1</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            h=min(height[i],height[j])</span><br><span class="line">            res=max(res,h*(j-i))</span><br><span class="line">            <span class="keyword">if</span> height[i]&gt;height[j]:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="15-三数之和-medium"><a href="#15-三数之和-medium" class="headerlink" title="15.三数之和(medium)"></a>15.三数之和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#第一种方法，可行但超时</span></span><br><span class="line">        <span class="comment"># if len(nums)==0 or len(nums)==1 or len(nums)==2:</span></span><br><span class="line">        <span class="comment">#     return []</span></span><br><span class="line">        <span class="comment"># sum_two=[]</span></span><br><span class="line">        <span class="comment"># d=&#123;&#125;</span></span><br><span class="line">        <span class="comment"># res=[]</span></span><br><span class="line">        <span class="comment"># count=0</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)-1):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,len(nums)):</span></span><br><span class="line">        <span class="comment">#         d[count]=[i,j]</span></span><br><span class="line">        <span class="comment">#         sum_two.append(nums[i]+nums[j])</span></span><br><span class="line">        <span class="comment">#         count+=1</span></span><br><span class="line">        <span class="comment"># # print(d)</span></span><br><span class="line">        <span class="comment"># # print(sum_two)</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for j in range(len(sum_two)):</span></span><br><span class="line">        <span class="comment">#         if i not in d[j] and nums[i]+sum_two[j]==0:</span></span><br><span class="line">        <span class="comment">#             temp = [nums[d[j][0]]] + [nums[i]] + [nums[d[j][1]]]</span></span><br><span class="line">        <span class="comment">#             temp.sort()</span></span><br><span class="line">        <span class="comment">#             if temp not in res:</span></span><br><span class="line">        <span class="comment">#                 res.append(temp)</span></span><br><span class="line">        <span class="comment"># # res = list(set([tuple(t) for t in res]))</span></span><br><span class="line">        <span class="comment"># # res = list([list(l) for l in res])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#第二种方法，还是超时....</span></span><br><span class="line">        <span class="comment"># d = &#123;&#125;</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># count=0</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)-1):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,len(nums)):</span></span><br><span class="line">        <span class="comment">#         d[count] = [i,j]</span></span><br><span class="line">        <span class="comment">#         count+=1</span></span><br><span class="line">        <span class="comment"># for k in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for v in d.values():</span></span><br><span class="line">        <span class="comment">#         if k not in v and nums[v[0]]+nums[v[1]]+nums[k]==0:</span></span><br><span class="line">        <span class="comment">#             temp = [nums[v[0]],nums[v[1]],nums[k]]</span></span><br><span class="line">        <span class="comment">#             temp.sort()</span></span><br><span class="line">        <span class="comment">#             if temp not in res:</span></span><br><span class="line">        <span class="comment">#                 res.append(temp)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#参考别人的方法</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                key = nums[j]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> d:</span><br><span class="line">                    value = d[key] + [key]</span><br><span class="line">                    value.sort()</span><br><span class="line">                    <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                        res.append(value)</span><br><span class="line">                key = -nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[key] = [nums[i], nums[j]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="17-电话号码的字母组合-medium"><a href="#17-电话号码的字母组合-medium" class="headerlink" title="17.电话号码的字母组合(medium)"></a>17.电话号码的字母组合(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        d=&#123;<span class="number">2</span>:[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>],<span class="number">3</span>:[<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>],<span class="number">4</span>:[<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>],<span class="number">5</span>:[<span class="string">"j"</span>,<span class="string">"k"</span>,<span class="string">"l"</span>],<span class="number">6</span>:[<span class="string">"m"</span>,<span class="string">"n"</span>,<span class="string">"o"</span>],<span class="number">7</span>:[<span class="string">"p"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"s"</span>],<span class="number">8</span>:[<span class="string">"t"</span>,<span class="string">"u"</span>,<span class="string">"v"</span>],<span class="number">9</span>:[<span class="string">"w"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>]&#125;</span><br><span class="line">        <span class="keyword">if</span> len(digits)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(digits)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> d[int(digits)]</span><br><span class="line">        l = len(digits)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> d[int(digits[<span class="number">0</span>])]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> d[int(digits[<span class="number">1</span>])]:</span><br><span class="line">                    res.append(i+j)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> d[int(digits[<span class="number">0</span>])]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> d[int(digits[<span class="number">1</span>])]:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> d[int(digits[<span class="number">2</span>])]:</span><br><span class="line">                        res.append(i+j+k)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">4</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> d[int(digits[<span class="number">0</span>])]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> d[int(digits[<span class="number">1</span>])]:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> d[int(digits[<span class="number">2</span>])]:</span><br><span class="line">                        <span class="keyword">for</span> m <span class="keyword">in</span> d[int(digits[<span class="number">3</span>])]:</span><br><span class="line">                            res.append(i+j+k+m)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="20-有效的括号-easy"><a href="#20-有效的括号-easy" class="headerlink" title="20.有效的括号(easy)"></a>20.有效的括号(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c=[]</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>]==<span class="string">')'</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">']'</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">'&#125;'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> len(c)==<span class="number">0</span>:</span><br><span class="line">                c.append(s[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (c[<span class="number">-1</span>]==<span class="string">'('</span> <span class="keyword">and</span> s[i]==<span class="string">')'</span>) <span class="keyword">or</span> (c[<span class="number">-1</span>]==<span class="string">'['</span> <span class="keyword">and</span> s[i]==<span class="string">']'</span>)  <span class="keyword">or</span> (c[<span class="number">-1</span>]==<span class="string">'&#123;'</span> <span class="keyword">and</span> s[i]==<span class="string">'&#125;'</span>):</span><br><span class="line">                    c.pop(<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c.append(s[i])</span><br><span class="line">        <span class="keyword">if</span> len(c)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><h4 id="21-合并两个有序链表-medium"><a href="#21-合并两个有序链表-medium" class="headerlink" title="21.合并两个有序链表(medium)"></a>21.合并两个有序链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=ListNode(<span class="literal">None</span>) <span class="comment">#合并之后的新数组</span></span><br><span class="line">        p=res <span class="comment">#保持头节点不动</span></span><br><span class="line">        <span class="keyword">if</span> l1==<span class="literal">None</span>:  </span><br><span class="line">            res.next=l2</span><br><span class="line">            <span class="keyword">return</span> res.next</span><br><span class="line">        <span class="keyword">if</span> l2==<span class="literal">None</span>:</span><br><span class="line">            res.next=l1</span><br><span class="line">            <span class="keyword">return</span> res.next</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.next=l1</span><br><span class="line">                l1=l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next=l2</span><br><span class="line">                l2=l2.next</span><br><span class="line">            p=p.next</span><br><span class="line">        <span class="keyword">if</span> l1: <span class="comment">#如果l1还没循环结束</span></span><br><span class="line">            p.next=l1</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#如果l2还没循环结束</span></span><br><span class="line">            p.next=l2</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure></li><li><h4 id="39-组合总和-medium"><a href="#39-组合总和-medium" class="headerlink" title="39.组合总和(medium)"></a>39.组合总和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(path,result,index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> result &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> result &gt;= candidates[i]:</span><br><span class="line">                    trace(path+[candidates[i]],result-candidates[i],i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        trace([],target,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="42-接雨水-hard"><a href="#42-接雨水-hard" class="headerlink" title="42.接雨水(hard)"></a>42.接雨水(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(height) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#两层循环时间复杂度太大了。不过思路没问题</span></span><br><span class="line">        <span class="comment"># ans=0</span></span><br><span class="line">        <span class="comment"># start=0</span></span><br><span class="line">        <span class="comment"># end=0</span></span><br><span class="line">        <span class="comment"># max_h = max(height)</span></span><br><span class="line">        <span class="comment"># for i in range(1,max_h+1):</span></span><br><span class="line">        <span class="comment">#     for j in range(len(height)):</span></span><br><span class="line">        <span class="comment">#         if height[j]&gt;=i:</span></span><br><span class="line">        <span class="comment">#             start=j</span></span><br><span class="line">        <span class="comment">#             break</span></span><br><span class="line">        <span class="comment">#     for k in range(len(height)):</span></span><br><span class="line">        <span class="comment">#         if height[len(height)-k-1]&gt;=i:</span></span><br><span class="line">        <span class="comment">#             end=len(height)-k-1</span></span><br><span class="line">        <span class="comment">#             break</span></span><br><span class="line">        <span class="comment">#     for j in range(start+1,end):</span></span><br><span class="line">        <span class="comment">#         if height[j]&lt;i:</span></span><br><span class="line">        <span class="comment">#             ans+=1</span></span><br><span class="line">        <span class="comment"># return ans</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#找到最大值</span></span><br><span class="line">        max_h = max(height)</span><br><span class="line">        <span class="comment">#找到最大值的下标(第一个最大值)</span></span><br><span class="line">        index = height.index(max_h)</span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="comment">#从左到最大值遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index):</span><br><span class="line">            <span class="keyword">if</span> height[i]&lt;height[temp]:</span><br><span class="line">                ans=ans+(height[temp]-height[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp=i</span><br><span class="line">        height=list(reversed(height[index:]))</span><br><span class="line">        temp2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">            <span class="keyword">if</span> height[i]&lt;height[temp2]:</span><br><span class="line">                ans=ans+(height[temp2]-height[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp2=i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li><li><h4 id="46-全排列-medium"><a href="#46-全排列-medium" class="headerlink" title="46.全排列(medium)"></a>46.全排列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># res=[]</span></span><br><span class="line">        <span class="comment"># def backtrack(nums,tmp):</span></span><br><span class="line">        <span class="comment">#     if not nums:</span></span><br><span class="line">        <span class="comment">#         res.append(tmp)</span></span><br><span class="line">        <span class="comment">#         return </span></span><br><span class="line">        <span class="comment">#     for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#         backtrack(nums[:i]+nums[i+1:],tmp+[nums[i]])</span></span><br><span class="line">        <span class="comment"># backtrack(nums,[])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            ans.extend([[n] + p <span class="keyword">for</span> p <span class="keyword">in</span> self.permute(nums[:i] + nums[i + <span class="number">1</span>:])])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li><li><h4 id="48-旋转图像-medium"><a href="#48-旋转图像-medium" class="headerlink" title="48.旋转图像(medium)"></a>48.旋转图像(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        matrix[::] = map(list,zip(*reversed(matrix)))</span><br></pre></td></tr></table></figure></li><li><h4 id="49-字母异位词分组-medium"><a href="#49-字母异位词分组-medium" class="headerlink" title="49.字母异位词分组(medium)"></a>49.字母异位词分组(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#方法一</span></span><br><span class="line">        <span class="comment"># res=[]</span></span><br><span class="line">        <span class="comment"># c=[]</span></span><br><span class="line">        <span class="comment"># result=[]</span></span><br><span class="line">        <span class="comment"># for i in range(len(strs)):</span></span><br><span class="line">        <span class="comment">#     res.append((strs[i],Counter(strs[i])))</span></span><br><span class="line">        <span class="comment"># while len(res)!=0:</span></span><br><span class="line">        <span class="comment">#     temp=res[0][1]</span></span><br><span class="line">        <span class="comment">#     num=[]</span></span><br><span class="line">        <span class="comment">#     count=[]</span></span><br><span class="line">        <span class="comment">#     for i in range(len(res)):</span></span><br><span class="line">        <span class="comment">#         if temp==res[i][1]:</span></span><br><span class="line">        <span class="comment">#             num.append(res[i][0])</span></span><br><span class="line">        <span class="comment">#             count.append(i)</span></span><br><span class="line">        <span class="comment">#     result.append(num)</span></span><br><span class="line">        <span class="comment">#     for i in reversed(count):</span></span><br><span class="line">        <span class="comment">#         res.pop(i)</span></span><br><span class="line">        <span class="comment"># return result</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#其他解法</span></span><br><span class="line">        res = []</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            keys = <span class="string">""</span>.join(sorted(s))</span><br><span class="line">            <span class="keyword">if</span> keys <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[keys] = [s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[keys].append(s)</span><br><span class="line">        <span class="keyword">return</span> list(dic.values())</span><br></pre></td></tr></table></figure></li><li><h4 id="62-不同路径-medium"><a href="#62-不同路径-medium" class="headerlink" title="62.不同路径(medium)"></a>62.不同路径(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[[<span class="number">1</span>]*n]*m</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                res[i][j]=res[i][j<span class="number">-1</span>]+res[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="64-最小路径和-medium"><a href="#64-最小路径和-medium" class="headerlink" title="64.最小路径和(medium)"></a>64.最小路径和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:  grid[i][j] = grid[i][j - <span class="number">1</span>] + grid[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:  grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j]</span><br><span class="line">                <span class="keyword">else</span>: grid[i][j] = min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="70-爬楼梯-easy"><a href="#70-爬楼梯-easy" class="headerlink" title="70.爬楼梯(easy)"></a>70.爬楼梯(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-3</span>):</span><br><span class="line">            res.append(res[<span class="number">-1</span>]+res[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="75-颜色分类-medium"><a href="#75-颜色分类-medium" class="headerlink" title="75.颜色分类(medium)"></a>75.颜色分类(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(i,j,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=j:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            p = res[i]</span><br><span class="line">            low = i</span><br><span class="line">            high = j</span><br><span class="line">            <span class="keyword">while</span> i&lt;j:</span><br><span class="line">                <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> res[j]&gt;=p:</span><br><span class="line">                    j-=<span class="number">1</span></span><br><span class="line">                res[i]=res[j]</span><br><span class="line">                <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> res[i]&lt;=p:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                res[j]=res[i]</span><br><span class="line">            res[j]=p</span><br><span class="line">            quicksort(low,i<span class="number">-1</span>,res)</span><br><span class="line">            quicksort(i+<span class="number">1</span>,high,res)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        quicksort(<span class="number">0</span>,len(nums)<span class="number">-1</span>,nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># return nums.sort()</span></span><br></pre></td></tr></table></figure></li><li><h4 id="78-子集-medium"><a href="#78-子集-medium" class="headerlink" title="78.子集(medium)"></a>78.子集(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res+=[j+[i] <span class="keyword">for</span> j <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="94-二叉树的中序遍历-medium"><a href="#94-二叉树的中序遍历-medium" class="headerlink" title="94.二叉树的中序遍历(medium)"></a>94.二叉树的中序遍历(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)</span><br></pre></td></tr></table></figure></li><li><h4 id="98-验证二叉搜索树-medium"><a href="#98-验证二叉搜索树-medium" class="headerlink" title="98.验证二叉搜索树(medium)"></a>98.验证二叉搜索树(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            inorder(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            inorder(node.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">if</span> sorted(list(set(res))) == res:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><h4 id="101-对称二叉树-easy"><a href="#101-对称二叉树-easy" class="headerlink" title="101.对称二叉树(easy)"></a>101.对称二叉树(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.ismirror(root,root)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ismirror</span><span class="params">(self,p,q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">None</span> <span class="keyword">and</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">None</span> <span class="keyword">or</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">            <span class="keyword">return</span> self.ismirror(p.left,q.right) <span class="keyword">and</span> self.ismirror(p.right,q.left)</span><br></pre></td></tr></table></figure></li><li><h4 id="102-二叉树的层序遍历-medium"><a href="#102-二叉树的层序遍历-medium" class="headerlink" title="102.二叉树的层序遍历(medium)"></a>102.二叉树的层序遍历(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        num=[]</span><br><span class="line">        temp=[]</span><br><span class="line">        <span class="keyword">while</span> len(queue)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> len(queue)&gt;<span class="number">0</span>:</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># print(type(node))</span></span><br><span class="line">                num.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    temp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    temp.append(node.right)</span><br><span class="line">            <span class="comment"># print(type(temp[0]))</span></span><br><span class="line">            res.append(num)</span><br><span class="line">            num=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">                queue.append(temp[i])</span><br><span class="line">            temp=[]</span><br><span class="line">            <span class="comment"># for i in temp:</span></span><br><span class="line">            <span class="comment">#     queue.append(temp)</span></span><br><span class="line">            <span class="comment"># temp=[]</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="104-二叉树的最大深度-easy"><a href="#104-二叉树的最大深度-easy" class="headerlink" title="104.二叉树的最大深度(easy)"></a>104.二叉树的最大深度(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><h4 id="105-从前序与中序遍历序列构造二叉树-medium"><a href="#105-从前序与中序遍历序列构造二叉树-medium" class="headerlink" title="105.从前序与中序遍历序列构造二叉树(medium)"></a>105.从前序与中序遍历序列构造二叉树(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        x = preorder[<span class="number">0</span>]</span><br><span class="line">        node = TreeNode(x)</span><br><span class="line">        i = inorder.index(x)</span><br><span class="line"></span><br><span class="line">        node.left = self.buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>],inorder[:i])</span><br><span class="line">        node.right = self.buildTree(preorder[i+<span class="number">1</span>:],inorder[i+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li></ul><ul><li><h4 id="121-买卖股票的最佳时机-easy"><a href="#121-买卖股票的最佳时机-easy" class="headerlink" title="121.买卖股票的最佳时机(easy)"></a>121.买卖股票的最佳时机(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># max_num=0</span></span><br><span class="line">        <span class="comment"># if len(prices)==0:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="comment"># for i in range(1,len(prices)):</span></span><br><span class="line">        <span class="comment">#     if prices[i]-min(prices[:i])&gt;max_num:</span></span><br><span class="line">        <span class="comment">#         max_num = prices[i]-min(prices[:i])</span></span><br><span class="line">        <span class="comment"># return max_num</span></span><br><span class="line"></span><br><span class="line">        max_num=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_num=prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            min_num = min(min_num,prices[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> prices[i]-min_num&gt;max_num:</span><br><span class="line">                max_num = prices[i]-min_num</span><br><span class="line">        <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure></li><li><h4 id="128-最长连续序列-hard"><a href="#128-最长连续序列-hard" class="headerlink" title="128.最长连续序列(hard)"></a>128.最长连续序列(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = list(set(nums))</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        res=[<span class="number">1</span>]</span><br><span class="line">        count=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]-nums[i<span class="number">-1</span>]==<span class="number">1</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(count)</span><br><span class="line">                count=<span class="number">1</span></span><br><span class="line">        res.append(count)</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br></pre></td></tr></table></figure></li><li><h4 id="136-只出现一次的数字-easy"><a href="#136-只出现一次的数字-easy" class="headerlink" title="136.只出现一次的数字(easy)"></a>136.只出现一次的数字(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            a = a ^ num</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></li><li><h4 id="141-环型链表-easy"><a href="#141-环型链表-easy" class="headerlink" title="141.环型链表(easy)"></a>141.环型链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        p=head</span><br><span class="line">        q=head.next</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> q.next==p:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q.next==<span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> q.next.next==<span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                p=p.next</span><br><span class="line">                q=q.next.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><h4 id="142"><a href="#142" class="headerlink" title="142"></a>142</h4></li><li><h4 id="148"><a href="#148" class="headerlink" title="148"></a>148</h4></li><li><h4 id="152"><a href="#152" class="headerlink" title="152"></a>152</h4></li><li><h4 id="150"><a href="#150" class="headerlink" title="150"></a>150</h4></li><li><h4 id="155"><a href="#155" class="headerlink" title="155"></a>155</h4></li><li><h4 id="160"><a href="#160" class="headerlink" title="160"></a>160</h4></li><li><h4 id="169"><a href="#169" class="headerlink" title="169"></a>169</h4></li><li><h4 id="206"><a href="#206" class="headerlink" title="206"></a>206</h4></li><li><h4 id="215"><a href="#215" class="headerlink" title="215"></a>215</h4></li><li><h4 id="226"><a href="#226" class="headerlink" title="226"></a>226</h4></li><li><h4 id="234"><a href="#234" class="headerlink" title="234"></a>234</h4></li><li><h4 id="238"><a href="#238" class="headerlink" title="238"></a>238</h4></li><li><h4 id="279"><a href="#279" class="headerlink" title="279"></a>279</h4></li><li><h4 id="283"><a href="#283" class="headerlink" title="283"></a>283</h4></li><li><h4 id="287"><a href="#287" class="headerlink" title="287"></a>287</h4></li><li><h4 id="297"><a href="#297" class="headerlink" title="297"></a>297</h4></li><li><h4 id="338"><a href="#338" class="headerlink" title="338"></a>338</h4></li><li><h4 id="347"><a href="#347" class="headerlink" title="347"></a>347</h4></li><li><h4 id="394"><a href="#394" class="headerlink" title="394"></a>394</h4></li><li><h4 id="448"><a href="#448" class="headerlink" title="448"></a>448</h4></li><li><h4 id="461"><a href="#461" class="headerlink" title="461"></a>461</h4></li><li><h4 id="560"><a href="#560" class="headerlink" title="560"></a>560</h4></li><li><h4 id="617"><a href="#617" class="headerlink" title="617"></a>617</h4></li><li><h4 id="647"><a href="#647" class="headerlink" title="647"></a>647</h4></li><li><h4 id="739"><a href="#739" class="headerlink" title="739"></a>739</h4></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;1-两数之和-easy&quot;&gt;&lt;a href=&quot;#1-两数之和-easy&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和(easy)&quot;&gt;&lt;/a&gt;1.两数之和(easy)&lt;/h4&gt;&lt;figure class=&quot;highlight p
      
    
    </summary>
    
    
      <category term="算法" scheme="elssm.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Composite Adversarial Attacks</title>
    <link href="elssm.github.io/2021/03/05/Composite-Adversarial-Attacks/"/>
    <id>elssm.github.io/2021/03/05/Composite-Adversarial-Attacks/</id>
    <published>2021-03-05T10:22:07.000Z</published>
    <updated>2021-04-13T09:38:18.219Z</updated>
    
    <content type="html"><![CDATA[<p>论文地址：<a href="https://arxiv.org/pdf/2012.05434.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/2012.05434.pdf</a><br>代码地址：<a href="https://github.com/vtddggg/CAA" target="_blank" rel="noopener">https://github.com/vtddggg/CAA</a></p><h4 id="What-is-adversarial-attack？"><a href="#What-is-adversarial-attack？" class="headerlink" title="What is adversarial attack？"></a>What is adversarial attack？</h4><p>对抗攻击是指通过对输入添加微小的扰动使得分类器分类错误，一般对用于深度学习的网络的攻击算法最为常见，对抗攻击的应用场景包括CV和NLP等。例如，通过对图片添加精心准备的扰动噪声使得分类器出错，或者通过对一个句子中的某些词进行同义词替换使得情感分类错误。</p><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>在实践中，攻击算法是由专家人工选择和调整的，用以破坏机器学习系统，然而，手动选择攻击者往往不是最优的，这容易导致错误的评估模型安全性。因此这篇文章提出了一种新的组合对抗攻击方法(CAA)，用于从32个攻击者候选池中自动搜索攻击算法以及超参数的最佳组合。</p><p>文中作者设计了一个搜索空间，将攻击策略表示为一个攻击序列，即：前一个攻击者的输出被用作后续攻击者的初始化输入。采用NSGA-II多目标遗传算法寻找复杂度最小的最强攻击策略。</p><h4 id="What-is-NSGA-II？"><a href="#What-is-NSGA-II？" class="headerlink" title="What is NSGA-II？"></a>What is NSGA-II？</h4><p>NSGA-II是目前最流行的多目标遗传算法之一，它降低了非劣排序遗传算法的复杂性，具有运算速度快，解集的收敛性好的优点，成为其他多目标优化算法性能的基准。<br>NSGA-II就是在第一代非支配排序遗传算法的基础上改进而来，其改进主要是针对如上所述的三个方面：</p><ul><li>提出了快速非支配排序算法，一方面降低了计算的复杂度，另一方面它将父代种群跟子代种群进行合并，使得下一代的种群从双倍的空间中进行选取，从而保留了最为优秀的所有个体</li><li>引进精英策略，保证某些优良的种群个体在进化过程中不会被丢弃，从而提高了优化结果的精度</li><li>采用拥挤度和拥挤度比较算子，不但克服了NSGA中需要人为指定共享参数的缺陷，而且将其作为种群中个体间的比较标准，使得准Pareto域中的个体能均匀地扩展到整个Pareto域，保证了种群的多样性。</li></ul><p>具体有关NSGA-II遗传算法的内容这里不多详述。有兴趣可以观看视频了解。<br>视频地址：<a href="https://www.bilibili.com/video/BV1q7411C77i?from=search&amp;seid=12093857430959589428" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1q7411C77i?from=search&amp;seid=12093857430959589428</a></p><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>深度神经网络很容易受到对抗性攻击，这些攻击的目的是通过产生难以察觉的干扰来欺骗一个训练良好的模型，这一严重的安全隐患很快就引起了机器学习社区的广泛关注，通过对对抗实例的深入研究，大量的攻击算法被提出用来验证对抗的鲁棒性。同时，也产生了一些开源的工具箱。</p><h4 id="对抗攻击实现工具"><a href="#对抗攻击实现工具" class="headerlink" title="对抗攻击实现工具"></a>对抗攻击实现工具</h4><p>目前来说，比较主流的工具有cleverhans，foolbox，advertorch。</p><div class="table-container"><table><thead><tr><th></th><th>cleverhans</th><th>foolbox</th><th>advertorch</th></tr></thead><tbody><tr><td>针对模型框架</td><td>tensorflow/keras/pytorch</td><td>tensorflow/pytorch</td><td>pytorch</td></tr><tr><td>产生速度</td><td>可以批量</td><td>无法批量</td><td>可以批量</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cleverhans:https://github.com/cleverhans-lab/cleverhans</span><br><span class="line">foolbox:https://github.com/bethgelab/foolbox</span><br><span class="line">advertorch:https://github.com/BorealisAI/advertorch</span><br></pre></td></tr></table></figure><h4 id="The-necessity-of-CAA"><a href="#The-necessity-of-CAA" class="headerlink" title="The necessity of CAA"></a>The necessity of CAA</h4><p>然而，即使开发了设计良好的工具箱，攻击一个模型仍然需要大量的用户体验或手动调整攻击的超参数，特别是当我们不知道目标模型的防御机制时，这种依赖用户的特性也使得对抗性攻击的工具化变得困难。另一方面，手动选择攻击者有一定的倾向性和次优性。这可能引起对模型安全性的错误评估。为了实现更全面，更强的攻击，我们首先提出了通过从一组攻击算法中搜索有效的攻击策略来实现自动化攻击过程。我们将这个过程称为复合对抗攻击(CAA)</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/1.png" alt="1"></p><p>上图是CIFAR-10对抗训练模式下CAA与其他攻击者的比较，其中CAA-n代表CAA攻击有几次重启，从上图可以发现CAA只需要少量的梯度评估就能获得最佳的攻击性能。<br>为了演示CAA的关键思想，图2中给出了一个示例。假设有两种可能的攻击方式，空间攻击和FGSM攻击，目标是选择其中一个或多个来组成一个更强的攻击策略。在图2(b)中，最简单的方法是选择最佳的单次攻击作为最终策略。然而，单个攻击者总是不够强大和一般化。一个更好的解决方案是找到多个攻击者，然后通过不断选择能够成功为模型提供工具的最佳输出来集成它们(如图2(c))，虽然这样可以获得较高的攻击成功率，但集成攻击只提供输出级的聚合，没有考虑不同攻击机制之间的互补性。<br>在我们的复合对抗攻击中，我们将攻击策略定义为攻击者的串行连接，其中前一个攻击者的输出作为后继攻击者的初始化输入。在图2（d）中，两个攻击者可以生成四种可能的排列。通过使用搜索算法来寻找最佳排列，我们发现空间攻击之后的FGSM攻击错误率比他们整体可以高出26%。</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/2.png" alt="2"></p><p>该策略的优点在于两个方面：1）通过引入身份攻击，CAA模型可以表示任意一种攻击。集合攻击也可以用CAA的策略集合来表示，因此，CAA是更为广义的公式。2） 一个强大的攻击可以通过渐进的步骤产生，早期的研究发现，一些接近决策边界的起始点比原始种子更适合于优化攻击。类似地，在CAA中，我们使用前面的攻击者创建一个距离原始种子足够远、距离边界足够近的示例。这样，随后的攻击更容易找到一个更强的对抗实例。<br>具体来说，CAA是通过一个包含多个选择和攻击顺序的搜索空间来实现操作。对于每一个攻击操作都有两个超参数，幅值$\epsilon$和迭代步骤t，采用NSGA-II遗传算法去寻找能够突破目标模型最好的攻击策略，具有最高的准确率和最低的复杂度。大量实验表明，CAA在两个用例中取得了很好的改进：1）CAA可以直接应用于感兴趣的目标模型上，以找到最佳攻击策略$CAA_{dic}$ 2）学习策略可以在不同的任务下保持较高的成功率转移到攻击多模型体系结构$CAA_{sub}$。我们对最近提出的11种关于L无穷、L2和无限制设置的防御机制的$CAA_{dic}$和$CAA_{sub}$进行了评估。结果表明，复合对抗攻击(CAA)在白盒场景中达到了很好的效果，大大降低了攻击时间开销。</p><h4 id="Preliminaries-and-Related-work"><a href="#Preliminaries-and-Related-work" class="headerlink" title="Preliminaries and Related work"></a>Preliminaries and Related work</h4><p><strong>符号定义</strong>：具体请看文章定义。<br><strong>常规对抗性实例</strong>：常规的对抗性例子是具有有限数量级的扰动，这通常是通过将扰动限定在某个范围内来实现的，有许多改进版本的FGSM使用基于动量的多步优化，或扰动的随机初始化。基于L2范式的攻击（如DDNL2和C&amp;W）。基于L1的攻击者保证扰动的稀疏性，如EAD。但是，L1攻击在实际攻击设置中并不常用。因此，文章没有实现在L1限制下的CAA<br><strong>无限制对抗实例</strong>：无限制对抗性实例是一种新型的不受范数有界小扰动限制的对抗性实例。在这种情况下，攻击者可能会在不更改语义的情况下显著更改输入。首先介绍了无限制对抗的概念，并提出了一个两人无限制攻防对抗的例子。近年来，有许多研究利用生成模型或空间变换来构造这种更强的无限制攻击。在本文中，我们还实现了最大搜索空间（总共19次攻击）的无限制CAA。我们发现，即使应用非常简单的基本攻击者来形成搜索空间，我们的CAA搜索的策略在不受限制的设置下仍然产生令人惊讶的攻击能力。<br><strong>自动机器学习</strong>：我们的方法受到自动机器学习及其子方向（如神经结构搜索（NAS）和超参数优化（HPO））的最新进展的启发。其中，搜索算法用于算法选择、特征预处理步骤和超参数的自动提取。另一个类似的方向是自动增强，它自动搜索改进的数据增强策略。这些自动化技术不仅使人们摆脱了繁琐的算法微调过程，而且大大提高了学习系统的效果和效率。在本文中，我们采用了AutoML中的一些搜索技术，证明了搜索更好的算法和参数也有助于对抗性攻击。<br>有关<strong>AutoML</strong>相关知识可移步这篇文章：<a href="https://zhuanlan.zhihu.com/p/112148211" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112148211</a></p><h4 id="Composite-Adversarial-Attacks"><a href="#Composite-Adversarial-Attacks" class="headerlink" title="Composite Adversarial Attacks"></a>Composite Adversarial Attacks</h4><p><strong>通过重投影模块限制$l_p$范式</strong></p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/3.png" alt="3"></p><p>在文中problem formulation中公式2所提出的攻击策略是一种一般形式，它对全局扰动没有约束，当攻击序列变长时，每个攻击算法的计算扰动会进行累加，这就会导致对原始输入的最终扰动较大，为了解决这一问题，作者提出在两个连续攻击算法之间插入一个重投影模块，如上图3所示，重投影模块首先会判断该策略对以前的攻击者所累积的$\epsilon$是否大于全局的$\epsilon_{global}$，如果是，累计扰动将会被剪切或重新缩放，使得$l_p$-norm在$\epsilon_{global}$中有界，有了这种改进，可以在任意范数条件下使用复合对抗攻击。</p><h4 id="搜索目标"><a href="#搜索目标" class="headerlink" title="搜索目标"></a>搜索目标</h4><p>之前的工作通常以攻击成功率(ASR)或鲁棒准确率(RA)作为设计算法的目标。然而，这些目标都可以通过花费更多的时间来实现。例如通过随机重启或者多目标方式以获得更高的成功率，这样也就牺牲了运行效率。从而使得算法变得非常慢，甚至比一些黑盒攻击还要耗时。CAA强调一个好的并且强大的攻击者应该是有效且高效的，为了达到这个目标，作者设计了最小化两个术语的目标：强大的准确性和复杂性。第一个术语RA是目标模型在生成的对抗性例子上的准确性，这也反映了攻击者的实力。对于第二项复杂度，使用梯度评价的个数作为复杂度度量，对于普通攻击算法，梯度评估次数表示攻击算法在攻击过程中计算目标模型梯度的次数，一般等于优化步骤t。因此我们可以将总体目标函数表示为：<br><img src="/2021/03/05/Composite-Adversarial-Attacks/4.png" alt="4"><br>其中s(x)代表输入x后攻击策略的输出。N代表攻击策略的长度。$\alpha$是一个权衡攻击强度和复杂性的系数。之后可以应用一个搜索算法，通过最小化目标，从数千种可能的策略中找到最优的的攻击策略。</p><h4 id="搜索空间"><a href="#搜索空间" class="headerlink" title="搜索空间"></a>搜索空间</h4><p>搜索空间被分为两个部分 1）寻找攻击操作的选择和命令。2）寻找每一次攻击操作的幅值$\epsilon$和步数t。对于由N个基础攻击操作组成的攻击策略。攻击操作搜索形成了一个$||A||^N$可能性的问题空间。此外，每个操作也与他们的幅值和步数有关。我们将幅值$\epsilon$和步数t的范围大小离散为8个值(均匀间距)，这样就可以将复合对抗攻击搜索简化为一个离散优化问题。最后，整个搜索空间的总大小为$(8<em>8</em>||A||)^N$<br>在这篇文章中，将策略空间分为三种类型：$S_{l_\infty},S_{l_2}和S_{unrestricted}$,分别在$S_{l_\infty}和S_{l_2}$上实现了6种$S_{l_\infty}$攻击和6种$S_{l_2}$攻击。在不受限制的情况下使用了更大的搜索空间实现了19种攻击算法。此外，所有的$S_{l_\infty},S_{l_2}和S_{unrestricted}$都采用身份攻击来表示身份操作，攻击策略在各搜索空间的输出可视化如图4所示：</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/5.png" alt="5"></p><h4 id="搜索策略"><a href="#搜索策略" class="headerlink" title="搜索策略"></a>搜索策略</h4><p>搜索策略在寻找最好的攻击策略中起到了很重要的作用，在我们的问题设置中，搜索空间的规模相对较小，而且策略评估的成本比起其他任务（如NAS）要低很多，有关NAS的介绍请移步这篇文章，在此不做过多介绍。<br>一篇NAS的介绍：<a href="https://zhuanlan.zhihu.com/p/45133026" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45133026</a><br>这样就允许我们使用一些高性能的搜索算法，作者比较了三种广泛使用的方法，即：贝叶斯优化，强化学习和NSGA-II遗传算法。虽然贝叶斯优化和强化学习在自动学习领域被广泛认为是有效的，但在解决文章中的这个问题上，一是它们更加耗时，二是收敛的比较缓慢。相比之下，NSGA-II更快，因为在搜索期间不需要额外的模型优化过程。它只需要几次迭代的种群更新就可以快速地找到最优解。<br>具体来说，NSGA-II需要维护所有可能策略的有限集合和策略评估函数，NSGA-II算法通过三个步骤来搜索潜在攻击策略的空间。一个人口初始化步骤，使用随机策略生成人口$P_0$,一个包括攻击策略的交叉和变异的探索步骤，一种利用被评估策略的整个历史中隐藏的知识并找到最优策略的开发步骤。整个过程如下图算法所示：</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/6.png" alt="6"></p><h4 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h4><p>为了验证CAA的性能，在11个开源防御模型上对$S_{l_\infty},S_{l_2}和S_{unrestricted}$上的搜索攻击策略进行了评估。在CIFAR-10和ImageNet数据集上进行了$l_\infty和l_2$攻击实验。对Bird&amp;Bicycle数据集进行了无限制攻击。将鲁棒精确度记录为测量值，与最近排名前10位的攻击者进行比较，在实现过程中，取策略的所有中间结果并将其集合位相似的结果。<br>CAA的候选池包括32个攻击行为，其中有六个$l_\infty$攻击，六个$l_2$攻击，十九个无限制攻击和最后的身份攻击。具体实现的攻击算法总结如下图所示：</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/7.png" alt="7"></p><p><strong>数据配置</strong>：对于CIFAR-10，我们在一个小的子集上搜索最佳策略，该子集包含从训练集中随机选择的4000个示例。测试集中总共使用了10000个示例来评估搜索的策略。对于ImageNet，由于整个验证集比较大，因此作者随机从训练数据库和册书数据库中分别选取1000张图像进行策略搜索和1000张图像进行评估。对于Bird&amp;Bicycle数据集，使用所有250个测试图像评估，以及1000个随机选择的训练图像进行攻击策略搜索。<br><strong>实验总结</strong>：调查了4个案例 1）BestAttack，在候选池中寻找最佳单个攻击者。2）EnsAttack，搜索多个攻击者的集合。3）$CAA_{dic}$，直接搜索给定数据集的CAA策略。4）$CAA_{sub}$，通过攻击对抗性训练模型作为替代进行搜索，并转移到其他模型或任务中。<br>为了研究在黑盒和白盒环境下CAA的可转移性，后续又对不同策略搜索算法和攻击策略长度N的影响进行了研究。分析了非目标攻击和目标攻击搜索策略的区别。</p><p>表2给出了4种变量基于$l_\infty$的攻击结果。这些攻击都是在CIFAR-10数据集上实现的</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/8.png" alt="8"></p><p>这些攻击者梯度评估的总次数（复杂度）都大于1000，相比之下，$CAA_{sub}$具有更低的复杂度（800），并且以更高的错误率打破了模型。这也表明了即使是替代攻击策略也可能具有较高的时间效率和可靠性。</p><p>同样的，在ImageNet数据集上，CAA取得了更大的进步。特别的，$CAA_{sub}$攻击$l_\infty$对抗训练模型的准确率达到38.30%，比最新技术提高了2%左右。这意味着CAA更适合攻击复杂的分类任务。ImageNet分类有更多的类别和更大的图像输入大小。同样我们发现由基础攻击者生成的对抗示例在ImageNet上更加多样化。对于这样一个复杂的任务，攻击策略设计有更多的空间。<br>对于无限制攻击选择Bird&amp;Bicycle基准。并使用排行榜上排名前两名的防御模型LLR和TRADESv2进行评估。</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/9.png" alt="9"></p><p><strong>搜索策略分析</strong>：表2是对$S_{l_\infty},S_{l_2}和S_{unrestricted}$的最佳搜索策略的可视化，该策略是在CIFAR-10分类任务上通过攻击对抗性训练模型来搜索的。在所有的$S_{l_\infty},S_{l_2}$和无限制攻击场景中，CAA倾向于选择强攻击性。以$S_{l_\infty}$策略为例。CAA选择最强的MT-LinfAttack作为第一和第二位置的攻击，同时放弃较弱的攻击者，例如单此FGSM攻击。所以一个良好选择的候选攻击池对CAA的性能至关重要。另一个基础是CAA更喜欢一些组合了不同基础攻击者的政策。这意味着用ML-Linf和PGD-Linf攻击所形成的策略通常不会有太大的改进，因为这两个攻击之间的差异很小（他们的原理和目标函数相同），相比之下，在$S_{l_\infty}$的最佳策略下，CAA选择了更多样化的基于边界损失的CW-Linf攻击来辅助基于交叉熵损失的攻击者，从而提高了攻击性能。<br><strong>攻击可转移性</strong>：文章在两个场景下研究了CAA的可转移性。一个是在黑盒设定下，一个是在白盒设定下。黑盒设定下，由于无法获得目标模型的梯度，所以使用CAA来搜索替代模型的策略，并生成对抗的例子来攻击目标模型。在白盒设定下，梯度评估是被允许的，因此在替代任务或模型上的策略搜索被直接用在目标模型上生成对抗实例。<br><strong>CAA的黑盒可转移性</strong>：为了能够讨论是否CAA能够被用于搜索黑盒转移攻击，在对抗样例生成阶段，使用攻击策略s来攻击替代模型，然后在目标模型上对这些对抗性的例子进行测试。将目标模型的鲁棒性精度作为策略s的评价分数。除此之外，整个搜索过程保持不变，作者将这种变体命名为$CAA_{trans}$,在攻击可转移性实验中使用了三种不同架构的模型（VGG16，Inceptionv3和ResNet50），这三种模型都经过了标准的对抗性训练，在表4种记录了实验结果，其中第一列是实验设置，R—-&gt;V表示使用ResNet50作为替代模型攻击VGG16。</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/10.png" alt="10"></p><p>结果表明，自动搜索过程有助于发现一个黑盒可转移的攻击策略，这不仅限于白盒场景。在随后的实验中发现$CAA_{trans}$并没有采用一些强攻击，因为这种攻击可能具有较差的可转移性。相反，像FGSM或MI-Linf攻击往往被选择为策略中更好的可转移成分，从而解释了为什么$CAA_{trans}$能够提高攻击的可转移性。<br><strong>CAA的白盒可转移性</strong>：那么在白盒情况下是否有可能转移攻击策略，即在替代任务或模型上搜索的策略被用于攻击目标模型。实验发下，在CIFAR-10上搜索的策略仍然可以很好的传输到许多模型架构和数据集，因此，CAA并没有“过度拟合”数据集或模型架构，它也确实找到了有效的策略。然而，并不能保证攻击策略在防御系统之间转移。提高防御之间可转移的一个经验实践是在候选池中引入更强，更多样化的攻击算法。在表2中通过使用6个强攻击者在多个防御模型上都取得了很好的结果。<br><strong>策略长度N的分析</strong>：作者进行了一系列的实验来探索一个更长的策略，它可以采用更多和多样化的基础攻击者，是否表现出更强的攻击能力，选择了长度为1、2、3、5和7的5个策略。图5展示稳健精度随策略长度变化的曲线。</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/11.png" alt="11"></p><p>当N=1的时候，CAA往往能够找到最佳的基础攻击者，但是在这种情况下，性能是最差的，随着N的增加，攻击策略在$S_{l_\infty},S_{l_2}$和无限制攻击的设置下变得更强。同时也发现策略长度在$l_2$攻击设定下有最小的影响，因此对于$l_2$攻击更多的基本攻击意味着更多的优化步骤这也是合理的。相比之下，在无限制攻击下，N对性能影响很大，从图5(c)中我们可以发现，当N大于3时，准确度会迅速下降到0左右。<br><strong>不同的搜索方法</strong>：表5给出了四种优化方法的性能和搜索时间，随机搜索，有100个随机策略的试验和最好的选择，被视为一个基线。与基线相比，所有启发式算法都能找到更好的策略。虽然贝叶斯优化和强化学习被广泛认为是搜索大面积空间的有效方法，但在本问题中，它们更耗时且容易陷入局部最优。相比之下，NSGA-II以较低的3 GPU/d成本找到了更好的策略，获得了更好的性能。<br><strong>目标攻击 vs 非目标攻击</strong>：目标攻击是一种特殊的应用场景，攻击者欺骗模型输出他们想要的目标标签。相反，非目标攻击没有给出目标标签。对于目标攻击，CAA搜索具有较少随机初始化的策略，这表明没有随机初始化的攻击者更适合目标设置。此外，与边界损失相比，具有交叉熵损失的基础攻击者更受CAA的青睐。</p><h4 id="Couclusion"><a href="#Couclusion" class="headerlink" title="Couclusion"></a>Couclusion</h4><p>本文提出了一个自动学习攻击策略的过程，该策略由一系列基础攻击者组成，可以用来破坏机器学习系统。通过将CAA与10个最近的攻击者在11种不同防御上进行比较，发现CAA能够以更少的运行时间实现了更好的攻击成功率。经验证明，搜索更好的算法和超参数也有助于对抗攻击。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;论文地址：&lt;a href=&quot;https://arxiv.org/pdf/2012.05434.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/pdf/2012.05434.pdf&lt;/a&gt;&lt;br&gt;代码地址：&lt;a hr
      
    
    </summary>
    
    
      <category term="论文笔记" scheme="elssm.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="elssm.github.io/2021/02/06/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2021/02/06/Linux学习笔记/</id>
    <published>2021-02-06T04:38:11.000Z</published>
    <updated>2021-03-03T02:12:10.775Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h4 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">-a 显示所有文件，包括隐藏文件</span><br><span class="line">-l 详细信息显示</span><br><span class="line">-d 查看目录属性</span><br><span class="line">-i 查询文件号</span><br><span class="line">-h 文件大小显示更直观</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>文件类型</span><br><span class="line">f 文件</span><br><span class="line">d 目录</span><br><span class="line">l 软链接</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>文件权限</span><br><span class="line">r 读</span><br><span class="line">w 写</span><br><span class="line">x 执行</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">mkdir</span><br><span class="line">-p 递归创建</span><br><span class="line"></span><br><span class="line">rmdir #删除空目录</span><br><span class="line">cd</span><br><span class="line">pwd #显示绝对路径</span><br><span class="line">. #当前目录</span><br><span class="line">.. #当前目录的上一级目录</span><br><span class="line"></span><br><span class="line">cp</span><br><span class="line">-r 复制目录</span><br><span class="line">-p 保留文件属性</span><br><span class="line"></span><br><span class="line">mv 剪切</span><br><span class="line"></span><br><span class="line">rm </span><br><span class="line">-r 删除目录</span><br><span class="line">-f 强制执行</span><br><span class="line"></span><br><span class="line">touch</span><br><span class="line"></span><br><span class="line">cat</span><br><span class="line">-n #显示行号</span><br><span class="line"></span><br><span class="line">tac</span><br><span class="line"></span><br><span class="line">more</span><br><span class="line">空格 #翻页</span><br><span class="line">回车 #换行</span><br><span class="line">q   #退出</span><br><span class="line"></span><br><span class="line">less</span><br><span class="line">空格 #向下翻页</span><br><span class="line">pageup #向上翻页</span><br><span class="line">down #下一行</span><br><span class="line">up   #上一行</span><br><span class="line">q   #退出</span><br><span class="line">/+关键词 #搜索</span><br><span class="line"></span><br><span class="line">head -n 行数 文件名 #查看文件前几行</span><br><span class="line">tail -n 行数 文件名 #查看文件前几行</span><br><span class="line"></span><br><span class="line">ln -s 原文件 目标文件 #生成链接文件</span><br><span class="line">-s #软链接</span><br><span class="line"></span><br><span class="line">linux中软链接 以l开头权限是三个rwx</span><br><span class="line"></span><br><span class="line">删除原文件，软链接文件会删除，硬链接可以访问（相当于拷贝）</span><br><span class="line">硬链接的好处：做一个实时的备份</span><br><span class="line">硬链接的缺点：不能跨分区，不允许将硬链接指向目录</span><br></pre></td></tr></table></figure></li><li><h4 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chmod</span><br><span class="line">  </span><br><span class="line">r---4</span><br><span class="line">w---2</span><br><span class="line">x---1</span><br><span class="line"></span><br><span class="line">chmod [ugoa] [+-=] [文件名]</span><br><span class="line">chmod [777] [文件名]</span><br><span class="line">chmod -R [777] [文件]</span><br><span class="line"></span><br><span class="line">chown #改变所有者</span><br><span class="line">chgrp #改变所属组</span><br></pre></td></tr></table></figure></li><li><h4 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">find [搜索范围] [匹配条件]</span><br><span class="line">find [搜索范围] -size +n #在搜索范围查找大于n的文件</span><br><span class="line">find [搜索范围] -user username #在搜索范围下查找所有者为username的文件</span><br><span class="line"></span><br><span class="line">find [搜索范围] -cmin -5 #在搜索范围下查找5分钟内被修改过属性的文件和目录</span><br><span class="line">-amin 访问时间 access</span><br><span class="line">-cmin 文件属性 change</span><br><span class="line">-mmin 文件内容 modify</span><br><span class="line">-iname #查找不区分大小写</span><br><span class="line">-type #根据文件类型查找</span><br><span class="line">-inum #根据i节点查找</span><br><span class="line">-exec 命令 &#123;&#125; \; #对搜索结果执行操作</span><br><span class="line"></span><br><span class="line">locate #在文件资料库中查找文件</span><br><span class="line">-i #查找时不区分大小写</span><br><span class="line"></span><br><span class="line">which #搜索命令所在目录及别名信息</span><br><span class="line">whereis #搜索命令所在目录及帮助文档路径</span><br><span class="line"></span><br><span class="line">grep #在文件中搜寻字符串匹配的行并输出</span><br><span class="line">grep 字符串 文件路径</span><br><span class="line">-i #不区分大小写</span><br><span class="line">-v #排除指定字符串</span><br></pre></td></tr></table></figure></li><li><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">man</span><br><span class="line">man [命令或配置信息]</span><br><span class="line">linux中 1表示命令 5表示配置文件</span><br><span class="line">man 5 passwd #查看配置文件为passwd的帮助文档</span><br><span class="line"></span><br><span class="line">whatis 命令 #得到一个命令的简短信息</span><br><span class="line">apropos 配置文件 #得到一个配置文件的简短信息</span><br><span class="line"></span><br><span class="line">help</span><br><span class="line">help 命令 #获得shell内置命令的帮助信息</span><br><span class="line">内置命令：通俗来讲指找不到路径的命令</span><br></pre></td></tr></table></figure></li><li><h4 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名 #添加新用户</span><br><span class="line">passwd 用户名 #设置用户密码</span><br><span class="line">who #查看用户登陆信息</span><br><span class="line">w #查看登陆用户详细信息</span><br></pre></td></tr></table></figure></li><li><h4 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gzip #只能压缩文件</span><br><span class="line">gzip [文件] #压缩文件</span><br><span class="line">gunzip [文件] #解压缩文件</span><br><span class="line">gzip -d [文件] #解压缩文件</span><br><span class="line"></span><br><span class="line">tar #打包目录</span><br><span class="line">tar 选项[-zcf] [压缩后文件名] [目录]</span><br><span class="line">-c 打包</span><br><span class="line">-v 显示详情信息</span><br><span class="line">-f 指定文件名</span><br><span class="line">-z 打包同时压缩</span><br><span class="line"></span><br><span class="line">tar命令解压缩语法</span><br><span class="line">-x 解包</span><br><span class="line">-v 显示详情信息</span><br><span class="line">-f 指定解压文件</span><br><span class="line">-z 解压缩</span><br><span class="line"></span><br><span class="line">zip #压缩文件或目录</span><br><span class="line">zip 选项[-r] [压缩后文件名] [文件或目录]</span><br><span class="line">-r 压缩目录</span><br><span class="line">unzip #解压缩</span><br><span class="line"></span><br><span class="line">bzip2 #压缩文件</span><br><span class="line">bzip2 选项[-k] [文件] </span><br><span class="line">-k 产生压缩文件后保留原文件</span><br><span class="line">bunzip #解压缩</span><br></pre></td></tr></table></figure></li><li><h4 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">write #给用户发信息，以Ctrl+D保存结束</span><br><span class="line">write &lt;用户名&gt; #用户必须在线</span><br><span class="line"></span><br><span class="line">wall #发广播信息 </span><br><span class="line">wall [message]</span><br><span class="line"></span><br><span class="line">ping #测试网络连通性</span><br><span class="line">ping ip</span><br><span class="line">-c + 次数</span><br><span class="line"></span><br><span class="line">ifconfig #查看和设置网卡信息</span><br><span class="line">ifconfig 网卡名称 IP地址</span><br><span class="line"></span><br><span class="line">mail #查看发送电子邮件</span><br><span class="line">mail [用户名]</span><br><span class="line"></span><br><span class="line">last #列出目前与过去登入系统的用户信息</span><br><span class="line">lastlog #检查某特定用户上次登陆的时间 </span><br><span class="line">-u uid</span><br><span class="line"></span><br><span class="line">traceroute #显示数据包到主机间的路径</span><br><span class="line">traceroute www.baidu.com</span><br><span class="line"></span><br><span class="line">netstat #显示网络相关信息</span><br><span class="line">netstat [选项]</span><br><span class="line">-t : TCP协议</span><br><span class="line">-u : UDP协议</span><br><span class="line">-l : 监听</span><br><span class="line">-r : 路由</span><br><span class="line">-n : 显示IP地址和端口号</span><br><span class="line">netstat -tlun#查看本机监听的端口</span><br><span class="line">netstat -an#查看本机所有的网络链接</span><br><span class="line">netstat -rn#查看本机路由表</span><br><span class="line"></span><br><span class="line">setup #配置网路</span><br><span class="line"></span><br><span class="line">mount #挂载命令</span><br><span class="line">mount [-t 文件系统] 设备文件名 挂载点</span><br><span class="line">mount -t iso9660 /dev/sr0 /mnt/cdrom</span><br></pre></td></tr></table></figure></li><li><h4 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">shutdown #关机重启操作</span><br><span class="line">shutdown [选项] 时间</span><br><span class="line">-c : 取消 </span><br><span class="line">-h : 关机</span><br><span class="line">-r : 重启</span><br><span class="line"></span><br><span class="line">其他重启命令</span><br><span class="line">reboot</span><br><span class="line">init 6</span><br><span class="line"></span><br><span class="line">其他关机命令</span><br><span class="line">halt</span><br><span class="line">poweroff</span><br><span class="line">init 0</span><br><span class="line"></span><br><span class="line">系统运行级别</span><br><span class="line">0关机</span><br><span class="line">1单用户</span><br><span class="line">2不完全多用户，不含NFS服务</span><br><span class="line">3完全多用户</span><br><span class="line">4未分配</span><br><span class="line">5图形界面</span><br><span class="line">6重启</span><br><span class="line"></span><br><span class="line">logout #退出登录命令</span><br></pre></td></tr></table></figure></li><li><h4 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h4></li></ul><p>  插入命令</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td>在光标所在字符后插入</td></tr><tr><td style="text-align:center">A</td><td>在光标所在行尾插入</td></tr><tr><td style="text-align:center">i</td><td>在光标所在字符前插入</td></tr><tr><td style="text-align:center">I</td><td>在光标所在行行首插入</td></tr><tr><td style="text-align:center">o</td><td>在光标下插入新行</td></tr><tr><td style="text-align:center">O</td><td>在光标上插入新行</td></tr></tbody></table></div><p>  定位命令</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>: set nu</td><td>设置行号</td></tr><tr><td>: set nonu</td><td>取消行号</td></tr><tr><td>gg<br>G</td><td>到第一行<br>到最后一行</td></tr><tr><td>nG</td><td>到第n行</td></tr><tr><td>: n</td><td>到第n行</td></tr><tr><td>$</td><td>移动至行尾</td></tr><tr><td>0</td><td>移动至行首</td></tr></tbody></table></div><p>  删除命令</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>x</td><td>删除光标所在处字符</td></tr><tr><td>nx</td><td>删除光标所在处后n个字符</td></tr><tr><td>dd</td><td>删除光标所在行，ndd删除n行</td></tr><tr><td>dG</td><td>删除光标所在行到文件末尾内容</td></tr><tr><td>D</td><td>删除光标所在处到行尾内容</td></tr><tr><td>: nl,n2d</td><td>删除指定范围的行</td></tr></tbody></table></div><p>  复制和剪切命令</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>yy</td><td>复制当前行</td></tr><tr><td>nyy</td><td>复制当前行以下n行</td></tr><tr><td>dd</td><td>剪切当前行</td></tr><tr><td>ndd</td><td>剪切当前行以下n行</td></tr><tr><td>p、P</td><td>粘贴在当前光标所在行下或行上</td></tr></tbody></table></div><p>  替换和取消命令</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>r</td><td>取代光标所在处字符</td></tr><tr><td>R</td><td>从光标所在处开始替换字符，按Esc结束</td></tr><tr><td>u</td><td>取消上一步操作</td></tr></tbody></table></div><p>  搜索和搜索替换命令</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>/string</td><td>搜索指定字符串<br>搜索时忽略大小写 :set ic</td></tr><tr><td>n</td><td>搜索指定字符串的下一个出现位置</td></tr><tr><td>: %s/old/new/g</td><td>全文替换指定字符串</td></tr><tr><td>: n1,n2s/old/new/g</td><td>在一定范围内替换指定字符串</td></tr></tbody></table></div><p>  保存和退出命令</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>: w</td><td>保存修改</td></tr><tr><td>:w new_filename</td><td>另存为指定文件</td></tr><tr><td>: wq</td><td>保存修改并退出</td></tr><tr><td>ZZ</td><td>快捷键，保存修改并退出</td></tr><tr><td>: q!</td><td>不保存修改退出</td></tr><tr><td>: wq!</td><td>保存修改并退出（文件所有者及root可使用）</td></tr></tbody></table></div><p>  定制快捷键：map 快捷键 触发命令<br>  导入命令执行结果：r ！命令<br>  替换：ab test test123</p><ul><li><h4 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h4><p>软件包分类</p><ul><li>源码包</li><li>二进制包</li></ul><p>源码包的优点</p><ul><li>开源</li><li>可以自由选择所需的功能</li><li>软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高</li><li>卸载方便</li></ul><p>源码包的缺点</p><ul><li>安装过程步骤多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误</li><li>编译过程时间较长，安装比二进制安装时间长</li><li>因为是编译安装，安装过程中一旦报错新手很难解决</li></ul><p>二进制包的优点</p><ul><li>包管理系统简单，只通过几个命令就可以实现包的安装，升级，查询和卸载</li><li>安装速度比源码包安装快的多</li></ul><p>二进制包的缺点</p><ul><li>经过编译，不再可以看到源代码</li><li>功能选额不如源码包灵活</li><li>依赖性</li></ul><p>RPM包命名规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">httpd-2.2.15-15.el6.centos.1.i686.rpm</span><br><span class="line"></span><br><span class="line">httpd#软件包名</span><br><span class="line">2.2.15#软件版本</span><br><span class="line">15#软件发布的次数</span><br><span class="line">el6.centos#适合的Linux平台</span><br><span class="line">i686#适合的硬件平台</span><br><span class="line">rpm#rpm包扩展名</span><br></pre></td></tr></table></figure><p>包全名：操作的包是没有安装的软件包时，使用包全名，而且要注意路径。<br>包名：操作已经安装的软件包时，使用包名。是搜索<code>/var/lib/rpm</code>中的数据库。</p><p>RPM安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh 包全名</span><br><span class="line">-i（install）安装</span><br><span class="line">-v（verbose）显示详细信息</span><br><span class="line">-h（hash）显示进度</span><br><span class="line">-nodeps 不显示依赖性</span><br></pre></td></tr></table></figure><p>RPM卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -e 包名</span><br><span class="line">-e（erase）卸载</span><br><span class="line">--nodeps 不检查依赖性</span><br></pre></td></tr></table></figure><p>查询是否安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rpm -q 包名#查询包是否安装</span><br><span class="line">-q 查询 </span><br><span class="line">rpm -qa #查询所有已经安装的RPM包 </span><br><span class="line">-a 所有</span><br><span class="line">rpm -qi 包名 #查询软件包详细信息</span><br><span class="line">-i 查询软件信息</span><br><span class="line">-p 查询未安装包信息</span><br><span class="line">rpm -ql 包名 #查询包中文件安装位置</span><br><span class="line">-l 列表</span><br><span class="line">-p 查询未安装包信息</span><br><span class="line">rpm -qf 系统文件名 #查询系统文件属于哪个RPM包</span><br><span class="line">-f 查询系统文件属于哪个文件包</span><br><span class="line">rpm -qR 包名 #查询软件包的依赖性</span><br><span class="line">-R 查询软件包的依赖性</span><br><span class="line">-p 查询未安装包信息 </span><br><span class="line">rpm -V 已安装的包名 #RPM包校验</span><br><span class="line">-V 校验指定RPM包中的文件</span><br><span class="line">rpm2cpio 包全名 ｜ cpio -idv .文件绝对路径 #RPM包中文件提取</span><br><span class="line">-i : copy-in模式，还原</span><br><span class="line">-d : 还原时自动新建目录</span><br><span class="line">-v : 显示还原过程</span><br></pre></td></tr></table></figure></li><li><h4 id="常用yum命令"><a href="#常用yum命令" class="headerlink" title="常用yum命令"></a>常用yum命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yum list #查询所有可用软件包列表</span><br><span class="line">yum search #搜索服务器上所有和关键字相关的包</span><br><span class="line">yum -y install 包名</span><br><span class="line">install 安装</span><br><span class="line">-y 自动回答yes</span><br><span class="line">yum -y updata 包名 </span><br><span class="line">updata 升级</span><br><span class="line">-y 自动回答yes</span><br><span class="line">yum -y remove 包名</span><br><span class="line">remove 卸载</span><br><span class="line">-y 自动回答yes</span><br><span class="line">yum grouplist #列出所有可用的软件组列表</span><br><span class="line">yum groupinstall 软件组名 #安装指定软件组，组名可以由grouplist查询出来</span><br><span class="line">yum groupremove 软件组名 #卸载指定软件组</span><br></pre></td></tr></table></figure><p>RPM包安装的服务可以使用系统服务管理命令（service）来管理<br>源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中，所以只能用绝对路径进行服务的管理</p></li><li><h4 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a>用户和用户组管理</h4><ul><li>越是对服务器安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范</li><li>在Linux中主要是通过用户配置文件来查看和修改用户信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd #用户信息文件</span><br><span class="line"></span><br><span class="line">  第1字段：用户名称</span><br><span class="line">  第2字段：密码标志</span><br><span class="line">  第3字段：UID（用户ID）</span><br><span class="line">    0：超级用户</span><br><span class="line">    1-499：系统用户（伪用户）</span><br><span class="line">    500-65535：普通用户</span><br><span class="line">  第4字段：GID（用户初始组ID）</span><br><span class="line">  第5字段：用户说明</span><br><span class="line">  第6字段：家目录</span><br><span class="line">    普通用户：/home/用户名/</span><br><span class="line">    超级用户：/root/</span><br><span class="line">  第7字段：登录之后的shell</span><br></pre></td></tr></table></figure><p>初始组：指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户的用户名相同的组名作为这个用户的初始组<br>附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个<br>Shell：shell就是Linux的命令解释器，在<code>/etc/passwd</code>当中，除了标准shell是<code>/bin/bash</code>之外，还可以写如<code>/sbin/nologin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/etc/shadow #影子文件</span><br><span class="line"></span><br><span class="line">  第1字段：用户名</span><br><span class="line">  第2字段：加密密码</span><br><span class="line">    加密算法升级为SHA512散列加密算法</span><br><span class="line">    如果密码位是“!!”或“*”代表没有密码，不能登录</span><br><span class="line">  第3字段：密码最后一次修改日期</span><br><span class="line">  第4字段：两次密码的修改间隔时间（和第3字段相比）</span><br><span class="line">  第5字段：密码有效期（和第3字段相比）</span><br><span class="line">  第6字段：密码修改到期前的警告天数（和第5字段相比）</span><br><span class="line">  第7字段：密码过期后的宽限天数（和第5字段相比）</span><br><span class="line">    0：代表密码过期后立即失效</span><br><span class="line">    -1:代表密码永远不会失效</span><br><span class="line">  第8字段：账号失效时间</span><br><span class="line">    要用时间戳表示</span><br><span class="line">  第9字段：保留</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/etc/group #组信息文件</span><br><span class="line"></span><br><span class="line">  第1字段：组名</span><br><span class="line">  第2字段：组密码标志</span><br><span class="line">  第3字段：GID</span><br><span class="line">  第4字段：组中附加用户</span><br><span class="line">  </span><br><span class="line">/etc/gshadow #组密码文件</span><br><span class="line"></span><br><span class="line">第1字段：组名</span><br><span class="line">  第2字段：组密码</span><br><span class="line">  第3字段：组管理员用户名</span><br><span class="line">  第4字段：组中附加用户</span><br></pre></td></tr></table></figure><p>用户管理相关文件</p><ul><li><p>用户的家目录</p><p>普通用户：<code>/home/用户名/</code>，所有者和所属组都是此用户，权限是700</p><p>超级用户：<code>/root/</code>，所有者和所属组都是root用户，权限是550</p></li><li><p>用户的邮箱</p><p><code>/var/spool/mail/用户名/</code></p></li><li><p>用户模版目录</p><p><code>/etc/skel</code></p></li></ul></li><li><h4 id="用户管理命令-1"><a href="#用户管理命令-1" class="headerlink" title="用户管理命令"></a>用户管理命令</h4><p>用户添加命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useradd</span><br><span class="line"></span><br><span class="line">useradd [选项] 用户名</span><br><span class="line">-u UID : 手工指定用户的UID号</span><br><span class="line">-d 家目录 : 手工指定用户的家目录</span><br><span class="line">-c 用户说明 : 手工指定用户的说明</span><br><span class="line">-g 组名 : 手工指定用户的初始组</span><br><span class="line">-G 组名 : 指定用户的附加组</span><br><span class="line">-s shell : 手工指定用户的登录shell。默认是/bin/bash</span><br></pre></td></tr></table></figure><p>用户默认值文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/etc/default/useradd</span><br><span class="line"></span><br><span class="line">  GROUP=100#用户默认组</span><br><span class="line">  HOME=/home #用户家目录</span><br><span class="line">  INACTIVE=-1#密码过期宽限天数（shadow文件7字段）</span><br><span class="line">  EXPIRE= #密码失效时间（shadow文件8字段）</span><br><span class="line">  SHELL=/bin/bash #默认shell</span><br><span class="line">  SKEL=/etc/skel  #模版目录</span><br><span class="line">  CREATE_MAIL_SPOOL=yes #是否建立邮箱</span><br><span class="line"></span><br><span class="line">/etc/login.defs</span><br><span class="line"></span><br><span class="line">  PASS_MAX_DAYS 99999#密码有效期（shadow文件5字段）</span><br><span class="line">  PASS_MIN_DAYS 0#密码修改间隔（shadow文件4字段）</span><br><span class="line">  PASS_MIN_LEN 5#密码最小5位（PAM）</span><br><span class="line">  PASS_WARN_AGE 7#密码到期警告（shadow文件6字段）</span><br><span class="line">  UID_MIN500#最小和最大UID范围</span><br><span class="line">  GID_MAX60000</span><br><span class="line">  ENCRYPT_METHODSHA512#加密模式</span><br></pre></td></tr></table></figure><p>修改用户密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">passwd </span><br><span class="line"></span><br><span class="line">passwd [选项] 用户名</span><br><span class="line">-S#查询用户密码的密码状态，仅root用户可用</span><br><span class="line">-l#暂时锁定用户，仅root用户可用</span><br><span class="line">-u#解锁用户，仅root用户可用</span><br><span class="line">--stdin #可以通过管道符输出的数据作为用户的密码</span><br></pre></td></tr></table></figure><p>修改用户信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">usermod</span><br><span class="line"></span><br><span class="line">usermod [选项] 用户名</span><br><span class="line">-u UID : 修改用户的UID号</span><br><span class="line">-c 用户说明: 修改用户的说明信息</span><br><span class="line">-G 组名: 修改用户的附加组</span><br><span class="line">-L : 临时锁定用户（Lock）</span><br><span class="line">-U : 解锁用户锁定（Unlock）</span><br><span class="line">usermod -c 'test user' elssm#修改用户的说明</span><br><span class="line">usermod -G root elssm#把elssm用户加入root组</span><br><span class="line">usermod -L elssm#锁定用户</span><br><span class="line">usermod -U elssm#解锁用户</span><br></pre></td></tr></table></figure><p>修改用户密码状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">chage</span><br><span class="line"></span><br><span class="line">chage [选项] 用户名</span><br><span class="line">-l:列出用户的详细密码状态</span><br><span class="line">-d 日期: 修改密码最后一次更改日期（shadow3字段）</span><br><span class="line">-m 天数: 两次密码修改间隔（shadow4字段）</span><br><span class="line">-M 天数: 密码有效期（shadow5字段）</span><br><span class="line">-W 天数: 密码过期前警告天数（shadow6字段）</span><br><span class="line">-I 天数: 密码过期后宽限天数（shadow7字段）</span><br><span class="line">-E 日期:  账号失效时间（shadow8字段 ）</span><br></pre></td></tr></table></figure><p>删除用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userdel</span><br><span class="line"></span><br><span class="line">userdel [-r] 用户名</span><br><span class="line">-r 删除用户的同时删除用户家目录</span><br></pre></td></tr></table></figure><p>切换用户身份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line"></span><br><span class="line">su [选项] 用户名</span><br><span class="line">- : 选项只使用“-”代表连带用户的环境变量一起切换</span><br><span class="line">-c命令 : 仅执行一次命令，而不切换用户身份</span><br></pre></td></tr></table></figure><p>用户和用户组管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] 组名 #添加用户组</span><br><span class="line">-g GID指定组ID</span><br><span class="line"></span><br><span class="line">groupmod [选项] 组名 #修改用户组</span><br><span class="line">-g GID修改组ID</span><br><span class="line">-n 新组名 修改组名</span><br><span class="line"></span><br><span class="line">groupdel 组名#删除用户组</span><br><span class="line"></span><br><span class="line">gpasswd [选项] 组名 #把用户添加入组或从组中删除</span><br><span class="line">-a 用户名 : 把用户加入组</span><br><span class="line">-d 用户名 : 把用户从组中删除</span><br></pre></td></tr></table></figure><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>ACL权限：解决身份不足</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">查看ACL命令</span><br><span class="line"></span><br><span class="line">getfacl 文件名#查看acl权限</span><br><span class="line"></span><br><span class="line">setfacl 选项 文件名#设定ACL权限的命令</span><br><span class="line">-m设定ACL权限</span><br><span class="line">-x删除指定的ACL权限</span><br><span class="line">-b删除所有的ACL权限</span><br><span class="line">-d设定默认ACL权限</span><br><span class="line">-k删除默认ACL权限</span><br><span class="line">-R递归设定ACL权限 </span><br><span class="line"></span><br><span class="line">setfcal -x u:用户名 文件名#删除指定用户的ACL权限</span><br><span class="line">setfacl -x g:组名文件名#删除指定用户组的ACL权限</span><br><span class="line">setfacl-m u:用户名:权限 -R 文件名#递归ACL权限</span><br><span class="line">setfacl-m d:u:用户名:权限 文件名#默认ACL权限</span><br></pre></td></tr></table></figure><p>最大有效权限mask：mask是用来指定最大有效权限的，如果我给用户赋予了ACL权限，是需要和mask的权限“相与”才能得到用户的真正权限。<br>递归ACL权限：递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限<br>默认ACL权限：默认ACL权限的作用时如果给父目录设定了默认ACL权限，那么父目录中所有新建的子文件都会继承父目录的ACL权限</p><p>文件特殊权限</p><ul><li><p>SetUID的功能</p><ul><li>只有可以执行的二进制程序才能设定SUID权限</li></ul></li><li><p>命令执行者要对该程序拥有x（执行）权限</p><ul><li>命令执行者在执行该程序时获得该程序文件属主的身份</li><li>SetUID权限只在该程序执行过程中有效</li></ul></li><li><p>设定SetUID的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 4755 文件名#4代表SUID</span><br><span class="line">  chmodu+s文件名</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>SetGID针对目录的作用</p><ul><li>普通用户必须对此目录拥有r和x权限，才能进入此目录</li></ul></li><li><p>普通用户在此目录中的有效组会变成此目录的属组</p><ul><li>若普通用户对此目录拥有w权限时，新建的文件的默认属组是这个目录的属组</li></ul></li><li><p>SetGID针对文件的作用</p><ul><li>只有可执行的二进制程序才能设置SGID权限</li></ul></li><li><p>命令执行者要对该程序拥有x（执行）权限</p><ul><li>命令执行在执行程序的时候，组身份升级为该程序文件的属组</li><li>SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效</li></ul></li><li><p>设定SetGID的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 2755 文件名#2代表SGID</span><br><span class="line">  chmodg+s文件名</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SBIT粘着位作用</p><ul><li>粘着位目前只对目录有效</li></ul></li><li><p>普通用户对该目录拥有w和x权限， 即普通用户可以在此目录拥有写入权限</p><ul><li>如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件，一旦赋予了粘着位。除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件</li></ul></li><li><p>设置和取消粘着位</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置粘着位</span><br><span class="line">    chmod 1755 目录名</span><br><span class="line">    chmodo+t目录名</span><br><span class="line">  </span><br><span class="line">  取消粘着位</span><br><span class="line">    chmod 777 目录名</span><br><span class="line">    chmodo-t目录名</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>文件系统属性权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chattr</span><br><span class="line">  chattr [+-=] [选项] 文件或目录名</span><br><span class="line">  +: 增加权限</span><br><span class="line">  -: 删除权限</span><br><span class="line">  =: 等于某权限</span><br><span class="line">  选项</span><br><span class="line">  i: 如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据，如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件</span><br><span class="line">  a: 如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据，如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除</span><br><span class="line">  </span><br><span class="line">  lasttr 选项 文件名#查看文件系统属性</span><br><span class="line">  -a 显示所有文件和目录</span><br><span class="line">  -d 若目标是目录，仅列出目录本身的属性，而不是子文件的</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>系统命令权限</p><p>sudo权限</p><ul><li>root把本来只能超级用户执行的命令赋予普通用户执行</li></ul></li><li>sudo的操作对象是系统命令</li></ul><ul><li><h4 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">df [选项] [挂载点]#文件系统查看命令</span><br><span class="line">-a显示所有的文件系统信息，包括特殊文件系统，如/proc、/sysfs</span><br><span class="line">-h使用习惯单位显示容量，如KB，MB或GB等</span><br><span class="line">-T显示文件系统类型</span><br><span class="line">-m以MB为单位显示容量</span><br><span class="line">-k以KB为单位显示容量</span><br><span class="line"></span><br><span class="line">du [选项] [目录或文件名]#统计目录或文件大小</span><br><span class="line">-a显示每个子文件的磁盘占用量，默认只统计子目录的磁盘占用量</span><br><span class="line">-h使用习惯单位显示容量，如KB，MB或GB等</span><br><span class="line">-s统计总占用量，而不列出子目录和子文件的占用量</span><br><span class="line"></span><br><span class="line">fsck [选项] 分区设备文件名#文件系统修复命令</span><br><span class="line">-a不用显示用户提示，自动修复文件系统</span><br><span class="line">-y自动修复，和-a作用一致，不过有些文件系统只支持-y</span><br><span class="line"></span><br><span class="line">dumpe2fs 分区设备文件名#显示磁盘状态命令</span><br><span class="line"></span><br><span class="line">mount[-l]#查询系统中已经挂载的设备，-l会显示卷标名称</span><br><span class="line">mount -a#依据配置文件/etc/fstab的内容，自动挂载</span><br><span class="line"></span><br><span class="line">挂载命令格式</span><br><span class="line">mount [-t 文件系统][-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span><br><span class="line">-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3 ext4、iso9660等文件系统</span><br><span class="line">-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</span><br><span class="line">-o 特殊选项：可以指定挂载的额外选项</span><br></pre></td></tr></table></figure></li></ul><ul><li><h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><p>shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序,用户可以用Shell来启动、挂起、停止甚至是编写一些程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 输出命令</span><br><span class="line">echo [选项] [输出内容]</span><br><span class="line">-e支持反斜线控制的字符转换</span><br></pre></td></tr></table></figure></li></ul><ul><li><h4 id="Bash基本功能"><a href="#Bash基本功能" class="headerlink" title="Bash基本功能"></a>Bash基本功能</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">history [选项] [历史命令保存文件] #历史命令</span><br><span class="line">-c清空历史命令</span><br><span class="line">-w把缓存中的历史命令写入历史命令保存文件~/.bash_history</span><br><span class="line"></span><br><span class="line">alias #查询命令别名</span><br><span class="line">alias 别名='原命令' #设定命令别名</span><br><span class="line">unalias 别名 #删除别名</span><br></pre></td></tr></table></figure></li></ul><p>  输出重定向</p><div class="table-container"><table><thead><tr><th>类型</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>标准输出</td><td>命令 &gt; 文件</td><td>以覆盖的方式把命令的正确输出输出到指定的文件或设备当中</td></tr><tr><td>重定向</td><td>命令 &gt;&gt; 文件</td><td>以追加的方式把命令的正确输出输出到指定的文件或设备当中</td></tr><tr><td>标准错误输出</td><td>错误命令 2&gt; 文件</td><td>以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中</td></tr><tr><td>重定向</td><td>错误命令 2&gt;&gt; 文件</td><td>以追加的方式，把命令的错误输出输出到指定的文件或设备当中</td></tr><tr><td>正确输出</td><td>命令 &gt; 文件 2&gt;&amp;1</td><td>以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td>和</td><td>命令 &gt;&gt; 文件 2&gt;&amp;1</td><td>以追加的方式，把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td>错误输出</td><td>命令 &amp;&gt; 文件</td><td>以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td>同时保存</td><td>命令 &amp;&gt;&gt; 文件</td><td>以追加的方式，把正确输出和错误输出都保存到同一个文件当中</td></tr><tr><td></td><td>命令 &gt;&gt; 文件1 2&gt;&gt; 文件2</td><td>把正确的输出追加到文件1中，把错误的输出追加到文件2中</td></tr></tbody></table></div><p>  输入重定向</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wc [选项] [文件名]</span><br><span class="line">-c统计字节数</span><br><span class="line">-w统计单词数</span><br><span class="line">-l统计行数</span><br></pre></td></tr></table></figure><p>  多命令顺序执行</p><div class="table-container"><table><thead><tr><th>多命令执行符</th><th>格式</th><th>作用</th></tr></thead><tbody><tr><td>;</td><td>命令1; 命令2;</td><td>多个命令顺序执行，命令之间没有任何逻辑联系</td></tr><tr><td>&amp;&amp;</td><td>命令1&amp;&amp;命令2</td><td>逻辑与<br>当命令1正确执行，则命令2才会执行<br>当命令1执行不正确，则命令2不会执行</td></tr><tr><td>｜｜</td><td>命令1｜｜命令2</td><td>逻辑或<br>当命令1执行不正确，则命令2才会执行<br>当命令1执行正确，则命令2不会执行</td></tr></tbody></table></div>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dd if=输入文件 of=输出文件 bs=字节数 count=个数</span><br><span class="line">if=输入文件指定源文件或源设备</span><br><span class="line">of=输出文件指定目标文件或目标设备</span><br><span class="line">bs=字节数 指定一次输入/输出多少字节，即把这些字节看作一个数据块</span><br><span class="line">count=个数指定输入/输出多少个数据块</span><br><span class="line"></span><br><span class="line">example：</span><br><span class="line">date ; dd if=/dev/zero of=/root/testfile bs=1k count=100000 ; date</span><br></pre></td></tr></table></figure><p>  管道符</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">命令1 | 命令2 #命令1的正确输出作为命令2的操作对象</span><br><span class="line">ll -a /etc/ | more</span><br><span class="line">netstat -an | grep 'ESTABLISHED'</span><br><span class="line"></span><br><span class="line">grep [选项] “搜索内容” 文件名</span><br><span class="line">-i忽略大小写</span><br><span class="line">-n输出行号</span><br><span class="line">-v反向查找</span><br><span class="line">--color=auto搜索出的关键字用颜色显示</span><br></pre></td></tr></table></figure><p>  通配符</p><div class="table-container"><table><thead><tr><th>通配符</th><th>作用</th></tr></thead><tbody><tr><td>？</td><td>匹配一个任意字符</td></tr><tr><td>*</td><td>匹配0个或任意多个任意字符，也就是可以匹配任何内容</td></tr><tr><td>[]</td><td>匹配中括号中任意一个字符，例如：[abc]代表一定匹配一个字符，或者是a,或者是b,或者是c</td></tr><tr><td>[-]</td><td>匹配中括号中任意一个字符，例如[a-z]代表匹配一个小写字母</td></tr><tr><td>[ ^ ]</td><td>逻辑非，表示匹配不是中括号内的一个字符，例如[ ^0-9 ]表示匹配一个不是数字的字符</td></tr></tbody></table></div><ul><li><h4 id="Bash变量"><a href="#Bash变量" class="headerlink" title="Bash变量"></a>Bash变量</h4></li></ul><p>  位置参数变量</p><div class="table-container"><table><thead><tr><th>位置参数变量</th><th>作用</th></tr></thead><tbody><tr><td>$n</td><td>n为数字,$0代表命令本身,$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含如${10}</td></tr><tr><td>$*</td><td>这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体</td></tr><tr><td>$@</td><td>这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</td></tr><tr><td>$#</td><td>这个变量代表命令行中所有参数的个数</td></tr></tbody></table></div>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">num1=$1</span><br><span class="line">num2=$2</span><br><span class="line">sum=$(($num1+$num2))</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure><p>  预定义变量</p><div class="table-container"><table><thead><tr><th>预定义变量</th><th>作用</th></tr></thead><tbody><tr><td>$?</td><td>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行，如果这个变量的值为非0，则证明上一个命令执行不正确。</td></tr><tr><td>$$</td><td>当前进程的进程号（PID）</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的进程号（PID）</td></tr></tbody></table></div><p>  接收键盘输入</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read [选项] [变量名]</span><br><span class="line">-p 提示信息：在等待read输入时，输出提示信息</span><br><span class="line">-t 秒数：read命令回一致等待用户输入，使用此选项可以指定等待时间</span><br><span class="line">-n 字符数：read命令只接受指定的字符数，就会执行</span><br><span class="line">-s： 隐藏输入的数据，适用于机密信息的输入</span><br></pre></td></tr></table></figure><p>  declare声明变量类型</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare [+/-][选项] 变量名</span><br><span class="line">-：给变量设定类型属性</span><br><span class="line">+：取消变量的类型属性</span><br><span class="line">-i：将变量声明为整数型</span><br><span class="line">-x：将变量声明为环境变量</span><br><span class="line">-p：显示指定变量的被声明的类型</span><br></pre></td></tr></table></figure><p>  三种数值运算举例</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line"></span><br><span class="line">declare -i c=$a+$b</span><br><span class="line">echo $c</span><br><span class="line"></span><br><span class="line">d=$(expr $a + $b)#‘+’左右两侧必须要有空格</span><br><span class="line">echo $d </span><br><span class="line"></span><br><span class="line">f=$(($a+$b))</span><br><span class="line">echo $f</span><br></pre></td></tr></table></figure><ul><li><h4 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h4><p>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如<br><code>PATH</code>、<code>HISTSIZE</code>、<code>PS1</code>、<code>HOSTNAME</code>等默认环境变量<br><code>/etc/profile</code><br><code>/etc/profile.d/*.sh</code><br><code>`~/.bash_profile</code><br><code>~/.bashrc</code><br><code>/etc/bashrc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source命令</span><br><span class="line">source 配置文件 或 .配置文件</span><br></pre></td></tr></table></figure><p>注销时生效的环境变量配置文件：<code>~/.bash_logout</code><br>其他配置文件：<code>~bash_history</code></p></li><li><h4 id="正则表达式与通配符"><a href="#正则表达式与通配符" class="headerlink" title="正则表达式与通配符"></a>正则表达式与通配符</h4><p>正则表达式用来在文件中匹配符合条件的字符串，正则时包含匹配。grep、awk、sed等命令可以支持正则表达式<br>通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配了</p><p>基础正则表达式</p></li></ul><div class="table-container"><table><thead><tr><th>元字符</th><th>作用</th></tr></thead><tbody><tr><td>*</td><td>前一个字符匹配0次或任意多次</td></tr><tr><td>.</td><td>匹配除了换行符外任意一个字符</td></tr><tr><td>^</td><td>匹配行首，例如：^hello会匹配以hello开头的行</td></tr><tr><td>$</td><td>匹配行尾，例如：hello&amp;会匹配以hello结尾的行</td></tr><tr><td>[]</td><td>匹配中括号中指定的任意一个字符，只匹配一个字符</td></tr><tr><td><sup><a href="#fn_" id="reffn_"></a></sup></td><td>匹配除中括号的字符以外的任意一个字符</td></tr><tr><td>\</td><td>转义符</td></tr><tr><td>\{n\}</td><td>表示其前面的字符恰好出现n次</td></tr><tr><td>\{n,\}</td><td>表示其前面的字符出现不小于n次</td></tr><tr><td>\{n,m\}</td><td>表示其前面的字符至少出现n次，最多出现m次</td></tr></tbody></table></div><ul><li><h4 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">cut</span><br><span class="line"></span><br><span class="line">cut [选项] 文件名</span><br><span class="line">-f 列号：提取第几列</span><br><span class="line">-d 分隔符：按照指定分隔符分割列</span><br><span class="line"></span><br><span class="line">printf</span><br><span class="line"></span><br><span class="line">printf ‘输出类型输出格式’ 输出内容</span><br><span class="line">输出类型：</span><br><span class="line"><span class="meta">%</span>ns：输出字符串，n是数字指代输出几个字符</span><br><span class="line"><span class="meta">%</span>ni：输出整数，n是数字指代输出几个数字</span><br><span class="line"><span class="meta">%</span>m.nf：输出浮点数，m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表输出8位数，2位小数，6位整数</span><br><span class="line">输出格式：</span><br><span class="line">\a：输出警告声音</span><br><span class="line">\b：输出退格键，也就是backspace键</span><br><span class="line">\f：清除屏幕</span><br><span class="line">\n：换行</span><br><span class="line">\r：回车也就是enter键</span><br><span class="line">\t：水平输出退格键，也就是tab键</span><br><span class="line">\v：垂直输出退格键，也就是tab键</span><br><span class="line"></span><br><span class="line">awk</span><br><span class="line"></span><br><span class="line">awk '条件1&#123;动作1&#125;条件2&#123;动作2&#125;...' 文件名</span><br><span class="line">条件（Pattern）：</span><br><span class="line">一般使用关系表达式作为条件</span><br><span class="line"><span class="meta">x&gt;</span>10 判断变量x是否大于10</span><br><span class="line"><span class="meta">x&gt;</span>=10 大于等于</span><br><span class="line">x&lt;=10 小于等于</span><br><span class="line">动作（Action）：</span><br><span class="line">格式化输出</span><br><span class="line">流程控制语句</span><br><span class="line"></span><br><span class="line">sed</span><br><span class="line"></span><br><span class="line">sed [选项] ‘[动作]’ 文件名</span><br><span class="line">-n：一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕</span><br><span class="line">-e：允许对输入数据应用多条sed命令编辑</span><br><span class="line">-i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出</span><br><span class="line">动作：</span><br><span class="line">a \：追加</span><br><span class="line">c \：行替换</span><br><span class="line">i \：插入</span><br><span class="line">d：删除</span><br><span class="line">p：打印</span><br><span class="line">s：字串替换</span><br></pre></td></tr></table></figure></li><li><h4 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">排序命令sort</span><br><span class="line"></span><br><span class="line">sort [选项] 文件名</span><br><span class="line">-f：忽略大小写</span><br><span class="line">-n：以数值型进行排序，默认使用字符串型排序</span><br><span class="line">-r：反向排序</span><br><span class="line">-t：指定分隔符，默认是分隔符是制表符</span><br><span class="line">-k n[,m]：按照指定的字段范围排序，从第n字段开始，m字段结束（默认到行尾）</span><br><span class="line"></span><br><span class="line">统计命令wc</span><br><span class="line"></span><br><span class="line">wc [选项] 文件名</span><br><span class="line">-l：只统计行数</span><br><span class="line">-w：只统计单词数</span><br><span class="line">-m：只统计字符数</span><br></pre></td></tr></table></figure></li><li><h4 id="Linux服务管理"><a href="#Linux服务管理" class="headerlink" title="Linux服务管理"></a>Linux服务管理</h4><p>Linux服务</p><ul><li><p>RPM包默认安装的服务</p><p>独立的服务</p><p>基于xinetd服务</p></li><li><p>源码包安装的服务</p></li></ul><p>RPM安装服务和源码包安装服务的区别就是安装位置的不同</p><ul><li>源码包安装在指定位置，一般是<code>/usr/local/</code></li><li>RPM包安装在默认位置中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/：启动脚本位置(独立服务的启动脚本  )</span><br><span class="line">/etc/sysconfig/：初始化环境配置文件位置</span><br><span class="line">/etc/：配置文件位置</span><br><span class="line">/etc/xinetd.conf：xinetd配置文件</span><br><span class="line">/etc/xinetd.d/：基于xinetd服务的启动脚本</span><br><span class="line">/var/lib/：服务产生的数据放在这里</span><br><span class="line">/var/log：日志</span><br></pre></td></tr></table></figure><p>独立服务的启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/独立服务名 start/stop/status/restart/</span><br><span class="line">service 独立服务名 start/stop/restart/status</span><br></pre></td></tr></table></figure></li><li><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。<br>进程查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ps aux #查看系统中所有进程，使用BSD操作系统格式</span><br><span class="line">ps -le #查看系统中所有进程，使用Linux标准命令格式</span><br><span class="line"></span><br><span class="line">top #查看系统健康状态</span><br><span class="line"></span><br><span class="line">top [选项]</span><br><span class="line">-d 秒数：指定top命令每隔几秒更新，默认是3秒</span><br><span class="line">在top命令的交互模式当中可以执行的命令：</span><br><span class="line">？或h：显示交互模式的帮助</span><br><span class="line">P：以CPU使用率排序，默认就是此项</span><br><span class="line">M：以内存的使用率排序</span><br><span class="line">N：以PID排序</span><br><span class="line">q：退出top</span><br><span class="line"></span><br><span class="line">pstree [选项] #查看进程树</span><br><span class="line">-p：显示进程的PID</span><br><span class="line">-u：显示进程的所属用户</span><br></pre></td></tr></table></figure><p>终止进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kill -l #查看可用的进程信号</span><br><span class="line">killall [选项][信号] 进程名 #按照进程名杀死进程</span><br><span class="line">-i：交互式，询问是否要杀死某个进程</span><br><span class="line">-I：忽略进程名的大小写</span><br><span class="line">pkill [选项][信号] 进程名 #按照进程名终止进程</span><br><span class="line">-t 终端号：按照终端号踢出用户</span><br></pre></td></tr></table></figure></li><li><h4 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs [-l] #查看后台的工作</span><br><span class="line">-l：显示工作的PID</span><br><span class="line">fg %工作号 #将后台暂停的工作恢复到前台执行</span><br><span class="line"><span class="meta">%</span>工作号：%号可以省略，但是注意工作号和PID的区别</span><br></pre></td></tr></table></figure><p>系统资源查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vmstat命令监控系统资源</span><br><span class="line">vmstat [刷新延时 刷新次数]</span><br><span class="line"></span><br><span class="line">dmesg开机时内核检测信息</span><br><span class="line">dmesg</span><br><span class="line"></span><br><span class="line">free命令查看内存使用状态</span><br><span class="line">free [-b|-k|-m|-g]</span><br><span class="line">-b：以字节为单位显示</span><br><span class="line">-k：以KB为单位显示，默认就是以KB为单位显示</span><br><span class="line">-m：以MB为单位显示</span><br><span class="line">-g：以GB为单位显示 </span><br><span class="line"></span><br><span class="line">cat /proc/cpuinfo #查看cpu信息</span><br><span class="line">uptime #显示系统的启动时间和平均负载，也就是top命令的第一行</span><br><span class="line">uname [选项] #查看系统与内核相关信息</span><br><span class="line">-a：查看系统所有相关信息</span><br><span class="line">-r：查看内核版本</span><br><span class="line">-s：查看内核名称</span><br><span class="line">-m：判断系统位数</span><br><span class="line">file /bin/ls #判断当前系统的位数</span><br><span class="line">lsof [选项] #列出进程调用或打开的文件的信息</span><br><span class="line">-c 字符串：只列出以字符串开头的进程打开的文件</span><br><span class="line">-u 用户名：只列出某个用户的进程打开的文件</span><br><span class="line">-p pid： 列出某个PID进程打开的文件</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;文件处理命令&quot;&gt;&lt;a href=&quot;#文件处理命令&quot; class=&quot;headerlink&quot; title=&quot;文件处理命令&quot;&gt;&lt;/a&gt;文件处理命令&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SeqGAN论文笔记</title>
    <link href="elssm.github.io/2021/01/23/SeqGAN%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2021/01/23/SeqGAN论文笔记/</id>
    <published>2021-01-23T14:03:51.000Z</published>
    <updated>2021-01-24T05:35:18.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SeqGAN-Sequence-GenerativeAdversarial-Nets-with-Policy-Gradient"><a href="#SeqGAN-Sequence-GenerativeAdversarial-Nets-with-Policy-Gradient" class="headerlink" title="SeqGAN: Sequence GenerativeAdversarial Nets with Policy Gradient"></a>SeqGAN: Sequence GenerativeAdversarial Nets with Policy Gradient</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">论文地址：https://arxiv.org/abs/1609.05473 </span><br><span class="line">代码地址：https://github.com/LantaoYu/SeqGAN （Tensorflow）</span><br><span class="line">       ：https://github.com/suragnair/seqGAN （Pytorch）</span><br></pre></td></tr></table></figure><p>当目标是离散序列数据时，生成模型的离散输出使得从判别模型到生成模型的梯度更新很难传递，此外，判别模型只能评估一个完整的序列。对于一个部分生成的序列，平衡当前的分数和未来的分数时非常重要的。</p><h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><ul><li>Generator难以传递梯度更新</li><li>Discriminator难以评估非完整序列。</li></ul><h4 id="两种解决方法"><a href="#两种解决方法" class="headerlink" title="两种解决方法"></a>两种解决方法</h4><ul><li>Policy Gradien</li><li>MCTS</li></ul><h4 id="What-is-policy"><a href="#What-is-policy" class="headerlink" title="What is policy?"></a>What is policy?</h4><p><img src="/2021/01/23/SeqGAN论文笔记/2.png" alt="2"></p><p>一个由agent和environment组成的结构。</p><p><em>Agent</em>通过观察当前环境的状态 $s_t$ ，得出当前应当执行的动作 $a_t$。Agent执行完动作之后环境对应发生了改变，并且环境会给予<em>Agent</em>一个反馈<em>reward</em> $r_t$。此时又会是一个新的环境状态 $s’$，基于本次的环境状态，<em>Agent</em>又会执行对应的动作…以此类推持续进行下去，直到无法继续。</p><p>Policy Gradient就是基于我们的策略<em>Policy</em>来做梯度下降从而优化我们的模型。</p><h4 id="What-is-MCTS"><a href="#What-is-MCTS" class="headerlink" title="What is MCTS?"></a>What is MCTS?</h4><p>MCTS也就是蒙特卡罗树搜索（Monte Carlo Tree Search），是一类树搜索算法的统称，可以较为有效地解决一些探索空间巨大的问题，例如一般的围棋算法都是基于MCTS实现的。MCTS要解决的问题是搜索空间足够大，不能计算得到所有子树的价值，这是需要一种较为高效的搜索策略，同时也得兼顾探索和利用，避免陷入局部最优解。</p><p>MCTS可以无限循环，而每一次循环都由以下4个步骤构成：</p><ul><li>Selection：从根节点开始，连续选择子节点向下搜索，直至抵达一个叶节点。子节点的选择方法一般采用UCT（Upper Confidence Bound applied to trees）算法，根据节点的“胜利次数”和“游戏次数”来计算被选中的概率，保持了Exploitation和Exploration的平衡，是保证搜索向最优发展的关键。</li><li>Expansion：在叶节点创建多个子节点。</li><li>Simulation：在创建的子节点中根据roll-out policy选择一个节点进行模拟，又称为playout或者rollout。它和Selection的区别在于：Selection指的是对于搜索树中已有节点的选择，从根节点开始，有历史统计数据作为参考，使用UCT算法选择每次的子节点；Simulation是简单的模拟，从叶节点开始，用自定义的roll-out policy（可以只是简单的随机概率）来选择子节点，且模拟经过的节点并不加入树中。</li><li>Backpropagation：根据Simulation的结果，沿着搜索树的路径向上更新节点的统计信息，包括“胜利次数”和“游戏次数”，用于Selection做决策。</li></ul><h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><ul><li>agent：生成模型</li><li>state：生成的token</li><li>action：生成下一个token的操作</li></ul><p>BLEU：nlp中机器翻译的模型评估指标</p><h4 id="文本生成相关工作"><a href="#文本生成相关工作" class="headerlink" title="文本生成相关工作"></a>文本生成相关工作</h4><ul><li>variational autoencoder (VAE) that combinesdeep learning with statistical inference intended to representa data instance in a latent hidden space</li><li>proposed an alternativetraining methodology to generative models, i.e. GANs, wherethe training procedure is aminimaxgame between a gener-ative model and a discriminative model.However, little progress has been madein applying GANs to sequence discrete data generation prob-lems, e.g. natural language generation.This isdue to the generator network in GAN is designed to be ableto adjust the output continuously, which does not work ondiscrete data generation</li><li>The most popular way oftraining RNNs is to maximize the likelihood of each tokenin the training data whereas pointedout that the discrepancy between training and generatingmakes the maximum likelihood estimation suboptimal andproposed scheduled sampling strategy (SS).</li><li>the sequence data generation can be formulated as a sequentialdecision making process, which can be potentially be solvedby reinforcement learning techniques.</li></ul><h4 id="SeqGAN"><a href="#SeqGAN" class="headerlink" title="SeqGAN"></a>SeqGAN</h4><p>基于RL的生成器对GAN进行扩展，解决序列生成问题</p><p>鉴别器通过蒙特卡洛方法在每次结束时提供一个奖励信号，生成器使用估计的总体奖励选择动作并学习策略。</p><p>policy的模型是：</p><script type="math/tex; mode=display">G_\theta(y_t|Y_{1:t-1})</script><h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p><img src="/2021/01/23/SeqGAN论文笔记/1.png" alt="1"></p><p>左边是GAN的训练步骤一，根据真实样本和伪造样本训练判别器D网络，这里的D网络用的CNN实现。</p><p>右边是GAN的训练步骤二，根据D网络回传的判别概率通过增强学习更新G网络，这里的G网络用的LSTM。</p><h4 id="SeqGAN-via-Policy-Gradient"><a href="#SeqGAN-via-Policy-Gradient" class="headerlink" title="SeqGAN via Policy Gradient"></a>SeqGAN via Policy Gradient</h4><script type="math/tex; mode=display">J(\theta)=E[R_T|s_0,\theta]=\sum_{y1\epsilon\gamma}G_\theta(y1|s_0)·Q_{D_{\phi}}^{G_\theta}(s_0,y_1)</script><p>其中，$R_T$是整个序列的奖励，奖励来自于判别器$D_\phi$。$Q_{D_{\phi}}^{G_\theta}(s,a)$是序列的作用值函数。目标函数的合理性应该是：从给定的初始状态，generator的目标是产生一个序列，使得discriminator认为是真的。</p><p>下一个问题是如何预测the action-value function。在这篇文章中，作者采用强化学习算法。如果判别器D认为给定的fake sequence是真的，其概率记为reward，此时，概率越高，reward越大，这两者是成正比例关系的。正式的来讲我们有如下公式：</p><script type="math/tex; mode=display">Q_{D_{\phi}}^{G_\theta}(a=y_T,s=Y_{1:T-1})=D_\phi(Y_{1:T})</script><p>然而，这个discriminator仅仅提供了一个reward给一个已经结束的sequence。然而我们实际关系的是长期的回报，在每一个时间步骤，我们不但应该考虑到previous tokens的拟合程度，也要考虑到the resulted future outcome。就像是下棋的游戏。因此，为了评价the action-value for an intermediate state，我们采用 MC search with a roll-out policy to sample the unkown last T-1 tokens。我们表示一个 N-time 的 MC search 为：</p><script type="math/tex; mode=display">{\{Y_{1:T}^1,...,Y_{1:T}^N\}=MC^{G_\beta}(Y_{1:t};N)}</script><p>在我们的实验当中，$G^\beta$ 也设置为 the generator。为了降低 variance，并且得到更加精确的 action value 的估计值，我们运行 the roll-out policy starting from current state 直到 序列的结束，N times，以得到一批输出样本。所以，我们有：</p><script type="math/tex; mode=display">Q_{D_{\phi}}^{G_\theta}(s=Y_{1:t-1},a=y_t)=\begin{cases} \frac1N\sum_{n=1}^ND_\phi(Y_{1:T}^n),Y_{1:T}^n\epsilon MC^{G_\beta}(Y_{1:t};N)& \text{for t<T} \\ D_\phi(Y_{1:t}) &\text{for t=T} \end{cases}</script><p>我们看到，当没有立刻的奖赏的时候，函数被迭代的定义为the next-state value starting from states′=Y1:tand rolling out to the end.</p><p>利用判别器D作为奖赏函数的一个函数是为了进一步的提升生成式模型，它可以被动态的更新，一旦我们有了更加realistic的生成序列，我们应该重新训练判别器模型，公式如下：</p><script type="math/tex; mode=display">min_\phi-E_Y\sim p_{data}[logD_\phi(Y)-E_Y\sim G_\theta[log(1-D_\phi(Y))]</script><p>当一个新的判别式模型已经被训练完毕的时候，我们已经准备好来更新generator，所提出的基于策略的方法依赖于优化一个参数化的策略，来直接最大化the long-term reward。目标函数J的梯度可以写为：</p><script type="math/tex; mode=display">\nabla_\theta J(\theta)=E_{Y_{1:t-1}}\sim G_\theta[\sum_{y_t\epsilon\gamma}\nabla_\theta G_\theta(y_t|Y_{1:t-1})·]Q_{D_{\phi}}^{G_\theta}(Y_{1:t-1},y_t)</script><p>上述形式是由于the deterministic state transition and zero intermediate rewards。利用likelihood ratio，我们构建一种无偏估计在每一轮中</p><p><img src="/2021/01/23/SeqGAN论文笔记/3.png" alt="3"></p><p>其中$Y_{1:t}$是观察到的 intermediate state sampled from $G_\theta$。因为期望E[·]可以通过采样的方法进行估计，然后更新生成器的参数。</p><script type="math/tex; mode=display">\theta \leftarrow \theta+\alpha_h\nabla_\theta J(\theta)</script><p>其中，$\alpha$代表了对应的适合h-th step的学习率。</p><h4 id="生成模型-G-theta"><a href="#生成模型-G-theta" class="headerlink" title="生成模型$G_\theta$"></a>生成模型$G_\theta$</h4><p>文章中使用RNN模型作为生成模型，RNN将输入嵌入表示$x1,…,x_T$映射为序列隐层$h_1,…,h_T$，通过递归的使用更新函数g：</p><script type="math/tex; mode=display">h_t = g(h_{t-1},x_t)</script><p>然后一层softmax神经网络层z，将隐层映射到输出单词分布（token distribution）</p><script type="math/tex; mode=display">p(y_t|x_1,...,x_t)=z(h_t)=softmax(c+Vh_t)</script><p>其中c是偏置，V是权重矩阵，为了避免梯度消失和梯度爆炸，这里实际上使用LSTM神经单元</p><h4 id="What-is-LSTM？"><a href="#What-is-LSTM？" class="headerlink" title="What is LSTM？"></a>What is LSTM？</h4><p>RNN是包含循环的网络，允许信息的持久化。链式的特征揭示了 RNN 本质上是与序列和列表相关的。他们是对于这类数据的最自然的神经网络架构</p><p><img src="/2021/01/23/SeqGAN论文笔记/5.png" alt="5"></p><p>RNN 的关键点之一就是他们可以用来连接先前的信息到当前的任务上，例如使用过去的视频段来推测对当前段的理解。但是同样会有一些更加复杂的场景。这种场景下相关信息和当前预测位置之间的间隔会变得非常大，不幸的是，在这个间隔不断增大时，RNN 会丧失学习到连接如此远的信息的能力。在理论上，RNN 绝对可以处理这样的 长期依赖问题。人们可以仔细挑选参数来解决这类问题中的最初级形式，但在实践中，RNN 肯定不能够成功学习到这些知识。</p><p>长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。LSTM 通过刻意的设计来避免长期依赖问题。记住长期的信息在实践中是 LSTM 的默认行为，而非需要付出很大代价才能获得的能力！所有 RNN 都具有一种重复神经网络模块的链式的形式。在标准的 RNN 中，这个重复的模块只有一个非常简单的结构，例如一个 <code>tanh</code> 层。</p><p><img src="/2021/01/23/SeqGAN论文笔记/6.png" alt="6"></p><p>LSTM 同样是这样的结构，但是重复的模块拥有一个不同的结构。不同于 单一神经网络层，这里是有四个，以一种非常特殊的方式进行交互。</p><p><img src="/2021/01/23/SeqGAN论文笔记/7.png" alt="7"></p><p>LSTM 的关键就是细胞状态，水平线在图上方贯穿运行。细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。</p><h4 id="判别器模型-D-phi"><a href="#判别器模型-D-phi" class="headerlink" title="判别器模型$D_\phi$"></a>判别器模型$D_\phi$</h4><p>文中判别器选用的是CNN，生成的序列长度是固定的T ，并且CNN通过使用max-over-time池化操作这样可以适用于变长序列判别。max-over-time池化操作，也就是对每个feature map选取最大值，这样只需要filter个数固定那么池化后得到的向量长度就是固定的，就自然适应于变长的序列。</p><p>我们首先将输入序列$x_1,…,x_T$表示为：</p><script type="math/tex; mode=display">\varepsilon_{1:T}=x_1\bigoplus x_2 \bigoplus...\bigoplus x_T</script><p>这里$\bigoplus$表示并置，也就是并置为一个矩阵，其中$x_t\epsilon R^k$，是k维的向量，得到的矩阵是$\varepsilon_{1:T}\epsilon R^{T*k}$，如上图所示，然后使用一个核做一个窗口大小为l个单词的卷积操作，产生一个feature map：</p><script type="math/tex; mode=display">c_i=\rho(w)\bigotimes \varepsilon_{i:i+l-1}+b</script><p>这里$\bigotimes$表示度对应元素相乘，b是偏置，$\rho$是一个非线形函数，我们可以使用具有不同窗口大小的各种数量的内核来提取不同的特征，最终我们对feature map使用max-over-time池化操作得到</p><script type="math/tex; mode=display">\tilde{c}=max\{c_1,...,c_{T-l+1}\}</script><h4 id="算法流程图如下"><a href="#算法流程图如下" class="headerlink" title="算法流程图如下"></a>算法流程图如下</h4><p><img src="/2021/01/23/SeqGAN论文笔记/4.png" alt="4"></p><p>算法步骤</p><ul><li>随机初始化G网络和D网络参数</li><li>通过MLE预训练G网络，目的是提高G网络的搜索效率</li><li>通过G网络生成部分负样本预训练D网络</li><li>通过G网络生成sequence用D网络去评判，得到reward，根据计算得到每个action选择得到的奖励并求得累计奖励的期望，以此为loss function，并求导对网络进行梯度更新</li><li>根据GAN网络结构可知，训练目标是最大化识别真实样本的概率，最小化误识别伪造样本的概率</li><li>循环以上过程直到收敛</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;SeqGAN-Sequence-GenerativeAdversarial-Nets-with-Policy-Gradient&quot;&gt;&lt;a href=&quot;#SeqGAN-Sequence-GenerativeAdversarial-Nets-with-Policy-Gr
      
    
    </summary>
    
    
      <category term="论文笔记" scheme="elssm.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记</title>
    <link href="elssm.github.io/2021/01/18/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2021/01/18/Mysql学习笔记/</id>
    <published>2021-01-18T14:22:20.000Z</published>
    <updated>2021-01-18T14:23:44.672Z</updated>
    
    <content type="html"><![CDATA[<p>mysql逻辑架构</p><ul><li><p>连接层</p><p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信</p></li><li><p>服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行</p></li><li><p>引擎层</p><p>存储引擎真正的负责了MYSQL中数据的存储和提取，服务器通过API与存储引擎进行通信</p></li><li><p>存储层</p><p>主要是将数据存储在运行于裸设备的文件系统之上，并完成于存储引擎的交互</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> x <span class="keyword">from</span> tableA A <span class="keyword">left</span> <span class="keyword">join</span> tableB B <span class="keyword">on</span> A.key=B.key</span><br><span class="line"><span class="keyword">select</span> x <span class="keyword">from</span> tableA A <span class="keyword">right</span> <span class="keyword">join</span> tableB B <span class="keyword">on</span> A.key=B.key <span class="keyword">where</span> A.key <span class="keyword">is</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">select</span> x <span class="keyword">from</span> tableA A <span class="keyword">Full</span> <span class="keyword">outer</span> <span class="keyword">join</span> tableB <span class="keyword">on</span> A.key=B.key <span class="keyword">where</span> A.key <span class="keyword">is</span> <span class="literal">Null</span> <span class="keyword">or</span> B.key <span class="keyword">is</span> Bull</span><br></pre></td></tr></table></figure><p>建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tbl_dept`</span>(</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`deptName`</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`locAdd`</span> <span class="built_in">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tbl_emp`</span>(</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`deptId`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_dept_id`</span> (<span class="string">`deptId`</span>)</span><br><span class="line">  <span class="comment">#CONSTRAINT `fk_dept_id` FOREIGN KEY (deptId) REFERENCES `tbl_dept` (`id`)</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>索引：索引是帮助MYSQL高效获取数据的数据结构（排好序的快速查找数据结构）</p><p>索引分类</p><ul><li><p>单值索引</p></li><li><p>唯一索引</p></li><li><p>复合索引</p></li><li><p>基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建</span><br><span class="line">CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length));</span><br><span class="line"></span><br><span class="line">ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnname(length))</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">DROP INDEX [indexName] ON mytable;</span><br><span class="line"></span><br><span class="line">查看</span><br><span class="line">SHOW INDEX FROM table_name\G</span><br></pre></td></tr></table></figure></li><li><p>哪些情况需要创建索引</p><p>主键自动建立唯一索引</p><p>频繁作为查询条件的字段应该创建索引</p><p>查询中与其他表关联的字段，外键关系建立索引</p><p>频繁更新的字段不适合创建索引</p><p>Where条件里用不到的字段不创建索引</p></li><li><p>哪些情况不需要创建索引</p><p>表记录太少</p><p>经常增删改的表</p><p>数据重复且分布平均的表字段</p></li><li><p>MYSQL常见瓶颈</p><p>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</p><p>I/O：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</p><p>服务器硬件的性能瓶颈：top，free，uistat和vmstat来查看系统的性能状态</p></li><li><p>explain+SQL</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id|select_type|table|type|possible_keys|key|key_len|ref|rows|Extra</span><br></pre></td></tr></table></figure><ul><li>select_type<ul><li>SIMPLE：简单的select查询，不包含子查询或者UNION</li><li>PRIMARY：查询中若包含任何复杂的子部分，最外层查询被标记为</li><li>SUBQUERY：在SELECT或WHERE列表中国呢包含了子查询</li><li>DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)</li><li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION</li><li>UNION RESULT：从UNION表获取结果的SELECT</li></ul></li><li>type</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</span><br></pre></td></tr></table></figure><ul><li>possible_keys：理论上应该用到哪些索引</li><li>key：真正用到的索引</li><li>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</li><li>Extra（包含不适合在其他列中显示但十分重要的额外信息）<ul><li>Using filesort：说明mysql会对数据使用过一个外部的索引排序，而不是按照表内的索引顺序进行读取（文件内排序）</li><li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。 </li><li>Using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行</li></ul></li></ul></li></ul><p>索引失效（避免索引失效）</p><ul><li>全局匹配我最爱</li><li>最佳左前缀法则</li><li>不在索引列上做任何操作，会导致索引失效转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引，减少select *</li><li>mysql在使用不等于(!=或者&lt;&gt;)的时候无法使用索引会导致全表扫描</li><li>is null , is not null也无法使用索引</li><li>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作</li><li>字符串不加单引号索引失效</li><li><p>少用or，用它来连接时会索引失效</p></li><li><p>查询截取分析</p><ul><li>慢查询的开启与捕获</li><li>explain+慢SQL分析</li><li>show profile查询SQL在mysql服务器里面的执行细节和生命周期情况</li><li>SQL数据库服务器的参数调优</li></ul><p>优化原则：小表驱动大表</p><ul><li>当B表的数据集必须小于A表的数据集时，用in优于exists</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B)</span><br></pre></td></tr></table></figure><ul><li>当A表的数据集必须小于B表的数据集时，用exists优于in</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br></pre></td></tr></table></figure><ul><li><p>批量数据脚本</p><ul><li>建表</li><li>设置参数log_bin_trust_function_creators</li><li>创建函数，保证每条数据都不同</li><li>创建存储过程</li><li>调用存储过程</li></ul></li><li><p>MYSQL的表级锁有两种模式</p><ul><li><p>表共享读锁</p></li><li><p>表独占写锁</p></li></ul><p>读锁会阻塞写，但是不会堵塞读，而写锁会把读和写都堵塞。</p></li><li><p>并发事物处理带来的问题</p><ul><li><p>更新丢失：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题。</p></li><li><p>脏读：事务A读取到了事务B已修改但尚未提交的数据。</p></li><li><p>不可重复读：事务A读取到了事务B已经提交的修改数据，不符合隔离性</p></li><li><p>幻读：事务A读取到了事务B已提交的新增数据，不符合隔离性。</p></li></ul></li><li><p>MYSQL事务隔离级别</p><ul><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>可序列化</li></ul></li><li><p>MYSQL复制过程分成三步</p><ul><li>master将change记录到二进制日志（binary log），这些记录过程叫做二进制日志事件，binary log events</li><li>slave将master的binary log events拷贝到它的中继日志（relay log）</li><li>slave重做中继日志中的事件，将改变应用到自己的数据库中，MYSQL复制是异步的且串行化的</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql逻辑架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;连接层&lt;/p&gt;
&lt;p&gt;最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务层&lt;/p&gt;
&lt;p&gt;第二层架构主要完成大多数的核心服
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习</title>
    <link href="elssm.github.io/2021/01/18/Redis%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/01/18/Redis学习/</id>
    <published>2021-01-18T14:16:56.000Z</published>
    <updated>2021-01-18T14:18:56.255Z</updated>
    
    <content type="html"><![CDATA[<p>NoSQL数据库的四大分类</p><ul><li>KV键值对（Redis）</li><li>文档型数据库（bson，MongoDb）</li><li>列存储数据库（分布式文件系统，HBase）</li><li>图关系数据库（Infinite Graph）</li></ul><p>传统数据库</p><ul><li>Atomicity：原子性</li><li>Consistency：一致性</li><li>Isolation：独立性</li><li>Durability：持久性</li></ul><p>NoSQL</p><ul><li>Consistency：强一致性</li><li>Availability：可用性</li><li>Partition tolerance：分区容错性</li></ul><p>CA：单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大</p><p>CP：满足一致性，分区容忍性的系统，通常性能不是特别高</p><p>AP：满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p><p>BASE为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案</p><ul><li>基本可用（Basically Available）</li><li>软状态（Soft state）</li><li>最终一致（Eventually consistent）</li></ul><p>分布式：不同的多台服务器上面部署不同的服务模块</p><p>集群：不同的多台服务器上面部署相同的服务模块</p><p>Redis的三个特点：</p><ul><li>支持数据的持久化，可以将内存中的数据保持在磁盘中</li><li>不仅支持key-value类型，还提供list，set，zset，hash等数据结构</li><li>支持数据的备份，即master-slave模式的数据备份</li></ul><p>日志级别</p><ul><li>debug</li><li>verbose</li><li>notice</li><li>warning</li></ul><p>缓存策略</p><ul><li>Volatile-lru（只对设置了过期时间的key）</li><li>Allkeys-lru</li><li>Volatile-random（只对设置了过期时间的key）</li><li>Alleys-random</li><li>Volatile-ttl（移除那些TTL值最小的key）</li><li>Noeviction（不进行移除）</li></ul><p>RDB（Redis DataBase）</p><ul><li><p>在指定的时间间隔内将内存中的数据集快照写入磁盘</p><ul><li>1分钟内改了1w次</li><li>5分钟内改了10次</li><li>15分钟内改了1次</li></ul></li><li><p>劣势</p><p>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</p><p>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p></li></ul><p>AOF（Append Only File）</p><ul><li><p>以日志的形式来记录每一个写操作</p></li><li><p>Apendfsync</p><p>Always：同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但是数据完整性比较好</p><p>Everysec：出厂默认推荐，异步操作，每秒记录，如果一秒内宕机。有数据丢失</p><p>No</p></li></ul><p>Rewrite：AOF文件持续增长而过大时，会fork出一个新进程来将文件重写（先写临时文件最后rename）</p><ul><li>触发机制：默认配置是当AOF文件大小是上次rewrite之后大小的一倍且文件大于64M</li></ul><p>事务：一个队列中一次性、顺序性、排他性的执行一系列命令</p><ul><li>MULTI</li><li>discard</li><li>EXEC</li></ul><p>悲观锁：锁整张表</p><p>乐观锁：版本号</p><p>主从复制：主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，master以写为主，slave以读为主</p><ul><li>主要用于读写分离和容灾恢复</li></ul><p>常用三招</p><ul><li>一主二仆</li><li>薪火相传</li><li>反客为主（slaveof no one）</li></ul><p>复制原理</p><ul><li>slave启动成功连接到master后会发送一个sync命令</li><li>master接到命令启动后台的存盘进程，同时手机所有接收到的用于修改数据集命令。在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步</li><li>全局复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave完成同步</li><li>但是只要重新连接master，依次完全同步（全局复制）将被自动执行</li></ul><p>哨兵模式：反客为主的自动版</p><ul><li>新建sentinel.conf</li><li>配置哨兵：sentinel monitor 主机名 127.0.0.1 6379 1</li><li>启动哨兵：redis-sentinel /文件路径/sentinel.conf</li></ul><p>主从复制会出现复制延迟</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NoSQL数据库的四大分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KV键值对（Redis）&lt;/li&gt;
&lt;li&gt;文档型数据库（bson，MongoDb）&lt;/li&gt;
&lt;li&gt;列存储数据库（分布式文件系统，HBase）&lt;/li&gt;
&lt;li&gt;图关系数据库（Infinite Graph）&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>组成原理笔记</title>
    <link href="elssm.github.io/2018/11/01/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2018/11/01/组成原理笔记/</id>
    <published>2018-11-01T12:44:54.000Z</published>
    <updated>2021-01-23T14:32:13.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><ul><li><h4 id="系统复杂性管理的方法1"><a href="#系统复杂性管理的方法1" class="headerlink" title="系统复杂性管理的方法1"></a>系统复杂性管理的方法1</h4><p>抽象</p></li><li><h4 id="系统复杂性管理的方法2（3Y）"><a href="#系统复杂性管理的方法2（3Y）" class="headerlink" title="系统复杂性管理的方法2（3Y）"></a>系统复杂性管理的方法2（3Y）</h4><p>层次化（Hierachy）：将被设计的系统划分为多个模块和子模块</p><p>模块化（Modularity）：有明确定义的功能和接口</p><p>规则性（Regularity）：模块更容易被重用</p></li><li><h4 id="冯诺伊曼计算机的特点"><a href="#冯诺伊曼计算机的特点" class="headerlink" title="冯诺伊曼计算机的特点"></a>冯诺伊曼计算机的特点</h4><p>计算机由五大部件组成（存储器，控制器，运算器，输入设备，输出设备）</p><p>指令和数据以同等地位存于存储器，可按地址访问</p><p>指令和数据用二进制表示</p><p>指令由操作码和地址码组成</p><p>存储程序</p><p>以运算器为中心</p></li></ul><h4 id="运算器的组成"><a href="#运算器的组成" class="headerlink" title="运算器的组成"></a>运算器的组成</h4><p>运算单元（ALU）</p><p>输入数据寄存器（ACC和X）</p><p>额外数据寄存器（MQ）</p><h4 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h4><p><img src="/2018/11/01/组成原理笔记/1.png" alt="1"></p><p>MAR：存储器地址寄存器（反应存储单元的个数）</p><p>MDR：存储器数据寄存器（存储器数据寄存器反映存储字长）</p><p>存储体—存储单元—存储元件</p><p>存储单元：存放一串二进制代码</p><p>存储字：存储单元中二进制代码的组合</p><p>存储字长：存储单元中二进制代码的位数，每个存储单元赋予一个地址 </p><p>按地址寻访</p><h4 id="控制器的功能"><a href="#控制器的功能" class="headerlink" title="控制器的功能"></a>控制器的功能</h4><p>解释指令</p><p>保证指令的按序执行</p><h4 id="完成一条指令"><a href="#完成一条指令" class="headerlink" title="完成一条指令"></a>完成一条指令</h4><ul><li>取指令    PC（存放当前欲执行指令的地址，具有计数功能PC+1=PC）</li><li>分析指令    IR（存放当前欲执行的指令）</li><li>执行指令    CU</li></ul><h4 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h4><ul><li>机器字长：CPU一次能处理数据的位数，与CPU中的寄存器位数有关</li></ul><h3 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h3><ul><li>主频</li><li>核数，每个核支持的线程数</li><li>吉普森法</li><li>CPI 执行一条指令所需时钟周期数</li><li>MIPS 每秒执行百万条指令</li></ul><h4 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h4><p>存放二进制信息的总位数</p><h4 id="硬件技术对计算机更新换代的影响"><a href="#硬件技术对计算机更新换代的影响" class="headerlink" title="硬件技术对计算机更新换代的影响"></a>硬件技术对计算机更新换代的影响</h4><p>   时间            硬件技术</p><p>1946-1957        电子管</p><p>1958-1964        晶体管</p><p>1965-1971        中小规模集成电路</p><p>1972-1977        大规模集成电路</p><p>1978-现在        超大规模集成电路</p><h4 id="微型计算机的出现和发展"><a href="#微型计算机的出现和发展" class="headerlink" title="微型计算机的出现和发展"></a>微型计算机的出现和发展</h4><p>微处理器芯片 1971</p><p>存储器芯片     1970</p><h4 id="芯片集成度的提高受以下三方面的限制"><a href="#芯片集成度的提高受以下三方面的限制" class="headerlink" title="芯片集成度的提高受以下三方面的限制"></a>芯片集成度的提高受以下三方面的限制</h4><ul><li>芯片集成度受物理极限的制约</li><li>按几何级数递增的制作成本</li><li>芯片的功耗，散热，线延迟</li></ul><h3 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h3><h4 id="什么是总线？"><a href="#什么是总线？" class="headerlink" title="什么是总线？"></a>什么是总线？</h4><p>总显示连接各个部件的信号传输线，是各个部件共享的传输介质</p><h4 id="总线上信息的传递"><a href="#总线上信息的传递" class="headerlink" title="总线上信息的传递"></a>总线上信息的传递</h4><p>串行：一条数据线</p><p>并行：多条数据线</p><h4 id="单总线结构框图"><a href="#单总线结构框图" class="headerlink" title="单总线结构框图"></a>单总线结构框图</h4><p><img src="/2018/11/01/组成原理笔记/2.png" alt="2"></p><h4 id="面向CPU的双总线结构框图"><a href="#面向CPU的双总线结构框图" class="headerlink" title="面向CPU的双总线结构框图"></a>面向CPU的双总线结构框图</h4><p><img src="/2018/11/01/组成原理笔记/3.png" alt="3"></p><h4 id="以存储器为中心的双总线结构框图"><a href="#以存储器为中心的双总线结构框图" class="headerlink" title="以存储器为中心的双总线结构框图"></a>以存储器为中心的双总线结构框图</h4><p><img src="/2018/11/01/组成原理笔记/4.png" alt="4"></p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><p>1：片内总线    芯片内部的总线</p><p>2：系统总线    计算机各部件之间的信息传输线</p><ul><li>数据总线        （双向 与机器字长，存储字长有关）</li><li>地址总线         （单向 与存储地址，I/O地址有关）</li><li>控制总线         （有出 有入）</li></ul><p>3：通信总线</p><p>用于计算机系统之间或计算机系统与其他系统（如控制仪表，移动通信等）之间的通信</p><ul><li>串行通信总线</li><li>并行通信总线</li></ul><h3 id="总线特性及性能指标"><a href="#总线特性及性能指标" class="headerlink" title="总线特性及性能指标"></a>总线特性及性能指标</h3><h4 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h4><ul><li>机械特性    尺寸，形状，管脚数及排列顺序</li><li>电气特性    传输方向和有效的电平范围</li><li>功能特性    每根传输线的功能（如地址，数据，控制）</li><li>时间特性    信号的时序关系</li></ul><h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4><ul><li>总线宽度    （数据线的根数）</li><li>标准传输率    （每秒传输的最大字节数（MBps））</li><li>时钟同步    （异步    同步，不同步）</li><li>总线复用    （地址线与数据线复用）</li><li>信号线数    （地址线，数据线和控制线的总和）</li><li>总线控制方式    （突发，自动，仲裁，逻辑，计数）</li><li>其他指标     （负载能力）</li></ul><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><p><img src="/2018/11/01/组成原理笔记/5.png" alt="5"></p><h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p><img src="/2018/11/01/组成原理笔记/6.png" alt="6"></p><h4 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h4><p>双总线结构</p><p><img src="/2018/11/01/组成原理笔记/7.png" alt="7"></p><p>三总线结构</p><p><img src="/2018/11/01/组成原理笔记/8.png" alt="8"></p><p>三总线结构另一种形式</p><p><img src="/2018/11/01/组成原理笔记/9.png" alt="9"></p><p>四总线结构</p><p><img src="/2018/11/01/组成原理笔记/10.png" alt="10"></p><h4 id="总线结构举例"><a href="#总线结构举例" class="headerlink" title="总线结构举例"></a>总线结构举例</h4><p>传统微型机总线结构</p><p><img src="/2018/11/01/组成原理笔记/11.png" alt="11"></p><p>VL-BUS局部总线结构</p><p><img src="/2018/11/01/组成原理笔记/12.png" alt="12"></p><p>PCI总线结构</p><p><img src="/2018/11/01/组成原理笔记/13.png" alt="13"></p><p>多层PCI总线结构</p><p><img src="/2018/11/01/组成原理笔记/14.png" alt="14"></p><h3 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h3><h4 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h4><p>根据是否能提出总线请求将总线上的设备分为两类</p><ul><li>主设备（或者是主模块）对总线有控制权</li><li>从设备（或者是从模块）响应从主设备发来的总线命令</li></ul><p>总线判优控制</p><ul><li>集中式（链式查询，计数器定时查询，独立请求方式）</li><li>分布式</li></ul><h4 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h4><p>电路控制结构</p><p><img src="/2018/11/01/组成原理笔记/15.png" alt="15"></p><h4 id="计数器定时查询方式（总线控制部件中有一个计数器）"><a href="#计数器定时查询方式（总线控制部件中有一个计数器）" class="headerlink" title="计数器定时查询方式（总线控制部件中有一个计数器）"></a>计数器定时查询方式（总线控制部件中有一个计数器）</h4><p>电路控制结构</p><p><img src="/2018/11/01/组成原理笔记/16.png" alt="16"></p><h4 id="独立请求方式（总线控制部件内部有一个排队器）"><a href="#独立请求方式（总线控制部件内部有一个排队器）" class="headerlink" title="独立请求方式（总线控制部件内部有一个排队器）"></a>独立请求方式（总线控制部件内部有一个排队器）</h4><p>电路控制结构</p><p><img src="/2018/11/01/组成原理笔记/17.png" alt="17"></p><h4 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h4><p>1 目的：解决通信双方协调配合问题</p><p>2 总线传输周期</p><ul><li>申请分配阶段    （主模块申请，总线仲裁决定）</li><li>寻址阶段    （主模块向从模块给出地址和命令）</li><li>传数阶段    （主模块和从模块交换数据）</li><li>结束阶段     （主模块撤消有关信息）   </li></ul><h4 id="总线通信的四种方式"><a href="#总线通信的四种方式" class="headerlink" title="总线通信的四种方式"></a>总线通信的四种方式</h4><ul><li>同步通信（由统一时标控制数据传送）</li><li>异步通信（采用应答方式，没有公共时钟标准）</li><li>半同步通信（同步，异步结合）</li><li>分离式通信（充分挖掘系统总线每个瞬间的潜力）</li></ul><h4 id="同步式数据输入"><a href="#同步式数据输入" class="headerlink" title="同步式数据输入"></a>同步式数据输入</h4><p><img src="/2018/11/01/组成原理笔记/18.png" alt="18"></p><h4 id="同步式数据输出"><a href="#同步式数据输出" class="headerlink" title="同步式数据输出"></a>同步式数据输出</h4><p><img src="/2018/11/01/组成原理笔记/19.png" alt="19"></p><h4 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h4><p><img src="/2018/11/01/组成原理笔记/20.png" alt="20"></p><h4 id="半同步通信（同步，异步结合）"><a href="#半同步通信（同步，异步结合）" class="headerlink" title="半同步通信（同步，异步结合）"></a>半同步通信（同步，异步结合）</h4><p>同步：发送方用系统时钟前沿发信号，接收方用系统时钟后沿判断，识别</p><p>异步：允许不同速度的模块和谐工作，增加一条等待响应信号 WAIT</p><h4 id="一个总线传输周期（以输入数据为例）"><a href="#一个总线传输周期（以输入数据为例）" class="headerlink" title="一个总线传输周期（以输入数据为例）"></a>一个总线传输周期（以输入数据为例）</h4><ul><li>主模块发地址，命令（占用总线）</li><li>从模块准备数据（不占用总线，总线空闲）</li><li>从模块向主模块发数据（占用总线）</li></ul><h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><p>充分挖掘系统总线每个瞬间的潜力</p><h4 id="一个总线传输周期"><a href="#一个总线传输周期" class="headerlink" title="一个总线传输周期"></a>一个总线传输周期</h4><ul><li>子周期1：主模块申请占用总线，使用完后即放弃总线的使用权</li><li>子周期2：从模块申请占用总线，将各种信息送至总线上</li></ul><h4 id="分离式通信特点"><a href="#分离式通信特点" class="headerlink" title="分离式通信特点"></a>分离式通信特点</h4><p>1：各模块有权申请占用总线</p><p>2：采用同步方式通信，不等对方回答</p><p>3：各模块准备数据时，不占用总线</p><p>4：总线被占用时，无空闲</p><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><ul><li>按存储介质分类<ul><li>半导体存储器（TTL,MOS）易失性</li><li>磁表面存储器（磁头，载磁体）非失性</li><li>磁芯存储器（硬磁材料，环状元件）非失性</li><li>光盘存储器（激光，磁光材料）非失性</li></ul></li><li>按存取方式分类<ul><li>存取时间与物理地址无关（随机访问）<ul><li>随机存储器（在程序的执行过程中可读可写）</li><li>只读存储器（在程序的执行过程中只读）</li></ul></li><li>存取时间与物理地址有关（串行访问）<ul><li>顺序存取存储器（磁带）</li><li>直接存取存储器（磁盘）</li></ul></li></ul></li><li>按在计算机中的作用分类<ul><li>主存储器<ul><li>RAM（静态RAM,动态RAM）</li><li>ROM（MROM,PROM,EPROM,EEPROM）</li></ul></li><li>Flash Memory</li><li>高速缓冲存储器（Cache）</li><li>辅助存储器（磁盘，磁带，光盘）</li></ul></li></ul><h3 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h3><p>存储容量（主存存放二进制代码的总位数）</p><p>存储时间</p><ul><li>存储时间（存储器的访问时间，读出时间，写入时间）</li><li>存取周期（连续两次独立的存储器操作所需要的最小时间间隔，读周期，写周期）</li><li>存储器的带宽（位/秒）</li></ul><h4 id="动态RAM和静态RAM的比较"><a href="#动态RAM和静态RAM的比较" class="headerlink" title="动态RAM和静态RAM的比较"></a>动态RAM和静态RAM的比较</h4><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">DRAM</th><th style="text-align:center">SRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储原理</td><td style="text-align:center">电容</td><td style="text-align:center">触发器</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">芯片引脚</td><td style="text-align:center">少</td><td style="text-align:center">多</td></tr><tr><td style="text-align:center">功耗</td><td style="text-align:center">小</td><td style="text-align:center">大</td></tr><tr><td style="text-align:center">价格</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">速度</td><td style="text-align:center">慢</td><td style="text-align:center">快</td></tr><tr><td style="text-align:center">刷新</td><td style="text-align:center">有</td><td style="text-align:center">无</td></tr></tbody></table></div><h4 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h4><ul><li>掩模ROM（MROM）</li><li>PROM（一次性编程）</li><li>EPROM（多次性编程）</li><li>EEPROM（多次性编程）</li><li>FLASH Memory（闪存型存储器）</li></ul><h4 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h4><ul><li>地址线得连接</li><li>数据线的链接</li><li>读/写命令线的连接</li><li>片选线的连接</li><li>合理选择存储芯片</li><li>其他   时序，负载 </li></ul><h4 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h4><p>编码的最小距离</p><ul><li><p>任意两组合法代码之间二进制位数的最小差异</p></li><li><p>编码的纠错，检错能力与编码的最小距离有关</p><p>L-1=D+C（D&gt;=C）</p><p>L——编码的最小距离</p><p>D——检测错误的位数</p><p>C——纠正错位的位数</p></li></ul><h4 id="汉明码的组成"><a href="#汉明码的组成" class="headerlink" title="汉明码的组成"></a>汉明码的组成</h4><ul><li>汉明码采用奇偶校验</li><li>汉明码采用分组校验</li></ul><h4 id="提高访存速度的措施"><a href="#提高访存速度的措施" class="headerlink" title="提高访存速度的措施"></a>提高访存速度的措施</h4><ul><li>采用高速器件</li><li>采用层次结构 Cache-主存</li><li>调整主存结构</li></ul><h3 id="输入输出系统的组成"><a href="#输入输出系统的组成" class="headerlink" title="输入输出系统的组成"></a>输入输出系统的组成</h3><p>I/O软件</p><ul><li><p>I/O指令（CPU指令的一部分）</p><p>格式：|操作码|命令码|设备码|</p></li><li><p>通道指令（通道自身的指令）</p><p>指出数组的首地址，传送字数。操作命令</p></li></ul><p>I/O硬件</p><ul><li>设备    I/O接口</li><li>设备        设备控制器        通道</li></ul><h3 id="I-O设备与主机的联系方式"><a href="#I-O设备与主机的联系方式" class="headerlink" title="I/O设备与主机的联系方式"></a>I/O设备与主机的联系方式</h3><p>统一编址（用取数，存数指令）</p><p>不统一编址（有专门的I/O指令）</p><h3 id="联络方式"><a href="#联络方式" class="headerlink" title="联络方式"></a>联络方式</h3><p>立即响应</p><p>异步工作采用应答信号（并行传输和串行传输）</p><h3 id="I-O设备与主机的连接方式"><a href="#I-O设备与主机的连接方式" class="headerlink" title="I/O设备与主机的连接方式"></a>I/O设备与主机的连接方式</h3><p>辐射式连接（不便于增删设备）</p><p>总线连接（便于增删设备）</p><h3 id="I-O设备与主机信息传送的控制方式"><a href="#I-O设备与主机信息传送的控制方式" class="headerlink" title="I/O设备与主机信息传送的控制方式"></a>I/O设备与主机信息传送的控制方式</h3><p>程序查询方式</p><p>程序中断方式</p><p>DMA方式</p><h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h3><h4 id="为什么要设置接口？"><a href="#为什么要设置接口？" class="headerlink" title="为什么要设置接口？"></a>为什么要设置接口？</h4><ul><li>实现设备的选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串-并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反映设备的状态</li></ul><h4 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h4><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">组成</th></tr></thead><tbody><tr><td style="text-align:center">选址功能</td><td style="text-align:center">设备选择电路</td></tr><tr><td style="text-align:center">传送命令的功能</td><td style="text-align:center">命令寄存器，命令译码器</td></tr><tr><td style="text-align:center">传送数据的功能</td><td style="text-align:center">数据缓冲寄存器（DBR）</td></tr><tr><td style="text-align:center">反映设备状态的功能</td><td style="text-align:center">设备状态标记</td></tr></tbody></table></div><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><h4 id="按数据传送方式分类"><a href="#按数据传送方式分类" class="headerlink" title="按数据传送方式分类"></a>按数据传送方式分类</h4><ul><li><p>并行接口（Intel 8255）</p></li><li><p>串行接口（Intel 8251）</p></li></ul><h4 id="按功能选择的灵活性分类"><a href="#按功能选择的灵活性分类" class="headerlink" title="按功能选择的灵活性分类"></a>按功能选择的灵活性分类</h4><ul><li><p>可编程接口（Intel 8255，Intel 8251）</p></li><li><p>不可编程接口（Intel 8212）</p></li></ul><h4 id="按通用性分类"><a href="#按通用性分类" class="headerlink" title="按通用性分类"></a>按通用性分类</h4><ul><li>通用接口（Intel 8255，Intel 8251）</li><li>专用接口（Intel 8279，Intel 8275）</li></ul><h4 id="按数据传送的控制方式分类"><a href="#按数据传送的控制方式分类" class="headerlink" title="按数据传送的控制方式分类"></a>按数据传送的控制方式分类</h4><ul><li>中断方式（Intel 8259）</li><li>DMA接口（Intel 8257）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机系统的层次结构&quot;&gt;&lt;a href=&quot;#计算机系统的层次结构&quot; class=&quot;headerlink&quot; title=&quot;计算机系统的层次结构&quot;&gt;&lt;/a&gt;计算机系统的层次结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;系统复杂性管理的方法1&quot;&gt;&lt;a href=&quot;#系
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C语言八大排序</title>
    <link href="elssm.github.io/2018/10/09/C%E8%AF%AD%E8%A8%80%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
    <id>elssm.github.io/2018/10/09/C语言八大排序/</id>
    <published>2018-10-09T09:54:40.000Z</published>
    <updated>2018-12-03T14:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间对8大排序算法进行了整理，并用C语言进行了简单的实现。</p><ul><li><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,t;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;s;j++)</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">&#123;</span><br><span class="line">t=a[i];</span><br><span class="line">a[i]=a[j];</span><br><span class="line">a[j]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">selectSort(a,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="起泡-冒泡排序"><a href="#起泡-冒泡排序" class="headerlink" title="起泡/冒泡排序"></a>起泡/冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,flag=<span class="number">1</span>,t;</span><br><span class="line"><span class="keyword">for</span>(i=high;i&gt;<span class="number">0</span>&amp;&amp;flag;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">t=a[j];</span><br><span class="line">a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">a[j+<span class="number">1</span>]=t;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;; </span><br><span class="line">BubbleSort(a,<span class="number">0</span>,<span class="number">9</span>); </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="插入排序1"><a href="#插入排序1" class="headerlink" title="插入排序1"></a>插入排序1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=a[i];</span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; a[j]&gt;temp;j--)</span><br><span class="line">a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">a[j+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">InsertSort(a,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="插入排序2"><a href="#插入排序2" class="headerlink" title="插入排序2"></a>插入排序2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k,t;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;s;i++)</span><br><span class="line">&#123;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(a[j]&lt;a[i]&amp;&amp;(j&lt;i))</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(i!=j)</span><br><span class="line">&#123;</span><br><span class="line">t=a[i];</span><br><span class="line"><span class="keyword">for</span>(k=i;k&gt;j;k--)</span><br><span class="line">a[k]=a[k<span class="number">-1</span>];</span><br><span class="line">a[j]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">insertSort(a,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="希尔排序1"><a href="#希尔排序1" class="headerlink" title="希尔排序1"></a>希尔排序1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j,gap;</span><br><span class="line"><span class="keyword">for</span> (gap=n/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span>(j=gap;j&lt;n;j++)</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[j-gap])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp=a[j];</span><br><span class="line"><span class="keyword">int</span> k=j-gap;</span><br><span class="line"><span class="keyword">while</span>(k&gt;=<span class="number">0</span> &amp;&amp; a[k]&gt;temp)</span><br><span class="line">&#123;</span><br><span class="line">a[k+gap]=a[k];</span><br><span class="line">k-=gap;</span><br><span class="line">&#125;</span><br><span class="line">a[k+gap]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">shellSort(a,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="希尔排序2"><a href="#希尔排序2" class="headerlink" title="希尔排序2"></a>希尔排序2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> d,i,j,temp;</span><br><span class="line">     <span class="keyword">for</span>(d=n/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=d;i&lt;n;i++)&#123;</span><br><span class="line">            temp=a[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-d;(j&gt;= <span class="number">0</span>) &amp;&amp; (a[j] &gt;temp);j=j-d)&#123;</span><br><span class="line">                a[j+d]=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+d]=temp;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">ShellSort(a,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="归并排序（递归实现）"><a href="#归并排序（递归实现）" class="headerlink" title="归并排序（递归实现）"></a>归并排序（递归实现）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 20 </span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,m[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=low,j=mid+<span class="number">1</span>,k=low;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;s[j])</span><br><span class="line">            m[k++]=s[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m[k++]=s[j++];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">        m[k++]=s[i++];</span><br><span class="line">    <span class="keyword">while</span> (j&lt;=high)</span><br><span class="line">        m[k++]=s[j++];</span><br><span class="line">    <span class="keyword">for</span> ( i = low; i &lt;=high ; i++)</span><br><span class="line">        s[i]=m[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(a+b)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(a,mid);</span><br><span class="line">        mergeSort(mid+<span class="number">1</span>,b);</span><br><span class="line">        merge(a,mid,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">mergeSort(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d"</span>,s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> s[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i=l,j=r,x=s[l];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; s[j]&gt;=x) </span><br><span class="line">j--;  </span><br><span class="line">            <span class="keyword">if</span>(i&lt;j) </span><br><span class="line">s[i++]=s[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; s[i]&lt;x) </span><br><span class="line">i++;  </span><br><span class="line">            <span class="keyword">if</span>(i&lt;j) </span><br><span class="line">s[j--]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s[i]=x;</span><br><span class="line">        quicksort(s,l,i<span class="number">-1</span>); </span><br><span class="line">        quicksort(s,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlink</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">quicksort(a,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">printlink(a,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNum</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">t=num/<span class="built_in">pow</span>(<span class="number">10</span>,pos<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> t%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">array</span>[<span class="number">10</span>];  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">array</span>[i]=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) *(s));</span><br><span class="line"><span class="built_in">array</span>[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pos=<span class="number">1</span>;pos&lt;<span class="number">10</span>;pos++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num=GetNum(a[i],pos);</span><br><span class="line"><span class="keyword">int</span> sum=++<span class="built_in">array</span>[num][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">array</span>[num][sum]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="built_in">array</span>[i][<span class="number">0</span>];k++)</span><br><span class="line">a[j++]=<span class="built_in">array</span>[i][k];</span><br><span class="line"><span class="built_in">array</span>[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> i,a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    RadixSort(a,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">( <span class="keyword">int</span> *a, <span class="keyword">int</span> *b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">temp=*b;</span><br><span class="line">    *b=*a;</span><br><span class="line">    *a=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> i,<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child, temp;</span><br><span class="line">    <span class="keyword">for</span>(temp=a[i];<span class="number">2</span>*i+<span class="number">1</span>&lt;s;i=child)</span><br><span class="line">    &#123;</span><br><span class="line">        child=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(child!=s<span class="number">-1</span> &amp;&amp; a[child+<span class="number">1</span>]&gt;a[child])</span><br><span class="line">            ++child;</span><br><span class="line">        <span class="keyword">if</span> (temp&lt;a[child])</span><br><span class="line">            a[i]=a[child];</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        HeapAdjust(a,i,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s<span class="number">-1</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(&amp;a[<span class="number">0</span>],&amp;a[i]);</span><br><span class="line">        HeapAdjust(a,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i,a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    HeapSort(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%3d"</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一段时间对8大排序算法进行了整理，并用C语言进行了简单的实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;简单选择排序&quot;&gt;&lt;a href=&quot;#简单选择排序&quot; class=&quot;headerlink&quot; title=&quot;简单选择排序&quot;&gt;&lt;/a&gt;简单选择排序&lt;/h3&gt;&lt;figure
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="elssm.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
