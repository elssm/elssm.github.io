<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ELSSM</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="elssm.github.io/"/>
  <updated>2021-09-16T12:39:47.985Z</updated>
  <id>elssm.github.io/</id>
  
  <author>
    <name>elssm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解计算机系统（一）</title>
    <link href="elssm.github.io/2021/09/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>elssm.github.io/2021/09/16/深入理解计算机系统（一）/</id>
    <published>2021-09-16T11:07:17.000Z</published>
    <updated>2021-09-16T12:39:47.985Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统漫游"><a href="#系统漫游" class="headerlink" title="系统漫游"></a>系统漫游</h3><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><p>从<code>hello world</code>说起。<code>hello world</code>程序的生命周期是从一个源程序开始的，程序员通过编辑器创建并保存的文本文件，文件名为<code>hello.c</code>。源程序实际上是一个由0和1组成的位序列。8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello,world\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hello.c</code>程序是以字节序列的方式存储在文件中的，每个字节都有一个整数值，对应于某些字符。例如第一个字节的整数值是35，对应的字符是“#”。需要注意的是，每个文本行都是以一个看不见的换行符“\n”来结束的，像<code>hello.c</code>这样只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p><p><code>hello.c</code>的表示方法说明了一个基本思想，系统中所有的信息包括磁盘文件、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。在不同上下文中，一个发相同的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><code>hello</code>程序的生命周期是从一个高级C语言程序开始的，因为这种形式能够被人读懂，然而为了在系统上运行<code>hello.c</code>程序，每条C语言都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包。并以二进制磁盘文件的形式存放起来，目标程序也被称为可执行目标文件。</p><p>在Unix系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/1.png" alt="1"></p><p>在这里，GCC编译器驱动程序读取源程序文件<code>hello.c</code>，并把它翻译成一个可执行目标文件<code>hello</code>。这个翻译过程可分为以上四个阶段完成。执行这四个阶段的程序一起构成了编译系统。</p><ul><li>预处理阶段。预处理器根据以字符<code>#</code>开头的命令，修改原始的C程序。比如<code>hello.c</code>中第一行的命令告诉预处理器读取系统头文件<code>stdio.h</code>的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以<code>.i</code>作为文件扩展名。</li><li>编译阶段。编译器将文本文件<code>hello.i</code>翻译成文本文件<code>hello.s</code>，它包含一个汇编语言程序，该程序包含函数main的定义。</li><li>汇编阶段。汇编器将<code>hello.s</code>翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件<code>hello.o</code>中，<code>hello.o</code>文件是一个二进制文件，它包含的17个字节是函数main的指令编码。</li><li>链接阶段。hello程序调用了printf函数，它是每个C编译器豆提供的标准C库中的一个函数。printf函数存在于一个名为<code>printf.o</code>的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的<code>hello.o</code>程序中，链接器就负责处理这种合并，结果就得到hello文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。</li></ul><h4 id="系统硬件组成"><a href="#系统硬件组成" class="headerlink" title="系统硬件组成"></a>系统硬件组成</h4><ul><li><strong>总线</strong>：贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。</li><li><strong>I/O设备</strong>：I/O设备是系统与外部世界的联系通道。，我们的示例系统包括四个I/O设备：作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘启动器，最开始，可执行程序就存放在磁盘上。<strong>每个I/O设备都通过一个控制器或适配器与I/O总线相连。</strong>控制器和适配器之间的区别主要在于它们的封装方式。</li><li><strong>主存</strong>：主存是一个临时存储设备。在处理器执行程序时，用来存放程序和程序处理的数据，从物理上来说，主寸是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的。一般来讲，组成程序的每条机器指令都由不同数量的字节构成。</li><li><strong>处理器</strong>：处理器是解释存储在主存中指令的引擎，处理器的核心是一个大小为一个字的存储设备，称为程序计数器(PC)。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）</li></ul><p>一个典型系统的硬件组成如下图所示</p><p><img src="/2021/09/16/深入理解计算机系统（一）/2.png" alt="2"></p><h4 id="程序的运行"><a href="#程序的运行" class="headerlink" title="程序的运行"></a>程序的运行</h4><ul><li><p>初识时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串<code>./hello</code>时，shell程序将字符逐一读入寄存器，再把它存放到内存中。</p></li><li><p>当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入，然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。</p></li><li>通过DMA，数据可以不通过处理器而直接从磁盘到达主存。</li><li>一旦hello中的代码和数据被加载到主存，处理器就开始执行hello程序中的main程序中的机器语言指令，这些指令将”hello,world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备。最终显示在屏幕上。</li></ul><h4 id="高速缓存的重要性"><a href="#高速缓存的重要性" class="headerlink" title="高速缓存的重要性"></a>高速缓存的重要性</h4><p>没有高速缓存，系统将会花费大量的时间把信息从一个地方挪到另一个地方，例如机器指令从磁盘复制到主存，从主存复制到处理器。数据也是如此，从磁盘复制到主存，从主存复制到显示设备。根据机械原理，较大的存储设备要比较小的存储设备运行的慢。类似的，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节，然而，处理器从寄存器文件中读取数据比从主存中读取数据几乎要快100倍。随着近几年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备。称为高速缓存存储器。作为暂时的集结区域，存放处理器近期可能会需要的信息。</p><p><img src="/2021/09/16/深入理解计算机系统（一）/3.png" alt="3"></p><h4 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h4><p>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。<br>操作系统有两个基本功能</p><ul><li><p>防止硬件被失控的应用程序滥用</p></li><li><p>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备</p></li></ul><p>操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能，其中，文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;系统漫游&quot;&gt;&lt;a href=&quot;#系统漫游&quot; class=&quot;headerlink&quot; title=&quot;系统漫游&quot;&gt;&lt;/a&gt;系统漫游&lt;/h3&gt;&lt;h4 id=&quot;Hello-world&quot;&gt;&lt;a href=&quot;#Hello-world&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统编程</title>
    <link href="elssm.github.io/2021/09/15/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <id>elssm.github.io/2021/09/15/Linux系统编程/</id>
    <published>2021-09-15T07:14:24.000Z</published>
    <updated>2021-09-18T03:24:04.630Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><p>命令解释器，根据舒服的命令执行相应命令</p><p>查看当前系统下有哪些shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p>查看当前系统正在使用的shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><p>常见shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash（就是linux的默认的shell）</span><br><span class="line">/bin/csh（已经被/bin/tcsh所取代）</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/ksh（Kornshell由AT&amp;T Bell lab发展出来的，兼容于bash）</span><br><span class="line">/bin/sh（已经被/bin/bash所取代）</span><br><span class="line">/bin/tcsh（整合C Shell，提供更多功能）</span><br><span class="line">/bin/zsh（基于ksh发展出来的，功能更强大的shell）</span><br></pre></td></tr></table></figure><h4 id="主键功能"><a href="#主键功能" class="headerlink" title="主键功能"></a>主键功能</h4><div class="table-container"><table><thead><tr><th>功能</th><th>快捷键</th><th>助记</th></tr></thead><tbody><tr><td>Home</td><td>Ctrl-a</td><td>The first letter</td></tr><tr><td>End</td><td>Ctrl-e</td><td>end</td></tr><tr><td>Clear</td><td>Ctrl-u</td><td>Clear</td></tr></tbody></table></div><h4 id="类Unix系统目录"><a href="#类Unix系统目录" class="headerlink" title="类Unix系统目录"></a>类Unix系统目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bin:存放二进制可执行文件</span><br><span class="line">boot:存放开机启动程序</span><br><span class="line">dev:存放设备文件</span><br><span class="line">home:存放用户</span><br><span class="line">etc:用户信息和系统配置文件</span><br><span class="line">lib:库文件</span><br><span class="line">root:管理员宿主目录</span><br><span class="line">usr:用户资源管理目录</span><br></pre></td></tr></table></figure><h4 id="Linux系统文件类型"><a href="#Linux系统文件类型" class="headerlink" title="Linux系统文件类型"></a>Linux系统文件类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">普通文件：-</span><br><span class="line">目录文件：d </span><br><span class="line">字符设备文件：c</span><br><span class="line">块设备文件：b</span><br><span class="line">软连接：l</span><br><span class="line">管道文件：p</span><br><span class="line">套接字：s</span><br><span class="line">未知文件</span><br></pre></td></tr></table></figure><p>软链接：为保证软链接可以任意搬移，创建时务必对源文件使用绝对路径</p><p>硬链接：操作系统给每一个文件赋予唯一的inode，当有相同inode的文件存在时，彼此同步。删除时，只将硬链接计数减一。减为0时，inode被释放。</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-type 按文件类型搜索</span><br><span class="line">-name 按文件名搜索</span><br><span class="line">-maxdepth 指定搜索深度</span><br><span class="line">-size 按文件大小搜索，单位：k、M、G</span><br><span class="line">-atime、mtime、ctime</span><br><span class="line">-exec 将find搜索的结果集执行某一指定命令</span><br><span class="line">-ok 以交互式的方式将find搜索的结果集执行某一指定命令</span><br><span class="line">-xargs 将find搜索的结果集执行某一指定命令，当结果集数量过大时，可以分片映射</span><br></pre></td></tr></table></figure><h4 id="压缩解压缩"><a href="#压缩解压缩" class="headerlink" title="压缩解压缩"></a>压缩解压缩</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">压缩</span><br><span class="line">tar -zcvf 要生成的压缩包名 压缩材料</span><br><span class="line">tar zcvf test.tar.gz file1 dir2 使用gzip方式压缩</span><br><span class="line">tar jcvf test.tar.gz file1 dir2 使用bzip2方式压缩</span><br><span class="line"></span><br><span class="line">解压</span><br><span class="line">  tar xcvf test.tar.gz 使用gzip方式解压</span><br><span class="line">tar xcvf test.tar.gz 使用bzip2方式解压</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rar</span><br><span class="line"></span><br><span class="line">rar a -r newdir dir 打包：将dir压缩成newdir.dir</span><br><span class="line">unrar x newdir.rar 解包：把newdir.rar解压缩到当前目录</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zip</span><br><span class="line"></span><br><span class="line">zip -r dir.zip dir 打包</span><br><span class="line">zip dir.zip 解压</span><br></pre></td></tr></table></figure><h4 id="vim基础操作"><a href="#vim基础操作" class="headerlink" title="vim基础操作"></a>vim基础操作</h4><p>进入插入模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i:插入光标前一个字符</span><br><span class="line">I:插入行首</span><br><span class="line">a:插入光标后一个字符</span><br><span class="line">A:插入行末</span><br><span class="line">o:向下新开一行，插入行首</span><br><span class="line">O:向上新开一行，插入行首</span><br></pre></td></tr></table></figure><p>进入命令模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">ESC:从插入模式或末行模式进入命令模式</span><br><span class="line">移动光标：</span><br><span class="line">h:左移</span><br><span class="line">j:下移</span><br><span class="line">k:上移</span><br><span class="line">l:右移</span><br><span class="line"></span><br><span class="line">跳转到指定行</span><br><span class="line">88G（命令模式）</span><br><span class="line">88（末行模式）</span><br><span class="line"></span><br><span class="line">跳转文件首</span><br><span class="line">gg（命令模式）</span><br><span class="line">跳转文件尾</span><br><span class="line">G（命令模式）</span><br><span class="line"></span><br><span class="line">自动格式化程序</span><br><span class="line">gg=G（命令模式）</span><br><span class="line"></span><br><span class="line">大括号对应</span><br><span class="line"><span class="meta">%</span>（命令模式）</span><br><span class="line"></span><br><span class="line">删除单个字符</span><br><span class="line">x（命令模式）执行结束，工作模式不变</span><br><span class="line">替换单个字符</span><br><span class="line">将待替换的字符用光标选中，r（命令模式），再按欲替换的字符</span><br><span class="line">删除一个单词</span><br><span class="line">dw（命令模式）光标置于首字母进行操作</span><br><span class="line">删除光标至行尾</span><br><span class="line">D（命令模式）执行结束，工作模式不变</span><br><span class="line">光标移至行首</span><br><span class="line">0（命令模式）执行结束，工作模式不变</span><br><span class="line">光标移至行尾</span><br><span class="line"><span class="meta">$</span>（命令模式）执行结束，工作模式不变</span><br><span class="line">删除光标至行尾</span><br><span class="line">D或者d$（命令模式）</span><br><span class="line">删除光标至行首</span><br><span class="line">d0(命令模式)</span><br><span class="line">删除指定区域</span><br><span class="line">按V（命令模式）切换为“可视模式”，使用hjkl挪动光标来选中待删除区域，按d删除该区域数据</span><br><span class="line">删除指定行</span><br><span class="line">在光标所在行，按dd（命令模式）</span><br><span class="line">删除指定N行</span><br><span class="line">在光标所待删除首行，按Ndd（命令模式）</span><br><span class="line">复制一行</span><br><span class="line">yy</span><br><span class="line">粘贴</span><br><span class="line">p：向后，P：向前（粘贴位置为当前光标所在行的上一行或者下一行）</span><br><span class="line">查找</span><br><span class="line">找设想内容：命令模式下，按“/”输入欲搜索关键字，回车，使用n检索下一个</span><br><span class="line">找看到的内容：命令模式下，将光标置于单词任意一个字符上，按“*” 或 “#”</span><br><span class="line">单行替换</span><br><span class="line">将光标置于待替换行上，进入末行模式，输入 :s /原数据/新数据</span><br><span class="line">全局替换</span><br><span class="line">将光标置于待替换行上，进入末行模式，输入 :%s /原数据/新数据/g,如果不加g只替换每行首个</span><br><span class="line">指定行的替换</span><br><span class="line">末行模式，:起始行号，终止行号s /原数据/新数据/g</span><br><span class="line">撤销、反撤销</span><br><span class="line">u、ctrl+r（命令模式）</span><br><span class="line">分屏</span><br><span class="line">sp：横屏分。Ctrl+ww切换</span><br><span class="line">vsp：竖屏分。Ctrl+ww切换</span><br><span class="line">跳转至man手册</span><br><span class="line">将光标置于待查看函数单词上，使用K（命令模式）跳转。</span><br><span class="line">查看宏定义</span><br><span class="line">将光标置于待查看宏定义单词上，使用[d查看定义语句。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Shell&quot;&gt;&lt;a href=&quot;#Shell&quot; class=&quot;headerlink&quot; title=&quot;Shell&quot;&gt;&lt;/a&gt;Shell&lt;/h4&gt;&lt;p&gt;命令解释器，根据舒服的命令执行相应命令&lt;/p&gt;
&lt;p&gt;查看当前系统下有哪些shell&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>消息队列总结</title>
    <link href="elssm.github.io/2021/09/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93/"/>
    <id>elssm.github.io/2021/09/14/消息队列总结/</id>
    <published>2021-09-14T00:13:35.000Z</published>
    <updated>2021-09-17T13:00:06.458Z</updated>
    
    <content type="html"><![CDATA[<h4 id="消息队列MQ"><a href="#消息队列MQ" class="headerlink" title="消息队列MQ"></a>消息队列MQ</h4><p>中间件：位于操作系统之上，客户应用系统之下的中间层，针对某些特定的领域抽取他们的共性部分独立出来的一套组件，称之为中间件。目的是为了进一步简化应用系统的开发，避免重复劳动。</p><ul><li>消息队列系统传输的对象是消息，消息如何来表示，即消息格式，比如使用CSV、XML、JSON或是二进制序列。</li><li>消息如何传输，消息在生产者，服务器和消费者之间如何流转，即是传输模型。</li></ul><h5 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h5><p>消息被保存在队列中，一个或多个消费者可以消耗队列中的消息，但是特定消息只能由最多一个消费者消费。一旦消费者读取队列中的消息，该消息就会从队列中消失。</p><h5 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布/订阅模型"></a>发布/订阅模型</h5><p>该模型有一个Topic的概念，和点对点模型不同的是，该模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，他们都能接收到相同主题的消息。</p><h4 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h4><ul><li>业务解耦（将频繁变动的非关键业务代码与稳定且关键的业务逻辑代码剥离开来）</li><li>异步调用（下单业务中，同步调用的调用链会很长，响应时间较长，异步调用会提高响应时间）</li><li>削峰填谷（遇到一些类似于双11的大促业务，可以使用MQ承接多的流量，之后再通过机器去MQ中拉取消息处理业务）</li><li>信息汇聚（大数据场景下，多数据源将各自产生的数据集中收拢到消息中间件，然后再由下游清洗和消费）</li><li>数据同步管道（用于同步数据变化的场景，例如数据库日志在两个数据库实例间的同步）</li></ul><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>生产者：消息发布的角色，支持分布式集群方式部署，通过MQ的负载均衡模块（SDK）选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p><p>服务端NameServer：元数据管理中心，类似于Zookeeper，支持Broker的动态注册与发现，以及Topic的路由注册。NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据，然后提供心跳检测机制，检查Broker是否还存活。每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息，然后Producer和Consumer通过NameServer就可以知道整个Broker集群的路由信息。从而进行 消息的投递和消费。Broker向每一台NameServer注册自己的路由信息，所以当某一个NameServer下线之后，Broker仍然可以向其他NameServer同步其路由信息。</p><p>Broker服务实例：负责消息的投递、存储和查询以及服务高可用保证。Broker下的子模块</p><ul><li>Remoting Moudle：整个Broker的实体，负责处理来自客户端的请求。</li><li>Client Manager：负责管理客户端和维护Consumer的Topic订阅信息。</li><li>Store Service：提供方便简单的API接口处理消息存储到无力硬盘和查询功能</li><li>HA Service：高可用服务，提供Master Broker和Slaver Broker之间的数据同步功能</li><li>Index Service：根据特定的Message Key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li></ul><p>消费者：支持分布式集群方式部署，支持长轮询模式对消息进行消费，同时也支持集群方式和广播方式的消费，以及实时消息订阅机制。</p><h4 id="RocketMQ集群工作流程"><a href="#RocketMQ集群工作流程" class="headerlink" title="RocketMQ集群工作流程"></a>RocketMQ集群工作流程</h4><ul><li>启动NameServer，监听端口，等待Broker、Producer和Consumer连接。</li><li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。</li><li>收发消息前，先创建Topic，创建时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li><li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并默认每隔30秒从NameServer中拉取Topic路由信息TopicPublishInfoTable，缓存到本地，从TopicPublishInfoTable中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。Broker作为消息的接收者接收消息并落盘存储。</li><li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，通过客户端负载均衡机制选择某一个或者几个消息队列来拉取消息进行消费。这里的拉取其实是兼顾拉（pull）和推（push）的长轮询模式（long polling），即首先消费者客户端向Broker发出拉取请求，如果Broker上的相应队列有数据，则拉取该数据；如果没有，则Broker作为服务端会hold该拉取请求30s，30s内有数据，则数据返回本次请求结束；如果30s内没有数据，则timeout，该请求结束，客户端立即发起下一次请求。</li></ul><h4 id="消费端负载均衡算法"><a href="#消费端负载均衡算法" class="headerlink" title="消费端负载均衡算法"></a>消费端负载均衡算法</h4><ul><li>平均分配算法</li><li>hash一致性算法</li><li>按机房分配算法</li><li>自定义算法</li></ul><p>默认的是消息队列的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的记录。</p><h4 id="RocketMQ的rebalance"><a href="#RocketMQ的rebalance" class="headerlink" title="RocketMQ的rebalance"></a>RocketMQ的rebalance</h4><p>Consumer在消费过程中是会连上具体的Broker server的，而且会定期上报心跳，因此Broker上是有全量的Consumer信息的，Consumer客户端可以拉取到整体有多少个Consumer节点，自己的排序情况如何；同时Consumer也能从Broker上拉取它所订阅的Topic全量的MessageQueue信息即总size。总size除以Consumer节点数就得到每页（每个）Consumer应该分配的MessageQueue。Broker定时会主动触发检查Topic的MessageQueue数量是否发生变化，如果变化则会触发为每个Consumer节点重新分配MessageQueue的计算。</p><h4 id="RocketMQ的存储机制"><a href="#RocketMQ的存储机制" class="headerlink" title="RocketMQ的存储机制"></a>RocketMQ的存储机制</h4><ul><li>CommitLog：日志数据文件，即消息主体以及元数据的存储主体，由Broker来创建，它解决了消息存哪里的问题。生产者（Producer）通过API发送消息到Broker端，首先会以顺序写的方式追加到一个名为CommitLog的文件末尾。这里的CommitLog文件就是真正存储消息本身的地方。默认一个CommitLog文件为1G大小，这是为了避免一个过大文件存储所有消息，导致读和写的效率低下。一个Broker实例下所有的Topic队列共用一个（组）CommitLog来存储消息</li><li>ConsumeQueue，即逻辑消费队列，可以等同的理解为前文中提到的逻辑分片messageQueue。它解决队列怎么存，消费者如何消费的问题。一个Topic会以多个ConsumeQueue的形式来存储（默认是4），Consumequeue以文件形式存储，采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量（commitLogOffset）、4字节的消息长度（msgSize）、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。因此，我们可以看出ConsumeQueue没有重复存储消息本身，而是作为消息的索引，帮助Consumer来查找待消费的数据。只要有了物理偏移量（commitLogOffset）和消息长度（msgSize），消费者就完全可以从CommitLog中读到它想要消费的信息了。</li><li>IndexFile: 即索引文件，Broker在创建ConsumeQueue的同时也会创建IndexFile，它用于解决性能问题。它提供了一种可以通过Key或时间区间来查询消息的方法。</li><li>miniOffset，consumerOffset和maxOffset，用于解决如何消费的问题。</li></ul><h4 id="RocketMQ消息刷盘机制"><a href="#RocketMQ消息刷盘机制" class="headerlink" title="RocketMQ消息刷盘机制"></a>RocketMQ消息刷盘机制</h4><ul><li><p>同步刷盘：只有在消息真正持久化至磁盘后RocketMQ的Broker端才会返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，要谨慎使用，一般适用于金融业务。</p></li><li><p>异步刷盘：能够充分利用OS的页缓存（PageCache）的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</p></li></ul><h4 id="幂等处理"><a href="#幂等处理" class="headerlink" title="幂等处理"></a>幂等处理</h4><p>在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p><p>实现幂等性的技术方案</p><ul><li>查询操作：select是天然的幂等操作</li><li>删除操作</li><li>唯一索引，防止新增脏数据</li><li>token机制，防止页面重复提交</li><li>悲观锁</li><li>乐观锁</li><li>分布式锁</li></ul><h4 id="2PC（两阶段提交协议）https-segmentfault-com-a-1190000012534071"><a href="#2PC（两阶段提交协议）https-segmentfault-com-a-1190000012534071" class="headerlink" title="2PC（两阶段提交协议）https://segmentfault.com/a/1190000012534071"></a>2PC（两阶段提交协议）<a href="https://segmentfault.com/a/1190000012534071" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012534071</a></h4><p>两阶段提交协议的目标在于为分布式系统保证数据的一致性，许多分布式系统采用该协议提供对分布式事务的支持。顾名思义，该协议将一个分布式的事务过程拆分成两个阶段： 投票和事务提交 。为了让整个数据库集群能够正常的运行，该协议指定了一个 协调者 单点，用于协调整个数据库集群各节点的运行。为了简化描述，我们将数据库集群中的各个节点称为 参与者 ，三阶段提交协议中同样包含协调者和参与者这两个角色定义</p><p>第一阶段：投票</p><p>该阶段的主要目的在于打探数据库集群中的各个参与者是否能够正常的执行事务</p><ul><li>协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果；</li><li>事务参与者收到请求之后，执行事务但不提交，并记录事务日志；</li><li>参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。</li></ul><p>第二阶段：事务提交</p><p>经过第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在 3 种可能性</p><ul><li><p>所有的参与者都回复能够正常执行事务。</p><p>处理如下</p><ul><li>协调者向各个参与者发送 commit 通知，请求提交事务；</li><li>参与者收到事务提交通知之后执行 commit 操作，然后释放占有的资源；</li><li>参与者向协调者返回事务 commit 结果信息。</li></ul></li><li><p>一个或多个参与者回复事务执行失败。</p><p>处理如下</p><ul><li>协调者向各个参与者发送事务 rollback 通知，请求回滚事务；</li><li>参与者收到事务回滚通知之后执行 rollback 操作，然后释放占有的资源；</li><li>参与者向协调者返回事务 rollback 结果信息。</li></ul></li><li><p>协调者等待超时。</p><p>处理如下</p><ul><li>协调者向各个参与者发送事务 rollback 通知，请求回滚事务；</li><li>参与者收到事务回滚通知之后执行 rollback 操作，然后释放占有的资源；</li><li>参与者向协调者返回事务 rollback 结果信息。</li></ul></li></ul><h4 id="Kafka（消息引擎系统）"><a href="#Kafka（消息引擎系统）" class="headerlink" title="Kafka（消息引擎系统）"></a>Kafka（消息引擎系统）</h4><p>传输模型</p><ul><li>点对点模型</li><li>发布/订阅模型</li></ul><p>体系结构</p><ul><li><p>Producer</p></li><li><p>Consumer</p></li><li><p>Broker：服务代理节点</p></li><li><p>Topic</p></li><li><p>Partition</p></li><li><p>Offset</p><p>一个topic有多个Partition，一个Partition又会有多个Replica，一个Replica中记录的是Log，Log又可以被分为多个LogSegment，LogSegment包含<code>.log</code>、<code>.index</code>、<code>.timeindex</code>等文件</p></li></ul><p>Kafka的多副本机制</p><ul><li>同一分区的不同副本中保存的是相同的消息，副本之间是“一主多从”的关系</li></ul><p>Kafka的主要场景还是在消息引擎而不是以数据存储的方式对外提供读服务，通常设计频繁的生产消息和消费消息，这不属于典型的读多写少场景，因此读写分离不适合kafka。</p><ul><li>AR（Assigned Replicas）：分区中的所有副本</li><li>ISR（In-Sync Replicas）：所有与leader副本保持一定程度同步的副本（包括leader副本）</li><li>OSR（Out-of-Sync Replicas）：与leader副本同步滞后过多的副本</li><li>HW（High watermark）：高水位，标识了一个特定的消息偏移量，消费者只能拉取到这个offset之前的消息</li><li>LEO（Log End Offset）：标识当前日志文件中下一条待写入消息的offset</li></ul><p>Kafka的三层消息架构：</p><ul><li>第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</li><li>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</li><li>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</li></ul><p>Kafka的分区策略</p><ul><li>轮询策略（Round-robin）</li><li>随机策略（Randomness）</li><li>按消息键保存策略</li></ul><p>Rebalance的触发条件</p><ul><li>组成员数发生变更。比如有新的 Consumer 实例加入组或者离开组，抑或是有 Consumer 实例崩溃被“踢出”组。</li><li>订阅主题数发生变更。Consumer Group 可以使用正则表达式的方式订阅主题，比如 consumer.subscribe(Pattern.compile(“t.*c”)) 就表明该 Group 订阅所有以字母 t 开头、字母 c 结尾的主题。在 Consumer Group 的运行过程中，你新创建了一个满足这样条件的主题，那么该 Group 就会发生 Rebalance。</li><li>订阅主题的分区数发生变更。Kafka 当前只能允许增加一个主题的分区数。当分区数增加时，就会触发订阅该主题的所有 Group 开启 Rebalance。</li></ul><p>位移主题：_consumer_offsets是kafka的内部主题，也被称为位移主题，即Offsets Topic。</p><p>老版本Consumer的位移管理依托于ZooKeeper，它会自动或手动的将位移数据提交到ZooKeeper中保存，当Consumer重启后，它能自动从ZooKeeper中读取位移数据，从而在上次消费截止的地方继续消费。ZooKeeper的缺点时不适用于高频的写操作。</p><p>新版本Consumer的位移管理很简单，就是将Consumer的位移数据作为一条条普通的Kafka消息，提交到_consumer_offsets中，可以说，_consumer_offsets的主要作用是保存Kafka消费者的位移信息，要求这个提交过程不仅要支持高持久性，还要支持高频的写操作。</p><p>kafka consumer多线程方案</p><ul><li>消费者程序启动多个线程，每个线程维护专属的 KafkaConsumer 实例，负责完整的消息获取、消息处理流程。</li><li>消费者程序使用单或多线程获取消息，同时创建多个消费线程执行消息处理逻辑。获取消息的线程可以是一个，也可以是多个，每个线程维护专属的 KafkaConsumer 实例，处理消息则交由特定的线程池来做，从而实现消息获取与消息处理的真正解耦。</li></ul><p>副本机制的好处</p><ul><li>提供数据冗余。即使系统部分组件失效，系统依然能够继续运转，因而增加了整体可用性以及数据持久性。</li><li>提供高伸缩性。支持横向扩展，能够通过增加机器的方式来提升读性能，进而提高读操作吞吐量。</li><li>改善数据局部性。允许将数据放入与用户地理位置相近的地方，从而降低系统延时。</li></ul><p>Kafka的Leader-based副本机制</p><ul><li>在 Kafka 中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本。</li><li>在 Kafka 中，追随者副本是不对外提供服务的。这就是说，追随者副本不处理客户端请求，它唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。</li><li>领导者副本挂掉了，或者说领导者副本所在的 Broker 宕机时，Kafka 依托于 ZooKeeper 提供的监控功能能够实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老 Leader 副本重启回来后，只能作为追随者副本加入到集群中。</li></ul><p>Read-your-writes：这里指当你使用生产者API向Kafka成功写入消息后，马上使用消费者API去读取刚才生产的消息。</p><p>Monotonic Reads（单调读）：对于一个消费者用户而言，在多次消费消息时，他不会看到某条消息一会存在一会不存在。如果第一次读到的是leader副本的消息，第二次可能读到follow副本的消息。而此时follow副本还没有同步leader副本中的消息。</p><p>Unclean领导者选举：通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程称为 Unclean 领导者选举。开启 Unclean 领导者选举可能会造成数据丢失，但好处是，它使得分区 Leader 副本一直存在，不至于停止对外提供服务，因此提升了高可用性。反之，禁止 Unclean 领导者选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性。这就是我们常说的分布式系统的CAP理论。</p><p>Reactor模式：Kafka处理请求的方式。</p><ul><li>Broker中存在一个类似于Reactor中的dispatcher的组件名叫SocketServer，它有对应的Acceptor线程和一个工作线程池。在kafka中这个线程池叫网络线程池。当网络线程拿到请求后，它不是自己处理，而是将请求放到一个共享请求队列中。Broker端还有个IO线程池，负责从该队列中取出请求，执行真正的处理。如果是 PRODUCE 生产请求，则将消息写入到底层的磁盘日志中；如果是 FETCH 请求，则从磁盘或页缓存中读取消息。IO 线程池处中的线程才是执行请求逻辑的线程。请求队列是所有网络线程共享的，而响应队列则是每个网络线程专属的。这么设计的原因就在于，Dispatcher 只是用于请求分发而不负责响应回传，因此只能让每个网络线程自己发送 Response 给客户端，所以这些 Response 也就没必要放在一个公共的地方。</li><li>Purgatory组件：用来缓存延时请求，所谓延时请求，就是那些一时未满足条件不能立刻处理的请求。比如设置了 acks=all 的 PRODUCE 请求，一旦设置了 acks=all，那么该请求就必须等待 ISR 中所有副本都接收了消息后才能返回，此时处理该请求的 IO 线程就必须等待其他 Broker 的写入结果。当请求不能立刻处理时，它就会暂存在 Purgatory 中。稍后一旦满足了完成条件，IO 线程会继续处理该请求，并将 Response 放入对应网络线程的响应队列中。</li></ul><p>Coordinator：Kafka的协调者，专门为Consumer Group服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。具体来讲，Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。所有 Broker 在启动时，都会创建和开启相应的 Coordinator 组件。也就是说，所有 Broker 都有各自的 Coordinator 组件。</p><p>Controller：Kafka的核心组件。它的主要作用是在Apache Zookeeper的帮助下管理和协调整个Kafka集群。集群中任意一台Broker都能充当控制器的角色，但在运行过程中，只能有一个Broker成为控制器，行使其管理和协调的职责。</p><p>控制器的功能</p><ul><li>主题管理（创建、删除、增加分区）</li><li>分区重分配：Kafka-reassign-partitions脚本提供的对已有主题分区进行细粒度的分配功能。</li><li>Preferred领导者选举：Kafka为了避免部分Broker负载过重而提供的一种换Leader的方案。</li><li>集群成员管理（新增Broker、Broker主动关闭、Broker宕机）</li><li>数据服务：控制器上保存了最全的集群元数据信息，其他所有Broker会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据。</li></ul><p>Kafka的定时器：kafka基于时间轮的概念自定义实现了一个用于延时功能的定时器(SystemTimer)。可以将插入和删除操作的时间复杂度降为O(1)。例如当配置了acks=all的生产者发送的请求必须确保ISR中的所有副本都成功响应这次写入，这就是所谓的延时请求。</p><p>kafka中使用的请求被延时处理的机制是分层时间轮算法。</p><p>kafka的broker如何实现持久化数据：使用消息日志(Log)来保存数据，一个日志就是磁盘上一个只能追加写消息的物理文件，不过如果不停的向一个日志写消息，最终也会耗尽所有的磁盘空间，因此Kafka通过Log Segment机制，在Kafka底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满一个日志段后，Kafka会自动切分出一个新的日志段，并将老的日志段封存起来，Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p><p>kafka控制器的选举机制：每个代理节点都会作为ZK的客户端，向ZK服务端尝试创建/controller临时节点。Zookeeper里采用的是Zab共识算法/协议。</p><h4 id="Kafka命令行操作"><a href="#Kafka命令行操作" class="headerlink" title="Kafka命令行操作"></a>Kafka命令行操作</h4><p>查看当前服务器中的所有topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p>创建topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br><span class="line"></span><br><span class="line">--topic 定义topic名</span><br><span class="line">--replication-factor 定义副本数</span><br><span class="line">--partitions 定义分区数</span><br></pre></td></tr></table></figure><p>删除topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --delete --zookeeper localhost:2181 --topic test</span><br></pre></td></tr></table></figure><p>查看某个topic的详情</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --describe --zookeeper localhost:2181 --topic test</span><br></pre></td></tr></table></figure><p>生产消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:9092 --topic test</span><br></pre></td></tr></table></figure><p>消费消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning</span><br></pre></td></tr></table></figure><h4 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h4><p>核心思想：计算存储分离</p><p>特点：多租户，易于扩展</p><h4 id="Pulsar核心组件"><a href="#Pulsar核心组件" class="headerlink" title="Pulsar核心组件"></a>Pulsar核心组件</h4><p>Broker：计算层，整个消息层的生产和消费，无存储状态。</p><ul><li>Dispatcher：调度分发模块，承担协议转换、序列化反序列化等。</li><li>Load balancer：负载均衡模块，对访问流量进行控制管理。</li><li>Global replicators：跨集群复制模块，承担异步的跨集群消息同步功能。</li><li>Service discovery：服务发现模块，为每个 topic 选择无状态的主节点。</li></ul><p>BookKeeper：存储层，数据持久化保存的节点，有存储状态。</p><ul><li>Bookie：存储设备</li></ul><p>RocksDB：内嵌在 BookKeeper 中的数据库，存储每个条目的位置索引。</p><p>Zookeeper：元数据管理，存储 Pulsar 和 BookKeeper 元数据 和 节点状态，以及服务发现（发现 broker ，发现bookie）。在 Pulsar 里的作用是存储 Pulsar 系统里元数据的存储和集群的管理以及节点的发现等，节点发现是指发现集群里有多少个 broker，有多少 bookie。</p><ul><li>local zk：负责Pulsar Cluster内部的配置等</li><li>global zk：则用于Pulsar Cluster之间的数据复制等。</li><li>Configuration Store：存储的是集群复制信息，让集群之间互相了解各自的地址。同时还包括一些 clients 或 namespace 的相关配置信息。</li></ul><h4 id="Pulsar订阅模型"><a href="#Pulsar订阅模型" class="headerlink" title="Pulsar订阅模型"></a>Pulsar订阅模型</h4><ul><li>Exclusive（独享）：一个订阅只能有一个消费者消费消息</li><li>Fail-Over（灾备）：一个订阅同时只有一个消费者，可以有多个备份消费者。一旦主消费者故障则备份消费者接管。不会出现同时有两个活跃的消费者。</li><li>Shared（共享）：一个订阅中同时可以有多个消费者，多个消费者共享Topic中的消息。消息通过轮询机制分发给不同的消费者，并且每个消息仅会被分发给一个消费者。当消费者断开连接，所有被发送给它，但没有被确认的消息将被重新安排，分发给其他存活的消费者。</li><li>Key Shared（Key共享）：一个订阅中同时可以有多个消费者，消息在各个使用者之间进行分发，其规则是相同Key的消息仅传递给一个使用者。不管消息被重新发送多少次，它都会被发送到同一消费者。</li></ul><h4 id="Puslar消息路由策略"><a href="#Puslar消息路由策略" class="headerlink" title="Puslar消息路由策略"></a>Puslar消息路由策略</h4><ul><li>单分区：生产者随机挑选一个分区，并将数据写入该分区。</li><li>轮询：生产者通过轮询的方式将数据平均地分布到各个分区上。</li><li>哈希：每个消息会带上一个键，要写入哪个分区取决于它所带的键。</li><li>自定义：生产者使用自定义函数生成分区对应的数值，然后根据这个数值将消息写入对应的分区。</li></ul><p>Pulsar 的数据存储节点 Bookkeeper 被称为 Bookie，相当于一个 Kafka Broker。Ledger 是 Topic 的若干日志的集合，是 Pulsar 数据删除的最小单元，即 Pulsar 每次淘汰以 Ledger 为单位进行删除。Fragment 是 Bookkeeper 的概念，对应一个日志文件，每个 Ledger 由若干 Fragment 组成。</p><h4 id="Pulsar-Broker"><a href="#Pulsar-Broker" class="headerlink" title="Pulsar Broker"></a>Pulsar Broker</h4><p>Pulsar 的 metadata 存储在 zookeeper 上，而消息数据存储在 Bookkeeper 上。Broker 虽然需要这些 metadata，但是其自身并不持久化存储这些数据，所以可以认为是无状态的。不像 Kafka 是在 Partition 级别拥有一个 leader Broker，Pulsar 是在 Topic 级别拥有一个 leader Broker，称之为拥有 Topic 的所有权，针对该 Topic 所有的 R/W 都经过该 Broker 完成。</p><p>Pulsar Broker 可以认为是一种 Proxy，它对 client 屏蔽了服务端读写流程的复杂性，是保证数据一致性与数据负载均衡的重要角色，所以 Pulsar 可以认为是一种基于 Proxy 的分布式系统。与之形成对比的 kafka 可以认为是一种基于 SmartClient 的系统，所以 Kafka 服务端自身的数据一致性流程还需要 Client SDK 与之配合完成。</p><p>Kafka 的所有 Broker 会选出一个 Leader，作为 Broker Leader 决定 Broker 宕机判断、集群扩容、创建删除 Topic、Topic Replica分布、Topic Partition 的 Leader 的选举。Pulsar 的所有 Broker 也会借助 zookeeper 加锁的方式选举一个 Leader【或者称为 Master 更合适，以区分于 Topic 的 Leader】，对 Broker 宕机判断（Failover）、根据 Bookie 集群负载Topic Ledger 所有权【即 Ledger 所在的 Bookie】等任务</p><h4 id="Pulsar-Bookie"><a href="#Pulsar-Bookie" class="headerlink" title="Pulsar Bookie"></a>Pulsar Bookie</h4><p>Pulsar 的底层数据 以 Ledger（上图中的 Segment 就是 Ledger） 形式存储在多个 BookKeeper 上，当集群扩容添加 Bookies 后，Pulsar 会在新的 Bookie 上创建新的 Segment(即 Bookeeper 的 Ledger)，所以不需要再扩容时候像 Kafka 一样进行 Rebalance 操作，其结果就是 Fragments跨多个Bookies以带状分布。但是这样的结果就是同一个 Ledger 的 Fragments 分布在多个 Bookie 上，导致读取和写入会在多个 Bookies 之间跳跃。Topic的 Ledger 和 Fragment 之间映射关系等元数据存储在 Zookeeper 中，Pulsar Broker 需要实时跟踪这些关系进行读写流程。</p><h4 id="Ledgers"><a href="#Ledgers" class="headerlink" title="Ledgers"></a>Ledgers</h4><p>一个Topic实际上是一个ledgers流。Ledger本身就是一个日志。所以一系列的子日志(Ledgers)组成了一个父日志(Topic)。</p><p>Ledgers追加到一个Topic，条目(消息或者一组消息)追加到Ledgers。Ledger一旦关闭是不可变的。Ledger作为最小的删除单元，也就是说我们不能删除单个条目而是去删除整个Ledger。</p><p>Ledgers本身也被分解为多个Fragment。Fragment是BookKeeper集群中最小的分布单元，每个Ledger(由一个或多个Fragment组成)可以跨多个BookKeeper节点(Bookies)进行复制，以实现数据容灾和提升读取性能。每个Fragment都在一组不同的Bookies中复制(存在足够的Bookies)。</p><p>每个Ledger有三个关键配置</p><ul><li>Ensemble Size（E）：Ensemble表示将要写入的实际的Bookies数量</li><li>Write Quorum Size（Qw）：Write Quorum (Qw) 是Pulsar将要写入的实际的Bookies数量。可以等于或者小于Ensemble。</li><li>Ack Quorum Size（Qa）：Ack Quorum (Qa) 是确认写入Bookies的数量，Pulsar Broker将确认发送给客户端。为了一致性，Qa应该是：(Qw + 1) / 2 或者更大。</li></ul><h4 id="Pulsar总结"><a href="#Pulsar总结" class="headerlink" title="Pulsar总结"></a>Pulsar总结</h4><ul><li>每个Topic都有一个归属的Broker</li><li>每个Topic在逻辑上分解为Ledgers、Fragments和Entries。</li><li>Fragments分布在Bookie集群中。Topic与Bookie并不耦合。</li><li>Fragments可以跨多个Bookies带状分布。</li><li>当Pulsar Broker不可用时，该Broker持有的Topic所有权将转移至其他的Broker。Fencing机制避免了同一个Topic当前的Ledger同时有两个所有者(Broker)。</li><li>当Bookie不可用时，自动恢复(如果启用)将自动进行数据重新复制到其他的Bookies。如果禁用，则可以手动启动此过程。</li><li>Broker缓存尾部消息日志，可以非常高效的为尾部读取操作提供服务。</li><li><p>Bookies使用Journal提供持久化保证。该日志可用于故障恢复时恢复尚未写入Entry Log文件的数据。</p></li><li><p>所有Topic的的条目都保存在Entry Log文件中。查找索引保存在RocksDB中。</p></li><li>所有Topic的的条目都保存在Entry Log文件中。查找索引保存在RocksDB中。</li><li>Bookies可以通过单独的磁盘做IO读写分离。</li><li>Zookeeper存储Pulsar和BookKeeper的所有元数据。如果Zookeeper不可用整个Pulsar将不可用。</li><li>存储可以单独扩展。如果存储是瓶颈，那么只需要添加更多的Bookies，他们会自动承担负载，不需要Rebalance。</li></ul><h4 id="Kafka和Pulsar"><a href="#Kafka和Pulsar" class="headerlink" title="Kafka和Pulsar"></a>Kafka和Pulsar</h4><p>Kafka：单片架构模型，服务与存储相结合</p><p>Pulsar：多层架构，可以在单独的层内进行管理</p><p>相对于kafka，这是一个非常不同且复杂的模型。对于kafka，每个Partition副本都完整的存储在kafka节点上。Partition以及Partition副本由一系列的Segment和索引文件组成。kafka模型的优点在于简单快捷。所有读写都是顺序的。不好的是，单个节点必须有足够的磁盘空间来处理副本，因此非常大的副本可能会迫使你是用非常大的磁盘。第二个缺点是，在集群扩展时必须做Rebalance。这个过程是比较痛苦的，需要良好的计划和执行来保证没有任何故障的情况下分散节点的存储压力。</p><p>在Pulsar+BookKeeper模型中，Topic中的数据分布在多个Bookies上。Topic被分割成Ledgers，Ledgers被分割成Fragments分布在Fragment使用的Bookies上。当需要做集群扩展时，只需添加更多Bookies，它们就会在创建新的Fragment时开始在的Bookies上写入数据，不再需要kafka的Rebalance操作。</p><h4 id="事务区别"><a href="#事务区别" class="headerlink" title="事务区别"></a>事务区别</h4><p>RocketMQ中的事务，它解决的问题是，确保执行本地事务和发消息这两个操作，要么都成功，要么都失败。并且RocketMQ增加了一个事务反查的机制，来尽量提高事务执行的成功率和数据一致性。</p><p>Kafka 中的事务，它解决的问题是，确保在一个事务中发送的多条消息，要么都成功，要么都失败。（这里面的多条消息不一定要在同一个主题和分区中，可以是发往多个主题和分区的消息）当然也可以在kafka事务执行过程中开启本地事务来实现类似RocketMQ事务消息的效果，但是Kafka是没有事务消息反查机制的，它是直接抛出异常的，用户可以根据异常来实现自己的重试等方法保证事务正常运行。</p><p>它们的共同点就是：都是通过两阶段提交来实现事务的，事务消息都保存在单独的主题上。不同的地方就是RocketMQ是通过“半消息”来实现的，kafka是直接将消息发送给对应的topic，通过客户端来过滤实现的。而且它们两个使用的场景区别是非常之大的，RockteMQ主要解决的是基于本地事务和消息的数据一致性，而Kafka的事务则是用于实现它的Exactly-once机制，应用于实时流计算的场景中。</p><p>Pulsar的事务消息和Kafka应用场景和语义类似，只是由于底层实现机制有差别，在一些细节上有区别。</p><p>参考资料：</p><p><a href="http://matt33.com/2019/01/28/bk-store-realize/" target="_blank" rel="noopener">http://matt33.com/2019/01/28/bk-store-realize/</a></p><p><a href="https://mp.weixin.qq.com/s/CIpCLCxqpLoQVUKz6QeDJQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CIpCLCxqpLoQVUKz6QeDJQ</a></p><p><a href="https://alexstocks.github.io/html/pulsar.html" target="_blank" rel="noopener">https://alexstocks.github.io/html/pulsar.html</a></p><p><a href="https://segmentfault.com/a/1190000023605433" target="_blank" rel="noopener">https://segmentfault.com/a/1190000023605433</a></p><p><a href="https://segmentfault.com/a/1190000038173886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000038173886</a></p><p><a href="https://blog.csdn.net/shijinghan1126/article/details/117418520" target="_blank" rel="noopener">https://blog.csdn.net/shijinghan1126/article/details/117418520</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;消息队列MQ&quot;&gt;&lt;a href=&quot;#消息队列MQ&quot; class=&quot;headerlink&quot; title=&quot;消息队列MQ&quot;&gt;&lt;/a&gt;消息队列MQ&lt;/h4&gt;&lt;p&gt;中间件：位于操作系统之上，客户应用系统之下的中间层，针对某些特定的领域抽取他们的共性部分独立出来的一套组件，
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>腾讯精选练习50题(LeetCode)</title>
    <link href="elssm.github.io/2021/06/24/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A050%E9%A2%98-LeetCode/"/>
    <id>elssm.github.io/2021/06/24/腾讯精选练习50题-LeetCode/</id>
    <published>2021-06-24T05:40:34.000Z</published>
    <updated>2021-06-24T06:28:58.108Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两数相加-medium"><a href="#两数相加-medium" class="headerlink" title="两数相加(medium)"></a>两数相加(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c1=[]</span><br><span class="line">        c2=[]</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            c1.append(l1.val)</span><br><span class="line">            l1=l1.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            c2.append(l2.val)</span><br><span class="line">            l2=l2.next</span><br><span class="line">        j1=<span class="number">-1</span></span><br><span class="line">        j2=<span class="number">-1</span></span><br><span class="line">        sum1=<span class="number">0</span></span><br><span class="line">        sum2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c1)):</span><br><span class="line">            sum1=sum1*<span class="number">10</span>+c1[j1]</span><br><span class="line">            j1=j1<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c2)):</span><br><span class="line">            sum2=sum2*<span class="number">10</span>+c2[j2]</span><br><span class="line">            j2=j2<span class="number">-1</span></span><br><span class="line">        res=sum1+sum2</span><br><span class="line">        p=head=node=ListNode(<span class="literal">None</span>)</span><br><span class="line">        l=len(str(res))</span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            node=ListNode(res%<span class="number">10</span>)</span><br><span class="line">            p.next=node</span><br><span class="line">            p=node</span><br><span class="line">            res/=<span class="number">10</span></span><br><span class="line">            l-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><h4 id="寻找两个正序数组的中位数-hard"><a href="#寻找两个正序数组的中位数-hard" class="headerlink" title="寻找两个正序数组的中位数(hard)"></a>寻找两个正序数组的中位数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            nums1.append(i)</span><br><span class="line">        nums1 = sorted(nums1)</span><br><span class="line">        <span class="keyword">if</span> len(nums1)%<span class="number">2</span> !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[len(nums1)/<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums1[len(nums1)/<span class="number">2</span>]+nums1[len(nums1)/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span></span><br></pre></td></tr></table></figure><h4 id="最长回文子串-medium"><a href="#最长回文子串-medium" class="headerlink" title="最长回文子串(medium)"></a>最长回文子串(medium)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,t,n,l;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* ret = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">1001</span>);</span><br><span class="line">    <span class="built_in">memset</span>(ret,<span class="number">0</span>,<span class="number">1001</span>);</span><br><span class="line"><span class="comment">//int m[1000];</span></span><br><span class="line"><span class="comment">//char *m=(char *)malloc(sizeof(char)*strlen(s));</span></span><br><span class="line">t=<span class="built_in">strlen</span>(s); </span><br><span class="line"><span class="keyword">for</span>(i=t;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;t-i+<span class="number">1</span>;j++)&#123;</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line">n=j+i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(k=j;k&lt;i/<span class="number">2</span>+j;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[k]==s[n--])&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count==i/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count==i/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(l=j;l&lt;j+i;l++)&#123;</span><br><span class="line">ret[a++]=s[l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整数反转-easy"><a href="#整数反转-easy" class="headerlink" title="整数反转(easy)"></a>整数反转(easy)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> t,sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">  t=x%<span class="number">10</span>;</span><br><span class="line">  x=x/<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">2147483647</span>/<span class="number">10</span>||(sum==<span class="number">2147483647</span>/<span class="number">10</span> &amp;&amp; t&gt;<span class="number">7</span>))</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">-2147483648</span>/<span class="number">10</span>||(sum==<span class="number">-2147483648</span>/<span class="number">10</span> &amp;&amp; t&lt;<span class="number">-8</span>))</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     sum=sum*<span class="number">10</span>+t;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串转换整数-medium"><a href="#字符串转换整数-medium" class="headerlink" title="字符串转换整数(medium)"></a>字符串转换整数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="string">""</span></span><br><span class="line">        flag=<span class="number">1</span></span><br><span class="line">        temp1=[<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>]</span><br><span class="line">        temp2=[<span class="string">"-"</span>,<span class="string">"+"</span>]</span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i]!=<span class="string">" "</span>:</span><br><span class="line">                temp=i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        s=s[temp:]</span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">0</span> <span class="keyword">or</span> (s[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp1 <span class="keyword">and</span> s[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> temp2):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] <span class="keyword">in</span> temp1:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i] <span class="keyword">in</span> temp1:</span><br><span class="line">                    res += s[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> int(res) - <span class="number">2147483647</span> &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> int(res)</span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] <span class="keyword">in</span> temp2:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i] <span class="keyword">in</span> temp1:</span><br><span class="line">                    flag=<span class="number">0</span></span><br><span class="line">                    res += s[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> s[<span class="number">0</span>]==<span class="string">"-"</span>:</span><br><span class="line">                <span class="keyword">if</span> -int(res) - (<span class="number">-2147483648</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> -int(res)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-2147483648</span></span><br><span class="line">            <span class="keyword">elif</span> s[<span class="number">0</span>]==<span class="string">"+"</span>:</span><br><span class="line">                <span class="keyword">if</span> int(res) - <span class="number">2147483647</span> &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2147483647</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> int(res)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="回文数-easy"><a href="#回文数-easy" class="headerlink" title="回文数(easy)"></a>回文数(easy)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,t,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">k=x;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">t=x%<span class="number">10</span>;</span><br><span class="line">sum=sum*<span class="number">10</span>+t;</span><br><span class="line">x=x/<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum==k)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="盛最多水的容器-medium"><a href="#盛最多水的容器-medium" class="headerlink" title="盛最多水的容器(medium)"></a>盛最多水的容器(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(height)<span class="number">-1</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            h=min(height[i],height[j])</span><br><span class="line">            res=max(res,h*(j-i))</span><br><span class="line">            <span class="keyword">if</span> height[i]&gt;height[j]:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="最长公共前缀-easy"><a href="#最长公共前缀-easy" class="headerlink" title="最长公共前缀(easy)"></a>最长公共前缀(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(strs)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        c=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">            c.append(len(strs[i]))</span><br><span class="line">        minl = min(c)</span><br><span class="line">        s=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(minl):</span><br><span class="line">            res=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">                res.append(strs[j][i])</span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">1</span>:] == res[:<span class="number">-1</span>]:</span><br><span class="line">                s+=strs[j][i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h4 id="三数之和-medium"><a href="#三数之和-medium" class="headerlink" title="三数之和(medium)"></a>三数之和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#第一种方法，可行但超时</span></span><br><span class="line">        <span class="comment"># if len(nums)==0 or len(nums)==1 or len(nums)==2:</span></span><br><span class="line">        <span class="comment">#     return []</span></span><br><span class="line">        <span class="comment"># sum_two=[]</span></span><br><span class="line">        <span class="comment"># d=&#123;&#125;</span></span><br><span class="line">        <span class="comment"># res=[]</span></span><br><span class="line">        <span class="comment"># count=0</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)-1):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,len(nums)):</span></span><br><span class="line">        <span class="comment">#         d[count]=[i,j]</span></span><br><span class="line">        <span class="comment">#         sum_two.append(nums[i]+nums[j])</span></span><br><span class="line">        <span class="comment">#         count+=1</span></span><br><span class="line">        <span class="comment"># # print(d)</span></span><br><span class="line">        <span class="comment"># # print(sum_two)</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for j in range(len(sum_two)):</span></span><br><span class="line">        <span class="comment">#         if i not in d[j] and nums[i]+sum_two[j]==0:</span></span><br><span class="line">        <span class="comment">#             temp = [nums[d[j][0]]] + [nums[i]] + [nums[d[j][1]]]</span></span><br><span class="line">        <span class="comment">#             temp.sort()</span></span><br><span class="line">        <span class="comment">#             if temp not in res:</span></span><br><span class="line">        <span class="comment">#                 res.append(temp)</span></span><br><span class="line">        <span class="comment"># # res = list(set([tuple(t) for t in res]))</span></span><br><span class="line">        <span class="comment"># # res = list([list(l) for l in res])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="comment"># n = len(nums)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                key = nums[j]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> d:</span><br><span class="line">                    value = d[key] + [key]</span><br><span class="line">                    value.sort()</span><br><span class="line">                    <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                        res.append(value)</span><br><span class="line">                key = -nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[key] = [nums[i], nums[j]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="最接近的三数之和-medium"><a href="#最接近的三数之和-medium" class="headerlink" title="最接近的三数之和(medium)"></a>最接近的三数之和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            low=i+<span class="number">1</span></span><br><span class="line">            high=len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> low&lt;high:</span><br><span class="line">                sums=nums[i]+nums[low]+nums[high]</span><br><span class="line">                res.append(sums)</span><br><span class="line">                <span class="keyword">if</span> sums==target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">elif</span> sums&lt;target:</span><br><span class="line">                    low+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    high-=<span class="number">1</span></span><br><span class="line">        res.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target&lt;=res[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> target&gt;=res[<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(res)):</span><br><span class="line">            <span class="keyword">if</span> target&gt;res[i<span class="number">-1</span>] <span class="keyword">and</span> target&lt;res[i]:</span><br><span class="line">                a=target-res[i<span class="number">-1</span>]</span><br><span class="line">                b=res[i]-target</span><br><span class="line">                <span class="keyword">if</span> a&gt;b:</span><br><span class="line">                    <span class="keyword">return</span> res[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> res[i<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="有效的括号-easy"><a href="#有效的括号-easy" class="headerlink" title="有效的括号(easy)"></a>有效的括号(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c=[]</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>]==<span class="string">')'</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">']'</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">'&#125;'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> len(c)==<span class="number">0</span>:</span><br><span class="line">                c.append(s[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (c[<span class="number">-1</span>]==<span class="string">'('</span> <span class="keyword">and</span> s[i]==<span class="string">')'</span>) <span class="keyword">or</span> (c[<span class="number">-1</span>]==<span class="string">'['</span> <span class="keyword">and</span> s[i]==<span class="string">']'</span>)  <span class="keyword">or</span> (c[<span class="number">-1</span>]==<span class="string">'&#123;'</span> <span class="keyword">and</span> s[i]==<span class="string">'&#125;'</span>):</span><br><span class="line">                    c.pop(<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c.append(s[i])</span><br><span class="line">        <span class="keyword">if</span> len(c)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="合并两个有序链表-easy"><a href="#合并两个有序链表-easy" class="headerlink" title="合并两个有序链表(easy)"></a>合并两个有序链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=ListNode(<span class="literal">None</span>) <span class="comment">#合并之后的新数组</span></span><br><span class="line">        p=res <span class="comment">#保持头节点不动</span></span><br><span class="line">        <span class="keyword">if</span> l1==<span class="literal">None</span>:  </span><br><span class="line">            res.next=l2</span><br><span class="line">            <span class="keyword">return</span> res.next</span><br><span class="line">        <span class="keyword">if</span> l2==<span class="literal">None</span>:</span><br><span class="line">            res.next=l1</span><br><span class="line">            <span class="keyword">return</span> res.next</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.next=l1</span><br><span class="line">                l1=l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next=l2</span><br><span class="line">                l2=l2.next</span><br><span class="line">            p=p.next</span><br><span class="line">        <span class="keyword">if</span> l1: <span class="comment">#如果l1还没循环结束</span></span><br><span class="line">            p.next=l1</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#如果l2还没循环结束</span></span><br><span class="line">            p.next=l2</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure><h4 id="合并K个升序链表-hard"><a href="#合并K个升序链表-hard" class="headerlink" title="合并K个升序链表(hard)"></a>合并K个升序链表(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#如果lists为空，直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> len(lists)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment">#temp用来存两个单链表合并后的结果</span></span><br><span class="line">        temp=ListNode()</span><br><span class="line">        temp.val=<span class="literal">None</span> <span class="comment">#将初始temp值置空</span></span><br><span class="line">        <span class="comment">#从第一个升序链表开始比较</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            <span class="comment">#保存temp和每一个升序链表比较后的结果</span></span><br><span class="line">            node=ListNode()</span><br><span class="line">            <span class="comment">#如果当前链表为空，直接将node指向temp，并开始比较下一个链表</span></span><br><span class="line">            <span class="keyword">if</span> lists[i]==<span class="literal">None</span>:</span><br><span class="line">                node.next=temp</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#如果temp为空，node指向当前链表并将temp指向node</span></span><br><span class="line">            <span class="keyword">if</span> temp==<span class="literal">None</span>:</span><br><span class="line">                node.next=lists[i]</span><br><span class="line">                temp=node.next</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#两个都不为空，需要一个保存node节点，所以使用head开始向后比较</span></span><br><span class="line">            head=node</span><br><span class="line">            <span class="keyword">while</span> temp !=<span class="literal">None</span> <span class="keyword">and</span> lists[i]!=<span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> temp.val&gt;lists[i].val:</span><br><span class="line">                    head.next=lists[i]</span><br><span class="line">                    head=head.next</span><br><span class="line">                    lists[i]=lists[i].next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    head.next=temp</span><br><span class="line">                    head=head.next</span><br><span class="line">                    temp=temp.next</span><br><span class="line">            <span class="keyword">if</span> temp!=<span class="literal">None</span>:</span><br><span class="line">                head.next=temp</span><br><span class="line">            <span class="keyword">if</span> lists[i]!=<span class="literal">None</span>:</span><br><span class="line">                head.next=lists[i]</span><br><span class="line">            <span class="comment">#两个链表比较完毕后将temp重置，并开始下一轮的比较</span></span><br><span class="line">            temp=node.next</span><br><span class="line">        <span class="comment">#最后返回node节点</span></span><br><span class="line">        <span class="keyword">return</span> node.next.next</span><br></pre></td></tr></table></figure><h4 id="删除有序数组中的重复项-easy"><a href="#删除有序数组中的重复项-easy" class="headerlink" title="删除有序数组中的重复项(easy)"></a>删除有序数组中的重复项(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]!=nums[c]:</span><br><span class="line">                nums[c+<span class="number">1</span>]=nums[i]</span><br><span class="line">                c+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c+<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="搜索旋转排序数组-medium"><a href="#搜索旋转排序数组-medium" class="headerlink" title="搜索旋转排序数组(medium)"></a>搜索旋转排序数组(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> nums.index(target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="字符串相乘-medium"><a href="#字符串相乘-medium" class="headerlink" title="字符串相乘(medium)"></a>字符串相乘(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num1: str</span></span><br><span class="line"><span class="string">        :type num2: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># return str(int(num1)*int(num2))</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(num1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(num2)+<span class="number">1</span>):</span><br><span class="line">                res += int(num1[-i]) * int(num2[-j]) *<span class="number">10</span>**(i+j<span class="number">-2</span>)</span><br><span class="line">        <span class="keyword">return</span> str(res)</span><br></pre></td></tr></table></figure><h4 id="全排列-medium"><a href="#全排列-medium" class="headerlink" title="全排列(medium)"></a>全排列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(path,choice)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path)==len(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> choice:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> path:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(i)</span><br><span class="line">                trace(path,choice)</span><br><span class="line">                path.pop()</span><br><span class="line">        trace([],nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="最大子序和-easy"><a href="#最大子序和-easy" class="headerlink" title="最大子序和(easy)"></a>最大子序和(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            nums[i] = nums[i]+max(nums[i<span class="number">-1</span>],<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br></pre></td></tr></table></figure><h4 id="螺旋矩阵-medium"><a href="#螺旋矩阵-medium" class="headerlink" title="螺旋矩阵(medium)"></a>螺旋矩阵(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> len(matrix)!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> matrix[<span class="number">0</span>]:</span><br><span class="line">                res.append(i)</span><br><span class="line">            matrix.pop(<span class="number">0</span>)</span><br><span class="line">            matrix=list(zip(*matrix))</span><br><span class="line">            matrix.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="螺旋矩阵II-medium"><a href="#螺旋矩阵II-medium" class="headerlink" title="螺旋矩阵II(medium)"></a>螺旋矩阵II(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [[<span class="number">1</span>]]</span><br><span class="line">        res=[[n*n<span class="number">-1</span>],[n*n]]</span><br><span class="line">        i=n*n<span class="number">-2</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res)):</span><br><span class="line">                res[j].insert(<span class="number">0</span>,i)</span><br><span class="line">                i-=<span class="number">1</span></span><br><span class="line">            res=list(map(list,zip(*res)))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> res:</span><br><span class="line">                j.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="旋转链表-medium"><a href="#旋转链表-medium" class="headerlink" title="旋转链表(medium)"></a>旋转链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        node=head</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node!=<span class="literal">None</span>:</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            pre=node</span><br><span class="line">            node=node.next</span><br><span class="line">        s=k%count</span><br><span class="line">        t=count-s</span><br><span class="line">        pre.next=head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(t):</span><br><span class="line">            prenode=head</span><br><span class="line">            head=head.next</span><br><span class="line">        prenode.next=<span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="不同路径-medium"><a href="#不同路径-medium" class="headerlink" title="不同路径(medium)"></a>不同路径(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[[<span class="number">1</span>]*n]*m</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                res[i][j]=res[i][j<span class="number">-1</span>]+res[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="爬楼梯-easy"><a href="#爬楼梯-easy" class="headerlink" title="爬楼梯(easy)"></a>爬楼梯(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-3</span>):</span><br><span class="line">            res.append(res[<span class="number">-1</span>]+res[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="子集-medium"><a href="#子集-medium" class="headerlink" title="子集(medium)"></a>子集(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res+=[j+[i] <span class="keyword">for</span> j <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="合并两个有序数组-easy"><a href="#合并两个有序数组-easy" class="headerlink" title="合并两个有序数组(easy)"></a>合并两个有序数组(easy)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>,j = n - <span class="number">1</span>,k = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt; nums2[j])</span><br><span class="line">            nums1[k--] = nums1[i--];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">        nums1[k--] = nums2[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="格雷编码-medium"><a href="#格雷编码-medium" class="headerlink" title="格雷编码(medium)"></a>格雷编码(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先右移再异或</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>**n):</span><br><span class="line">            res.append(i^i&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="二叉树的最大深度-easy"><a href="#二叉树的最大深度-easy" class="headerlink" title="二叉树的最大深度(easy)"></a>二叉树的最大深度(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机-easy"><a href="#买卖股票的最佳时机-easy" class="headerlink" title="买卖股票的最佳时机(easy)"></a>买卖股票的最佳时机(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># max_num=0</span></span><br><span class="line">        <span class="comment"># if len(prices)==0:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="comment"># for i in range(1,len(prices)):</span></span><br><span class="line">        <span class="comment">#     if prices[i]-min(prices[:i])&gt;max_num:</span></span><br><span class="line">        <span class="comment">#         max_num = prices[i]-min(prices[:i])</span></span><br><span class="line">        <span class="comment"># return max_num</span></span><br><span class="line"></span><br><span class="line">        max_num=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_num=prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            min_num = min(min_num,prices[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> prices[i]-min_num&gt;max_num:</span><br><span class="line">                max_num = prices[i]-min_num</span><br><span class="line">        <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure><h4 id="买卖股票的最佳时机II-easy"><a href="#买卖股票的最佳时机II-easy" class="headerlink" title="买卖股票的最佳时机II(easy)"></a>买卖股票的最佳时机II(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sum=<span class="number">0</span></span><br><span class="line">        res=[]</span><br><span class="line">        temp=[]</span><br><span class="line">        <span class="comment">#这段用来分割连续增加的点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i]&lt;prices[i<span class="number">-1</span>]:</span><br><span class="line">                temp.append(i)</span><br><span class="line">        <span class="keyword">if</span> len(prices) <span class="keyword">not</span> <span class="keyword">in</span> temp:</span><br><span class="line">            temp.append(len(prices))</span><br><span class="line">        temp.insert(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#这段用来将每个连续增加段存入res</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(temp)):</span><br><span class="line">            res.append(prices[temp[i<span class="number">-1</span>]:temp[i]])</span><br><span class="line">        <span class="comment">#计算每个段中最大值和最小值并累加</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">if</span> len(i)&gt;=<span class="number">2</span>:</span><br><span class="line">                sum+=(max(i)-min(i))</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><h4 id="二叉树的最大路径和-hard"><a href="#二叉树的最大路径和-hard" class="headerlink" title="二叉树的最大路径和(hard)"></a>二叉树的最大路径和(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="只出现一次的数字-easy"><a href="#只出现一次的数字-easy" class="headerlink" title="只出现一次的数字(easy)"></a>只出现一次的数字(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            a = a ^ num</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h4 id="环形链表-easy"><a href="#环形链表-easy" class="headerlink" title="环形链表(easy)"></a>环形链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        p=head</span><br><span class="line">        q=head.next</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> q.next==p:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q.next==<span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> q.next.next==<span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                p=p.next</span><br><span class="line">                q=q.next.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="环形链表II-medium"><a href="#环形链表II-medium" class="headerlink" title="环形链表II(medium)"></a>环形链表II(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        node=head</span><br><span class="line">        <span class="keyword">while</span> node!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node.next <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                res.append(node)</span><br><span class="line">                node=node.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> node.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="LRU缓存机制-medium"><a href="#LRU缓存机制-medium" class="headerlink" title="LRU缓存机制(medium)"></a>LRU缓存机制(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.d = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        res = self.d[key]</span><br><span class="line">        self.d.pop(key)</span><br><span class="line">        self.d[key]= res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.d:</span><br><span class="line">            <span class="keyword">if</span> self.capacity &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> self.d.keys():</span><br><span class="line">                    self.d.pop(k)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.capacity-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.d.pop(key)</span><br><span class="line">        self.d[key]=value</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure><h4 id="排序链表-medium"><a href="#排序链表-medium" class="headerlink" title="排序链表(medium)"></a>排序链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># h_head = ListNode(None)</span></span><br><span class="line">        <span class="comment"># print(h_head)</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># while head != None:</span></span><br><span class="line">        <span class="comment">#    res.append(head)</span></span><br><span class="line">        <span class="comment">#    head = head.next</span></span><br><span class="line">        <span class="comment"># print(res) </span></span><br><span class="line">        <span class="comment"># res = sorted(res,key = lambda x:x.val)</span></span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="comment"># n = len(res)</span></span><br><span class="line">        <span class="comment"># h_head.next = res[0]</span></span><br><span class="line">        <span class="comment"># # res[0].next = res[1]</span></span><br><span class="line">        <span class="comment"># return h_head.next</span></span><br><span class="line">        <span class="comment"># for i in range(n-1):</span></span><br><span class="line">        <span class="comment">#     res[i].next = res[i+1]</span></span><br><span class="line">        <span class="comment"># return h_head.next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        h_head = ListNode(<span class="literal">None</span>) <span class="comment">#申请头节点</span></span><br><span class="line">        res = [] <span class="comment">#将节点保存在列表中</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_h = head.next</span><br><span class="line">            head.next = <span class="literal">None</span></span><br><span class="line">            res.append(head)</span><br><span class="line">            head = next_h</span><br><span class="line">            <span class="comment"># head = head.next</span></span><br><span class="line">        res = sorted(res,key = <span class="keyword">lambda</span> x:x.val)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        n = len(res)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        h_head.next = res[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            res[i].next = res[i+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> h_head.next</span><br></pre></td></tr></table></figure><h4 id="最小栈-easy"><a href="#最小栈-easy" class="headerlink" title="最小栈(easy)"></a>最小栈(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.l = [] <span class="comment">#列表操作</span></span><br><span class="line">        self.index = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># self.l.append(x)</span></span><br><span class="line">        <span class="comment"># self.minnum = min(self.l)</span></span><br><span class="line"></span><br><span class="line">        self.l.append(x)</span><br><span class="line">        self.index+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.l.pop()</span><br><span class="line">        <span class="comment"># self.minnum =not self.l or min(self.l)</span></span><br><span class="line">        self.index-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.l[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># return self.l[self.index]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># return self.minnum</span></span><br><span class="line">        <span class="keyword">return</span> min(self.l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure><h4 id="相交链表-easy"><a href="#相交链表-easy" class="headerlink" title="相交链表(easy)"></a>相交链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l1=<span class="number">0</span></span><br><span class="line">        l2=<span class="number">0</span></span><br><span class="line">        node1=headA</span><br><span class="line">        node2=headB</span><br><span class="line">        <span class="keyword">while</span> headA: <span class="comment">#求第一个链表长度</span></span><br><span class="line">            l1+=<span class="number">1</span></span><br><span class="line">            headA=headA.next</span><br><span class="line">        <span class="keyword">while</span> headB: <span class="comment">#求第二个链表长度</span></span><br><span class="line">            l2+=<span class="number">1</span></span><br><span class="line">            headB=headB.next</span><br><span class="line">        s=l1-l2</span><br><span class="line">        <span class="keyword">while</span> s&gt;<span class="number">0</span>: <span class="comment">#对齐两个链表长度</span></span><br><span class="line">            node1=node1.next</span><br><span class="line">            s-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> s&lt;<span class="number">0</span>:</span><br><span class="line">            node2=node2.next</span><br><span class="line">            s+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> node1 <span class="keyword">and</span> node2:</span><br><span class="line">            <span class="keyword">if</span> node1==node2:</span><br><span class="line">                <span class="keyword">return</span> node1</span><br><span class="line">            node1=node1.next</span><br><span class="line">            node2=node2.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># while node1!=node2: #从头开始判断地址是否相同</span></span><br><span class="line">        <span class="comment">#     node1=node1.next</span></span><br><span class="line">        <span class="comment">#     node2=node2.next</span></span><br><span class="line">        <span class="comment"># return node1</span></span><br></pre></td></tr></table></figure><h4 id="多数元素-easy"><a href="#多数元素-easy" class="headerlink" title="多数元素(easy)"></a>多数元素(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = sorted(nums)</span><br><span class="line">        <span class="keyword">return</span> res[(len(nums)//<span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h4 id="反转链表-easy"><a href="#反转链表-easy" class="headerlink" title="反转链表(easy)"></a>反转链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if head:</span></span><br><span class="line">        <span class="comment">#     pre=head</span></span><br><span class="line">        <span class="comment">#     q=head.next</span></span><br><span class="line">        <span class="comment">#     while pre.next:</span></span><br><span class="line">        <span class="comment">#         pre.next=q.next</span></span><br><span class="line">        <span class="comment">#         q.next=head</span></span><br><span class="line">        <span class="comment">#         head=q</span></span><br><span class="line">        <span class="comment">#         q=pre.next</span></span><br><span class="line">        <span class="comment"># return head</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre=head</span><br><span class="line">        q=head.next</span><br><span class="line">        <span class="keyword">while</span> pre.next:</span><br><span class="line">            pre.next=q.next</span><br><span class="line">            q.next=head</span><br><span class="line">            head=q</span><br><span class="line">            q=pre.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="数组中的第K个最大元素-medium"><a href="#数组中的第K个最大元素-medium" class="headerlink" title="数组中的第K个最大元素(medium)"></a>数组中的第K个最大元素(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = sorted(nums,reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> s[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="存在重复元素-easy"><a href="#存在重复元素-easy" class="headerlink" title="存在重复元素(easy)"></a>存在重复元素(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = dict(Counter(nums))</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">            <span class="keyword">if</span> v&gt;=<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中第K小的元素-medium"><a href="#二叉搜索树中第K小的元素-medium" class="headerlink" title="二叉搜索树中第K小的元素(medium)"></a>二叉搜索树中第K小的元素(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pre</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            pre(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            pre(node.right)</span><br><span class="line">        pre(root)</span><br><span class="line">        <span class="keyword">return</span> res[k<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># print(res)</span></span><br></pre></td></tr></table></figure><h4 id="2的幂-easy"><a href="#2的幂-easy" class="headerlink" title="2的幂(easy)"></a>2的幂(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool isPowerOfTwo(int n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>((n&amp;n<span class="number">-1</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的最近公共祖先-easy"><a href="#二叉搜索树的最近公共祖先-easy" class="headerlink" title="二叉搜索树的最近公共祖先(easy)"></a>二叉搜索树的最近公共祖先(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span> <span class="keyword">or</span> root==p <span class="keyword">or</span> root==q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right= self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left!=<span class="literal">None</span> <span class="keyword">and</span> right!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="二叉树的最近公共祖先-medium"><a href="#二叉树的最近公共祖先-medium" class="headerlink" title="二叉树的最近公共祖先(medium)"></a>二叉树的最近公共祖先(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#如果root不存在或者有一个值是根节点，直接返回根节点即可</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span> <span class="keyword">or</span> root==p <span class="keyword">or</span> root==q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment">#递归左右子树查找</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">        <span class="keyword">if</span> left!=<span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> left!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">elif</span> right!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="删除链表中的节点-easy"><a href="#删除链表中的节点-easy" class="headerlink" title="删除链表中的节点(easy)"></a>删除链表中的节点(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node.val=node.next.val</span><br><span class="line">        node.next=node.next.next</span><br></pre></td></tr></table></figure><h4 id="除自身以外数组的乘积-medium"><a href="#除自身以外数组的乘积-medium" class="headerlink" title="除自身以外数组的乘积(medium)"></a>除自身以外数组的乘积(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        res1=[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        res2 = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            res1[i]=nums[i<span class="number">-1</span>]*res1[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            res2[j]=nums[j+<span class="number">1</span>]*res2[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res1)):</span><br><span class="line">            res.append(res1[i]*res2[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for j in range(i):</span></span><br><span class="line">        <span class="comment">#         res[i]*=nums[j]</span></span><br><span class="line">        <span class="comment">#     for k in range(i+1,len(nums)):</span></span><br><span class="line">        <span class="comment">#         res[i]*=nums[k]</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure><h4 id="Nim游戏-easy"><a href="#Nim游戏-easy" class="headerlink" title="Nim游戏(easy)"></a>Nim游戏(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool canWinNim(int n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">4</span>!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转字符串-easy"><a href="#反转字符串-easy" class="headerlink" title="反转字符串(easy)"></a>反转字符串(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void reverseString(char* s, int sSize) &#123;</span><br><span class="line">    int temp;</span><br><span class="line">    int i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sSize/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        temp=s[i];</span><br><span class="line">        s[i]=s[sSize-i<span class="number">-1</span>];</span><br><span class="line">        s[sSize-i<span class="number">-1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转字符串中的单词III-easy"><a href="#反转字符串中的单词III-easy" class="headerlink" title="反转字符串中的单词III(easy)"></a>反转字符串中的单词III(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(i[::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> s.split())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># res = ""</span></span><br><span class="line">        <span class="comment"># s1 = list(s.split(" "))</span></span><br><span class="line">        <span class="comment"># for i in range(len(s1)-1):</span></span><br><span class="line">        <span class="comment">#     res+=s1[i][::-1]</span></span><br><span class="line">        <span class="comment">#     res+=" "</span></span><br><span class="line">        <span class="comment"># res+=s1[-1][::-1]</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;两数相加-medium&quot;&gt;&lt;a href=&quot;#两数相加-medium&quot; class=&quot;headerlink&quot; title=&quot;两数相加(medium)&quot;&gt;&lt;/a&gt;两数相加(medium)&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;t
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="elssm.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第52场双周赛write up</title>
    <link href="elssm.github.io/2021/05/16/Leetcode%E7%AC%AC52%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2021/05/16/Leetcode第52场双周赛write-up/</id>
    <published>2021-05-16T04:41:36.000Z</published>
    <updated>2021-05-16T09:16:06.150Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h4 id="将句子排序"><a href="#将句子排序" class="headerlink" title="将句子排序"></a>将句子排序</h4><p>第一步就是将句子进行分割，分割之后存在列表中，因为分割之后每个单词后面都有对应的数字，而且数字是唯一的，因此可以通过字典对数字进行排序，排序之后根据字典的key遍历即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortSentence</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        s1=<span class="string">""</span></span><br><span class="line">        res = s.split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            d[int(i[<span class="number">-1</span>])] = i[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> d.keys():</span><br><span class="line">            s1+=d[i]</span><br><span class="line">            s1+=<span class="string">" "</span></span><br><span class="line">        <span class="keyword">return</span> s1[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="增长的内存泄露"><a href="#增长的内存泄露" class="headerlink" title="增长的内存泄露"></a>增长的内存泄露</h4><p>首先需要设定一个不断增长的内存数，之后需要思考一下循环退出条件，即当内存数都大于两个内存条的可用内存时就退出。在循环中需要用较大的可用内存条数减去当前的内存数，最后通过一个列表接受三个值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">memLeak</span><span class="params">(self, memory1, memory2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type memory1: int</span></span><br><span class="line"><span class="string">        :type memory2: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=memory1 <span class="keyword">or</span> i&lt;=memory2:</span><br><span class="line">            <span class="keyword">if</span> memory1&gt;=memory2:</span><br><span class="line">                memory1-=i</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                memory2-=i</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        res.append(i)</span><br><span class="line">        res.append(memory1)</span><br><span class="line">        res.append(memory2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="旋转盒子"><a href="#旋转盒子" class="headerlink" title="旋转盒子"></a>旋转盒子</h4><p>此题可以先在旋转之间将字符的改变位置设定好，最后再进行一次顺时针旋转即可。具体是对矩阵的每一行进行单独操作，遍历每一行，如果是石头则累计石头的个数，如果遇到障碍物，则将石头的个数清零，如果遇到空位置，则需要将前面累计的石头一次延续到这个空位置，并将前面累计的第一个石头的位置设为空位置。最后将矩阵进行一次顺时针旋转即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateTheBox</span><span class="params">(self, box)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type box: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> box:</span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(i)):</span><br><span class="line">                <span class="keyword">if</span> i[j]==<span class="string">"#"</span>:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> i[j]==<span class="string">"*"</span>:</span><br><span class="line">                    count=<span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> i[j]==<span class="string">"."</span>:</span><br><span class="line">                    <span class="keyword">if</span> count!=<span class="number">0</span>:</span><br><span class="line">                        i[j-count]=<span class="string">"."</span></span><br><span class="line">                        i[j]=<span class="string">"#"</span></span><br><span class="line">        box[::] = zip(*box[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> box</span><br></pre></td></tr></table></figure></li><li><h4 id="向下取整数对和"><a href="#向下取整数对和" class="headerlink" title="向下取整数对和"></a>向下取整数对和</h4><p>排序后进行二分查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfFlooredPairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        mod = <span class="number">1000000007</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            j=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[i] * j &lt;= nums[n<span class="number">-1</span>]: <span class="comment">#判断是否小于最大值</span></span><br><span class="line">                start = self.binarySearch(nums, nums[i] * j) <span class="comment">#找到大于等于nums[i] * j的下标</span></span><br><span class="line">                ans = (ans + n - start) % mod</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self,nums,x)</span>:</span></span><br><span class="line">        l,r= <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r :</span><br><span class="line">            mid = (l+(r<span class="number">-1</span>))//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= x:</span><br><span class="line">                r=mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l=mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;将句子排序&quot;&gt;&lt;a href=&quot;#将句子排序&quot; class=&quot;headerlink&quot; title=&quot;将句子排序&quot;&gt;&lt;/a&gt;将句子排序&lt;/h4&gt;&lt;p&gt;第一步就是将句子进行分割，分割之后存在列表中，因为分割之后每个单词后面都有对应的数字，而且数字是唯
      
    
    </summary>
    
    
      <category term="算法" scheme="elssm.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CNN检测XSS攻击(Pytorch)</title>
    <link href="elssm.github.io/2021/04/23/CNN%E6%A3%80%E6%B5%8BXSS%E6%94%BB%E5%87%BB-Pytorch/"/>
    <id>elssm.github.io/2021/04/23/CNN检测XSS攻击-Pytorch/</id>
    <published>2021-04-23T05:08:36.000Z</published>
    <updated>2021-04-24T09:33:41.582Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前在Kaggle上看到了一个XSS的数据集，所以想着用pytorch实现一下，代码参考了kaggle上有人用keras实现的。</p><p><a href="https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-attack-detection-using-cnn" target="_blank" rel="noopener">https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-attack-detection-using-cnn</a></p><h3 id="XSS数据集介绍"><a href="#XSS数据集介绍" class="headerlink" title="XSS数据集介绍"></a>XSS数据集介绍</h3><p>数据集地址：<a href="https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-xss-dataset-for-deep-learning" target="_blank" rel="noopener">https://www.kaggle.com/syedsaqlainhussain/cross-site-scripting-xss-dataset-for-deep-learning</a></p><p>数据是csv形式的，一共有三列，第一列是序号，第二列是具体的代码，第三列是标签。一共有13686条数据，没有分训练集和测试集，因此后面我们需要分一下。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先我们应该对数据进行编码。转换成向量的形式，对于训练集和测试集每一行数据，我们都有编码和标签两种数据，之后通过模型进行训练，训练结果与标签进行比对，计算损失，最后通过测试集进行验证。</p><h4 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h4><p>其中cv2是一个进行图像处理的库，sklearn是基于python的机器学习攻击。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br></pre></td></tr></table></figure><h4 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">50</span></span><br><span class="line">epochs = <span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h4><p>将XSS数据集下载之后，放在和代码同级的目录下。通过pandas模块可以实现对csv文件的读取等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">"XSS_dataset.csv"</span>,encoding=<span class="string">"utf-8-sig"</span>)</span><br><span class="line">sentences = df[<span class="string">'Sentence'</span>].values</span><br></pre></td></tr></table></figure><h4 id="定义编码函数"><a href="#定义编码函数" class="headerlink" title="定义编码函数"></a>定义编码函数</h4><p>对于一些编码后比较大的字符，可以为他们分配一个比较小的值，方便后续进行正则化。将每一条数据都通过一个长度为10000的向量进行存储。之后<code>reshape</code>成一个二维向量，大小是100*100</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_ascii</span><span class="params">(sentence)</span>:</span></span><br><span class="line">    sentence_ascii = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sentence:</span><br><span class="line">        <span class="keyword">if</span> (ord(i) &lt; <span class="number">8222</span>):  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8217</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">134</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8221</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">129</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8220</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">130</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8216</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">131</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8217</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">132</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) == <span class="number">8211</span>):  </span><br><span class="line">                sentence_ascii.append(<span class="number">133</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ord(i) &lt;= <span class="number">128</span>):</span><br><span class="line">                sentence_ascii.append(ord(i))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    zer = np.zeros((<span class="number">10000</span>)) <span class="comment">#初始化一个长度为10000的向量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sentence_ascii)):</span><br><span class="line">        zer[i] = sentence_ascii[i]</span><br><span class="line">    zer.shape = (<span class="number">100</span>, <span class="number">100</span>) <span class="comment">#将一维转为二维</span></span><br><span class="line">    <span class="keyword">return</span> zer</span><br></pre></td></tr></table></figure><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>首先定一个数组，大小是数据集的长度，类型是一个二维向量，大小是100*100，之后对csv中每一条数据都进行编码转换，并将二维向量中的数据都转为float类型表示。之后得到的data就是对数据集编码后的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = np.zeros((len(sentences), <span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(sentences)):</span><br><span class="line">    image = convert_to_ascii(sentences[i])</span><br><span class="line"></span><br><span class="line">    x = np.asarray(image, dtype=<span class="string">'float'</span>) <span class="comment">#将二维里的数据类型转为float型</span></span><br><span class="line">    image = cv2.resize(x, dsize=(<span class="number">100</span>, <span class="number">100</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">    image /= <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    arr[i] = image</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reshape data for input to CNN</span></span><br><span class="line">data = arr.reshape(arr.shape[<span class="number">0</span>],<span class="number">1</span>,<span class="number">100</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="获取标签"><a href="#获取标签" class="headerlink" title="获取标签"></a>获取标签</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=df[<span class="string">'Label'</span>].values</span><br></pre></td></tr></table></figure><h4 id="划分数据集"><a href="#划分数据集" class="headerlink" title="划分数据集"></a>划分数据集</h4><p>采用<code>train_test_split</code>函数随机划分数据。其中<code>test_size</code>是指测试数据占样本数据的比例，这里取样本总数的20%作为测试数据，<code>random_state</code>是一个随机数种子。之后通过<code>DataLoader</code>函数设定训练批次大小和<code>shuffle</code>操作，这里需要注意的是，因为我们data和y中的数据都是<code>ndarray</code>类型的，因此我们还需要对他们进行类型转换，转为<code>tensor</code>类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trainX, testX, trainY, testY = train_test_split(data,y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line">trainX = torch.from_numpy(trainX)</span><br><span class="line">trainX = DataLoader(trainX,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line">testX = torch.from_numpy(testX)</span><br><span class="line">testX = DataLoader(testX,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line">trainY = torch.from_numpy(trainY)</span><br><span class="line">trainY = DataLoader(trainY,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br><span class="line">testY = torch.from_numpy(testY)</span><br><span class="line">testY = DataLoader(testY,batch_size=batch_size,shuffle=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN_XSS_Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(CNN_XSS_Net, self).__init__()</span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">64</span>,<span class="number">3</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">3</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>,<span class="number">3</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Relu(),</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">123904</span>,<span class="number">256</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">256</span>,<span class="number">128</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.fc4 = nn.Linear(<span class="number">64</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = torch.tensor(x, dtype=torch.float32)</span><br><span class="line">        cnn_res = self.cnn(x)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #128*256*22*22</span></span><br><span class="line">        cnn_res = cnn_res.view(cnn_res.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #128*123904</span></span><br><span class="line">        f1 = self.fc1(cnn_res)</span><br><span class="line">        f2 = self.fc2(f1)</span><br><span class="line">        f3 = self.fc3(f2)</span><br><span class="line">        f4 = self.fc4(f3)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f4</span><br></pre></td></tr></table></figure><h4 id="实例化模型"><a href="#实例化模型" class="headerlink" title="实例化模型"></a>实例化模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = CNN_XSS_Net()</span><br><span class="line">optimizer = optim.Adam(model.parameters(),<span class="number">0.001</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure><h4 id="定义训练函数"><a href="#定义训练函数" class="headerlink" title="定义训练函数"></a>定义训练函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(model,trainX,trainY,optimizer,epochs)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> zip(trainX,trainY):</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = criterion(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epochs, loss.item()))</span><br></pre></td></tr></table></figure><h4 id="定义测试函数"><a href="#定义测试函数" class="headerlink" title="定义测试函数"></a>定义测试函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,testX,testY)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> zip(testX,testY):</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(testX.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(testX.dataset)))</span><br></pre></td></tr></table></figure><h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    train(model,trainX,trainY,optimizer,epoch)</span><br><span class="line">    test_model(model,testX,testY)</span><br></pre></td></tr></table></figure><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p><img src="/2021/04/23/CNN检测XSS攻击-Pytorch/1.png" alt="1"></p><p><img src="/2021/04/23/CNN检测XSS攻击-Pytorch/2.png" alt="2"></p><p><img src="/2021/04/23/CNN检测XSS攻击-Pytorch/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;之前在Kaggle上看到了一个XSS的数据集，所以想着用pytorch实现一下，代码参考了kaggle上有人用keras实现的。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>自编码器生成MNIST(Pytorch)</title>
    <link href="elssm.github.io/2021/04/19/%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8%E7%94%9F%E6%88%90MNIST-Pytorch/"/>
    <id>elssm.github.io/2021/04/19/自编码器生成MNIST-Pytorch/</id>
    <published>2021-04-19T11:32:18.000Z</published>
    <updated>2021-04-19T12:37:47.975Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自编码器介绍"><a href="#自编码器介绍" class="headerlink" title="自编码器介绍"></a>自编码器介绍</h4><p>自编码器主要是由编码器(Encoder)和解码器(Decoder)组成，它是一个试图去还原原始输入的一个系统。在深度学习中，自编码器是一种无监督的神经网络模型。它可以学习到输入数据的隐含特征，同时通过学习到的特征可以重构出原始数据。它类似于PCA，可以起到特征提取器的功能。</p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/1.png" alt="1"></p><h4 id="自编码器生成MNIST"><a href="#自编码器生成MNIST" class="headerlink" title="自编码器生成MNIST"></a>自编码器生成MNIST</h4><h5 id="导入相关模块"><a href="#导入相关模块" class="headerlink" title="导入相关模块"></a>导入相关模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> data</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br></pre></td></tr></table></figure><h5 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">epochs = <span class="number">10</span></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">device = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h5 id="建立文件夹保存数据"><a href="#建立文件夹保存数据" class="headerlink" title="建立文件夹保存数据"></a>建立文件夹保存数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"ae_img"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"ae_img"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"test_ae_img"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"test_ae_img"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"params"</span>):</span><br><span class="line">    os.mkdir(<span class="string">"params"</span>)</span><br></pre></td></tr></table></figure><h5 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydataset = MNIST(root=<span class="string">"./mnist_data/"</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">dataloader = data.DataLoader(dataset=mydataset,shuffle=<span class="literal">True</span>,batch_size=batch_size)</span><br><span class="line">test_data = MNIST(root=<span class="string">"./mnist_data/"</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transforms)</span><br><span class="line">test_loader = data.DataLoader(dataset=test_data, shuffle=<span class="literal">True</span>, batch_size=batch_size)</span><br></pre></td></tr></table></figure><h5 id="定义编码器网络"><a href="#定义编码器网络" class="headerlink" title="定义编码器网络"></a>定义编码器网络</h5><p>在这里编码器网络采用两个卷积层和一个全连接层。并进行了归一化处理，激活函数使用<code>ReLU</code>激活函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(EncoderNet,self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">3</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">        )<span class="comment">#N,3,14,14</span></span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">6</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">        )<span class="comment">#N,6,7,7</span></span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">6</span>*<span class="number">7</span>*<span class="number">7</span>,<span class="number">128</span>),</span><br><span class="line">        )<span class="comment">#N,128</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        y1 = self.conv1(x)</span><br><span class="line">        y2 = self.conv2(y1)</span><br><span class="line">        <span class="comment"># print("encoder_y2",y2.shape) #[100, 6, 7, 7]</span></span><br><span class="line">        y2 = torch.reshape(y2,[y2.size(<span class="number">0</span>),<span class="number">-1</span>]) <span class="comment">#要经过全连接层，将4维转为2维,[100,294]</span></span><br><span class="line">        out = self.fc(y2)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h5 id="定义解码器网络"><a href="#定义解码器网络" class="headerlink" title="定义解码器网络"></a>定义解码器网络</h5><p>解码器网络和编码器网络相反，拿到编码器的输出，通过一个全连接层放大维度，之后是通过两个逆卷积层扩大图像的尺寸，扩大到<code>28*28</code>和MNIST原始数据集尺寸大小相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoderNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(DecoderNet,self).__init__()</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">128</span>,<span class="number">6</span>*<span class="number">7</span>*<span class="number">7</span>),</span><br><span class="line">            nn.BatchNorm1d(<span class="number">6</span>*<span class="number">7</span>*<span class="number">7</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )<span class="comment">#7,7</span></span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">6</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,output_padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">3</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )<span class="comment">#14,14</span></span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,output_padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )<span class="comment">#28,28</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        y1 = self.fc(x) <span class="comment">#[100,294]</span></span><br><span class="line">        <span class="comment"># print("decoder_y1", y1.shape)</span></span><br><span class="line">        y1 = torch.reshape(y1,[y1.size(<span class="number">0</span>),<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>]) <span class="comment">#全连接之后，从二维转为四维</span></span><br><span class="line">        y2 = self.conv1(y1)</span><br><span class="line">        out = self.conv2(y2)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h5 id="定义自编码器网络"><a href="#定义自编码器网络" class="headerlink" title="定义自编码器网络"></a>定义自编码器网络</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.encoder = EncoderNet()</span><br><span class="line">        self.decoder = DecoderNet()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        encoder_out = self.encoder(x)</span><br><span class="line">        decoder_out = self.decoder(encoder_out)</span><br><span class="line">        <span class="keyword">return</span> decoder_out</span><br></pre></td></tr></table></figure><h5 id="实例化模型"><a href="#实例化模型" class="headerlink" title="实例化模型"></a>实例化模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = Net()</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure><h5 id="定义优化器和损失函数"><a href="#定义优化器和损失函数" class="headerlink" title="定义优化器和损失函数"></a>定义优化器和损失函数</h5><p>损失函数我们这里使用的是均方损失函数，因为这里我们衡量的是真实图片和自编码器生成的图片的损失，采用均方差计算损失会好一些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = optim.Adam(model.parameters(),<span class="number">0.001</span>)</span><br><span class="line">criterion = nn.MSELoss()</span><br></pre></td></tr></table></figure><h5 id="定义训练函数"><a href="#定义训练函数" class="headerlink" title="定义训练函数"></a>定义训练函数</h5><p>在每一轮训练中加载训练数据集，并计算真实数据和生成数据的损失，之后进行梯度优化。并将真实图片和生成的图片保存在文件夹中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,num_epochs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> i, (data, label) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">            img = data.to(device)</span><br><span class="line">            out_img = model(img)</span><br><span class="line">            loss = criterion(out_img, img)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"epoch:&#123;&#125;,iteration:&#123;&#125;/&#123;&#125;,loss:&#123;:.3f&#125;"</span>.format(epoch, i, len(dataloader), loss.float()))</span><br><span class="line">            fake_image = out_img.cpu().data</span><br><span class="line">            real_image = img.cpu().data</span><br><span class="line">            save_image(fake_image, <span class="string">"./ae_img/epoch-&#123;&#125;-fake_img.jpg"</span>.format(epoch), nrow=<span class="number">10</span>)</span><br><span class="line">            save_image(real_image, <span class="string">"./ae_img/epoch-&#123;&#125;-real_img.jpg"</span>.format(epoch), nrow=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h5 id="保存训练模型"><a href="#保存训练模型" class="headerlink" title="保存训练模型"></a>保存训练模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">"./params/model.pth"</span>)</span><br></pre></td></tr></table></figure><h5 id="定义测试函数"><a href="#定义测试函数" class="headerlink" title="定义测试函数"></a>定义测试函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader,num_epochs)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> i, (img, label) <span class="keyword">in</span> enumerate(test_loader):</span><br><span class="line">            img = img.to(device)</span><br><span class="line">            out_img = model(img)</span><br><span class="line">            loss = criterion(out_img, img)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"epoch:&#123;&#125;,loss:&#123;:.3f&#125;"</span>.format(epoch, loss.float()))</span><br><span class="line">            fake_image = out_img.cpu().data</span><br><span class="line">            real_image = img.cpu().data</span><br><span class="line">            save_image(fake_image, <span class="string">"./test_ae_img/epoch-&#123;&#125;-fake_img.jpg"</span>.format(epoch), nrow=<span class="number">10</span>)</span><br><span class="line">            save_image(real_image, <span class="string">"./test_ae_img/epoch-&#123;&#125;-real_img.jpg"</span>.format(epoch), nrow=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h5 id="模型测试"><a href="#模型测试" class="headerlink" title="模型测试"></a>模型测试</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    train_model(model,dataloader,optimizer,epochs)</span><br><span class="line">    test_model(model,test_loader,epochs)</span><br></pre></td></tr></table></figure><h5 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h5><p>训练数据</p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/2.png" alt="2"></p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/3.png" alt="3"></p><p>测试数据</p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/4.png" alt="4"></p><p><img src="/2021/04/19/自编码器生成MNIST-Pytorch/5.png" alt="5"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;自编码器介绍&quot;&gt;&lt;a href=&quot;#自编码器介绍&quot; class=&quot;headerlink&quot; title=&quot;自编码器介绍&quot;&gt;&lt;/a&gt;自编码器介绍&lt;/h4&gt;&lt;p&gt;自编码器主要是由编码器(Encoder)和解码器(Decoder)组成，它是一个试图去还原原始输入的一个系统
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SVHN数据集识别(Pytorch)</title>
    <link href="elssm.github.io/2021/04/09/SVHN%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB-Pytorch/"/>
    <id>elssm.github.io/2021/04/09/SVHN数据集识别-Pytorch/</id>
    <published>2021-04-09T09:42:03.000Z</published>
    <updated>2021-04-19T14:25:03.598Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SVHN数据集介绍"><a href="#SVHN数据集介绍" class="headerlink" title="SVHN数据集介绍"></a>SVHN数据集介绍</h4><p>SVHN数据集是摘自Google街景图像中的门牌号，其风格与MNIST相似。其中包含了10个类别，数字1～9对应标签1～9，而“0”的标签则为10。其中训练集有73257张图像，测试集有26032张图像。</p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/1.png" alt="1"></p><h4 id="Pytorch识别SVHN数据集"><a href="#Pytorch识别SVHN数据集" class="headerlink" title="Pytorch识别SVHN数据集"></a>Pytorch识别SVHN数据集</h4><h5 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br></pre></td></tr></table></figure><h5 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h5><p>其中<code>Resize</code>是对图像大小重新设定，<code>ColorJitter</code>可以改变图像的属性，例如亮度、对比度、饱和度和色调，<code>RandomRotation</code>可以使得图像在设定的角度范围内随机旋转。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">epochs = <span class="number">5</span></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">128</span>,<span class="number">128</span>)), </span><br><span class="line">    transforms.ColorJitter(<span class="number">0.3</span>,<span class="number">0.3</span>,<span class="number">0.2</span>),</span><br><span class="line">    transforms.RandomRotation(<span class="number">5</span>), </span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize([<span class="number">0.485</span>,<span class="number">0.465</span>,<span class="number">0.406</span>],[<span class="number">0.229</span>,<span class="number">0.224</span>,<span class="number">0.225</span>])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h5 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_set = datasets.SVHN(<span class="string">"data_svhn"</span>,<span class="string">"train"</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">test_set = datasets.SVHN(<span class="string">"data_svhn"</span>,<span class="string">"test"</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h5 id="网络定义"><a href="#网络定义" class="headerlink" title="网络定义"></a>网络定义</h5><p> 卷就完事了！4这里我采用了3个卷积层，激活函数使用的是Relu，还加入了池化操作，用了一个全连接层。在进行<code>nn.Linear</code>操作之前要使用<code>view</code>将四维拉成二维，因为全连接层的输入与输出都是二维张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVHN_Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SVHN_Net,self).__init__()</span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">64</span>,<span class="number">3</span>,<span class="number">2</span>), <span class="comment">#64*63*63</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#64*31*31</span></span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">64</span>,<span class="number">3</span>), <span class="comment">#64 * 29 * 29</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#64*14*14</span></span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">32</span>,<span class="number">2</span>), <span class="comment">#32 * 13 * 13</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>) <span class="comment">#32 * 6 * 6</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">32</span>*<span class="number">6</span>*<span class="number">6</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        cnn_res = self.cnn(x)</span><br><span class="line">        cnn_res = cnn_res.view(cnn_res.size(<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        f1 = self.fc1(cnn_res)</span><br><span class="line">        <span class="keyword">return</span> f1</span><br></pre></td></tr></table></figure><h5 id="实例化模型和优化器"><a href="#实例化模型和优化器" class="headerlink" title="实例化模型和优化器"></a>实例化模型和优化器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = SVHN_Net()</span><br><span class="line">optimizer = optim.Adam(model.parameters(),<span class="number">0.001</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure><h5 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,epoch)</span>:</span></span><br><span class="line">    <span class="comment">#模型训练</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_index,(data,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = criterion(output,target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_index % <span class="number">200</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epoch,loss.item()))</span><br></pre></td></tr></table></figure><h5 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> test_loader:</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(test_loader.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(test_loader.dataset)))</span><br></pre></td></tr></table></figure><h5 id="调用训练和测试模型"><a href="#调用训练和测试模型" class="headerlink" title="调用训练和测试模型"></a>调用训练和测试模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs+<span class="number">1</span>):</span><br><span class="line">    train_model(model,train_loader,optimizer,epoch)</span><br><span class="line">    test_model(model,test_loader)</span><br></pre></td></tr></table></figure><h5 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h5><p>….好家伙这也太低了</p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/2.png" alt="2"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/3.png" alt="3"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/4.png" alt="4"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/5.png" alt="5"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/6.png" alt="6"></p><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/7.png" alt="7"></p><h4 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVHN_Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SVHN_Net,self).__init__()</span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">16</span>,<span class="number">3</span>,<span class="number">2</span>), <span class="comment">#64*63*63</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#64*31*31</span></span><br><span class="line">            nn.Conv2d(<span class="number">16</span>,<span class="number">32</span>,<span class="number">3</span>), <span class="comment">#64 * 29 * 29</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#64*14*14</span></span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">2</span>), <span class="comment">#64 * 13 * 13</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">2</span>), <span class="comment">#128 * 12 * 12</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#128 * 6 * 6</span></span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">128</span>,<span class="number">3</span>), <span class="comment">#128 *4 *4</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#128 *2 *2</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">128</span> *<span class="number">2</span> *<span class="number">2</span>,<span class="number">128</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">128</span>,<span class="number">11</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        cnn_res = self.cnn(x)</span><br><span class="line">        cnn_res = cnn_res.view(cnn_res.size(<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        f1 = self.fc1(cnn_res)</span><br><span class="line">        f1 = self.fc2(f1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f1</span><br></pre></td></tr></table></figure><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/8.png" alt="8"></p><h4 id="再次优化"><a href="#再次优化" class="headerlink" title="再次优化"></a>再次优化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#准确率达93.4%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">epochs = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ColorJitter(<span class="number">0.3</span>,<span class="number">0.3</span>,<span class="number">0.2</span>),</span><br><span class="line">    transforms.RandomRotation(<span class="number">5</span>),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize([<span class="number">0.485</span>,<span class="number">0.465</span>,<span class="number">0.406</span>],[<span class="number">0.229</span>,<span class="number">0.224</span>,<span class="number">0.225</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = datasets.SVHN(<span class="string">"data_svhn"</span>,<span class="string">"train"</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">test_set = datasets.SVHN(<span class="string">"data_svhn"</span>,<span class="string">"test"</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"下载完成"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SVHN_Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SVHN_Net,self).__init__()</span><br><span class="line">        self.cnn = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">32</span>,<span class="number">3</span>), <span class="comment">#32*30*30</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>), <span class="comment">#32 * 28 * 28</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#32*14*14</span></span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">3</span>), <span class="comment">#64 * 12 * 12</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>,<span class="number">128</span>,<span class="number">3</span>), <span class="comment">#128 * 10 * 10</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#128*5*5</span></span><br><span class="line">            nn.Dropout(<span class="number">0.3</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>,<span class="number">128</span>,<span class="number">3</span>), <span class="comment">#128 *3 *3</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>), <span class="comment">#128 *1 *1</span></span><br><span class="line">            nn.Dropout(<span class="number">0.4</span>),</span><br><span class="line">            <span class="comment"># nn.Conv2d(128,64,2), #64 *1 *1</span></span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">128</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="comment"># print(x.shape)</span></span><br><span class="line">        cnn_res = self.cnn(x)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #32 * 128 *1 *1</span></span><br><span class="line">        cnn_res = cnn_res.view(cnn_res.size(<span class="number">0</span>),<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># print(cnn_res.shape) #16*96</span></span><br><span class="line">        f1 = self.fc1(cnn_res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f1</span><br><span class="line"></span><br><span class="line">model = SVHN_Net()</span><br><span class="line">model = model.to(device)</span><br><span class="line">optimizer = optim.Adam(model.parameters(),<span class="number">0.0001</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,epoch)</span>:</span></span><br><span class="line">    <span class="comment">#模型训练</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_index,(data,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        data,target = data.to(device),target.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = criterion(output,target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_index % <span class="number">400</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epoch,loss.item()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader)</span>:</span></span><br><span class="line">    model.eval()</span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> test_loader:</span><br><span class="line">            data,target = data.to(device),target.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(test_loader.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(test_loader.dataset)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs+<span class="number">1</span>):</span><br><span class="line">    train_model(model,train_loader,optimizer,epoch)</span><br><span class="line">    test_model(model,test_loader)</span><br></pre></td></tr></table></figure><p><img src="/2021/04/09/SVHN数据集识别-Pytorch/9.png" alt="9"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;SVHN数据集介绍&quot;&gt;&lt;a href=&quot;#SVHN数据集介绍&quot; class=&quot;headerlink&quot; title=&quot;SVHN数据集介绍&quot;&gt;&lt;/a&gt;SVHN数据集介绍&lt;/h4&gt;&lt;p&gt;SVHN数据集是摘自Google街景图像中的门牌号，其风格与MNIST相似。其中包含
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>区块链笔记</title>
    <link href="elssm.github.io/2021/04/02/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2021/04/02/区块链笔记/</id>
    <published>2021-04-02T12:43:39.000Z</published>
    <updated>2021-04-16T04:12:58.668Z</updated>
    
    <content type="html"><![CDATA[<h4 id="区块链产生"><a href="#区块链产生" class="headerlink" title="区块链产生"></a>区块链产生</h4><ul><li>密码朋克：通过匿名性来保护隐私安全</li><li>不可篡改文件记录：加时间戳到文件内容中，证实数据真实存在</li><li>数字现金</li></ul><h4 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h4><ul><li>2009年，比特币诞生1.0</li><li>2014年，以太坊诞生2.0</li><li>2018年中期，EOS主网上线3.0</li><li>Fabric</li></ul><h4 id="区块链场景概念"><a href="#区块链场景概念" class="headerlink" title="区块链场景概念"></a>区块链场景概念</h4><ul><li>数字货币：可以与现金流进行等价交换，拥有现有现金流的属性和功能</li><li>ICO：众筹</li><li>电子钱包：在电商购物中的支付工具</li></ul><h4 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h4><ul><li>区块链是一种集成了点对点传输协议，现代密码学，共识算法，分布数据存储的新型应用模型</li></ul><h4 id="区块链特点"><a href="#区块链特点" class="headerlink" title="区块链特点"></a>区块链特点</h4><ul><li>可追溯</li><li>不可篡改</li><li>去中心化</li><li>完整备份</li><li>历史记录</li><li>交易广播</li></ul><h4 id="区块链加密货币特点"><a href="#区块链加密货币特点" class="headerlink" title="区块链加密货币特点"></a>区块链加密货币特点</h4><ul><li>独立性：所有货币都是独立存在的</li><li>唯一性：地址、交易都具有不重复的唯一性</li><li>匿名性：账户信息和个人信息没有关联，整个交易过程全程加密</li><li>不可伪造</li></ul><h4 id="区块链核心技术"><a href="#区块链核心技术" class="headerlink" title="区块链核心技术"></a>区块链核心技术</h4><ul><li>点对点传输协议：在网络中的数据流通方式</li><li>现代密码学：在区块链中的应用：公私钥签名，哈希算法</li><li>共识算法：数据一致性</li><li>分布式数据存储：实现去中心化的重要技术依据</li></ul><h4 id="区块链核心概念"><a href="#区块链核心概念" class="headerlink" title="区块链核心概念"></a>区块链核心概念</h4><ul><li><p>区块链</p><ul><li>本质：一个分布式账本，通过共识算法来决定谁能抢到当前的记账权。区块链以区块为单位，以区块产生的时间顺序去进行连接。</li></ul></li><li><p>区块</p><ul><li>概念：区块链的基本组成单位</li><li>区块头<ul><li>时间戳</li><li>当前区块哈希</li><li>父区块哈希</li><li>随机数</li><li>Merkle树</li><li>区块号码</li></ul></li><li>区块体：交易数据</li></ul></li><li><p>分布式数据库：区块链中的区块数据都会存储在每一个节点中，所有的节点组成一个分布式数据库。</p></li><li><p>节点</p><ul><li>可以理解称为一个运行区块软件的计算机</li><li>分类<ul><li>全节点：保存了完整的区块链的副本，安全性极高，效率不高</li><li>轻节点：不保存所有的区块，需要依赖全节点进行验证，效率更高，安全不如全节点</li><li>挖矿节点：带有挖矿功能的全节点，专门处理交易验证</li></ul></li></ul></li><li><p>挖矿</p><ul><li>对交易进行验证处理(记账)，区块就是通过挖矿产生的</li><li>穷举随机数算法，生成哈希，与目标哈希进行比较，成功则说明挖矿成功</li></ul></li><li><p>分叉</p><ul><li><p>升级分叉</p><p>矿工遵从不同的机制(规则)导致分叉</p><p>硬分叉：如果区块链共识规则改变之后，不允许前向兼容，旧节点没有办法认可新节点产生的区块</p><p>软分叉：如果区块链共识规则改变之后，允许前向兼容，旧节点可以兼容新节点产生的区块</p></li><li><p>挖矿分叉</p><p>现象：两个或者多个矿工，同时完成了工作量证明，就会产生两个新的区块，形成分叉</p><p>解决方案：不同矿工跟随了不同的区块，但是不同链算力会有区别，矿工的数量一样，链的增长速度就不会相同，最终会出现一条链更长，这条就会变成主链。</p></li></ul></li><li><p>交易</p><ul><li>概念：一笔资产在参与者之间的转移</li><li>内容<ul><li>金额</li><li>发送者</li><li>接受者</li><li>交易ID(HASH)</li></ul></li></ul></li><li><p>双花</p><ul><li><p>概念：复用数字货币的数字特性，可以完成两次或者多次支付</p></li><li><p>传统的虚拟货币之所以可以避免双花是因为有可依赖的第三方机构提供保证</p></li><li><p>区块链中需要达成只通过分布式节点之间的相互校验与共识来避免双花，同时完成价值转移</p></li></ul></li><li><p>UTXO(unspent transaction output)交易模式</p><ul><li>是比特币独有的交易模式，比特币交易过程中的基本单位，主要就是为了避免双花</li></ul></li><li><p>哈希</p><ul><li>将任意的原始数据(交易记录)通过指定哈希函数，编码为特定长度的字符串</li><li>在区块链中的使用：生成地址，交易验证</li><li>特点<ul><li>不可逆</li><li>随机性</li><li>时间正相关：输入的源数据越长，哈希的处理时间就越长</li></ul></li></ul></li><li><p>加密算法</p><ul><li>对称加密：加密与解密都是用相同的密钥</li><li>非对称加密<ul><li>采用公钥和私钥进行加密</li><li>无法用公钥反推私钥</li></ul></li></ul></li><li><p>数字签名</p></li><li><p>Merkle树</p><ul><li>Merkle树可以是二叉树，也可以是多叉树，它具有树的所有特点</li><li>在区块链中的作用：快速校验、归纳交易完整性</li><li>在区块链中，Merkle树可以极大的提高查询效率，区块头只需要保存一个Merkle根的hash</li><li>Merkle支持SPV</li></ul></li><li><p>P2P</p><ul><li>通过对等网络来分配工作任务的分布式应用架构</li><li>由于在P2P中，所有网络节点的地位是对等的，不存在任何一个中心化节点，也不存在所谓的层级结构，所以每个节点都需要承担验证区块数据等功能</li></ul></li></ul><h4 id="区块链的分类"><a href="#区块链的分类" class="headerlink" title="区块链的分类"></a>区块链的分类</h4><ul><li>公有链：真正意义上的去中心化分布式区块链，任何一个节点都可以随时加入/退出网络中</li><li>私有链：部分中心化的区块链，具有一定的分布式特点，但是有一个中心节点，可以指定参与者</li><li>联盟链：部分去中心化的区块链，拥有权限控制的功能<ul><li>代表：Fabric</li></ul></li></ul><h4 id="区块链架构特点"><a href="#区块链架构特点" class="headerlink" title="区块链架构特点"></a>区块链架构特点</h4><ul><li>去中心化：基于分布式系统，整个网络总没有中心机构存在</li><li>可靠数据库：分布式存储，参与系统的节点越多，数据库的安全性就越高</li><li>开源可编程：区块链提供了灵活的脚本系统甚至于完善的开发平台，支持用户创建更加高级的应用</li><li>集体维护：区块链中的数据由整个系统中所有具有记账功能的节点进行维护</li><li>安全可信：通过现代密码学实现</li><li>准匿名性：采用与身份信息无关的hash作为身份地址与交易ID</li></ul><h4 id="应用分析"><a href="#应用分析" class="headerlink" title="应用分析"></a>应用分析</h4><ul><li><p>比特币</p><p>架构</p><ul><li><p>前端</p><p>钱包：保存用户私钥，管理用户余额，提供比特币交易</p><p>钱包分类</p><ul><li><p>决定性钱包：所有的私钥都由一个私钥种子通过单向哈希算法生成</p><p>普通决定性钱包：由私钥种子一次性生成所有私钥</p><p>层级决定性钱包：由私钥种子生成父私钥，父私钥生成种子私钥</p></li><li><p>非决定性钱包：直接保存私钥，私钥直接放在DB</p></li></ul><p>展示方式的分类</p><p>​    桌面钱包</p><p>​        1.厚钱包：下载整条区块链，可以完整交易，安全性高，验证成本高</p><p>​        2.薄钱包：不会下载整条区块链，采用部分存储+节点请求验证的方式</p><p>​        3.离线钱包：USB设备，纸钱包，可以有效防范网络攻击</p><p>​    HTTP/JSON RPC API</p><p>​        1.比特币提供的接口，可以使外部通过该接口访问或者控制比特币</p><p>​    命令行接口</p><p>​        1.通过命令行的方式实现类似钱包的功能</p><p>​    浏览器</p><p>​        1.访问区块链的区块数据等信息</p><p>​    节点后台：负责参与比特币网络的通信，区块链的维护，验证，交易</p><p>​    比特币地址</p><p>​        1.基本概念：由哈希生成</p><p>​        2.生成过程：</p><p>​            1.随机数生成私钥</p><p>​            2.采用Secp256k1椭圆加密算法生成公钥</p><p>​        3.生成地址</p><p>​            1.以公钥作为输入，进行SHA256，再进行RIPEMD160，最后通过base58编码生成比特币地址</p><p>​    比特币区块校验：确保确实完成了工作量证明 </p><p>​            1.校验内容：格式、难度、时间戳、大小、交易</p><p>​    比特币交易</p><p>​        1.交易结构</p><p>​            1.输入(input)</p><p>​            2.输出(output)</p><p>​            3.交易ID(HASH)</p><p>​        2.说明</p><p>​            1.每一笔交易的输入来自于前面交易的输出</p><p>​        3.UTXO数据库：专门用来存储当前比特币中未被花费的输出</p></li></ul></li></ul><h4 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h4><ul><li>一个用于开发去中心化DAPP的分布式平台</li><li>智能合约：一个拥有自我校验与自我执行的协议</li><li>以太坊提供了非常方便的应用开发平台，对底层做了完善的封装，让开发者只需要关注与上层应用</li><li>共识：POW(ETHASH)</li></ul><h4 id="EOS"><a href="#EOS" class="headerlink" title="EOS"></a>EOS</h4><ul><li><p>一个用于开发去中心化DAPP的分布式平台</p></li><li><p>TPS有了极大的提高，能够达到百万级的TPS处理量</p></li><li><p>以太坊本身是一条公链，其中每个DAPP会消耗整条链上的资源</p></li><li><p>EOS本身不再是一条单纯的公链，它是一个区块链的基础架构，开发者可以自由再EOS上创建公链，链与</p><p>链之间不会影响彼此的资源使用，因此，不会出现单个应用占用的资源太多使得整个网络拥堵</p></li><li><p>共识算法：DPOS</p></li><li><p>EOS上的智能合约调用不需要手续费</p></li></ul><h4 id="Fabric-联盟链"><a href="#Fabric-联盟链" class="headerlink" title="Fabric(联盟链)"></a>Fabric(联盟链)</h4><ul><li>联盟链代表，与公链最大的区别在于不发行虚拟货币。</li><li>目标：实现一个通过权限管理区块链的底层基础框架。</li></ul><h4 id="比特币交易原理"><a href="#比特币交易原理" class="headerlink" title="比特币交易原理"></a>比特币交易原理</h4><ul><li><p>传统的web交易</p><p>账户<br>余额<br>参与者<br>货币</p></li><li><p>基本概念</p><ul><li>比特币系统中的交易没有余额的概念，它使用的是UTXO交易模型，在传统交易过程中所说的交易余额实际上指的是一个比特币钱包地址的UTXO集合</li></ul></li><li><p>交易组成</p><ul><li>在比特币中，交易主要由输入，输出，ID，交易时间组成</li></ul></li><li><p>UTXO交易模型</p><ul><li>比特币专有的交易模型</li><li>在比特币中，交易实际上就是不但查找指定钱包地址的UTXO集合，然后进行修改的过程</li><li>UTXO是比特币交易中最基本的单元，是不可拆分的</li></ul></li><li><p>交易过程</p><p>coinbase：挖矿奖励的比特币，没有发送者，由系统提供，所以不包含input</p><p>普通转账：正常的转账交易，有发送者参与，所以包含input</p></li></ul><h4 id="密码学回顾"><a href="#密码学回顾" class="headerlink" title="密码学回顾"></a>密码学回顾</h4><ul><li><p>在区块链中的用途</p><ul><li>地址生成</li><li>交易签名</li></ul></li><li><p>base64编码</p><ul><li>概念：用一种由64个字符来表示二进制数据的方法</li><li>作用：通常用于在HTTP中传递比较长的信息的处理方法</li><li>编码原理<ul><li>将给定的字符串进行整合，由3个8位转换为4个6位，在6位前面补0，对于要编码的数据(由字符串转换为二进制数据)如果不是3的倍数，最后余数只会是1或者2，Base64在末尾用\x00补足，而在编码展示的末尾，添加1个或者两个“=”，等号的个数代表补足的字节数，在解码的时候，自动将等号去掉。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/base64"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">s := <span class="string">"elssm"</span></span><br><span class="line">encode := base64.StdEncoding.EncodeToString([]<span class="keyword">byte</span>(s))</span><br><span class="line">fmt.Println(encode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/02/区块链笔记/2.png" alt="2"></p></li><li><p>base58编码</p><p>为什么需要base58编码</p><ul><li>在base64的基础上去掉了6个字符（0,O,大写I,小写l,+,/）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/big"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b58Alphabet = []<span class="keyword">byte</span>(<span class="string">""</span>+<span class="string">"123456789"</span>+<span class="string">"abcdefghijkmnopqrstuvwxyz"</span>+<span class="string">"ABCDEFGHJKLMNPQRSTUVWXYZ"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编码函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Base58Encode</span><span class="params">(input []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">//byte字节数组转换为big.int</span></span><br><span class="line">x := big.NewInt(<span class="number">0</span>).SetBytes(input)</span><br><span class="line"><span class="comment">//求余的基本长度</span></span><br><span class="line">base := big.NewInt(<span class="keyword">int64</span>(<span class="built_in">len</span>(b58Alphabet)))</span><br><span class="line"><span class="comment">//求余数和商</span></span><br><span class="line"><span class="comment">//判断条件，除掉的最终结果是否为0</span></span><br><span class="line">zero := big.NewInt(<span class="number">0</span>)</span><br><span class="line"><span class="comment">//设置余数，代表base58基数表的索引位置</span></span><br><span class="line">mod := &amp;big.Int&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> x.Cmp(zero) != <span class="number">0</span> &#123;</span><br><span class="line">x.DivMod(x,base,mod)</span><br><span class="line">result = <span class="built_in">append</span>(result,b58Alphabet[mod.Int64()])</span><br><span class="line">&#125;</span><br><span class="line">Reverse(result)</span><br><span class="line">result = <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;b58Alphabet[<span class="number">0</span>]&#125;,result...)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i,j :=<span class="number">0</span>,<span class="built_in">len</span>(data)<span class="number">-1</span>;i&lt;j;i,j = i+<span class="number">1</span>,j<span class="number">-1</span> &#123;</span><br><span class="line">data[i],data[j] = data[j],data[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Base58Decode</span><span class="params">(input []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">fmt.Println(input)</span><br><span class="line">result := big.NewInt(<span class="number">0</span>)</span><br><span class="line">zeroBytes := <span class="number">1</span></span><br><span class="line"><span class="comment">//去掉前缀</span></span><br><span class="line">data := input[zeroBytes:]</span><br><span class="line">fmt.Println(data)</span><br><span class="line"><span class="keyword">for</span> _,b := <span class="keyword">range</span> data &#123;</span><br><span class="line"><span class="comment">//查找input中指定数字/字符在基数表中出现的索引(mod)</span></span><br><span class="line">charIndex := bytes.IndexByte(b58Alphabet,b)</span><br><span class="line"><span class="comment">//余数*58</span></span><br><span class="line">result.Mul(result,big.NewInt(<span class="number">58</span>))</span><br><span class="line"><span class="comment">//乘积结果+mod(索引)</span></span><br><span class="line">result.Add(result,big.NewInt(<span class="keyword">int64</span>(charIndex)))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line"><span class="comment">//转换为byte字节数组</span></span><br><span class="line">decoded := result.Bytes()</span><br><span class="line">fmt.Println(decoded)</span><br><span class="line"><span class="keyword">return</span> decoded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">result := Base58Encode([]<span class="keyword">byte</span>(<span class="string">"elssm"</span>))</span><br><span class="line">fmt.Printf(<span class="string">"result : %s\n"</span>,result)</span><br><span class="line">decodeResult := Base58Decode([]<span class="keyword">byte</span>(<span class="string">"1crFth1D"</span>))</span><br><span class="line">fmt.Printf(<span class="string">"decode Result : %s\n"</span>,decodeResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Go语言区块链简单实现"><a href="#Go语言区块链简单实现" class="headerlink" title="Go语言区块链简单实现"></a>Go语言区块链简单实现</h4><p>创建一个<code>Block.go</code>文件，定义一个最基本的区块结构,这个结构包含了区块最基本的一些东西。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">TimeStamp <span class="keyword">int64</span> <span class="comment">//区块时间戳</span></span><br><span class="line">Hash []<span class="keyword">byte</span> <span class="comment">//当前区块哈希</span></span><br><span class="line">PrevBlochHash []<span class="keyword">byte</span> <span class="comment">//前区块哈希</span></span><br><span class="line">Height <span class="keyword">int64</span> <span class="comment">//区块高度</span></span><br><span class="line">Data []<span class="keyword">byte</span> <span class="comment">//交易数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着实现一个建立区块的函数,这个函数就是对区块结构进行一些初始化。对于区块的hash我们单独实现一个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(height <span class="keyword">int64</span>,prevBlockHash []<span class="keyword">byte</span>,data []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> block Block</span><br><span class="line"></span><br><span class="line">block = Block&#123;</span><br><span class="line">TimeStamp: time.Now().Unix(),</span><br><span class="line">Hash: <span class="literal">nil</span>,</span><br><span class="line">PrevBlochHash: prevBlockHash,</span><br><span class="line">Height: height,</span><br><span class="line">Data: data,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成哈希</span></span><br><span class="line">block.SetHash()</span><br><span class="line"><span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区块哈希实现,因为在区块结构中区块高度和时间戳都是<code>int</code>型，因此我们要将<code>int</code>转为<code>[]byte</code>，转换可以通过go语言中的encoding/binary包实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntToHex</span><span class="params">(data <span class="keyword">int64</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">buffer := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">err := binary.Write(buffer,binary.BigEndian,data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">"int transact to []byte failed! %v\n"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buffer.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">SetHash</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//调用sha256实现哈希生成</span></span><br><span class="line"><span class="comment">//实现int-&gt;hash</span></span><br><span class="line">timeStampBytes := IntToHex(b.TimeStamp)</span><br><span class="line">heightBytes := IntToHex(b.Height)</span><br><span class="line">blockBytes := bytes.Join([][]<span class="keyword">byte</span>&#123;</span><br><span class="line">heightBytes,</span><br><span class="line">timeStampBytes,</span><br><span class="line">b.PrevBlochHash,</span><br><span class="line">b.Data,</span><br><span class="line">&#125;,[]<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">hash := sha256.Sum256(blockBytes)</span><br><span class="line">b.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个生成创世区块的函数，在函数内部调用生成区块的函数实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateGenesisBlock</span><span class="params">(data []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewBlock(<span class="number">1</span>,<span class="literal">nil</span>,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>BlockChain.go</code>文件，首先定义区块链的基本结构，因为区块链他是一种链式的，所有我们用切片这种数据结构来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">Blocks []*Block <span class="comment">//区块的切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化区块链</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockChainWithGenesisBlock</span><span class="params">()</span> *<span class="title">BlockChain</span></span> &#123;</span><br><span class="line"><span class="comment">//生成创世区块</span></span><br><span class="line">block := CreateGenesisBlock([]<span class="keyword">byte</span>(<span class="string">"init blockchain"</span>))</span><br><span class="line"><span class="keyword">return</span> &amp;BlockChain&#123;[]*Block&#123;block&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加区块到区块链中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span> <span class="title">AddBlock</span><span class="params">(height <span class="keyword">int64</span>,prevBlockHash []<span class="keyword">byte</span>,data []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">newBlock := NewBlock(height,prevBlockHash,data)</span><br><span class="line">bc.Blocks = <span class="built_in">append</span>(bc.Blocks,newBlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>main.go</code>文件，进行一个简单的测试。首先创建一个创世区块，并添加两条新链，最后通过hash来判断是否上链成功。结果如下图，除了第一个创世区块没有prevhash值以外，后面的区块的prevhash值都是前一个区块的currenthash值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">bc := BLC.CreateBlockChainWithGenesisBlock()</span><br><span class="line"><span class="comment">//上链</span></span><br><span class="line">bc.AddBlock(bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Heigth+<span class="number">1</span>,bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Hash,[]<span class="keyword">byte</span>(<span class="string">"alice send 10 btc to bob"</span>))</span><br><span class="line">bc.AddBlock(bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Heigth+<span class="number">1</span>,bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Hash,[]<span class="keyword">byte</span>(<span class="string">"bob send 5 btc to troytan"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,block := <span class="keyword">range</span> bc.Blocks &#123;</span><br><span class="line">fmt.Printf(<span class="string">"prevBlockHash : %x , currentHash : %x\n"</span>,block.PrevBlochHash,block.Hash)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/02/区块链笔记/1.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;区块链产生&quot;&gt;&lt;a href=&quot;#区块链产生&quot; class=&quot;headerlink&quot; title=&quot;区块链产生&quot;&gt;&lt;/a&gt;区块链产生&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;密码朋克：通过匿名性来保护隐私安全&lt;/li&gt;
&lt;li&gt;不可篡改文件记录：加时间戳到文件内容中，证实数据真
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>AdvGAN学习</title>
    <link href="elssm.github.io/2021/04/01/AdvGAN%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/04/01/AdvGAN学习/</id>
    <published>2021-04-01T01:35:04.000Z</published>
    <updated>2021-04-01T05:27:40.111Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Generating-Adversarial-Examples-with-Adversarial-Networks"><a href="#Generating-Adversarial-Examples-with-Adversarial-Networks" class="headerlink" title="Generating Adversarial Examples with Adversarial Networks"></a>Generating Adversarial Examples with Adversarial Networks</h4><p><strong>论文链接：</strong><a href="https://arxiv.org/abs/1801.02610" target="_blank" rel="noopener">https://arxiv.org/abs/</a><a href="https://arxiv.org/abs/1801.02610" target="_blank" rel="noopener">1801.02610</a><br><strong>代码链接：</strong><a href="https://github.com/mathcbc/advGAN_pytorch" target="_blank" rel="noopener">https://github.com/mathcbc/advGAN_pytorch</a></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>为了更有效地生成感知真实的对抗性样本，本文提出一种基于GAN的方式来产生对抗样本。</p><p>1.训练一个产生扰动的前馈网络来产生不同的对抗性样本。</p><p>2.训练一判别网络来确保生成的样本是真实的。</p><p>3.应用了GAN网络在半白盒和黑盒设置中产生对抗性样本。</p><p>4.借助了CGAN的思想利用相似的范例生成高质量的图片。</p><h4 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h4><ul><li>训练了一个条件对抗性网络，直接生成对抗性实例，不仅可以生成感知逼真的实例，对不同目标模型的攻击成功率最高，而且生成过程更高效。</li><li>证明了AdvGAN可以通过训练一个提取的模型来攻击黑盒模型。我们提出用查询信息动态训练提取的模型，实现高黑盒攻击成功率和有针对性的黑盒攻击。</li><li>使用最先进的防御方法来抵御对抗性示例，并表明AdvGAN在当前防御下实现了更高的攻击成功率。</li></ul><h4 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h4><p>回顾了之前的一些对抗性例子和生成对抗网络。总结来看，对抗样本的生成方式无非是以下三种。</p><ul><li>基于梯度的生成方式（FGSM和PGD）</li><li>基于优化的生成方式（CW和JSMA）</li><li>基于GAN的生成方式</li></ul><p>作者提出了基于梯度和基于优化方式产生对抗样本的一些局限性。对于基于梯度来讲，在白盒攻击下攻击者需要完全清楚模型的参数。对于基于优化来讲，存在优化过程慢，只能优化每个特定实例的扰动等问题。相比之下，使用GAN来生成对抗样本，能够在不同防御下实现更高的攻击成功率。</p><h4 id="AdvGAN框架"><a href="#AdvGAN框架" class="headerlink" title="AdvGAN框架"></a>AdvGAN框架</h4><p><img src="/2021/04/01/AdvGAN学习/1.png" alt="1"></p><p>AdvGAN的整体框架如上图所示，主要包含三个部分。一个生成器G，一个判别器D和一个目标攻击网络模型f。从左边开始分析，生成器G会接受一张原始图像输入x，通过生成器G之后会生成一个微小的扰动G(x)，接着扰动实例x+G(x)会被分别送入判别器D和目标攻击网络模型f，判别器的任务是分辨生成数据和原始数据，判别器的作用是引导生成数据与原始类别数据不可区分。在目标攻击网络模型f中，扰动实例x+G(x)会作为输入参数，为了欺骗学习模型，作者先进行了白盒攻击，在白盒攻击下经过f输出对抗损失，对抗损失表示预测类别和要攻击到其错误分类类别的距离或者是与真实类别标签相反的距离。</p><p>其中在2014年Goodfellow提出的对抗损失可以被定义如下：</p><p><img src="/2021/04/01/AdvGAN学习/2.png" alt="2"></p><p>在这里判别器D的目标是分辨带有扰动的数据x+G(x)和原始数据x，其中真实数据是从真实类别中被采样的，目的是为了使得生成的数据尽可能的接近原始数据。</p><p>目标攻击网络模型f的损失被定义如下：</p><p><img src="/2021/04/01/AdvGAN学习/3.png" alt="3"></p><p>其中t是目标标签，$l_f$表示损失函数，在文中使用的是交叉熵损失来训练原始模型f。$L^f_{adv}$损失函数引导带有扰动的图像被错误分类成目标类别t。</p><p>为了限制扰动的大小，作者在L2 norm的基础上加了一个hinge loss，损失被定义如下：</p><p><img src="/2021/04/01/AdvGAN学习/4.png" alt="4"></p><p>这里c代表一个用户所定义的最大边界，可以稳定GAN的训练。</p><p>最终目标函数被表示为：</p><p><img src="/2021/04/01/AdvGAN学习/5.png" alt="5"></p><p>其中$\alpha$和$\beta$用来控制每个损失函数之间的相对重要程度$L^f_{adv}$用来生成对抗样本，$L_{GAN}$是为了使带有扰动的数据与原始数据相似，$L_{hinge}$用来限制perturbation的大小。</p><h4 id="生成对抗网络进行黑盒攻击"><a href="#生成对抗网络进行黑盒攻击" class="headerlink" title="生成对抗网络进行黑盒攻击"></a>生成对抗网络进行黑盒攻击</h4><h5 id="静态蒸馏"><a href="#静态蒸馏" class="headerlink" title="静态蒸馏"></a>静态蒸馏</h5><p>对于黑盒攻击，我们假设攻击者对于训练数据和需要攻击的模型没有先验知识。在我们进行的实验中，因为我们假设攻击者对于训练数据和模型没有先验知识，因此我们随机选取与原始训练数据不相交的图像数据去进行模型蒸馏。为了实现黑盒攻击，我们首先基于黑盒模型b的输出构建了一个蒸馏网络f。一旦我们获得了经过蒸馏的网络f，我们就会执行与白盒设置中描述的相同的攻击策略。蒸馏网络目标函数定义如下：</p><p><img src="/2021/04/01/AdvGAN学习/6.png" alt="6"></p><p>其中f(x)和b(x)分别表示蒸馏模型和黑盒模型的输出，H表示交叉熵损失函数，通过使用所有的训练图像去优化上面的目标函数，我们可以获得效果接近于黑盒模型b的蒸馏模型f。然后我们可以在这个蒸馏网络上进行我们的攻击策略。</p><p>不同于训练判别器D，在训练判别器D的过程中，我们只使用来自原始类别的真实数据去引导生成的对抗样本实例尽可能地接近它的原始类别。在这里我们训练蒸馏模型使用的是来自所有类别的全部数据。</p><h5 id="动态蒸馏"><a href="#动态蒸馏" class="headerlink" title="动态蒸馏"></a>动态蒸馏</h5><p>仅仅用所有原始的训练数据训练经过提炼的模型是不够的，因为我们不清楚黑盒和经过提炼的模型在生成的对抗样本上的表现有多接近，而这些样本在之前的训练集中没有出现过。在这里作者提出一种代替最小化方法去动态查询和联合训练蒸馏模型f和生成器G 。在每一次迭代中执行下面两个步骤：</p><p><img src="/2021/04/01/AdvGAN学习/7.png" alt="7"></p><p>1.对于给定的蒸馏网络$f_{i-1}$更新$G_i$：根据白盒攻击的算法步骤，利用前一个蒸馏网络$f_{i-1}$去训练生成器和判别器，初始化$G_i$的权重为$G_{i-1}$的权重，$G_i,D_i=arg\underset{G}{min}\underset{D}{max}L^{f_{i-1}}_{adv}+\alpha L_{GAN}+\beta L_{hinge}$</p><p>2.对于给定的生成器$G_{i-1}$更新$f_i$：首先我们使用$f_{i-1}$的权重初始化$f_i$的权重，然后对于给定的从$G_i$生成的对抗样本x+G(x)，蒸馏模型$f_i$会根据最新的在黑盒模型上对抗样本的查询结果和原始数据进行参数更新。$f_i=arg\underset{f}{min}E_xH(f(x),b(x))+E_xH(f(x+G_i(x)),b(x+G_i(x)))$这里我们使用原始图像x和生成的对抗样本x+$sG_i(x)$去更新蒸馏网络。</p><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>这一章节，我们首先评估AdvGAN在半白盒和黑盒情景下对于MNIST和CIFAR-10的效果。我们也在ImageNet上进行的半白盒攻击的测试。接着我们应用AdvGAN在不同的目标模型上生成对抗样本和在目前最好的防御方法下测试其攻击成功率，结果显示我们的方法与其他目前存在的方法相比能实现更高的攻击成功率。为了保证比较的公平性，我们利用各种攻击方法生成的对抗样本都是在相同的无穷范式的约束下（在MNIST是0.3，在CIFAR-10是8）。大致来看，AdvGAN对比其他白盒攻击和黑盒攻击的方法体现出了几点优势。</p><p><img src="/2021/04/01/AdvGAN学习/8.png" alt="8"></p><p>就计算效率来讲，AdvGAN执行速度更快甚至比高效的FGSM方法快，即使AdvGAN需要额外的训练时间去训练生成器。我们这里对比的所有攻击策略除了基于迁移性攻击策略，其他都可以进行目标攻击。除此之外，FGSM和基于优化的方法只能进行白盒攻击，但是AdvGAN可以在半白盒的情景下进行攻击。</p><h5 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h5><p>采用与image-to-image转换文献类似的生成器和鉴别器结构，采用C&amp;W方法中提出的损失函数作为损失函数。在黑盒攻击的情景下表示蒸馏网络。我们设置信度为0，优化方法使用Adam，批大小为128，学习率为0.001。对于生成式对抗网络的学习，我们使用最小平方目标函数，因为它有更好更稳定的结果。</p><h5 id="半白盒攻击下的AdvGAN"><a href="#半白盒攻击下的AdvGAN" class="headerlink" title="半白盒攻击下的AdvGAN"></a>半白盒攻击下的AdvGAN</h5><p>我们用不同的模型结构来评估AdvGAN在MNIST和CIFAR-10数据集上的表现。我们首先应用AdvGAN来执行针对MNIST的不同模型的半白盒攻击。可以看出AdvGAN能够生成对抗实例以高攻击成功率攻击所有模型。我们还从相同的原始实例x生成对抗样本，攻击到其他不同的类别，在MNIST的半白盒情景中，我们可以看到生成的不同模型的对抗样本看起来与原始图像十分接近。此外，我们还分析了基于不同损失函数的MNIST攻击成功率。在相同的perturbation下，如果我们把上面定义的完整的损失函数代替成Baluja和Fischer使用的损失函数，攻击成功率为86.2%。如果把损失函数替代为$L=L_{hinge}+L^f_{adv}$，攻击成功率为91.1%，AdvGAN的成功率为98.3%。</p><p><img src="/2021/04/01/AdvGAN学习/10.png" alt="10"></p><h5 id="黑盒攻击下的AdvGAN"><a href="#黑盒攻击下的AdvGAN" class="headerlink" title="黑盒攻击下的AdvGAN"></a>黑盒攻击下的AdvGAN</h5><p>黑盒攻击基于动态蒸馏策略，构造一个本地模型去蒸馏我们需要攻击的模型f。我们选择模型C作为我们本地模型的架构。注意的是我们随机选取与原始训练数据不同的图像实例子集去训练本地模型。我们假设攻击者对于训练数据和模型没有任何的先验了解。通过动态蒸馏策略，由AdvGAN产生的对抗样本实现了在MNIST数据集上超过90%的攻击成功率和在CIFAR-10上超过80%的攻击成功率。与此同时静态蒸馏在两个数据集上分别达到了30%和10%的攻击成功率。<br>我们使用AdvGAN在MNIST上生成能被错误分类到特定类别的对抗样本。通过对比生成的对抗样本和原图，我们可以看到对抗样本可以实现和原图一样高的视觉质量。特别地，原始图像被对抗噪声强调的部分暗含着视觉现实的操作。图3显示了在CIFAR-10上产生的对抗样本结果。这些对抗样本实例和原始图像相比具有照片的真实性。</p><p><img src="/2021/04/01/AdvGAN学习/11.png" alt="11"></p><h5 id="在防御算法下的攻击效果"><a href="#在防御算法下的攻击效果" class="headerlink" title="在防御算法下的攻击效果"></a>在防御算法下的攻击效果</h5><p>AdvGAN尝试生成隐含在真实数据分布中的对抗样本实例，它与其他攻击策略相比能在本质上产生更加真实的对抗扰动。因此AdvGAN有更高的概率能产生能抵抗不同防御方法的对抗样本。在</p><h5 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h5><p>大多数现在的防御策略在它们受到攻击时，并不表现得那么鲁棒。这里我们考虑一个较弱的威胁模型，当对手不知道防御方法，并直接尝试攻击原始的学习模型，这也是C&amp;W分析的第一个威胁模型。在这种场景下，假设攻击者依然能够成功地攻击模型，这表明攻击策略是具有鲁棒性的。在这种场景下，我们首先应用不同的攻击算法在不知道被攻击的模型使用了什么防御算法的前提下，去产生对抗样本。然后我们使用不同的防御机制直接对这些产生的对抗样本进行防御。</p><h5 id="半白盒攻击"><a href="#半白盒攻击" class="headerlink" title="半白盒攻击"></a>半白盒攻击</h5><p>在半白盒攻击下，攻击者对模型结构和参数能进行白盒式访问。我们将图1中的f替换成我们的威胁模型A,B,C。我们分别使用标准的FGSM对抗训练，集成对抗训练，迭代对抗训练这三种对抗训练算法去针对不同的模型架构去训练防御模型。我们通过攻击这些防御模型来评估攻击的有效性。我们的实验结果显示使用AdvGAN生成的对抗样本的攻击成功率比FGSM和Opt都高。如下图表3所示：</p><p><img src="/2021/04/01/AdvGAN学习/12.png" alt="12"></p><h5 id="黑盒攻击"><a href="#黑盒攻击" class="headerlink" title="黑盒攻击"></a>黑盒攻击</h5><p>对于AdvGAN，我们使用模型B作为黑盒攻击的模型，训练一个蒸馏模型进行黑盒攻击，攻击成功率在表4。</p><p><img src="/2021/04/01/AdvGAN学习/13.png" alt="13"></p><p>我们采用基于迁移性进行攻击的FGSM和Opt。我们使用FGSM和Opt在MNIST上攻击模型A，然后我们使用这些对抗样本去攻击模型B，显示对应分类的正确率。我们可以看到由AdvGAN生成的对抗样本的攻击成功率始终比其他攻击方法的高。对于CIFAR-10数据集，我们使用ResNet作为黑盒攻击模型，并且训练一个蒸馏模型对它进行黑盒攻击。为了与基于优化的黑盒攻击方法和FGSM进行对比，我们使用对Wide ResNet进行攻击生成的对抗样本在ResNet上测试。另外我们使用AdvGAN在MNIST挑战上，在表5上显示了几乎所有的标准攻击方法，其中AdvGAN实现了88.93%的攻击成功率在白盒攻击下。在与已经发表的黑盒攻击算法对比，AdvGAN实现了92.76%的攻击成功率，超过了所有其他在挑战中提交的最好的攻击策略。</p><p><img src="/2021/04/01/AdvGAN学习/14.png" alt="14"></p><p>在图4中，我们展示了随机挑选的由AdvGAN生成的原始图像数据和对抗样本。</p><p><img src="/2021/04/01/AdvGAN学习/15.png" alt="15"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>提出了一种基于生成式对抗网络的网络架构AdvGAN去生成对抗样本。在我们的网络架构中，前馈的生成器一旦训练完成，我们可以高效地生成对抗扰动。这种对抗样本在半白盒攻击和黑盒攻击下都能达到很高的成功率。另外，当我们使用AdvGAN去针对不同的未知防御方法的被攻击模型生成对抗样本时，生成的对抗样本可以保持高分辨率和高的视觉质量。能以高的攻击率成功攻击目前最好的防御方法。这个属性让AdvGAN成为有保障的提高对抗训练的途径。</p><h4 id="复现代码分析"><a href="#复现代码分析" class="headerlink" title="复现代码分析"></a>复现代码分析</h4><p>复现代码链接：<a href="https://github.com/mathcbc/advGAN_pytorch" target="_blank" rel="noopener">https://github.com/mathcbc/advGAN_pytorch</a></p><h5 id="training-the-target-model"><a href="#training-the-target-model" class="headerlink" title="training the target model"></a>training the target model</h5><p><code>train_target_model.py</code>的代码结构如下</p><p><img src="/2021/04/01/AdvGAN学习/16.png" alt="16"></p><p>模型定义在<code>model.py</code>文件中。模型采用了四个卷积层和三个全连接层。在<code>forward</code>函数中采用relu激活函数和池化操作并开启了dropout。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNIST_target_net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MNIST_target_net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">32</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">        self.conv4 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">200</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        self.logits = nn.Linear(<span class="number">200</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = F.relu(self.conv1(x))</span><br><span class="line">        x = F.relu(self.conv2(x))</span><br><span class="line">        x = F.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = F.relu(self.conv3(x))</span><br><span class="line">        x = F.relu(self.conv4(x))</span><br><span class="line">        x = F.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.dropout(x, <span class="number">0.5</span>)</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.logits(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Generating-Adversarial-Examples-with-Adversarial-Networks&quot;&gt;&lt;a href=&quot;#Generating-Adversarial-Examples-with-Adversarial-Networks&quot; clas
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实现rpc和grpc</title>
    <link href="elssm.github.io/2021/03/29/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0rpc%E5%92%8Cgrpc/"/>
    <id>elssm.github.io/2021/03/29/Go语言实现rpc和grpc/</id>
    <published>2021-03-29T03:03:17.000Z</published>
    <updated>2021-03-30T12:23:49.719Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h4><p>RPC（Remote Procedure Call）是一种远程调用协议，能够使应用像调用本地方法一样调用远程的过程或服务。可以应用在分布式服务、分布式计算、远程调用等场景。</p><h4 id="Go实现rpc-server"><a href="#Go实现rpc-server" class="headerlink" title="Go实现rpc-server"></a>Go实现rpc-server</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> World <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *World)</span> <span class="title">HelloWorld</span> <span class="params">(name <span class="keyword">string</span>,resp *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">*resp = name + <span class="string">" 你好!"</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//注册rpc服务</span></span><br><span class="line">err := rpc.RegisterName(<span class="string">"hello"</span>,<span class="built_in">new</span>(World))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"注册rpc服务失败！,err"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置监听</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8800"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line">fmt.Println(<span class="string">"开始监听...."</span>)</span><br><span class="line"><span class="comment">//建立链接</span></span><br><span class="line">conn,err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Accept() err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">fmt.Println(<span class="string">"链接成功..."</span>)</span><br><span class="line"><span class="comment">//绑定服务</span></span><br><span class="line">rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们要实定义类对象并绑定一个类方法。在<code>server</code>中的<code>main</code>函数中第一步需要实现的是注册RPC服务，绑定对象方法。<code>RegisterName</code>函数的第一个参数是服务名，是一个字符串类型。第二个参数对应rpc对象。方法必须是导出的，必须有两个参数，方法第二个参数必须是指针。方法只有一个error接口类型的返回值。第二步是设置监听，这里我们使用<code>net.listen</code>监听本地tcp下的<code>8800</code>端口。第三步是建立链接，使用<code>Accept</code>会返回一个用于通信的connect。最后绑定服务即可。这里注意对于listener和conn在使用完后一定要close。</p><h4 id="Go实现rpc-client"><a href="#Go实现rpc-client" class="headerlink" title="Go实现rpc-client"></a>Go实现rpc-client</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main01</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//用rpc链接服务器</span></span><br><span class="line">conn,err := rpc.Dial(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8800"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Dial err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//调用远程函数</span></span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">string</span> </span><br><span class="line">err = conn.Call(<span class="string">"hello.HelloWorld"</span>,<span class="string">"elssm"</span>,&amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Call err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>client</code>端第一步先通过<code>Dial</code>链接服务器。链接成功之后通过<code>Call</code>调用远程函数，对于<code>Call</code>的第一个参数是服务名.方法名，第二个是传入参数，第三个是接收参数，因为在server端类方法的第二个参数是指针类型。所以这里<code>Call</code>的第三个参数要传地址用于接收函数返回值。</p><h4 id="Json-rpc"><a href="#Json-rpc" class="headerlink" title="Json-rpc"></a>Json-rpc</h4><p>使用<code>nc -l 127.0.0.1 8800</code>充当服务器发起通信产生乱码</p><p><img src="/2021/03/29/Go语言实现rpc和grpc/1.png" alt="1"></p><p>这是因为rpc使用了go语言特有的数据序列化gob，其他编程语言不能解析。因此我们可以使用通用的序列化，反序列化例如json、protobuf来解决。</p><p>修改上面<code>client</code>端的链接服务器代码如下即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn,err := jsonrpc.Dial(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8800"</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/2.png" alt="2"></p><h4 id="RPC封装"><a href="#RPC封装" class="headerlink" title="RPC封装"></a>RPC封装</h4><h5 id="服务端封装"><a href="#服务端封装" class="headerlink" title="服务端封装"></a>服务端封装</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建接口，在接口中定义方法原型</span></span><br><span class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">HelloWorld(<span class="keyword">string</span>,*<span class="keyword">string</span>) error</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装注册服务方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterService</span><span class="params">(i MyInterface)</span></span>  &#123;</span><br><span class="line">rpc.RegisterName(<span class="string">"hello"</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端封装"><a href="#客户端封装" class="headerlink" title="客户端封装"></a>客户端封装</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="keyword">type</span> Myclient <span class="keyword">struct</span> &#123;</span><br><span class="line">c *rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitClient</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="title">Myclient</span></span> &#123;</span><br><span class="line">conn,_:= jsonrpc.Dial(<span class="string">"tcp"</span>,addr)</span><br><span class="line"><span class="keyword">return</span> Myclient&#123;c:conn&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定类方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Myclient)</span> <span class="title">HelloWorld</span><span class="params">(a <span class="keyword">string</span>,b *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> this.c.Call(<span class="string">"hello.HelloWorld"</span>,a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h4><p>protobuf是Google开发出来的一个语言无关、平台无关的数据序列化工具，在rpc或tcp通信等很多场景都可以使用。通俗来讲，如果客户端和服务端使用的是不同的语言，那么在服务端定义一个数据结构，通过protobuf转化为字节流，再传送到客户端解码，就可以得到对应的数据结构。如果实现rpc我们可以使用json进行序列化。如果使用protobuf做序列化就需要使用gRPC。</p><p>protobuf语法：<a href="https://www.bookstack.cn/read/topgoer/abb9896b6124ea54.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/topgoer/abb9896b6124ea54.md</a></p><h5 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h5><p>macos使用brew进行安装protobuf编译器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install protobuf</span><br></pre></td></tr></table></figure><h5 id="protobuf编写"><a href="#protobuf编写" class="headerlink" title="protobuf编写"></a>protobuf编写</h5><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认是proto2</span></span><br><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定所在包名</span></span><br><span class="line"><span class="keyword">package</span> pb;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> </span>&#123;</span><br><span class="line">  Monday = <span class="number">0</span>;</span><br><span class="line">  Turesday = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义消息体</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> age = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  People p = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">int32</span> score = <span class="number">4</span>; <span class="comment">//数组</span></span><br><span class="line">  <span class="comment">//枚举</span></span><br><span class="line">  Week w = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">//联合体</span></span><br><span class="line">  <span class="keyword">oneof</span> data &#123;</span><br><span class="line">    <span class="built_in">string</span> teacher = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">string</span> class = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息体可以嵌套</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> weight = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编译protobuf"><a href="#编译protobuf" class="headerlink" title="编译protobuf"></a>编译protobuf</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=./ *.proto</span><br></pre></td></tr></table></figure><p>在当前目录下会生成<code>myproto.pb.go</code>文件</p><h4 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h4><p>Consul是一个服务网格解决方案，提供了一个功能齐全的控制平面，具有服务发现、配置和分段功能。 这些功能中的每一项都可以根据需要单独使用，也可以一起使用来构建一个完整的服务网格。 Consul需要一个数据平面，并支持代理和原生集成模型。</p><h5 id="安装consul"><a href="#安装consul" class="headerlink" title="安装consul"></a>安装consul</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install consul</span><br></pre></td></tr></table></figure><p>macos在/etc目录下创建<code>consul.d</code>文件夹，进入<code>consul.d</code>文件夹下。</p><h5 id="创建json文件"><a href="#创建json文件" class="headerlink" title="创建json文件"></a>创建json文件</h5><p><img src="/2021/03/29/Go语言实现rpc和grpc/6.png" alt="6"></p><h5 id="启动consul"><a href="#启动consul" class="headerlink" title="启动consul"></a>启动consul</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=127.0.0.1 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/3.png" alt="3"></p><h5 id="浏览器查看"><a href="#浏览器查看" class="headerlink" title="浏览器查看"></a>浏览器查看</h5><p>访问<code>127.0.0.1:8500</code>查看节点信息</p><p><img src="/2021/03/29/Go语言实现rpc和grpc/4.png" alt="4"></p><h5 id="命令行查看"><a href="#命令行查看" class="headerlink" title="命令行查看"></a>命令行查看</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s 127.0.0.1:8500/v1/catalog/service/bj38</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/5.png" alt="5"></p><h5 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/consul.d/web.json</span><br></pre></td></tr></table></figure><p>写入配置文件信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"service"</span>:&#123;</span><br><span class="line">                <span class="attr">"name"</span>:<span class="string">"bj38"</span>,</span><br><span class="line">                <span class="attr">"tags"</span>:[<span class="string">"itcast"</span>,<span class="string">"itheima"</span>],</span><br><span class="line">                <span class="attr">"port"</span>:<span class="number">8800</span>,</span><br><span class="line"><span class="attr">"check"</span>:&#123;</span><br><span class="line"><span class="attr">"id"</span>:<span class="string">"api"</span>,</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"itcast check"</span>,</span><br><span class="line"><span class="attr">"http"</span>:<span class="string">"http://127.0.0.1:8800"</span>,</span><br><span class="line"><span class="attr">"interval"</span>:<span class="string">"5s"</span>,</span><br><span class="line"><span class="attr">"timeout"</span>:<span class="string">"1s"</span></span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动consul-1"><a href="#启动consul-1" class="headerlink" title="启动consul"></a>启动consul</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=n1 -bind=127.0.0.1 -ui -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/7.png" alt="7"></p><h4 id="gRPC介绍"><a href="#gRPC介绍" class="headerlink" title="gRPC介绍"></a>gRPC介绍</h4><p>官方中文文档：<a href="http://doc.oschina.net/grpc?t=58008" target="_blank" rel="noopener">http://doc.oschina.net/grpc?t=58008</a></p><h4 id="Go实现gRPC"><a href="#Go实现gRPC" class="headerlink" title="Go实现gRPC"></a>Go实现gRPC</h4><p>首先创建一个简单的go版本的protobuf文件，该文件在项目的pb文件夹中，命名为<code>person.proto</code>,项目名为<code>day02</code>。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//package pb;</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">"/;pb"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> age=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">hello</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> sayHello(Person) <span class="keyword">returns</span> (Person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里遇到了一个很坑的问题，就是要将上面的<code>package pb;</code>改为<code>option go_package = &quot;/;pb&quot;;</code>，这个问题折磨了我有半个下午。大概报错如下图</p><p><img src="/2021/03/29/Go语言实现rpc和grpc/8.png" alt="8"></p><p>一开始根本不知道问题出在哪。baidu/google了很久都没有找到解决办法。我想这可能跟protoc-gen-go的版本有关。来来回回安装protoc-gen-go，无果。最后终于在github上找到了解决办法。</p><p><img src="/2021/03/29/Go语言实现rpc和grpc/9.png" alt="9"></p><h5 id="生成-go文件"><a href="#生成-go文件" class="headerlink" title="生成.go文件"></a>生成<code>.go</code>文件</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:./ *.proto</span><br></pre></td></tr></table></figure><h5 id="gRPC-server"><a href="#gRPC-server" class="headerlink" title="gRPC-server"></a>gRPC-server</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"day02/pb"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="keyword">type</span> Children <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定类方法，实现接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Children)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context,p *pb.Person)</span> <span class="params">(*pb.Person,error)</span></span> &#123;</span><br><span class="line">p.Name = <span class="string">"hello "</span> + p.Name</span><br><span class="line"><span class="keyword">return</span> p,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 初始化grpc对象</span></span><br><span class="line">grpcServer := grpc.NewServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册服务</span></span><br><span class="line">pb.RegisterHelloServer(grpcServer,<span class="built_in">new</span>(Children))</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置监听</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">"127.0.0.1:8800"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"开始监听...."</span>)</span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">grpcServer.Serve(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/10.png" alt="10"></p><h5 id="gRPC-client"><a href="#gRPC-client" class="headerlink" title="gRPC-client"></a>gRPC-client</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"google.golang.org/grpc"</span></span><br><span class="line"><span class="string">"day02/pb"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//链接服务</span></span><br><span class="line">grocConn,_ := grpc.Dial(<span class="string">"127.0.0.1:8800"</span>,grpc.WithInsecure())</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化grpc客户端</span></span><br><span class="line">grpcClient := pb.NewHelloClient(grocConn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person pb.Person</span><br><span class="line">person.Name = <span class="string">"elssm"</span></span><br><span class="line">person.Age = <span class="number">22</span></span><br><span class="line"><span class="comment">//调用远程函数</span></span><br><span class="line">p,err := grpcClient.SayHello(context.TODO(),&amp;person)</span><br><span class="line">fmt.Println(p,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/29/Go语言实现rpc和grpc/11.png" alt="11"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;RPC介绍&quot;&gt;&lt;a href=&quot;#RPC介绍&quot; class=&quot;headerlink&quot; title=&quot;RPC介绍&quot;&gt;&lt;/a&gt;RPC介绍&lt;/h4&gt;&lt;p&gt;RPC（Remote Procedure Call）是一种远程调用协议，能够使应用像调用本地方法一样调用远程的过程或
      
    
    </summary>
    
    
      <category term="代码" scheme="elssm.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>初学influxdb</title>
    <link href="elssm.github.io/2021/03/26/%E5%88%9D%E5%AD%A6influxdb/"/>
    <id>elssm.github.io/2021/03/26/初学influxdb/</id>
    <published>2021-03-26T00:35:45.000Z</published>
    <updated>2021-03-26T03:46:45.853Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>influxDB官网：<a href="https://www.influxdata.com/" target="_blank" rel="noopener">https://www.influxdata.com/</a></p><p>正如官网所介绍，influxDB是一个开源的时序型数据库。使用Go语言编写。主要用来查询和存储时序型数据。和Mysql和Nosql不同的是，influxDB被广泛用于存储系统的监控数据。并且可以配合一些图形化界面例如Grafana进行图形化展示。</p><p>与MYSQL的基础概念对比</p><div class="table-container"><table><thead><tr><th>概念</th><th>MYSQL</th><th>influxDB</th></tr></thead><tbody><tr><td>数据库</td><td>database</td><td>database</td></tr><tr><td>表</td><td>table</td><td>measurement</td></tr><tr><td>列</td><td>column</td><td>tag</td></tr></tbody></table></div><h4 id="下载安装influxDB"><a href="#下载安装influxDB" class="headerlink" title="下载安装influxDB"></a>下载安装influxDB</h4><p>目前官网的influxDB版本是V2版本，我下载的是V1版本。版本号是<code>1.7.11</code><br><a href="http://66-ai.com/download/influxdb/influxdb-1.8.3_darwin_amd64.tar.gz" target="_blank" rel="noopener">mac版influxdb下载</a><br>下载好之后对文件进行解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf influxdb-1.7.11_darwin_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压之后进入文件夹<code>/usr/bin</code>下启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./influxd</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/1.png" alt="1"></p><p>启动客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./influx</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/2.png" alt="2"></p><p>influxDB操作和mysql相似。通过查询数据表发现里面只存在一个默认数据库<code>_internal</code></p><p><img src="/2021/03/26/初学influxdb/3.png" alt="3"></p><h4 id="gopsutil学习"><a href="#gopsutil学习" class="headerlink" title="gopsutil学习"></a>gopsutil学习</h4><p>gopsutil是一个查询系统性能数据的模块，通过go语言实现。通过安装gopsutil模块就可以实现对本机的一些参数进行查询。<br>小试牛刀</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/shirou/gopsutil</span><br></pre></td></tr></table></figure><p>模块导入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/cpu"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/disk"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/host"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/load"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/mem"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/net"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查询cpu信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCpuInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">cpuInfos,err := cpu.Info()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get cpu info failed,err:%v\n"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,ci := <span class="keyword">range</span> cpuInfos &#123;</span><br><span class="line">fmt.Println(ci)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/4.png" alt="4"></p><p>查询cpu负载</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLoad</span><span class="params">()</span></span>  &#123;</span><br><span class="line">info,err := load.Avg()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"load.Avg() failed,err:%v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/5.png" alt="5"></p><p>查询内存信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHostInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">info,_ := host.Info()</span><br><span class="line">fmt.Printf(<span class="string">"host info:%v uptime:%v boottime:%v\n"</span>,info,info.Uptime,info.BootTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/7.png" alt="7"></p><p>查询磁盘信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDiskInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//获取所有分区信息</span></span><br><span class="line">parts,err := disk.Partitions(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get disk Partitions failed,err:%v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(parts)</span><br><span class="line"><span class="keyword">for</span> _,part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">partInfo,err := disk.Usage(part.Mountpoint)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get part stat failed,err:%v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(partInfo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//磁盘IO</span></span><br><span class="line">ioStat,_ := disk.IOCounters()</span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> ioStat &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v:%v\n"</span>,k,v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/8.png" alt="8"></p><p>查询网络信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNetInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">netIOs,err := net.IOCounters(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"get net io counters failed,err:%v\n"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,netIO := <span class="keyword">range</span> netIOs &#123;</span><br><span class="line">fmt.Println(netIO)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/9.png" alt="9"></p><h4 id="Go操作influxDB"><a href="#Go操作influxDB" class="headerlink" title="Go操作influxDB"></a>Go操作influxDB</h4><p>安装influxdb V1版本的模块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/influxdata/influxdb1-client/v2</span><br></pre></td></tr></table></figure><p>模块导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">client &quot;github.com/influxdata/influxdb1-client/v2&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>连接influxdb，V1版本端口默认为8086，V2版本端口默认为9999，用户名默认为admin，密码默认为空</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connInflux</span><span class="params">()</span> <span class="title">client</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line">cli,err := client.NewHTTPClient(client.HTTPConfig&#123;</span><br><span class="line">Addr: <span class="string">"http://127.0.0.1:8086"</span>,</span><br><span class="line">Username: <span class="string">"admin"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn err = "</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cli</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询操作</p><p>这里我们查询的是<code>test</code>数据库。因此我们需要在数据库中手动创建一个<code>test</code>数据库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryDB</span><span class="params">(cli client.Client,cmd <span class="keyword">string</span>)</span> <span class="params">(res []client.Result,err error)</span></span> &#123;</span><br><span class="line">   q := client.Query&#123;</span><br><span class="line">      Command: cmd,</span><br><span class="line">      Database: <span class="string">"test"</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> response,err := cli.Query(q); err==<span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> response.Error() != <span class="literal">nil</span>&#123;</span><br><span class="line">         fmt.Println(<span class="string">"response error"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      res = response.Results</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res,err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/10.png" alt="10"></p><p>写入数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writesPoints</span><span class="params">(cli client.Client)</span></span> &#123;</span><br><span class="line">bp, err := client.NewBatchPoints(client.BatchPointsConfig&#123;</span><br><span class="line">Database:  <span class="string">"test"</span>,</span><br><span class="line">Precision: <span class="string">"s"</span>, <span class="comment">//精度，默认ns</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">tags := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"cpu"</span>: <span class="string">"ih-cpu"</span>&#125;</span><br><span class="line">fields := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"idle"</span>:   <span class="number">201.1</span>,</span><br><span class="line"><span class="string">"system"</span>: <span class="number">43.3</span>,</span><br><span class="line"><span class="string">"user"</span>:   <span class="number">86.6</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pt, err := client.NewPoint(<span class="string">"cpu_usage"</span>, tags, fields, time.Now())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">bp.AddPoint(pt)</span><br><span class="line">err = cli.Write(bp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">"insert success"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入数据成功</p><p><img src="/2021/03/26/初学influxdb/11.png" alt="11"></p><h4 id="influxDB客户端查询"><a href="#influxDB客户端查询" class="headerlink" title="influxDB客户端查询"></a>influxDB客户端查询</h4><p><img src="/2021/03/26/初学influxdb/12.png" alt="12"></p><h4 id="Grafana实战"><a href="#Grafana实战" class="headerlink" title="Grafana实战"></a>Grafana实战</h4><p>grafna下载地址：<a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a></p><p>macos下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install grafana</span><br></pre></td></tr></table></figure><p>启动grafana，默认端口是3000，访问127.0.0.1:3000即可，默认用户名和密码为admin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start grafana</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/13.png" alt="13"></p><h4 id="Grafana配置influxDB"><a href="#Grafana配置influxDB" class="headerlink" title="Grafana配置influxDB"></a>Grafana配置influxDB</h4><p><img src="/2021/03/26/初学influxdb/14.png" alt="14"></p><h4 id="实时监控cpu状态并存储influxDB中"><a href="#实时监控cpu状态并存储influxDB中" class="headerlink" title="实时监控cpu状态并存储influxDB中"></a>实时监控cpu状态并存储influxDB中</h4><p>代码如下</p><p>首先在influxdb中创建新的数据库为monitor，之后运行如下代码可以每隔1s获取cpu使用信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">client <span class="string">"github.com/influxdata/influxdb1-client/v2"</span></span><br><span class="line"><span class="string">"github.com/shirou/gopsutil/cpu"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">cli client.Client</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initConnInflux</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">cli,err = client.NewHTTPClient(client.HTTPConfig&#123;</span><br><span class="line">Addr: <span class="string">"http://127.0.0.1:8086"</span>,</span><br><span class="line">Username: <span class="string">"admin"</span>,</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writesPoints</span><span class="params">(percent <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">bp, err := client.NewBatchPoints(client.BatchPointsConfig&#123;</span><br><span class="line">Database:  <span class="string">"monitor"</span>,</span><br><span class="line">Precision: <span class="string">"s"</span>, <span class="comment">//精度，默认ns</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">tags := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"cpu"</span>: <span class="string">"cpu0"</span>&#125;</span><br><span class="line">fields := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"cpu_percent"</span>: percent ,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pt, err := client.NewPoint(<span class="string">"cpu_percent"</span>, tags, fields, time.Now())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">bp.AddPoint(pt)</span><br><span class="line">err = cli.Write(bp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">"insert success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCpuInfo</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//cpu使用率</span></span><br><span class="line">percent,_ := cpu.Percent(time.Second,<span class="literal">false</span>)</span><br><span class="line">fmt.Printf(<span class="string">"cpu percent:%v\n"</span>,percent)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入到influxdb中</span></span><br><span class="line">writesPoints(percent[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">err := initConnInflux()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"connect to influxdb failed,err:%v"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">getCpuInfo()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/26/初学influxdb/15.png" alt="15"></p><h5 id="Grafana展示"><a href="#Grafana展示" class="headerlink" title="Grafana展示"></a>Grafana展示</h5><p>在dashboard中创建新的panel</p><p><img src="/2021/03/26/初学influxdb/16.png" alt="16"></p><p>相关配置选择如下</p><p><img src="/2021/03/26/初学influxdb/17.png" alt="17"></p><p>之后可以自定义面板，选择折线图或者柱状图等等，数据就会从influxdb中被展示到面板中。</p><p><img src="/2021/03/26/初学influxdb/18.png" alt="18"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;influxDB官网：&lt;a href=&quot;https://www.influxdata.com/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Docker&amp;Kubernetes学习</title>
    <link href="elssm.github.io/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/03/22/Docker-Kubernetes学习/</id>
    <published>2021-03-22T07:49:26.000Z</published>
    <updated>2021-03-22T07:50:07.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><p>Docker容器数据卷</p><p>需求：容器的持久化和同步操作，容器间也是可以数据共享的</p><p>容器之间可以有一个数据共享的技术，Docker容器中产生的数据同步到本地</p><p>将我们容器内的目录，挂载到linux上面</p></li><li><p>具名和匿名挂载</p><p>匿名：在<code>-v</code>只写了容器内的路径，没有写容器外的路径</p><p>具名：通过<code>-v</code>  卷名:容器内路径</p><p>指定路径挂载：<code>-v</code> /宿主机路径：容器内路径</p></li><li><p>DockerFile </p><p>用来构建docker镜像的构建文件，命令脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建dockerfile文件</span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME ["volume01","volume02"]</span><br><span class="line"></span><br><span class="line">CMD echo "----end----"</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>构建称为一个镜像</span><br><span class="line">docker build -f dockerfile -t elssm/centos .</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>运行镜像</span><br><span class="line">docker run</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>发布镜像</span><br><span class="line">docker push</span><br></pre></td></tr></table></figure><p>DockerFile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行</p><p>Docker容器：容器就是镜像运行起来提供服务的</p></li><li><p>DockerFile的指令解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM #基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER #镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN #镜像构建的时候需要运行的命令</span><br><span class="line">ADD #步骤，添加内容</span><br><span class="line">WORKDIR #镜像的工作目录</span><br><span class="line">VOLUME #挂载的目录</span><br><span class="line">EXPOSE #指定暴露端口</span><br><span class="line">CMD #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD #当构建一个被继承DockerFile这个时候就会运行ONBUILD的指令</span><br><span class="line">COPY：#类似ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENV #构建的时候设置环境变量</span><br></pre></td></tr></table></figure></li><li><p>创建一个自己的centos</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>编写Dockerfile的文件</span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER elssm&lt;329847986@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim </span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo "---end---"</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>通过这个文件构建镜像</span><br><span class="line">docker build -f dockerfile -t name:0.1 .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>测试运行</span><br><span class="line">docker run -it image</span><br></pre></td></tr></table></figure></li><li><p>实战Tomcat镜像</p><ul><li><p>准备镜像文件tomcat压缩包，jdk的压缩包</p></li><li><p>编写dockerfile文件</p></li></ul></li><li><p>数据卷容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>容器间数据同步</span><br><span class="line">-- volumes -from</span><br></pre></td></tr></table></figure></li><li><p>Docker网络</p><p>原理：我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是veth-pair技术</p></li><li><p>veth-pair：就是一对虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连，正因为有这个特性，veth-pair充当一个桥梁，连接各种虚拟 网络设备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>查看docker下的所有network</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看详细信息</span><br><span class="line">docker network inspect bridge_ID</span><br></pre></td></tr></table></figure><p><code>--link</code>可以解决docker下网络联通问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>下载tomcat镜像</span><br><span class="line">docker pull tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>docker下启动两个tomcat</span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat02 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>启动tomcat03并绑定tomcat02</span><br><span class="line">docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>进入tomcat03并查看tomcat03配置文件</span><br><span class="line">docker exec -it tomcat03 cat /etc/hosts</span><br></pre></td></tr></table></figure></li><li><p>自定义网络</p><p>查看所有的docker网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p>网络模式</p><ul><li>bridge：桥接模式</li><li>none：不配置网络</li><li>host：和宿主机共享网络</li><li>container：容器内网络连通</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>我们可以自定义一个网络</span><br><span class="line"><span class="meta">#</span> --driver bridge</span><br><span class="line"><span class="meta">#</span> --subnet 192.168.0.0/16</span><br><span class="line"><span class="meta">#</span> --gateway 192.168.0.1</span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看自己创建的网络</span><br><span class="line">docker network inspect mynet</span><br></pre></td></tr></table></figure><p>自定义的网络docker都已经帮我们维护好了对应的关系</p><p>不同的集群使用不同的网络，保证集群是安全和健康的</p></li><li><p>网络连通</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>测试打通tomcat01 - mynet</span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>连通之后就是将tomcat01放到了mynet网络下</span><br><span class="line"><span class="meta">#</span>一个容器两个ip地址</span><br></pre></td></tr></table></figure></li></ul><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><ul><li><p>发展历程</p><p>Infrastructure as a Service（阿里云）</p><p>Platform as a service（新浪云）</p><p>Software as a Service（Office 365）</p></li><li><p>资源管理器</p><ul><li>Apache MESOS</li><li>docker SWARM</li><li>Kubernetes<ul><li>轻量级</li><li>开源</li><li>弹性伸缩</li><li>负载均衡</li></ul></li></ul></li><li><p>组件说明</p><ul><li>APISERVER：所有服务访问统一接口</li><li>ControllerManager：维护副本期望数据</li><li>Scheduler：负责介绍任务，选择合适的节点进行分配任务</li><li>ETCD：键值对数据库，存储K8S集群所有重要信息（持久化）</li><li>Kubelet：直接跟容器引擎交互实现容器的生命周期管理</li><li>Kube-proxy：负责写入规则至IPTABLES，IPVS实现服务映射访问</li><li>COREDNS：可以为集群中的SVC创建一个域名IP的对应关系解析</li><li>DASHBOARD：给K8S集群提供一个B/S结构访问体系</li><li>INGRESS CONTROLLER：官方只能实现四层代理，INGRESS可以实现七层代理</li><li>FEDERATION：提供一个可以跨集群中心多K8S统一管理功能</li><li>PROMETHEUS：提供K8S集群的监控能力</li><li>ELK：提供K8S集群日志统一分析接入平台</li></ul></li><li><p>Pod概念</p><ul><li><p>自主式Pod</p></li><li><p>控制器管理的Pod </p><p>ReplicationController：用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代，而如果异常多出来的容器也会自动回收。</p><p>ReplicaSet：和ReplicationController没有本质不同，支持集合式的selector</p><p>Deployment：自动管理ReplicaSet，支持滚动更新</p><p>Horizontal Pod Autoscaling：仅适用于Deployment和ReplicaSet</p><p>StatefullSet：为了解决有状态服务的问题，应用场景包括：</p><ul><li>稳定的持久化存储</li><li>稳定的网络标志</li><li>有序部署，有序扩展</li><li>有序收缩，有序删除</li></ul><p>DaemonSet：确保全部（或者一些）Node上运行一个Pod的副本，当有Node加入集群时，也会为他们新增一个Pod，当有Node从集群中移除时，这些Pod也会被回收，删除DaemonSet将会删除它创建的所有Pod，使用DaemonSet的一些典型用法：</p><ul><li>运行集群存储daemon，例如在每个Node上运行glusterd，ceph</li><li>在每个Node上运行日志收集daemon，例如fluentd，logstash</li><li>在每个Node上运行监控daemon，例如Prometheus，Node Exporter</li></ul><p>Job：负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</p><p>Cron Job：管理基于时间的Job，即在给定时间点只运行一次，周期性地在给定时间点运行</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Docker容器数据卷&lt;/p&gt;
&lt;p&gt;需求：容器的持久化和同步操作，容器间也是可以数据共享
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="elssm.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言实现向kafka中发送数据</title>
    <link href="elssm.github.io/2021/03/21/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%90%91kafka%E4%B8%AD%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/"/>
    <id>elssm.github.io/2021/03/21/Go语言实现向kafka中发送数据/</id>
    <published>2021-03-21T09:31:02.000Z</published>
    <updated>2021-03-21T12:44:46.531Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>今天用go语言简单实现kafka发送文件示例。</p><h4 id="kafla和zookeeper搭建"><a href="#kafla和zookeeper搭建" class="headerlink" title="kafla和zookeeper搭建"></a>kafla和zookeeper搭建</h4><p>安装kafka之前首先要安装zookeeper。本次安装是在Mac os下实现，使用homebrew进行安装</p><h5 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zookeeper</span><br></pre></td></tr></table></figure><h5 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install kafka</span><br></pre></td></tr></table></figure><h4 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp;</span><br></pre></td></tr></table></figure><h4 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh kafka-server-start /usr/local/etc/kafka/server.properties &amp;</span><br></pre></td></tr></table></figure><h4 id="下载sarama"><a href="#下载sarama" class="headerlink" title="下载sarama"></a>下载sarama</h4><p>在下载sarama过程中遇到很多问题。使用go get命令会提示下面类似错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</span><br></pre></td></tr></table></figure><p>解决方法如下：</p><p>首先查看自己go的版本，我的是1.15，对于go版本1.13及以上采用如下两条命令</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> env -w GO!!!MODULE=on</span><br><span class="line"><span class="keyword">go</span> env -w GOPROXY=https:<span class="comment">//goproxy.io,direct</span></span><br></pre></td></tr></table></figure><p>对于其他版本请参考如下链接：<a href="https://www.jianshu.com/p/9a476a40e16e" target="_blank" rel="noopener">https://www.jianshu.com/p/9a476a40e16e</a></p><h4 id="kafka实例"><a href="#kafka实例" class="headerlink" title="kafka实例"></a>kafka实例</h4><p>创建main.go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/Shopify/sarama"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//kafka client demo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//生产者配置</span></span><br><span class="line">config := sarama.NewConfig()</span><br><span class="line">config.Producer.RequiredAcks = sarama.WaitForAll <span class="comment">//ACK</span></span><br><span class="line">config.Producer.Partitioner = sarama.NewRandomPartitioner <span class="comment">//分区</span></span><br><span class="line">config.Producer.Return.Successes = <span class="literal">true</span> <span class="comment">//确认</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接kafka</span></span><br><span class="line">client,err := sarama.NewSyncProducer([]<span class="keyword">string</span>&#123;<span class="string">"127.0.0.1:9092"</span>&#125;,config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"producer closed err :"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装消息</span></span><br><span class="line">msg := &amp;sarama.ProducerMessage&#123;&#125;</span><br><span class="line">msg.Topic = <span class="string">"shopping"</span></span><br><span class="line">msg.Value = sarama.StringEncoder(<span class="string">"this is a test log"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">pid,offset,err := client.SendMessage(msg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"send msg failed,err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"pid:%v offset:%v\n"</span>,pid,offset)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="文件打包"><a href="#文件打包" class="headerlink" title="文件打包"></a>文件打包</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>在打包过程中又遇到了一些问题，类似报错如下，大致原因就是因为我们上面采用了代理下载go包，开启了 GO111MODULE，导致包管理非官方所说的在GOPATH\src，而是去了GOPATH\src\pkg\目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot find module providing package github.com/xxx</span><br></pre></td></tr></table></figure><p>此时就需要用go mod引入这些包 require github.com/gin-gonic/gin@latest ，从而可以解决import获取不了包的问题。运行命令如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init gin</span><br><span class="line"><span class="keyword">go</span> mod edit -require github.com/gin-gonic/gin@latest</span><br></pre></td></tr></table></figure><p>成功打包之后执行命令</p><p><img src="/2021/03/21/Go语言实现向kafka中发送数据/1.png" alt="1"></p><h4 id="查看kafka日志"><a href="#查看kafka日志" class="headerlink" title="查看kafka日志"></a>查看kafka日志</h4><p>kafka日志文件在<code>/usr/local/var/lib/</code>目录下的<code>kafka-logs</code>中。<code>kafka-logs</code>文件夹下有一个<code>shopping-0</code>文件夹，这个就是我们在代码里设置的Topic，里面有四个文件，<code>.log</code>结尾的就是我们的日志文件。</p><p><img src="/2021/03/21/Go语言实现向kafka中发送数据/2.png" alt="2"></p><h4 id="消费者打印日志"><a href="#消费者打印日志" class="headerlink" title="消费者打印日志"></a>消费者打印日志</h4><h5 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh kafka-console-consumer --bootstrap-server localhost:<span class="number">9092</span> --topic shopping --from-beginning</span><br></pre></td></tr></table></figure><h5 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h5><p><img src="/2021/03/21/Go语言实现向kafka中发送数据/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;今天用go语言简单实现kafka发送文件示例。&lt;/p&gt;
&lt;h4 id=&quot;kafla和zookeeper搭建&quot;&gt;&lt;a href=&quot;#kafla
      
    
    </summary>
    
    
      <category term="代码" scheme="elssm.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Go实现聊天室</title>
    <link href="elssm.github.io/2021/03/17/Go%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>elssm.github.io/2021/03/17/Go实现聊天室/</id>
    <published>2021-03-17T11:17:00.000Z</published>
    <updated>2021-03-17T14:45:44.805Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>用Go语言简单实现一个网络聊天室，首先创建一个chatroom的文件夹，在文件夹下创建<code>chatroom.go</code>文件。</p><h4 id="建立tcp-socket连接"><a href="#建立tcp-socket连接" class="headerlink" title="建立tcp socket连接"></a>建立tcp socket连接</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有代码写在一个文件中，不做代码整理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">":8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"服务器启动成功!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"=======&gt;主go程监听中..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listener.Accept err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">fmt.Println(<span class="string">"建立连接成功！"</span>)</span><br><span class="line"><span class="comment">//启动处理业务的go程</span></span><br><span class="line"><span class="keyword">go</span> handler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"启动业务..."</span>)</span><br><span class="line"><span class="comment">//TODO //代表这里以后再实现</span></span><br><span class="line">buf :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取客户端发送过来的数据</span></span><br><span class="line">cnt,err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn.Read err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"服务器接受客户端发送过来的数据为："</span>,<span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]),<span class="string">",cnt: "</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run chatroom.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/1.png" alt="1"></p><p>nc连接</p><p><img src="/2021/03/17/Go实现聊天室/2.png" alt="2"></p><p><img src="/2021/03/17/Go实现聊天室/3.png" alt="3"></p><h4 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h4><p>我们程序中有一个主go程，负责监听。客户端以一种数据流的形式建立连接，这个时候服务器就会启动一个<code>handler()</code> go程，在<code>handler()</code> go程中可以接受来自客户端发送的消息。这个时候服务器就应该把消息告诉所有人，因此我们应该在<code>handler()</code>中创建一个通道，它要将消息写入到公共通道message中，这个时候会有另外一个go程，它负责监听message，当message中有数据时，它会将数据发送给所有的用户。对于user用户的创建我们需要在<code>handler()</code>中实现，并将user添加到map中，每个用户都有一个自己的msg管道，当需要发送消息给所有用户的时候，go程会遍历用户map，并将消息写入每个用户的管道中。这个时候，每个用户的管道里都会有来自公共管道的message。之后我们再启动一个go程。每个用户都会拥有这个go程，负责将用户自己的msg回写给终端。</p><h4 id="定义User和map结构"><a href="#定义User和map结构" class="headerlink" title="定义User和map结构"></a>定义User和map结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">id <span class="keyword">string</span></span><br><span class="line">msg <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个全局的map结构，用于保存所有的用户</span></span><br><span class="line"><span class="keyword">var</span> allUsers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]User)</span><br></pre></td></tr></table></figure><p>在handler中调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端与服务器建立连接的时候，会有ip和port，因此将port当成user id</span></span><br><span class="line"><span class="comment">//创建user</span></span><br><span class="line">clientAddr := conn.RemoteAddr().String()</span><br><span class="line"><span class="comment">//fmt.Println("chiientAddr: ",clientAddr[10:])</span></span><br><span class="line">newUser := User&#123;</span><br><span class="line">  name: <span class="string">"虎扑JR"</span>+clientAddr[<span class="number">10</span>:],<span class="comment">//可以修改，会提供rename命令修改</span></span><br><span class="line">  id: clientAddr, <span class="comment">//id不会修改，作为map中的key</span></span><br><span class="line">  msg: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>),<span class="comment">//注意要make空间，否则无法写数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加user到map结构</span></span><br><span class="line">allUsers[newUser.id] = newUser</span><br></pre></td></tr></table></figure><h4 id="定义message通道"><a href="#定义message通道" class="headerlink" title="定义message通道"></a>定义message通道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个message全局通道，用接收任何人发送过来的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="创建监听广播go程函数"><a href="#创建监听广播go程函数" class="headerlink" title="创建监听广播go程函数"></a>创建监听广播go程函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向所有的用户广播消息，启动一个全局唯一的go程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"广播go程启动成功..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.从message中读取数据</span></span><br><span class="line">info := &lt;- message</span><br><span class="line"><span class="comment">//2.将数据写入到每一个用户的msg管道中</span></span><br><span class="line"><span class="keyword">for</span> _,user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line">user.msg &lt;- info</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动广播go程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动全局唯一的go程，负责监听message通道，写给所有的用户</span></span><br><span class="line"><span class="keyword">go</span> broadcast()</span><br></pre></td></tr></table></figure><p>写入上线数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向message写入数据，当前用户上线的消息，用于通知所有人</span></span><br><span class="line">loginInfo := fmt.Sprintf(<span class="string">"[%s]:[%s] ===&gt; 上线了login！！"</span>,newUser.id,newUser.name)</span><br><span class="line">message &lt;- loginInfo</span><br></pre></td></tr></table></figure><p>当前完整代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有代码写在一个文件中，不做代码整理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">id <span class="keyword">string</span></span><br><span class="line">msg <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个全局的map结构，用于保存所有的用户</span></span><br><span class="line"><span class="keyword">var</span> allUsers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]User)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个message全局通道，用接收任何人发送过来的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">":8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动全局唯一的go程，负责监听message通道，写给所有的用户</span></span><br><span class="line"><span class="keyword">go</span> broadcast()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"服务器启动成功!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"=======&gt;主go程监听中..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listener.Accept err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">fmt.Println(<span class="string">"建立连接成功！"</span>)</span><br><span class="line"><span class="comment">//启动处理业务的go程</span></span><br><span class="line"><span class="keyword">go</span> handler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"启动业务..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端与服务器建立连接的时候，会有ip和port，因此将port当成user id</span></span><br><span class="line"><span class="comment">//创建user</span></span><br><span class="line">clientAddr := conn.RemoteAddr().String()</span><br><span class="line"><span class="comment">//fmt.Println("chiientAddr: ",clientAddr[10:])</span></span><br><span class="line">newUser := User&#123;</span><br><span class="line">name: <span class="string">"虎扑JR"</span>+clientAddr[<span class="number">10</span>:],<span class="comment">//可以修改，会提供rename命令修改</span></span><br><span class="line">id: clientAddr, <span class="comment">//id不会修改，作为map中的key</span></span><br><span class="line">msg: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>),<span class="comment">//注意要make空间，否则无法写数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加user到map结构</span></span><br><span class="line">allUsers[newUser.id] = newUser</span><br><span class="line"></span><br><span class="line"><span class="comment">//向message写入数据，当前用户上线的消息，用于通知所有人</span></span><br><span class="line">loginInfo := fmt.Sprintf(<span class="string">"[%s]:[%s] ===&gt; 上线了login！！"</span>,newUser.id,newUser.name)</span><br><span class="line">message &lt;- loginInfo</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取客户端发送过来的数据</span></span><br><span class="line">cnt,err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn.Read err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"服务器接受客户端发送过来的数据为："</span>,<span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]),<span class="string">",cnt: "</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向所有的用户广播消息，启动一个全局唯一的go程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"广播go程启动成功..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.从message中读取数据</span></span><br><span class="line">info := &lt;-message</span><br><span class="line">fmt.Println(<span class="string">"message接收到的消息："</span>, info)</span><br><span class="line"><span class="comment">//2.将数据写入到每一个用户的msg管道中</span></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line"><span class="comment">//如果msg是非缓冲的，那么会在这里阻塞</span></span><br><span class="line">user.msg &lt;- info</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/4.png" alt="4"></p><p><img src="/2021/03/17/Go实现聊天室/5.png" alt="5"></p><h4 id="User监听通道go程"><a href="#User监听通道go程" class="headerlink" title="User监听通道go程"></a>User监听通道go程</h4><p>每个用户应该还有一个用来监听自己msg管道的go程，负责将数据返回给客户端。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每个用户应该还有一个用来监听自己msg管道的go程，负责将数据返回给客户端。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeBackToClient</span><span class="params">(user *User,conn net.Conn)</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user ： %s的go程正在监听自己的msg管道\n"</span>,user.name)</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> user.msg &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user:%s写回给客户端的数据为:%s\n"</span>,user.name,data)</span><br><span class="line">_,_ = conn.Write([]<span class="keyword">byte</span>(data+<span class="string">"\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前完整代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有代码写在一个文件中，不做代码整理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">id <span class="keyword">string</span></span><br><span class="line">msg <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个全局的map结构，用于保存所有的用户</span></span><br><span class="line"><span class="keyword">var</span> allUsers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]User)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个message全局通道，用接收任何人发送过来的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">":8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动全局唯一的go程，负责监听message通道，写给所有的用户</span></span><br><span class="line"><span class="keyword">go</span> broadcast()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"服务器启动成功!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"=======&gt;主go程监听中..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listener.Accept err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">fmt.Println(<span class="string">"建立连接成功！"</span>)</span><br><span class="line"><span class="comment">//启动处理业务的go程</span></span><br><span class="line"><span class="keyword">go</span> handler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"启动业务..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端与服务器建立连接的时候，会有ip和port，因此将port当成user id</span></span><br><span class="line"><span class="comment">//创建user</span></span><br><span class="line">clientAddr := conn.RemoteAddr().String()</span><br><span class="line"><span class="comment">//fmt.Println("chiientAddr: ",clientAddr[10:])</span></span><br><span class="line">newUser := User&#123;</span><br><span class="line">name: <span class="string">"虎扑JR"</span>+clientAddr[<span class="number">10</span>:],<span class="comment">//可以修改，会提供rename命令修改</span></span><br><span class="line">id: clientAddr, <span class="comment">//id不会修改，作为map中的key</span></span><br><span class="line">msg: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>),<span class="comment">//注意要make空间，否则无法写数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加user到map结构</span></span><br><span class="line">allUsers[newUser.id] = newUser</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动go程，负责将msg数据返回给客户端</span></span><br><span class="line"><span class="keyword">go</span> writeBackToClient(&amp;newUser,conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">//向message写入数据，当前用户上线的消息，用于通知所有人</span></span><br><span class="line">loginInfo := fmt.Sprintf(<span class="string">"[%s]:[%s] ===&gt; 上线了login！！"</span>,newUser.id,newUser.name)</span><br><span class="line">message &lt;- loginInfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//具体业务逻辑</span></span><br><span class="line">buf :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取客户端发送过来的数据</span></span><br><span class="line">cnt,err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn.Read err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"服务器接受客户端发送过来的数据为："</span>,<span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]),<span class="string">",cnt: "</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向所有的用户广播消息，启动一个全局唯一的go程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"广播go程启动成功..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.从message中读取数据</span></span><br><span class="line">info := &lt;-message</span><br><span class="line">fmt.Println(<span class="string">"message接收到的消息："</span>, info)</span><br><span class="line"><span class="comment">//2.将数据写入到每一个用户的msg管道中</span></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line"><span class="comment">//如果msg是非缓冲的，那么会在这里阻塞</span></span><br><span class="line">user.msg &lt;- info</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个用户应该还有一个用来监听自己msg管道的go程，负责将数据返回给客户端。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeBackToClient</span><span class="params">(user *User,conn net.Conn)</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user ： %s的go程正在监听自己的msg管道\n"</span>,user.name)</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> user.msg &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user:%s写回给客户端的数据为:%s\n"</span>,user.name,data)</span><br><span class="line">_,_ = conn.Write([]<span class="keyword">byte</span>(data+<span class="string">"\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/7.png" alt="7"></p><p><img src="/2021/03/17/Go实现聊天室/6.png" alt="6"></p><h4 id="增加功能"><a href="#增加功能" class="headerlink" title="增加功能"></a>增加功能</h4><h5 id="查询用户"><a href="#查询用户" class="headerlink" title="查询用户"></a>查询用户</h5><p>查询命令：who 将当前所有登陆的用户，展示出来，id，name返回给当前用户</p><p>在handler中处理业务逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.查询当前所有的用户 who</span></span><br><span class="line"><span class="comment">//判断接受的数据是不是who ==&gt; 长度&amp;字符串</span></span><br><span class="line">userInput := <span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]) <span class="comment">//这是用户输入的数据，最后一个是回车，去掉回车</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userInput)==<span class="number">3</span> &amp;&amp; userInput == <span class="string">"who"</span> &#123;</span><br><span class="line"><span class="comment">//遍历allUsers这个map：（key: userid value：user本身）</span></span><br><span class="line">fmt.Println(<span class="string">"用户即将查询所有用户信息！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个切片包含所有的用户信息</span></span><br><span class="line"><span class="keyword">var</span> userInfos []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line">userInfo := fmt.Sprintf(<span class="string">"userid:%s,username:%s"</span>,user.id,user.name)</span><br><span class="line">userInfos = <span class="built_in">append</span>(userInfos,userInfo )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终写到管道中，一定是一个字符串</span></span><br><span class="line">r := strings.Join(userInfos,<span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">//将数据返回给查询的客户端</span></span><br><span class="line">newUser.msg &lt;- r</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果用户输入的不是命令，只是普通的聊天信息，那么只需要写入到广播通道中，由其他的go程进行常规转发</span></span><br><span class="line">message &lt;- userInput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/8.png" alt="8"></p><h5 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(userInput) &gt;<span class="number">9</span> &amp;&amp; userInput[:<span class="number">7</span>]==<span class="string">"\\rename"</span> &#123;</span><br><span class="line"><span class="comment">//规则：rename|ddd</span></span><br><span class="line"><span class="comment">//读取数据判断长度，判断字符是rename</span></span><br><span class="line"><span class="comment">//使用|分割，获取|后面的内容，作为名字</span></span><br><span class="line"><span class="comment">//更新用户名字 newUser.name = ddd</span></span><br><span class="line">newUser.name = strings.Split(userInput,<span class="string">"|"</span>)[<span class="number">1</span>]</span><br><span class="line">allUsers[newUser.id] = newUser <span class="comment">//更新map中的user</span></span><br><span class="line"><span class="comment">//通知客户端，更新成功</span></span><br><span class="line">newUser.msg &lt;- <span class="string">"rename successfully!"</span></span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/9.png" alt="9"></p><h5 id="主动退出"><a href="#主动退出" class="headerlink" title="主动退出"></a>主动退出</h5><p>从map中删除，对应的conn要close</p><p>每个用户都有自己的watch go程，负责监听退出信号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动一个go程，负责监听退出信号，触发后进行清理工作：delete map，close conn都在这里处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(user *User,conn net.Conn,isQuit &lt;- <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"启动监听退出信号的go程..."</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"watch go程退出！"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- isQuit:</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s exit already!"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler函数中定义isQuit</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个退出信号，用户监听client退出</span></span><br><span class="line"><span class="keyword">var</span> isQuit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br></pre></td></tr></table></figure><p>在handler中启动go watch，同时传入相应信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动go程，负责监听退出信号</span></span><br><span class="line"><span class="keyword">go</span> watch(&amp;newUser,conn,isQuit)</span><br></pre></td></tr></table></figure><p>在<code>conn.Read(buf)</code>之后，通过读取的cnt判断用户退出，如果是ctrl+c主动退出，则触发isQuit</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cnt == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"客户端主动关闭ctrl+c，准备退出！"</span>)</span><br><span class="line"><span class="comment">//map删除用户，conn close</span></span><br><span class="line"><span class="comment">//服务器还可以主动的退出</span></span><br><span class="line"><span class="comment">//在这里不进行真正的退出动作，而是发送一个退出信号，统一做退出处理，可以使用新的管道做信号传递</span></span><br><span class="line">isQuit &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/17/Go实现聊天室/10.png" alt="10"></p><p><img src="/2021/03/17/Go实现聊天室/11.png" alt="11"></p><h5 id="超时退出"><a href="#超时退出" class="headerlink" title="超时退出"></a>超时退出</h5><p>使用定时器来进行超时管理。如果60s内没有发送任何数据，那么直接将这个连接关闭掉</p><p>更新watch函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动一个go程，负责监听退出信号，触发后进行清理工作：delete map，close conn都在这里处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(user *User,conn net.Conn,isQuit &lt;- <span class="keyword">chan</span> <span class="keyword">bool</span>,restTimer &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"启动监听退出信号的go程..."</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"watch go程退出！"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- isQuit:</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s exit already!\n"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;- time.After(<span class="number">10</span>*time.Second):</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s timeout exit already!\n"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;- restTimer:</span><br><span class="line">fmt.Printf(<span class="string">"连接%s 重置计数器！\n"</span>,user.name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建并传入restTimer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个用于重置计数器的管道，用于告知watch函数，当前用户正在输入</span></span><br><span class="line"><span class="keyword">var</span> restTimer = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//启动go程，负责监听退出信号</span></span><br><span class="line"><span class="keyword">go</span> watch(&amp;newUser,conn,isQuit,restTimer)</span><br></pre></td></tr></table></figure><p>只要有数据写入，每次写入数据之后都要设置restTimer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restTimer &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="聊天室完整代码"><a href="#聊天室完整代码" class="headerlink" title="聊天室完整代码"></a>聊天室完整代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有代码写在一个文件中，不做代码整理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">id <span class="keyword">string</span></span><br><span class="line">msg <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个全局的map结构，用于保存所有的用户</span></span><br><span class="line"><span class="keyword">var</span> allUsers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]User)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个message全局通道，用接收任何人发送过来的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line">listener,err := net.Listen(<span class="string">"tcp"</span>,<span class="string">":8080"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"net.Listen err:"</span>,err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动全局唯一的go程，负责监听message通道，写给所有的用户</span></span><br><span class="line"><span class="keyword">go</span> broadcast()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"服务器启动成功!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"=======&gt;主go程监听中..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listener.Accept err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">fmt.Println(<span class="string">"建立连接成功！"</span>)</span><br><span class="line"><span class="comment">//启动处理业务的go程</span></span><br><span class="line"><span class="keyword">go</span> handler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理具体业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(conn net.Conn)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"启动业务..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端与服务器建立连接的时候，会有ip和port，因此将port当成user id</span></span><br><span class="line"><span class="comment">//创建user</span></span><br><span class="line">clientAddr := conn.RemoteAddr().String()</span><br><span class="line"><span class="comment">//fmt.Println("chiientAddr: ",clientAddr[10:])</span></span><br><span class="line">newUser := User&#123;</span><br><span class="line">name: <span class="string">"虎扑JR"</span>+clientAddr[<span class="number">10</span>:],<span class="comment">//可以修改，会提供rename命令修改</span></span><br><span class="line">id: clientAddr, <span class="comment">//id不会修改，作为map中的key</span></span><br><span class="line">msg: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>),<span class="comment">//注意要make空间，否则无法写数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加user到map结构</span></span><br><span class="line">allUsers[newUser.id] = newUser</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个退出信号，用户监听client退出</span></span><br><span class="line"><span class="keyword">var</span> isQuit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//创建一个用于重置计数器的管道，用于告知watch函数，当前用户正在输入</span></span><br><span class="line"><span class="keyword">var</span> restTimer = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//启动go程，负责监听退出信号</span></span><br><span class="line"><span class="keyword">go</span> watch(&amp;newUser,conn,isQuit,restTimer)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动go程，负责将msg数据返回给客户端</span></span><br><span class="line"><span class="keyword">go</span> writeBackToClient(&amp;newUser,conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">//向message写入数据，当前用户上线的消息，用于通知所有人</span></span><br><span class="line">loginInfo := fmt.Sprintf(<span class="string">"[%s]:[%s] ===&gt; 上线了login！！\n"</span>,newUser.id,newUser.name)</span><br><span class="line">message &lt;- loginInfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//具体业务逻辑</span></span><br><span class="line">buf :=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取客户端发送过来的数据</span></span><br><span class="line">cnt,err := conn.Read(buf)</span><br><span class="line"><span class="keyword">if</span> cnt == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"客户端主动关闭ctrl+c，准备退出！"</span>)</span><br><span class="line"><span class="comment">//map删除用户，conn close</span></span><br><span class="line"><span class="comment">//服务器还可以主动的退出</span></span><br><span class="line"><span class="comment">//在这里不进行真正的退出动作，而是发送一个退出信号，统一做退出处理，可以使用新的管道做信号传递</span></span><br><span class="line">isQuit &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"conn.Read err:"</span>,err,<span class="string">",cnt:"</span>,cnt)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"服务器接受客户端发送过来的数据为："</span>,<span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]),<span class="string">",cnt: "</span>,cnt)</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务逻辑处理 开始-----------</span></span><br><span class="line"><span class="comment">//1.查询当前所有的用户 who</span></span><br><span class="line"><span class="comment">//判断接受的数据是不是who ==&gt; 长度&amp;字符串</span></span><br><span class="line">userInput := <span class="keyword">string</span>(buf[:cnt<span class="number">-1</span>]) <span class="comment">//这是用户输入的数据，最后一个是回车，去掉回车</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(userInput)==<span class="number">4</span> &amp;&amp; userInput == <span class="string">"\\who"</span> &#123;</span><br><span class="line"><span class="comment">//遍历allUsers这个map：（key: userid value：user本身）</span></span><br><span class="line">fmt.Println(<span class="string">"用户即将查询所有用户信息！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个切片包含所有的用户信息</span></span><br><span class="line"><span class="keyword">var</span> userInfos []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _,user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line">userInfo := fmt.Sprintf(<span class="string">"userid:%s,username:%s"</span>,user.id,user.name)</span><br><span class="line">userInfos = <span class="built_in">append</span>(userInfos,userInfo )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终写到管道中，一定是一个字符串</span></span><br><span class="line">r := strings.Join(userInfos,<span class="string">"\n"</span>) <span class="comment">//连接数字切片，生成字符串</span></span><br><span class="line"><span class="comment">//将数据返回给查询的客户端</span></span><br><span class="line">newUser.msg &lt;- r</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(userInput) &gt;<span class="number">9</span> &amp;&amp; userInput[:<span class="number">7</span>]==<span class="string">"\\rename"</span> &#123;</span><br><span class="line"><span class="comment">//规则：rename|ddd</span></span><br><span class="line"><span class="comment">//读取数据判断长度，判断字符是rename</span></span><br><span class="line"><span class="comment">//使用|分割，获取|后面的内容，作为名字</span></span><br><span class="line"><span class="comment">//更新用户名字 newUser.name = ddd</span></span><br><span class="line">newUser.name = strings.Split(userInput,<span class="string">"|"</span>)[<span class="number">1</span>]</span><br><span class="line">allUsers[newUser.id] = newUser <span class="comment">//更新map中的user</span></span><br><span class="line"><span class="comment">//通知客户端，更新成功</span></span><br><span class="line">newUser.msg &lt;- <span class="string">"rename successfully!"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果用户输入的不是命令，只是普通的聊天信息，那么只需要写入到广播通道中，由其他的go程进行常规转发</span></span><br><span class="line">message &lt;- userInput</span><br><span class="line">&#125;</span><br><span class="line">restTimer &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务逻辑处理 结束-----------</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向所有的用户广播消息，启动一个全局唯一的go程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"广播go程启动成功..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.从message中读取数据</span></span><br><span class="line">info := &lt;-message</span><br><span class="line">fmt.Println(<span class="string">"message接收到的消息："</span>, info)</span><br><span class="line"><span class="comment">//2.将数据写入到每一个用户的msg管道中</span></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> allUsers &#123;</span><br><span class="line"><span class="comment">//如果msg是非缓冲的，那么会在这里阻塞</span></span><br><span class="line">user.msg &lt;- info</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个用户应该还有一个用来监听自己msg管道的go程，负责将数据返回给客户端。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeBackToClient</span><span class="params">(user *User,conn net.Conn)</span></span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user ： %s的go程正在监听自己的msg管道\n"</span>,user.name)</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> user.msg &#123;</span><br><span class="line">fmt.Printf(<span class="string">"user:%s写回给客户端的数据为:%s\n"</span>,user.name,data)</span><br><span class="line">_,_ = conn.Write([]<span class="keyword">byte</span>(data+<span class="string">"\n"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动一个go程，负责监听退出信号，触发后进行清理工作：delete map，close conn都在这里处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(user *User,conn net.Conn,isQuit &lt;- <span class="keyword">chan</span> <span class="keyword">bool</span>,restTimer &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"启动监听退出信号的go程..."</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"watch go程退出！"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- isQuit:</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s exit already!\n"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;- time.After(<span class="number">10</span>*time.Second):</span><br><span class="line">logoutInfo := fmt.Sprintf(<span class="string">"%s timeout exit already!\n"</span>,user.name)</span><br><span class="line">fmt.Println(<span class="string">"删除当前用户："</span>,user.name)</span><br><span class="line"><span class="built_in">delete</span>(allUsers,user.id)</span><br><span class="line">message &lt;- logoutInfo</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;- restTimer:</span><br><span class="line">fmt.Printf(<span class="string">"连接%s 重置计数器！\n"</span>,user.name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;用Go语言简单实现一个网络聊天室，首先创建一个chatroom的文件夹，在文件夹下创建&lt;code&gt;chatroom.go&lt;/code&gt;文件。
      
    
    </summary>
    
    
      <category term="代码" scheme="elssm.github.io/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>利用FGSM攻击MNIST数据集(Pytorch)</title>
    <link href="elssm.github.io/2021/03/15/%E5%88%A9%E7%94%A8FGSM%E6%94%BB%E5%87%BBMNIST%E6%95%B0%E6%8D%AE%E9%9B%86-Pytorch/"/>
    <id>elssm.github.io/2021/03/15/利用FGSM攻击MNIST数据集-Pytorch/</id>
    <published>2021-03-15T06:37:09.000Z</published>
    <updated>2021-03-15T08:38:03.939Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>FGSM的全称是Fast Gradient Sign Method(快速梯度下降法），在白盒环境下，通过求出模型对输入的导数，然后用符号函数得到其具体的梯度方向，接着乘以一个步长，得到的“扰动”加在原来的输入 上就得到了在FGSM攻击下的样本。本文将实现在Pytorch框架下使用FGSM攻击MNIST数据集</p><h4 id="训练模型的保存"><a href="#训练模型的保存" class="headerlink" title="训练模型的保存"></a>训练模型的保存</h4><p>通过之前MNIST识别的代码实现，我们就可以实现模型的保存。只需要在最后加上一行代码即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), <span class="string">"mnist_model.pth"</span>)</span><br></pre></td></tr></table></figure><p>save函数有两个参数，第一个参数是模型的状态。其中<code>model.state_dict()</code>只保存模型权重参数，不保存模型结构，而<code>model</code>则保存整个模型的状态。这里我们使用<code>model.state_dict()</code>，第二个参数是路径和保存的文件名。这里我们保存在同级目录下，文件名是<code>mnist_model.pth</code></p><p>训练模型完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">epochs = <span class="number">5</span></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">test_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">20</span>*<span class="number">10</span>*<span class="number">10</span>,<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">500</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        input_size = x.size(<span class="number">0</span>) <span class="comment">#获取batch_size</span></span><br><span class="line">        x = self.conv1(x) <span class="comment">#卷积</span></span><br><span class="line">        x = F.relu(x) <span class="comment">#激活</span></span><br><span class="line">        x = F.max_pool2d(x,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">#池化</span></span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)  <span class="comment"># 激活</span></span><br><span class="line">        x = x.view(input_size,<span class="number">-1</span>) <span class="comment">#拉平</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x,dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line">optimizer = optim.Adam(model.parameters())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,epoch)</span>:</span></span><br><span class="line">    <span class="comment">#模型训练</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_index,(data,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment">#梯度初始化为0</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment">#预测</span></span><br><span class="line">        output = model(data)</span><br><span class="line">        <span class="comment">#计算损失</span></span><br><span class="line">        loss = F.cross_entropy(output,target)</span><br><span class="line">        <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">        <span class="comment"># pred = output.max(1,keepdim=True)</span></span><br><span class="line">        <span class="comment">#反向传播</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_index % <span class="number">600</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epoch,loss.item()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader)</span>:</span></span><br><span class="line">    <span class="comment">#模型验证</span></span><br><span class="line">    model.eval()</span><br><span class="line">    <span class="comment">#正确率</span></span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">#测试损失</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():<span class="comment">#不会计算梯度也不会进行反向传播</span></span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> test_loader:</span><br><span class="line">            <span class="comment">#测试数据</span></span><br><span class="line">            output = model(data)</span><br><span class="line">            <span class="comment">#计算测试损失</span></span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>] <span class="comment">#值 索引</span></span><br><span class="line">            <span class="comment">#pred = torch.max(output,dim=1)</span></span><br><span class="line">            <span class="comment">#pred = output.argmax(dim=1)</span></span><br><span class="line">            <span class="comment">#累计正确率</span></span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(test_loader.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(test_loader.dataset)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>,epochs+<span class="number">1</span>):</span><br><span class="line">    train_model(model,train_loader,optimizer,epoch)</span><br><span class="line">    test_model(model,test_loader)</span><br><span class="line">torch.save(model.state_dict(), <span class="string">"mnist_model.pth"</span>)</span><br></pre></td></tr></table></figure><h4 id="攻击代码"><a href="#攻击代码" class="headerlink" title="攻击代码"></a>攻击代码</h4><h5 id="相关模块的导入"><a href="#相关模块的导入" class="headerlink" title="相关模块的导入"></a>相关模块的导入</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>可能遇到的错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OMP: Error <span class="comment">#15: Initializing libomp.dylib, but found libiomp5.dylib already initialized.</span></span><br><span class="line">OMP: Hint This means that multiple copies of the OpenMP runtime have been linked into the program. That <span class="keyword">is</span> dangerous, since it can degrade performance <span class="keyword">or</span> cause incorrect results. The best thing to do <span class="keyword">is</span> to ensure that only a single OpenMP runtime <span class="keyword">is</span> linked into the process, e.g. by avoiding static linking of the OpenMP runtime <span class="keyword">in</span> any library. As an unsafe, unsupported, undocumented workaround you can set the environment variable KMP_DUPLICATE_LIB_OK=TRUE to allow the program to <span class="keyword">continue</span> to execute, but that may cause crashes <span class="keyword">or</span> silently produce incorrect results. For more information, please see http://openmp.llvm.org/</span><br></pre></td></tr></table></figure><p>解决方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"KMP_DUPLICATE_LIB_OK"</span>]=<span class="string">"TRUE"</span></span><br></pre></td></tr></table></figure><h5 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h5><p>其中epsilons是FGSM攻击所加的扰动，值不超过1。pretrained_model是预训练模型，也就是我们上面保存的训练模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epsilons = [<span class="number">0</span>, <span class="number">.05</span>, <span class="number">.1</span>, <span class="number">.15</span>, <span class="number">.2</span>, <span class="number">.25</span>, <span class="number">.3</span>]</span><br><span class="line">pretrained_model = <span class="string">"mnist_model.pth"</span></span><br></pre></td></tr></table></figure><h5 id="定义受攻击的模型"><a href="#定义受攻击的模型" class="headerlink" title="定义受攻击的模型"></a>定义受攻击的模型</h5><p>这里的模型与我们上面MNIST识别所定义的模型相同。我们使用两个卷积层和两个全连接层，具体定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">20</span>*<span class="number">10</span>*<span class="number">10</span>,<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">500</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        input_size = x.size(<span class="number">0</span>) <span class="comment">#获取batch_size</span></span><br><span class="line">        x = self.conv1(x) <span class="comment">#卷积</span></span><br><span class="line">        x = F.relu(x) <span class="comment">#激活</span></span><br><span class="line">        x = F.max_pool2d(x,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">#池化</span></span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)  <span class="comment"># 激活</span></span><br><span class="line">        x = x.view(input_size,<span class="number">-1</span>) </span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x,dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h5 id="加载测试集"><a href="#加载测试集" class="headerlink" title="加载测试集"></a>加载测试集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_loader = DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">'data'</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            ])),</span><br><span class="line">        batch_size=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h5 id="实例化模型"><a href="#实例化模型" class="headerlink" title="实例化模型"></a>实例化模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = Net()</span><br></pre></td></tr></table></figure><h5 id="加载预训练模型"><a href="#加载预训练模型" class="headerlink" title="加载预训练模型"></a>加载预训练模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.load_state_dict(torch.load(pretrained_model))</span><br></pre></td></tr></table></figure><h5 id="定义模型的评估模式"><a href="#定义模型的评估模式" class="headerlink" title="定义模型的评估模式"></a>定义模型的评估模式</h5><p>这里设置eval进行训练默认不开启Dropout和BatchNormalization</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.eval()</span><br></pre></td></tr></table></figure><h5 id="定义FGSM攻击模型"><a href="#定义FGSM攻击模型" class="headerlink" title="定义FGSM攻击模型"></a>定义FGSM攻击模型</h5><p>在FGSM攻击模型函数中一共有3个参数，第一个参数是原始图片，第二个参数是攻击的扰动量，一般在0～1之间，第三个参数是图像关于求导之后的损失。最后由于对抗样本可能会在（0，1）范围之外，所以通过clamp函数将加扰动之后的图片限制在（0，1）之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fgsm_attack</span><span class="params">(image, epsilon, data_grad)</span>:</span></span><br><span class="line">    sign_data_grad = data_grad.sign()</span><br><span class="line">    perturbed_image = image + epsilon*sign_data_grad</span><br><span class="line">    perturbed_image = torch.clamp(perturbed_image, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> perturbed_image</span><br></pre></td></tr></table></figure><h5 id="定义测试函数"><a href="#定义测试函数" class="headerlink" title="定义测试函数"></a>定义测试函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">( model, test_loader, epsilon )</span>:</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    adv_examples = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data.requires_grad = <span class="literal">True</span> <span class="comment">#开启自动求导</span></span><br><span class="line">        output = model(data)</span><br><span class="line">        init_pred = output.max(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">        <span class="keyword">if</span> init_pred.item() != target.item():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        loss = F.nll_loss(output, target) <span class="comment">#计算损失</span></span><br><span class="line">        model.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line"></span><br><span class="line">        data_grad = data.grad.data</span><br><span class="line">        perturbed_data = fgsm_attack(data, epsilon, data_grad)</span><br><span class="line"></span><br><span class="line">        output = model(perturbed_data) <span class="comment">#对加扰后的图片进行重新分类</span></span><br><span class="line"></span><br><span class="line">        final_pred = output.max(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line">        <span class="keyword">if</span> final_pred.item() == target.item():</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">            <span class="comment">#添加当epsilon为0的时候的5个对抗案例</span></span><br><span class="line">            <span class="keyword">if</span> (epsilon == <span class="number">0</span>) <span class="keyword">and</span> (len(adv_examples) &lt; <span class="number">5</span>):</span><br><span class="line">                adv_ex = perturbed_data.squeeze().detach().cpu().numpy()</span><br><span class="line">                adv_examples.append( (init_pred.item(), final_pred.item(), adv_ex))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(adv_examples) &lt; <span class="number">5</span>:</span><br><span class="line">                adv_ex = perturbed_data.squeeze().detach().cpu().numpy()</span><br><span class="line">                adv_examples.append( (init_pred.item(), final_pred.item(), adv_ex))</span><br><span class="line"></span><br><span class="line">    final_acc = correct/float(len(test_loader))</span><br><span class="line">    print(<span class="string">"Epsilon: &#123;&#125;\tTest Accuracy = &#123;&#125; / &#123;&#125; = &#123;&#125;"</span>.format(epsilon, correct, len(test_loader), final_acc))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回最终准确率和对抗案例</span></span><br><span class="line">    <span class="keyword">return</span> final_acc, adv_examples</span><br></pre></td></tr></table></figure><h5 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">accuracies = [] <span class="comment">#记录准确率</span></span><br><span class="line">examples = [] <span class="comment">#记录对抗攻击实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#针对每一个对抗扰动值进行一次训练</span></span><br><span class="line"><span class="keyword">for</span> eps <span class="keyword">in</span> epsilons:</span><br><span class="line">    acc, ex = test(model, test_loader, eps)</span><br><span class="line">    accuracies.append(acc)</span><br><span class="line">    examples.append(ex)</span><br></pre></td></tr></table></figure><h5 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h5><p><img src="/2021/03/15/利用FGSM攻击MNIST数据集-Pytorch/1.png" alt="1"></p><p>画出随着扰动值变化的准确率图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.plot(epsilons, accuracies, <span class="string">"*-"</span>)</span><br><span class="line">plt.yticks(np.arange(<span class="number">0</span>, <span class="number">1.1</span>, step=<span class="number">0.1</span>))</span><br><span class="line">plt.xticks(np.arange(<span class="number">0</span>, <span class="number">.35</span>, step=<span class="number">0.05</span>))</span><br><span class="line">plt.title(<span class="string">"Accuracy vs Epsilon"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Epsilon"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Accuracy"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/03/15/利用FGSM攻击MNIST数据集-Pytorch/2.png" alt="2"></p><p>画出在不同扰动值下对抗实例图，每个扰动值对应5张照片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">0</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(epsilons)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(examples[i])):</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        plt.subplot(len(epsilons),len(examples[<span class="number">0</span>]),cnt)</span><br><span class="line">        plt.xticks([], [])</span><br><span class="line">        plt.yticks([], [])</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">            plt.ylabel(<span class="string">"Eps: &#123;&#125;"</span>.format(epsilons[i]), fontsize=<span class="number">14</span>)</span><br><span class="line">        orig,adv,ex = examples[i][j]</span><br><span class="line">        plt.title(<span class="string">"&#123;&#125; -&gt; &#123;&#125;"</span>.format(orig, adv))</span><br><span class="line">        plt.imshow(ex, cmap=<span class="string">"gray"</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2021/03/15/利用FGSM攻击MNIST数据集-Pytorch/3.png" alt="3"></p><h4 id="FGSM攻击MNIST完整代码"><a href="#FGSM攻击MNIST完整代码" class="headerlink" title="FGSM攻击MNIST完整代码"></a>FGSM攻击MNIST完整代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"KMP_DUPLICATE_LIB_OK"</span>]=<span class="string">"TRUE"</span></span><br><span class="line"></span><br><span class="line">epsilons = [<span class="number">0</span>, <span class="number">.05</span>, <span class="number">.1</span>, <span class="number">.15</span>, <span class="number">.2</span>, <span class="number">.25</span>, <span class="number">.3</span>]</span><br><span class="line">pretrained_model = <span class="string">"mnist_model.pth"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#CNN model defination</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">20</span>*<span class="number">10</span>*<span class="number">10</span>,<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">500</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        input_size = x.size(<span class="number">0</span>) <span class="comment">#获取batch_size</span></span><br><span class="line">        x = self.conv1(x) <span class="comment">#卷积</span></span><br><span class="line">        x = F.relu(x) <span class="comment">#激活</span></span><br><span class="line">        x = F.max_pool2d(x,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">#池化</span></span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)  <span class="comment"># 激活</span></span><br><span class="line">        x = x.view(input_size,<span class="number">-1</span>) <span class="comment">#拉平</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x,dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">test_loader = DataLoader(</span><br><span class="line">    datasets.MNIST(<span class="string">'data'</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>, transform=transforms.Compose([</span><br><span class="line">            transforms.ToTensor(),</span><br><span class="line">            ])),</span><br><span class="line">        batch_size=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line">model.load_state_dict(torch.load(pretrained_model))</span><br><span class="line">model.eval()</span><br><span class="line"></span><br><span class="line"><span class="comment"># FGSM attack code</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fgsm_attack</span><span class="params">(image, epsilon, data_grad)</span>:</span></span><br><span class="line">    sign_data_grad = data_grad.sign()</span><br><span class="line">    perturbed_image = image + epsilon*sign_data_grad</span><br><span class="line">    perturbed_image = torch.clamp(perturbed_image, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> perturbed_image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">( model, test_loader, epsilon )</span>:</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    adv_examples = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">        data.requires_grad = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        output = model(data)</span><br><span class="line">        init_pred = output.max(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> init_pred.item() != target.item():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        loss = F.nll_loss(output, target)</span><br><span class="line">        model.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line"></span><br><span class="line">        data_grad = data.grad.data</span><br><span class="line">        perturbed_data = fgsm_attack(data, epsilon, data_grad)</span><br><span class="line">        output = model(perturbed_data)</span><br><span class="line"></span><br><span class="line">        final_pred = output.max(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] </span><br><span class="line">        <span class="keyword">if</span> final_pred.item() == target.item():</span><br><span class="line">            correct += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (epsilon == <span class="number">0</span>) <span class="keyword">and</span> (len(adv_examples) &lt; <span class="number">5</span>):</span><br><span class="line">                adv_ex = perturbed_data.squeeze().detach().cpu().numpy()</span><br><span class="line">                adv_examples.append( (init_pred.item(), final_pred.item(), adv_ex))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(adv_examples) &lt; <span class="number">5</span>:</span><br><span class="line">                adv_ex = perturbed_data.squeeze().detach().cpu().numpy()</span><br><span class="line">                adv_examples.append( (init_pred.item(), final_pred.item(), adv_ex))</span><br><span class="line"></span><br><span class="line">    final_acc = correct/float(len(test_loader))</span><br><span class="line">    print(<span class="string">"Epsilon: &#123;&#125;\tTest Accuracy = &#123;&#125; / &#123;&#125; = &#123;&#125;"</span>.format(epsilon, correct, len(test_loader), final_acc))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> final_acc, adv_examples</span><br><span class="line"></span><br><span class="line">accuracies = []</span><br><span class="line">examples = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> eps <span class="keyword">in</span> epsilons:</span><br><span class="line">    acc, ex = test(model, test_loader, eps)</span><br><span class="line">    accuracies.append(acc)</span><br><span class="line">    examples.append(ex)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.plot(epsilons, accuracies, <span class="string">"*-"</span>)</span><br><span class="line">plt.yticks(np.arange(<span class="number">0</span>, <span class="number">1.1</span>, step=<span class="number">0.1</span>))</span><br><span class="line">plt.xticks(np.arange(<span class="number">0</span>, <span class="number">.35</span>, step=<span class="number">0.05</span>))</span><br><span class="line">plt.title(<span class="string">"Accuracy vs Epsilon"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Epsilon"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Accuracy"</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(epsilons)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(examples[i])):</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        plt.subplot(len(epsilons),len(examples[<span class="number">0</span>]),cnt)</span><br><span class="line">        plt.xticks([], [])</span><br><span class="line">        plt.yticks([], [])</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">            plt.ylabel(<span class="string">"Eps: &#123;&#125;"</span>.format(epsilons[i]), fontsize=<span class="number">14</span>)</span><br><span class="line">        orig,adv,ex = examples[i][j]</span><br><span class="line">        plt.title(<span class="string">"&#123;&#125; -&gt; &#123;&#125;"</span>.format(orig, adv))</span><br><span class="line">        plt.imshow(ex, cmap=<span class="string">"gray"</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;FGSM的全称是Fast Gradient Sign Method(快速梯度下降法），在白盒环境下，通过求出模型对输入的导数，然后用符号函数
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用GAN生成MNIST数据集(Pytorch)</title>
    <link href="elssm.github.io/2021/03/14/%E4%BD%BF%E7%94%A8GAN%E7%94%9F%E6%88%90MNIST%E6%95%B0%E6%8D%AE%E9%9B%86-Pytorch/"/>
    <id>elssm.github.io/2021/03/14/使用GAN生成MNIST数据集-Pytorch/</id>
    <published>2021-03-14T11:35:06.000Z</published>
    <updated>2021-03-14T14:24:33.803Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上一篇文章里实现了MNIST手写数据集的识别之后，趁热打铁，这一篇文章使用GAN来实现MNIST数据集的生成。2014年Ian Goodfellow的那篇GAN是我接触的第一篇有关机器学习的文章。那篇文章被称为GAN的开山之作，它提出了一种新的生成式框架，其中包括生成模型和鉴别模型。生成模型用于描述数据的分布，生成尽可能拟合真实数据的分布，而鉴别模型用于对生成模型各个迭代轮次产生的结果进行评估，其中利用到了一种博弈的思想。</p><p><img src="/2021/03/14/使用GAN生成MNIST数据集-Pytorch/1.png" alt="1"></p><p>在GAN模型的后面是大量的度量单位和公式推导，在这里我们不做详细说明。今天主要是通过GAN的方式利用两个模型（卷积网络和线性网络）实现MNIST数据集的生成。</p><h4 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h4><p>首先还是模块的导入，对应相关模块的功能在上一篇文章已做了相关说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br></pre></td></tr></table></figure><p>参数定义，其中<code>z_dimension</code>是随机生成噪声的维度，这里定义为100维，可以自定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">epochs = <span class="number">3</span></span><br><span class="line">z_dimension = <span class="number">100</span></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>数据集的加载，由于是生成MNIST数据集，所以这次不需要对测试集进行加载，通过训练集进行训练生成即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,transform=transforms,download=<span class="literal">True</span>)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>判别器的定义,采用三层的线性模型。Linear的两个参数分别是输出层和隐藏层。在第一层的输出层是784是因为MNIST图片大小是<code>1*28*28</code>，中间的隐藏层可以自定义，线性变换之后采用一个LeakyReLU的激活函数实现非线性映射,参数0.2是激活函数的斜率。最后使用Sigmoid函数实现概率值的映射，sigmoid常用作二分类问题。在这里使用sigmoid函数得到一个0到1的概率进行二分类。在forward函数中还采用了一个squeeze函数，这个函数主要对数据的维度进行压缩，去掉维数为1的的维度，默认是将a中所有为1的维度删掉。x.squeeze(-1)用于将二维压缩为一维。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.dis = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>,<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.dis(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>生成器的定义，生成器和判别器的定义相同，也是经过一个三层的线性模型，其中第一个Linear函数的第一个参数是100，这是在前面参数定义的z_dimension = 100也就是随机噪声的维度，在生成器中使用的激活函数是Relu激活函数，最后一层Linear函数的输出层是784维对应了MNIST数据的大小，之后使用Tanh激活函数是希望生成的假的图片数据分布能够在-1～1之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.gen = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">100</span>,<span class="number">256</span>), </span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">256</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">784</span>),</span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.gen(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>实例化生成器模型和判别器模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dis = Discriminator()</span><br><span class="line">Gen = Generator()</span><br></pre></td></tr></table></figure><p>定义损失函数和优化器，其中BCELoss是单目标二分类交叉熵函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.BCELoss()</span><br><span class="line">Dis_optimizer = torch.optim.Adam(Dis.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line">Gen_optimizer = torch.optim.Adam(Gen.parameters(),lr=<span class="number">0.0003</span>)</span><br></pre></td></tr></table></figure><p>开始训练。训练集中包含图片和标签数据。通过img.size(0)可以得到每一批数据的数量，也就是我们之前设定的batch_size大小，随后通过view函数将数据进行拉平成二维方便后续的处理，之后分别计算真实图片和假图片的损失并进行迭代训练，最后将生成的真实图片和假的图片保存在img文件夹下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (img,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        num_img = img.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#训练判别器</span></span><br><span class="line">        img = img.view(num_img,<span class="number">-1</span>) <span class="comment">#拉成64*784</span></span><br><span class="line">        real_img = Variable(img) <span class="comment">#将tensor变成Variable计算</span></span><br><span class="line">        real_label = Variable(torch.ones(num_img)) <span class="comment">#真图片label为1</span></span><br><span class="line">        fake_label = Variable(torch.zeros(num_img)) <span class="comment">#假图片label为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算真实图片的loss</span></span><br><span class="line">        real_out = Dis(real_img) <span class="comment">#图片放入判别器</span></span><br><span class="line">        d_loss_real = criterion(real_out,real_label) <span class="comment">#计算loss</span></span><br><span class="line">        real_scores = real_out</span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算假图片的loss</span></span><br><span class="line">        z = Variable(torch.randn(num_img,z_dimension)) <span class="comment">#随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        fake_out = Dis(fake_img)</span><br><span class="line">        d_loss_fake = criterion(fake_out,fake_label)</span><br><span class="line">        fake_scores = fake_out</span><br><span class="line"></span><br><span class="line">        d_loss = d_loss_real + d_loss_fake</span><br><span class="line">        Dis_optimizer.zero_grad()</span><br><span class="line">        d_loss.backward()</span><br><span class="line">        Dis_optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#训练生成器</span></span><br><span class="line">        z = Variable(torch.randn(num_img, z_dimension))  <span class="comment"># 随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        output = Dis(fake_img)</span><br><span class="line">        g_loss = criterion(output,real_label)</span><br><span class="line"></span><br><span class="line">        Gen_optimizer.zero_grad()</span><br><span class="line">        g_loss.backward()</span><br><span class="line">        Gen_optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> ==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch &#123;&#125;,d_loss: &#123;:.6f&#125;,g_loss: &#123;:.6f&#125;,D real: &#123;:.6f&#125;,D fake: &#123;:.6f&#125;'</span>.format(                epoch,d_loss.item(),g_loss.item(),real_scores.data.mean(),fake_scores.data.mean()</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">if</span> epoch == <span class="number">0</span>:</span><br><span class="line">            real_images = to_img(real_img.data)</span><br><span class="line">            save_image(real_images.data,<span class="string">'img/real_images.png'</span>)</span><br><span class="line">        fake_images = to_img(fake_img.data)</span><br><span class="line">        save_image(fake_images.data,<span class="string">"img/fake_images-&#123;&#125;.png"</span>.format(epoch))</span><br></pre></td></tr></table></figure><p>结果展示，下图是训练3轮次后生成的图像。因为代码是在自己电脑上跑的所以训练的次数比较少，生成的图片不太清晰。</p><p><img src="/2021/03/14/使用GAN生成MNIST数据集-Pytorch/2.png" alt="2"></p><p>训练20轮次的结果</p><p><img src="/2021/03/14/使用GAN生成MNIST数据集-Pytorch/3.png" alt="3"></p><p>训练50轮次的结果，怎么感觉越训练越差了。。。后面再看看具体调优的事。</p><p><img src="/2021/03/14/使用GAN生成MNIST数据集-Pytorch/4.png" alt="4"></p><h4 id="卷积模型"><a href="#卷积模型" class="headerlink" title="卷积模型"></a>卷积模型</h4><p>卷积模型和线性模型的代码主要是模型的定义处不太相同。</p><p>首先是判别器的定义，其中判别器采用的是两层的卷积模型和一层的全连接层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">32</span>,<span class="number">5</span>,padding=<span class="number">2</span>),<span class="comment">#32,28,28</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>),<span class="comment">#32,14,14</span></span><br><span class="line">        )</span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>), <span class="comment">#64,14,14</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>), <span class="comment">#64,7,7</span></span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">7</span>*<span class="number">7</span>,<span class="number">1024</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>,<span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>) <span class="comment">#将4维转为2维</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>) <span class="comment">#将2维转为1维</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>其次是生成器的定义，生成器首先是经过一个全连接层，其中input_size是100也就是随机噪声的维度，num_feature是我们定义的数值为3136，这个可以自定义，只要最后转为[batch,1,28,28]形式就行。其中 BatchNorm2d函数用来做归一化处理，这里我们只写入了BatchNorm2d的第一个参数，也就是输入图像的通道数，所以刚开始是1。后面的通道数随着卷积操作的改变而改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, num_feature)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(input_size, num_feature)  <span class="comment"># batch, 3136=1x56x56</span></span><br><span class="line">        self.br = nn.Sequential(</span><br><span class="line">            nn.BatchNorm2d(<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">50</span>, <span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>),  <span class="comment"># batch, 50, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">50</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">50</span>, <span class="number">25</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),  <span class="comment"># batch, 25, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">25</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">25</span>, <span class="number">1</span>, <span class="number">2</span>, stride=<span class="number">2</span>),  <span class="comment"># batch, 1, 28, 28</span></span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">56</span>, <span class="number">56</span>)</span><br><span class="line">        x = self.br(x)</span><br><span class="line">        x = self.downsample1(x)</span><br><span class="line">        x = self.downsample2(x)</span><br><span class="line">        x = self.downsample3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>实例化生成器和判别器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dis = Discriminator()</span><br><span class="line">Gen = Generator(z_dimension,<span class="number">3136</span>)</span><br></pre></td></tr></table></figure><p>进行训练，这里需要注意的是在训练的时候不需要使用view函数将img转为二维，这里直接对四维数据进行处理。剩下的操作和线性模型相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (img,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment">#训练判别器</span></span><br><span class="line">        <span class="comment"># img = img.view(num_img,-1) #拉成64*784</span></span><br><span class="line">        real_img = Variable(img) <span class="comment">#将tensor变成Variable计算</span></span><br><span class="line">        real_label = Variable(torch.ones(num_img)) <span class="comment">#真图片label为1</span></span><br><span class="line">        fake_label = Variable(torch.zeros(num_img)) <span class="comment">#假图片label为0</span></span><br></pre></td></tr></table></figure><h4 id="线性模型完整代码"><a href="#线性模型完整代码" class="headerlink" title="线性模型完整代码"></a>线性模型完整代码</h4><p>注意要在同级目录下创建一个img的文件夹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment">#用来还原真实数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_img</span><span class="params">(x)</span>:</span></span><br><span class="line">    out = <span class="number">0.5</span> * (x + <span class="number">1</span>)</span><br><span class="line">    out = out.clamp(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">#将随机变化的数值限制在一个给定的区间</span></span><br><span class="line">    out = out.view(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">epochs = <span class="number">50</span></span><br><span class="line">z_dimension = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,transform=transforms,download=<span class="literal">True</span>)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.dis = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>,<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">256</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.dis(x)</span><br><span class="line">        x = x.squeeze(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.gen = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">100</span>,<span class="number">256</span>), <span class="comment">#输入一个100维的0～1之间的高斯分布</span></span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">256</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">256</span>,<span class="number">784</span>),</span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.gen(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">Dis = Discriminator()</span><br><span class="line">Gen = Generator()</span><br><span class="line"></span><br><span class="line">criterion = nn.BCELoss()</span><br><span class="line">Dis_optimizer = torch.optim.Adam(Dis.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line">Gen_optimizer = torch.optim.Adam(Gen.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (img,_) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        num_img = img.size(<span class="number">0</span>) <span class="comment">#获取图片大小 64</span></span><br><span class="line">        <span class="comment">#训练判别器</span></span><br><span class="line">        img = img.view(num_img,<span class="number">-1</span>) <span class="comment">#拉平成64*784</span></span><br><span class="line">        real_img = Variable(img) <span class="comment">#将tensor变成Variable计算</span></span><br><span class="line">        real_label = Variable(torch.ones(num_img)) <span class="comment">#真图片label为1</span></span><br><span class="line">        fake_label = Variable(torch.zeros(num_img)) <span class="comment">#假图片label为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算真实图片的loss</span></span><br><span class="line">        real_out = Dis(real_img) <span class="comment">#图片放入判别器</span></span><br><span class="line">        d_loss_real = criterion(real_out,real_label) <span class="comment">#计算loss</span></span><br><span class="line">        real_scores = real_out</span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算假图片的loss</span></span><br><span class="line">        z = Variable(torch.randn(num_img,z_dimension)) <span class="comment">#随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        fake_out = Dis(fake_img)</span><br><span class="line">        d_loss_fake = criterion(fake_out,fake_label)</span><br><span class="line">        fake_scores = fake_out</span><br><span class="line"></span><br><span class="line">        d_loss = d_loss_real + d_loss_fake</span><br><span class="line">        Dis_optimizer.zero_grad()</span><br><span class="line">        d_loss.backward()</span><br><span class="line">        Dis_optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#训练生成器</span></span><br><span class="line">        z = Variable(torch.randn(num_img, z_dimension))  <span class="comment"># 随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        output = Dis(fake_img)</span><br><span class="line">        g_loss = criterion(output,real_label)</span><br><span class="line"></span><br><span class="line">        Gen_optimizer.zero_grad()</span><br><span class="line">        g_loss.backward()</span><br><span class="line">        Gen_optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> ==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch &#123;&#125;,d_loss: &#123;:.6f&#125;,g_loss: &#123;:.6f&#125;,D real: &#123;:.6f&#125;,D fake: &#123;:.6f&#125;'</span>.format(</span><br><span class="line">                epoch,d_loss.item(),g_loss.item(),real_scores.data.mean(),fake_scores.data.mean()</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">if</span> epoch == <span class="number">0</span>:</span><br><span class="line">            real_images = to_img(real_img.data)</span><br><span class="line">            save_image(real_images.data,<span class="string">'img/real_images.png'</span>)</span><br><span class="line">        fake_images = to_img(fake_img.data)</span><br><span class="line">        save_image(fake_images.data,<span class="string">"img/fake_images-&#123;&#125;.png"</span>.format(epoch))</span><br></pre></td></tr></table></figure><h4 id="卷积模型完整代码"><a href="#卷积模型完整代码" class="headerlink" title="卷积模型完整代码"></a>卷积模型完整代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> save_image</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="comment">#还原真实数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_img</span><span class="params">(x)</span>:</span></span><br><span class="line">    out = <span class="number">0.5</span> * (x + <span class="number">1</span>)</span><br><span class="line">    out = out.clamp(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">#将随机变化的数值限制在一个给定的区间</span></span><br><span class="line">    out = out.view(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">epochs = <span class="number">3</span></span><br><span class="line">z_dimension = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,transform=transforms,download=<span class="literal">True</span>)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>,<span class="number">32</span>,<span class="number">5</span>,padding=<span class="number">2</span>),<span class="comment">#32,28,28</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>),<span class="comment">#32,14,14</span></span><br><span class="line">        )</span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>), <span class="comment">#64,14,41</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>), <span class="comment">#64,7,7</span></span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">7</span>*<span class="number">7</span>,<span class="number">1024</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>,<span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        x = x.squeeze(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, num_feature)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(input_size, num_feature)  <span class="comment"># batch, 3136=1x56x56</span></span><br><span class="line">        self.br = nn.Sequential(</span><br><span class="line">            nn.BatchNorm2d(<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">50</span>, <span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>),  <span class="comment"># batch, 50, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">50</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">50</span>, <span class="number">25</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),  <span class="comment"># batch, 25, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">25</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        self.downsample3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">25</span>, <span class="number">1</span>, <span class="number">2</span>, stride=<span class="number">2</span>),  <span class="comment"># batch, 1, 28, 28</span></span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">56</span>, <span class="number">56</span>)</span><br><span class="line">        x = self.br(x)</span><br><span class="line">        x = self.downsample1(x)</span><br><span class="line">        x = self.downsample2(x)</span><br><span class="line">        x = self.downsample3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dis = Discriminator()</span><br><span class="line">Gen = Generator(z_dimension,<span class="number">3136</span>)</span><br><span class="line"></span><br><span class="line">criterion = nn.BCELoss()</span><br><span class="line">Dis_optimizer = torch.optim.Adam(Dis.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line">Gen_optimizer = torch.optim.Adam(Gen.parameters(),lr=<span class="number">0.0003</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (img,_) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment">#训练判别器</span></span><br><span class="line">        real_img = Variable(img) <span class="comment">#将tensor变成Variable计算</span></span><br><span class="line">        real_label = Variable(torch.ones(num_img)) <span class="comment">#真图片label为1</span></span><br><span class="line">        fake_label = Variable(torch.zeros(num_img)) <span class="comment">#假图片label为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算真实图片的loss</span></span><br><span class="line">        real_out = Dis(real_img) <span class="comment">#图片放入判别器</span></span><br><span class="line">        d_loss_real = criterion(real_out,real_label) <span class="comment">#计算loss</span></span><br><span class="line">        real_scores = real_out</span><br><span class="line"></span><br><span class="line">        <span class="comment">#计算假图片的loss</span></span><br><span class="line">        z = Variable(torch.randn(num_img,z_dimension)) <span class="comment">#随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        fake_out = Dis(fake_img)</span><br><span class="line">        d_loss_fake = criterion(fake_out,fake_label)</span><br><span class="line">        fake_scores = fake_out</span><br><span class="line"></span><br><span class="line">        d_loss = d_loss_real + d_loss_fake</span><br><span class="line">        Dis_optimizer.zero_grad()</span><br><span class="line">        d_loss.backward()</span><br><span class="line">        Dis_optimizer.step()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#训练生成器</span></span><br><span class="line">        z = Variable(torch.randn(num_img, z_dimension))  <span class="comment"># 随机生成一些噪声</span></span><br><span class="line">        fake_img = Gen(z)</span><br><span class="line">        output = Dis(fake_img)</span><br><span class="line">        g_loss = criterion(output,real_label)</span><br><span class="line"></span><br><span class="line">        Gen_optimizer.zero_grad()</span><br><span class="line">        g_loss.backward()</span><br><span class="line">        Gen_optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> ==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Epoch &#123;&#125;,d_loss: &#123;:.6f&#125;,g_loss: &#123;:.6f&#125;,D real: &#123;:.6f&#125;,D fake: &#123;:.6f&#125;'</span>.format(</span><br><span class="line">                epoch,d_loss.item(),g_loss.item(),real_scores.data.mean(),fake_scores.data.mean()</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">if</span> epoch == <span class="number">0</span>:</span><br><span class="line">            real_images = to_img(real_img.data)</span><br><span class="line">            save_image(real_images.data,<span class="string">'img/real_images.png'</span>)</span><br><span class="line">        fake_images = to_img(fake_img.data)</span><br><span class="line">        save_image(fake_images.data,<span class="string">"img/fake_images-&#123;&#125;.png"</span>.format(epoch))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在上一篇文章里实现了MNIST手写数据集的识别之后，趁热打铁，这一篇文章使用GAN来实现MNIST数据集的生成。2014年Ian Goodf
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MNIST数据集识别(Pytorch)</title>
    <link href="elssm.github.io/2021/03/11/MNIST%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%86%E5%88%AB-Pytorch/"/>
    <id>elssm.github.io/2021/03/11/MNIST数据集识别-Pytorch/</id>
    <published>2021-03-11T02:11:37.000Z</published>
    <updated>2021-03-11T03:13:52.830Z</updated>
    
    <content type="html"><![CDATA[<p>入门机器学习的最简单案例就是对MNIST手写数据集的识别。本篇文章将会通过Pytorch框架完成对MNIST手写数据集识别。首先我们来简单了解一下MNIST。</p><h4 id="What-is-MNIST？"><a href="#What-is-MNIST？" class="headerlink" title="What is MNIST？"></a>What is MNIST？</h4><p>MNIST数据集是一个有名的手写数字数据集，该数据集包含60000个用于训练的示例和10000个用于测试的示例，这些数字已经经过尺寸标准化并位于图像中心，图像的固定大小是28*28像素，值为0到9。</p><h4 id="Pytorch识别MNIST"><a href="#Pytorch识别MNIST" class="headerlink" title="Pytorch识别MNIST"></a>Pytorch识别MNIST</h4><p>今天我们将通过Pytorch实现对MNIST的识别。对于Pytorch的安装这里不做介绍。</p><h4 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python==3.8</span><br><span class="line">torch==1.7.0</span><br></pre></td></tr></table></figure><p>本次代码利用pycharm进行编写，环境使用为<code>anaconda3</code>，使用cpu进行训练。</p><ul><li><h5 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h5><p>在使用Pytorch之前，我们要导入相关模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets,transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br></pre></td></tr></table></figure><p>其中，<code>datasets</code>用来导入MNIST数据集，<code>transforms</code>用于图像的转换处理，<code>DataLoader</code>用于加载数据集，<code>optim</code>用来加载优化器。</p></li><li><h5 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h5><p>在数据集识别中我们要定义比较多的参数和超参数，因为数据集比较大，如果一次训练太多的数据，效果不会很好，因此我们通常对数据集的训练数据进行分批训练，还有就是我们一般对一个数据集的所有数据不止训练一轮次，例如MNIST数据集，我们对它的60000张训练数据会进行多个轮次的训练，这样会产生更好的训练效果。具体定义如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">16</span> <span class="comment">#批次大小，一次训练16张数据</span></span><br><span class="line">epochs = <span class="number">5</span> <span class="comment">#对于60000张训练数据进行5轮训练</span></span><br><span class="line">transforms = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(), <span class="comment">#将图片转换为张量</span></span><br><span class="line">    transforms.Normalize((<span class="number">0.1307</span>,),(<span class="number">0.3081</span>,)) <span class="comment">#进行归一化处理，参数默认使用官网给定值</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure></li><li><h5 id="数据集加载"><a href="#数据集加载" class="headerlink" title="数据集加载"></a>数据集加载</h5><p>定义好参数之后我们开始对数据集进行加载，利用<code>torchvision</code>中的<code>datasets</code>模块就可以导入MNIST数据集。之后再利用<code>DataLoader</code>对数据集进行加载即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">test_set = datasets.MNIST(<span class="string">"data"</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,transform=transforms)</span><br><span class="line">train_loader = DataLoader(train_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_set,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>因为MNIST中分为训练数据和测试数据，因此我们需要进行两次导入和加载。其中<code>datasets.MNIST</code>的第一个参数是数据集导入的路径，这里使用<code>&quot;data&quot;</code>直接将数据集导入代码同级目录下，如果没有data目录会自动创建，在训练数据集的导入中，第二个参数<code>train</code>要设置为True，而在测试数据集中因为不需要进行训练，所以设置为False即可。后面的<code>transform</code>参数就是对图像进行一个处理，例如转换成张量和进行归一化处理，在<code>DataLoader</code>的参数中，<code>batch_size</code>就是每次训练的个数，<code>shuffle</code>参数的含义就是在每次训练的个数中进行一个随机打乱。这也算是处理过拟合现象的一种方式。</p></li><li><h5 id="模型的定义"><a href="#模型的定义" class="headerlink" title="模型的定义"></a>模型的定义</h5><p>在对数据集加载完成之后，我们开始定义自己的网络模型。我们使用了两个卷积层，之后使用了两个全连接层。在激活函数的选择上，我们使用relu作为激活函数，之后我们进行了一个2*2的池化操作，再对图像进行了一个拉平操作，最后我们采用<code>log_softmax</code>函数进行输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">20</span>*<span class="number">10</span>*<span class="number">10</span>,<span class="number">500</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">500</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        input_size = x.size(<span class="number">0</span>) <span class="comment">#获取batch_size</span></span><br><span class="line">        x = self.conv1(x) <span class="comment">#卷积</span></span><br><span class="line">        x = F.relu(x) <span class="comment">#激活</span></span><br><span class="line">        x = F.max_pool2d(x,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">#池化</span></span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = F.relu(x)  <span class="comment"># 激活</span></span><br><span class="line">        x = x.view(input_size,<span class="number">-1</span>) <span class="comment">#拉平</span></span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = F.relu(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        output = F.log_softmax(x,dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></li><li><h5 id="模型的使用"><a href="#模型的使用" class="headerlink" title="模型的使用"></a>模型的使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = Net()</span><br><span class="line">optimizer = optim.Adam(model.parameters())</span><br></pre></td></tr></table></figure><p>第一行代码我们实例化了一个模型，第二行代码我们利用<code>optim</code>选择合适的优化器，这里我们使用了Adam优化器，你也可以根据需求采用其他优化器例如SGD。</p></li><li><h5 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(model, train_loader,optimizer ,epoch)</span>:</span></span><br><span class="line">    <span class="comment">#模型训练</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_index,(data,target) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment">#梯度初始化为0</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment">#预测</span></span><br><span class="line">        output = model(data)</span><br><span class="line">        <span class="comment">#计算损失</span></span><br><span class="line">        loss = F.cross_entropy(output,target)</span><br><span class="line">        <span class="comment">#反向传播</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> batch_index % <span class="number">600</span> == <span class="number">0</span>: <span class="comment">#每训练600次进行一次输出</span></span><br><span class="line">            print(<span class="string">"Train Epoch : &#123;&#125; \t Loss : &#123;:.6f&#125;"</span>.format(epoch,loss.item()))</span><br></pre></td></tr></table></figure><p>在这里我们定义了一个训练函数，参数传递了定义的模型、训练的数据、优化器和训练轮次。在第二行代码中<code>model.train</code>的含义是在训练过程中采用Dropout和Normalization。这样有助于优化训练。之后我们对训练数据中的data和target进行提取。target相当于数据的标签。接下来我们对优化器的梯度进行初始化，如果不进行初始化梯度累加就会影响训练效果。计算损失这里采用交叉熵损失。接下来就是很重要的一步，进行反向传播。最后使用<code>optimizer.step()</code>对模型进行更新。</p></li><li><h5 id="测试集验证"><a href="#测试集验证" class="headerlink" title="测试集验证"></a>测试集验证</h5><p>测试集的验证和训练集差不多，不同的地方是在训练之前采用<code>model.eval()</code>，eval和train的区别在于，eval是不采用Dropout和Normalization。第二点就是在测试的时候不用计算梯度也不用进行反向传播。具体代码实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_model</span><span class="params">(model,test_loader)</span>:</span></span><br><span class="line">    <span class="comment">#模型验证</span></span><br><span class="line">    model.eval()</span><br><span class="line">    <span class="comment">#正确率</span></span><br><span class="line">    correct = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">#测试损失</span></span><br><span class="line">    test_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():<span class="comment">#不会计算梯度也不会进行反向传播</span></span><br><span class="line">        <span class="keyword">for</span> data,target <span class="keyword">in</span> test_loader:</span><br><span class="line">            <span class="comment"># data,target = data.to(device),target.to(device)</span></span><br><span class="line">            <span class="comment">#测试数据</span></span><br><span class="line">            output = model(data)</span><br><span class="line">            <span class="comment">#计算测试损失</span></span><br><span class="line">            test_loss+=F.cross_entropy(output,target).item()</span><br><span class="line">            <span class="comment">#找到概率值最大的下标</span></span><br><span class="line">            pred = output.max(<span class="number">1</span>,keepdim=<span class="literal">True</span>)[<span class="number">1</span>] <span class="comment">#值 索引</span></span><br><span class="line">            <span class="comment">#pred = torch.max(output,dim=1)</span></span><br><span class="line">            <span class="comment">#pred = output.argmax(dim=1)</span></span><br><span class="line">            <span class="comment">#累计正确率</span></span><br><span class="line">            correct += pred.eq(target.view_as(pred)).sum().item()</span><br><span class="line">        test_loss /= len(test_loader.dataset)</span><br><span class="line">        print(<span class="string">"Test ---- Average loss : &#123;:.4f&#125;,Accuracy : &#123;:.3f&#125;\n"</span>.format(test_loss,<span class="number">100.0</span>*correct/len(test_loader.dataset)))</span><br></pre></td></tr></table></figure></li><li><h5 id="训练和测试结果展示"><a href="#训练和测试结果展示" class="headerlink" title="训练和测试结果展示"></a>训练和测试结果展示</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>,epochs+<span class="number">1</span>): <span class="comment">#进行5轮次训练</span></span><br><span class="line">    train_model(model,train_loader,optimizer,epoch)</span><br><span class="line">    test_model(model,test_loader)</span><br></pre></td></tr></table></figure><p><img src="/2021/03/11/MNIST数据集识别-Pytorch/1.png" alt="1"></p><p><img src="/2021/03/11/MNIST数据集识别-Pytorch/2.png" alt="2"></p><p>从图中我们可以看到训练效果并不随着训练轮次的增加而变得更好，在本次训练中，训练轮次为4的时候，准确率最高，达到了99.03%</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;入门机器学习的最简单案例就是对MNIST手写数据集的识别。本篇文章将会通过Pytorch框架完成对MNIST手写数据集识别。首先我们来简单了解一下MNIST。&lt;/p&gt;
&lt;h4 id=&quot;What-is-MNIST？&quot;&gt;&lt;a href=&quot;#What-is-MNIST？&quot; cla
      
    
    </summary>
    
    
      <category term="机器学习" scheme="elssm.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Hot100(Python)</title>
    <link href="elssm.github.io/2021/03/10/Leetcode-Hot100-Python/"/>
    <id>elssm.github.io/2021/03/10/Leetcode-Hot100-Python/</id>
    <published>2021-03-10T01:59:19.000Z</published>
    <updated>2021-04-25T09:46:06.005Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1-两数之和-easy"><a href="#1-两数之和-easy" class="headerlink" title="1.两数之和(easy)"></a>1.两数之和(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]==target:</span><br><span class="line">                    c.append(i)</span><br><span class="line">                    c.append(j)</span><br><span class="line">                    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></li><li><h4 id="2-两数相加-medium"><a href="#2-两数相加-medium" class="headerlink" title="2.两数相加(medium)"></a>2.两数相加(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c1=[]</span><br><span class="line">        c2=[]</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            c1.append(l1.val)</span><br><span class="line">            l1=l1.next</span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            c2.append(l2.val)</span><br><span class="line">            l2=l2.next</span><br><span class="line">        j1=<span class="number">-1</span></span><br><span class="line">        j2=<span class="number">-1</span></span><br><span class="line">        sum1=<span class="number">0</span></span><br><span class="line">        sum2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c1)):</span><br><span class="line">            sum1=sum1*<span class="number">10</span>+c1[j1]</span><br><span class="line">            j1=j1<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c2)):</span><br><span class="line">            sum2=sum2*<span class="number">10</span>+c2[j2]</span><br><span class="line">            j2=j2<span class="number">-1</span></span><br><span class="line">        res=sum1+sum2</span><br><span class="line">        p=head=node=ListNode(<span class="literal">None</span>)</span><br><span class="line">        l=len(str(res))</span><br><span class="line">        <span class="keyword">while</span> l:</span><br><span class="line">            node=ListNode(res%<span class="number">10</span>)</span><br><span class="line">            p.next=node</span><br><span class="line">            p=node</span><br><span class="line">            res/=<span class="number">10</span></span><br><span class="line">            l-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure></li><li><h4 id="3-无重复字符的最长子串-medium"><a href="#3-无重复字符的最长子串-medium" class="headerlink" title="3.无重复字符的最长子串(medium)"></a>3.无重复字符的最长子串(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        maxl=<span class="number">0</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">in</span> s[i:j]:</span><br><span class="line">                i = s[i:j].find(s[j])+i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j-i+<span class="number">1</span>&gt;maxl:</span><br><span class="line">                maxl=j-i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxl</span><br></pre></td></tr></table></figure></li><li><h4 id="4-寻找两个正序数组的中位数-hard"><a href="#4-寻找两个正序数组的中位数-hard" class="headerlink" title="4.寻找两个正序数组的中位数(hard)"></a>4.寻找两个正序数组的中位数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            nums1.append(i)</span><br><span class="line">        nums1 = sorted(nums1)</span><br><span class="line">        <span class="keyword">if</span> len(nums1)%<span class="number">2</span> !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[len(nums1)/<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (nums1[len(nums1)/<span class="number">2</span>]+nums1[len(nums1)/<span class="number">2</span><span class="number">-1</span>])/<span class="number">2.0</span></span><br></pre></td></tr></table></figure></li><li><h4 id="11-盛最多水的容器-medium"><a href="#11-盛最多水的容器-medium" class="headerlink" title="11.盛最多水的容器(medium)"></a>11.盛最多水的容器(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=len(height)<span class="number">-1</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            h=min(height[i],height[j])</span><br><span class="line">            res=max(res,h*(j-i))</span><br><span class="line">            <span class="keyword">if</span> height[i]&gt;height[j]:</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="15-三数之和-medium"><a href="#15-三数之和-medium" class="headerlink" title="15.三数之和(medium)"></a>15.三数之和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#第一种方法，可行但超时</span></span><br><span class="line">        <span class="comment"># if len(nums)==0 or len(nums)==1 or len(nums)==2:</span></span><br><span class="line">        <span class="comment">#     return []</span></span><br><span class="line">        <span class="comment"># sum_two=[]</span></span><br><span class="line">        <span class="comment"># d=&#123;&#125;</span></span><br><span class="line">        <span class="comment"># res=[]</span></span><br><span class="line">        <span class="comment"># count=0</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)-1):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,len(nums)):</span></span><br><span class="line">        <span class="comment">#         d[count]=[i,j]</span></span><br><span class="line">        <span class="comment">#         sum_two.append(nums[i]+nums[j])</span></span><br><span class="line">        <span class="comment">#         count+=1</span></span><br><span class="line">        <span class="comment"># # print(d)</span></span><br><span class="line">        <span class="comment"># # print(sum_two)</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for j in range(len(sum_two)):</span></span><br><span class="line">        <span class="comment">#         if i not in d[j] and nums[i]+sum_two[j]==0:</span></span><br><span class="line">        <span class="comment">#             temp = [nums[d[j][0]]] + [nums[i]] + [nums[d[j][1]]]</span></span><br><span class="line">        <span class="comment">#             temp.sort()</span></span><br><span class="line">        <span class="comment">#             if temp not in res:</span></span><br><span class="line">        <span class="comment">#                 res.append(temp)</span></span><br><span class="line">        <span class="comment"># # res = list(set([tuple(t) for t in res]))</span></span><br><span class="line">        <span class="comment"># # res = list([list(l) for l in res])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#第二种方法，还是超时....</span></span><br><span class="line">        <span class="comment"># d = &#123;&#125;</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># count=0</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)-1):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,len(nums)):</span></span><br><span class="line">        <span class="comment">#         d[count] = [i,j]</span></span><br><span class="line">        <span class="comment">#         count+=1</span></span><br><span class="line">        <span class="comment"># for k in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for v in d.values():</span></span><br><span class="line">        <span class="comment">#         if k not in v and nums[v[0]]+nums[v[1]]+nums[k]==0:</span></span><br><span class="line">        <span class="comment">#             temp = [nums[v[0]],nums[v[1]],nums[k]]</span></span><br><span class="line">        <span class="comment">#             temp.sort()</span></span><br><span class="line">        <span class="comment">#             if temp not in res:</span></span><br><span class="line">        <span class="comment">#                 res.append(temp)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#参考别人的方法</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                key = nums[j]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">in</span> d:</span><br><span class="line">                    value = d[key] + [key]</span><br><span class="line">                    value.sort()</span><br><span class="line">                    <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                        res.append(value)</span><br><span class="line">                key = -nums[i] - nums[j]</span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[key] = [nums[i], nums[j]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="17-电话号码的字母组合-medium"><a href="#17-电话号码的字母组合-medium" class="headerlink" title="17.电话号码的字母组合(medium)"></a>17.电话号码的字母组合(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        d=&#123;<span class="number">2</span>:[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>],<span class="number">3</span>:[<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>],<span class="number">4</span>:[<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>],<span class="number">5</span>:[<span class="string">"j"</span>,<span class="string">"k"</span>,<span class="string">"l"</span>],<span class="number">6</span>:[<span class="string">"m"</span>,<span class="string">"n"</span>,<span class="string">"o"</span>],<span class="number">7</span>:[<span class="string">"p"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"s"</span>],<span class="number">8</span>:[<span class="string">"t"</span>,<span class="string">"u"</span>,<span class="string">"v"</span>],<span class="number">9</span>:[<span class="string">"w"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>]&#125;</span><br><span class="line">        <span class="keyword">if</span> len(digits)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(digits)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> d[int(digits)]</span><br><span class="line">        l = len(digits)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> d[int(digits[<span class="number">0</span>])]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> d[int(digits[<span class="number">1</span>])]:</span><br><span class="line">                    res.append(i+j)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> d[int(digits[<span class="number">0</span>])]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> d[int(digits[<span class="number">1</span>])]:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> d[int(digits[<span class="number">2</span>])]:</span><br><span class="line">                        res.append(i+j+k)</span><br><span class="line">        <span class="keyword">if</span> l==<span class="number">4</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> d[int(digits[<span class="number">0</span>])]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> d[int(digits[<span class="number">1</span>])]:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> d[int(digits[<span class="number">2</span>])]:</span><br><span class="line">                        <span class="keyword">for</span> m <span class="keyword">in</span> d[int(digits[<span class="number">3</span>])]:</span><br><span class="line">                            res.append(i+j+k+m)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="19-删除链表的倒数第N个节点-medium"><a href="#19-删除链表的倒数第N个节点-medium" class="headerlink" title="19.删除链表的倒数第N个节点(medium)"></a>19.删除链表的倒数第N个节点(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head.next==<span class="literal">None</span> <span class="keyword">and</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        nhead:找到需要删除的节点</span></span><br><span class="line"><span class="string">        pre_nhead:找到需要删除的节点的前一个节点</span></span><br><span class="line"><span class="string">        temp:通过从temp向后遍历找到倒数第n个节点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nhead = pre_nhead = temp = head</span><br><span class="line">        flag = <span class="number">1</span> <span class="comment">#如果flag没变，说明没进while循环，说明要删除的是头节点</span></span><br><span class="line">        <span class="keyword">while</span> n<span class="number">-1</span>&gt;<span class="number">0</span>:</span><br><span class="line">            temp =temp.next</span><br><span class="line">            n-=<span class="number">1</span></span><br><span class="line">        <span class="comment"># print(temp.val)</span></span><br><span class="line">        <span class="keyword">while</span> temp.next!=<span class="literal">None</span>:</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            temp = temp.next</span><br><span class="line">            pre_nhead = nhead</span><br><span class="line">            nhead = nhead.next</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            head = head.next</span><br><span class="line">            <span class="keyword">return</span> head </span><br><span class="line">        pre_nhead.next = nhead.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></li><li><h4 id="20-有效的括号-easy"><a href="#20-有效的括号-easy" class="headerlink" title="20.有效的括号(easy)"></a>20.有效的括号(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c=[]</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s==<span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>]==<span class="string">')'</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">']'</span> <span class="keyword">or</span> s[<span class="number">0</span>]==<span class="string">'&#125;'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> len(c)==<span class="number">0</span>:</span><br><span class="line">                c.append(s[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> (c[<span class="number">-1</span>]==<span class="string">'('</span> <span class="keyword">and</span> s[i]==<span class="string">')'</span>) <span class="keyword">or</span> (c[<span class="number">-1</span>]==<span class="string">'['</span> <span class="keyword">and</span> s[i]==<span class="string">']'</span>)  <span class="keyword">or</span> (c[<span class="number">-1</span>]==<span class="string">'&#123;'</span> <span class="keyword">and</span> s[i]==<span class="string">'&#125;'</span>):</span><br><span class="line">                    c.pop(<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c.append(s[i])</span><br><span class="line">        <span class="keyword">if</span> len(c)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><h4 id="21-合并两个有序链表-medium"><a href="#21-合并两个有序链表-medium" class="headerlink" title="21.合并两个有序链表(medium)"></a>21.合并两个有序链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=ListNode(<span class="literal">None</span>) <span class="comment">#合并之后的新数组</span></span><br><span class="line">        p=res <span class="comment">#保持头节点不动</span></span><br><span class="line">        <span class="keyword">if</span> l1==<span class="literal">None</span>:  </span><br><span class="line">            res.next=l2</span><br><span class="line">            <span class="keyword">return</span> res.next</span><br><span class="line">        <span class="keyword">if</span> l2==<span class="literal">None</span>:</span><br><span class="line">            res.next=l1</span><br><span class="line">            <span class="keyword">return</span> res.next</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.next=l1</span><br><span class="line">                l1=l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next=l2</span><br><span class="line">                l2=l2.next</span><br><span class="line">            p=p.next</span><br><span class="line">        <span class="keyword">if</span> l1: <span class="comment">#如果l1还没循环结束</span></span><br><span class="line">            p.next=l1</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#如果l2还没循环结束</span></span><br><span class="line">            p.next=l2</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure></li><li><h4 id="39-组合总和-medium"><a href="#39-组合总和-medium" class="headerlink" title="39.组合总和(medium)"></a>39.组合总和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(path,result,index)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> result &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> result == <span class="number">0</span>:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index,len(candidates)):</span><br><span class="line">                <span class="keyword">if</span> result &gt;= candidates[i]:</span><br><span class="line">                    trace(path+[candidates[i]],result-candidates[i],i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        res = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        trace([],target,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="42-接雨水-hard"><a href="#42-接雨水-hard" class="headerlink" title="42.接雨水(hard)"></a>42.接雨水(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(height) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#两层循环时间复杂度太大了。不过思路没问题</span></span><br><span class="line">        <span class="comment"># ans=0</span></span><br><span class="line">        <span class="comment"># start=0</span></span><br><span class="line">        <span class="comment"># end=0</span></span><br><span class="line">        <span class="comment"># max_h = max(height)</span></span><br><span class="line">        <span class="comment"># for i in range(1,max_h+1):</span></span><br><span class="line">        <span class="comment">#     for j in range(len(height)):</span></span><br><span class="line">        <span class="comment">#         if height[j]&gt;=i:</span></span><br><span class="line">        <span class="comment">#             start=j</span></span><br><span class="line">        <span class="comment">#             break</span></span><br><span class="line">        <span class="comment">#     for k in range(len(height)):</span></span><br><span class="line">        <span class="comment">#         if height[len(height)-k-1]&gt;=i:</span></span><br><span class="line">        <span class="comment">#             end=len(height)-k-1</span></span><br><span class="line">        <span class="comment">#             break</span></span><br><span class="line">        <span class="comment">#     for j in range(start+1,end):</span></span><br><span class="line">        <span class="comment">#         if height[j]&lt;i:</span></span><br><span class="line">        <span class="comment">#             ans+=1</span></span><br><span class="line">        <span class="comment"># return ans</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#找到最大值</span></span><br><span class="line">        max_h = max(height)</span><br><span class="line">        <span class="comment">#找到最大值的下标(第一个最大值)</span></span><br><span class="line">        index = height.index(max_h)</span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="comment">#从左到最大值遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index):</span><br><span class="line">            <span class="keyword">if</span> height[i]&lt;height[temp]:</span><br><span class="line">                ans=ans+(height[temp]-height[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp=i</span><br><span class="line">        height=list(reversed(height[index:]))</span><br><span class="line">        temp2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">            <span class="keyword">if</span> height[i]&lt;height[temp2]:</span><br><span class="line">                ans=ans+(height[temp2]-height[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp2=i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li><li><h4 id="46-全排列-medium"><a href="#46-全排列-medium" class="headerlink" title="46.全排列(medium)"></a>46.全排列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># res=[]</span></span><br><span class="line">        <span class="comment"># def backtrack(nums,tmp):</span></span><br><span class="line">        <span class="comment">#     if not nums:</span></span><br><span class="line">        <span class="comment">#         res.append(tmp)</span></span><br><span class="line">        <span class="comment">#         return </span></span><br><span class="line">        <span class="comment">#     for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#         backtrack(nums[:i]+nums[i+1:],tmp+[nums[i]])</span></span><br><span class="line">        <span class="comment"># backtrack(nums,[])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            ans.extend([[n] + p <span class="keyword">for</span> p <span class="keyword">in</span> self.permute(nums[:i] + nums[i + <span class="number">1</span>:])])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li><li><h4 id="48-旋转图像-medium"><a href="#48-旋转图像-medium" class="headerlink" title="48.旋转图像(medium)"></a>48.旋转图像(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        matrix[::] = map(list,zip(*reversed(matrix)))</span><br></pre></td></tr></table></figure></li><li><h4 id="49-字母异位词分组-medium"><a href="#49-字母异位词分组-medium" class="headerlink" title="49.字母异位词分组(medium)"></a>49.字母异位词分组(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#方法一</span></span><br><span class="line">        <span class="comment"># res=[]</span></span><br><span class="line">        <span class="comment"># c=[]</span></span><br><span class="line">        <span class="comment"># result=[]</span></span><br><span class="line">        <span class="comment"># for i in range(len(strs)):</span></span><br><span class="line">        <span class="comment">#     res.append((strs[i],Counter(strs[i])))</span></span><br><span class="line">        <span class="comment"># while len(res)!=0:</span></span><br><span class="line">        <span class="comment">#     temp=res[0][1]</span></span><br><span class="line">        <span class="comment">#     num=[]</span></span><br><span class="line">        <span class="comment">#     count=[]</span></span><br><span class="line">        <span class="comment">#     for i in range(len(res)):</span></span><br><span class="line">        <span class="comment">#         if temp==res[i][1]:</span></span><br><span class="line">        <span class="comment">#             num.append(res[i][0])</span></span><br><span class="line">        <span class="comment">#             count.append(i)</span></span><br><span class="line">        <span class="comment">#     result.append(num)</span></span><br><span class="line">        <span class="comment">#     for i in reversed(count):</span></span><br><span class="line">        <span class="comment">#         res.pop(i)</span></span><br><span class="line">        <span class="comment"># return result</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#其他解法</span></span><br><span class="line">        res = []</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            keys = <span class="string">""</span>.join(sorted(s))</span><br><span class="line">            <span class="keyword">if</span> keys <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[keys] = [s]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[keys].append(s)</span><br><span class="line">        <span class="keyword">return</span> list(dic.values())</span><br></pre></td></tr></table></figure></li><li><h4 id="62-不同路径-medium"><a href="#62-不同路径-medium" class="headerlink" title="62.不同路径(medium)"></a>62.不同路径(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[[<span class="number">1</span>]*n]*m</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                res[i][j]=res[i][j<span class="number">-1</span>]+res[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="64-最小路径和-medium"><a href="#64-最小路径和-medium" class="headerlink" title="64.最小路径和(medium)"></a>64.最小路径和(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:  grid[i][j] = grid[i][j - <span class="number">1</span>] + grid[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:  grid[i][j] = grid[i - <span class="number">1</span>][j] + grid[i][j]</span><br><span class="line">                <span class="keyword">else</span>: grid[i][j] = min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="70-爬楼梯-easy"><a href="#70-爬楼梯-easy" class="headerlink" title="70.爬楼梯(easy)"></a>70.爬楼梯(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-3</span>):</span><br><span class="line">            res.append(res[<span class="number">-1</span>]+res[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="75-颜色分类-medium"><a href="#75-颜色分类-medium" class="headerlink" title="75.颜色分类(medium)"></a>75.颜色分类(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(i,j,res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=j:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            p = res[i]</span><br><span class="line">            low = i</span><br><span class="line">            high = j</span><br><span class="line">            <span class="keyword">while</span> i&lt;j:</span><br><span class="line">                <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> res[j]&gt;=p:</span><br><span class="line">                    j-=<span class="number">1</span></span><br><span class="line">                res[i]=res[j]</span><br><span class="line">                <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> res[i]&lt;=p:</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                res[j]=res[i]</span><br><span class="line">            res[j]=p</span><br><span class="line">            quicksort(low,i<span class="number">-1</span>,res)</span><br><span class="line">            quicksort(i+<span class="number">1</span>,high,res)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        quicksort(<span class="number">0</span>,len(nums)<span class="number">-1</span>,nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># return nums.sort()</span></span><br></pre></td></tr></table></figure></li><li><h4 id="78-子集-medium"><a href="#78-子集-medium" class="headerlink" title="78.子集(medium)"></a>78.子集(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res+=[j+[i] <span class="keyword">for</span> j <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="94-二叉树的中序遍历-medium"><a href="#94-二叉树的中序遍历-medium" class="headerlink" title="94.二叉树的中序遍历(medium)"></a>94.二叉树的中序遍历(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)</span><br></pre></td></tr></table></figure></li><li><h4 id="98-验证二叉搜索树-medium"><a href="#98-验证二叉搜索树-medium" class="headerlink" title="98.验证二叉搜索树(medium)"></a>98.验证二叉搜索树(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            inorder(node.left)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            inorder(node.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">if</span> sorted(list(set(res))) == res:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><h4 id="101-对称二叉树-easy"><a href="#101-对称二叉树-easy" class="headerlink" title="101.对称二叉树(easy)"></a>101.对称二叉树(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.ismirror(root,root)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ismirror</span><span class="params">(self,p,q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">None</span> <span class="keyword">and</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">None</span> <span class="keyword">or</span> q == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">            <span class="keyword">return</span> self.ismirror(p.left,q.right) <span class="keyword">and</span> self.ismirror(p.right,q.left)</span><br></pre></td></tr></table></figure></li><li><h4 id="102-二叉树的层序遍历-medium"><a href="#102-二叉树的层序遍历-medium" class="headerlink" title="102.二叉树的层序遍历(medium)"></a>102.二叉树的层序遍历(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        num=[]</span><br><span class="line">        temp=[]</span><br><span class="line">        <span class="keyword">while</span> len(queue)&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> len(queue)&gt;<span class="number">0</span>:</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># print(type(node))</span></span><br><span class="line">                num.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    temp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    temp.append(node.right)</span><br><span class="line">            <span class="comment"># print(type(temp[0]))</span></span><br><span class="line">            res.append(num)</span><br><span class="line">            num=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temp)):</span><br><span class="line">                queue.append(temp[i])</span><br><span class="line">            temp=[]</span><br><span class="line">            <span class="comment"># for i in temp:</span></span><br><span class="line">            <span class="comment">#     queue.append(temp)</span></span><br><span class="line">            <span class="comment"># temp=[]</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="104-二叉树的最大深度-easy"><a href="#104-二叉树的最大深度-easy" class="headerlink" title="104.二叉树的最大深度(easy)"></a>104.二叉树的最大深度(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><h4 id="105-从前序与中序遍历序列构造二叉树-medium"><a href="#105-从前序与中序遍历序列构造二叉树-medium" class="headerlink" title="105.从前序与中序遍历序列构造二叉树(medium)"></a>105.从前序与中序遍历序列构造二叉树(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        x = preorder[<span class="number">0</span>]</span><br><span class="line">        node = TreeNode(x)</span><br><span class="line">        i = inorder.index(x)</span><br><span class="line"></span><br><span class="line">        node.left = self.buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>],inorder[:i])</span><br><span class="line">        node.right = self.buildTree(preorder[i+<span class="number">1</span>:],inorder[i+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></li></ul><ul><li><h4 id="114-二叉树展开为链表-medium"><a href="#114-二叉树展开为链表-medium" class="headerlink" title="114.二叉树展开为链表(medium)"></a>114.二叉树展开为链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line">        tmp = root.right</span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="literal">None</span>):</span><br><span class="line">            root = root.right</span><br><span class="line">        root.right = tmp</span><br></pre></td></tr></table></figure></li><li><h4 id="121-买卖股票的最佳时机-easy"><a href="#121-买卖股票的最佳时机-easy" class="headerlink" title="121.买卖股票的最佳时机(easy)"></a>121.买卖股票的最佳时机(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># max_num=0</span></span><br><span class="line">        <span class="comment"># if len(prices)==0:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="comment"># for i in range(1,len(prices)):</span></span><br><span class="line">        <span class="comment">#     if prices[i]-min(prices[:i])&gt;max_num:</span></span><br><span class="line">        <span class="comment">#         max_num = prices[i]-min(prices[:i])</span></span><br><span class="line">        <span class="comment"># return max_num</span></span><br><span class="line"></span><br><span class="line">        max_num=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_num=prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            min_num = min(min_num,prices[i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> prices[i]-min_num&gt;max_num:</span><br><span class="line">                max_num = prices[i]-min_num</span><br><span class="line">        <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure></li><li><h4 id="128-最长连续序列-hard"><a href="#128-最长连续序列-hard" class="headerlink" title="128.最长连续序列(hard)"></a>128.最长连续序列(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = list(set(nums))</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">        res=[<span class="number">1</span>]</span><br><span class="line">        count=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]-nums[i<span class="number">-1</span>]==<span class="number">1</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(count)</span><br><span class="line">                count=<span class="number">1</span></span><br><span class="line">        res.append(count)</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br></pre></td></tr></table></figure></li><li><h4 id="136-只出现一次的数字-easy"><a href="#136-只出现一次的数字-easy" class="headerlink" title="136.只出现一次的数字(easy)"></a>136.只出现一次的数字(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            a = a ^ num</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></li><li><h4 id="141-环型链表-easy"><a href="#141-环型链表-easy" class="headerlink" title="141.环型链表(easy)"></a>141.环型链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        p=head</span><br><span class="line">        q=head.next</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> q.next==p:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q.next==<span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> q.next.next==<span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                p=p.next</span><br><span class="line">                q=q.next.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><h4 id="142-环形链表II-medium"><a href="#142-环形链表II-medium" class="headerlink" title="142.环形链表II(medium)"></a>142.环形链表II(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        node=head</span><br><span class="line">        <span class="keyword">while</span> node!=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node.next <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                res.append(node)</span><br><span class="line">                node=node.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> node.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></li><li><h4 id="148-排序链表-medium"><a href="#148-排序链表-medium" class="headerlink" title="148.排序链表(medium)"></a>148.排序链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        h_head = ListNode(<span class="literal">None</span>) <span class="comment">#申请头节点</span></span><br><span class="line">        res = [] <span class="comment">#将节点保存在列表中</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            next_h = head.next</span><br><span class="line">            head.next = <span class="literal">None</span></span><br><span class="line">            res.append(head)</span><br><span class="line">            head = next_h</span><br><span class="line">            <span class="comment"># head = head.next</span></span><br><span class="line">        res = sorted(res,key = <span class="keyword">lambda</span> x:x.val)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        n = len(res)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        h_head.next = res[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            res[i].next = res[i+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> h_head.next</span><br></pre></td></tr></table></figure></li><li><h4 id="152-乘积最大子数组-medium"><a href="#152-乘积最大子数组-medium" class="headerlink" title="152.乘积最大子数组(medium)"></a>152.乘积最大子数组(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rev_nums = nums[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            nums[i] *= nums[i<span class="number">-1</span>] <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">            rev_nums[i] *= rev_nums[i<span class="number">-1</span>] <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(max(nums),max(rev_nums))</span><br></pre></td></tr></table></figure></li><li><h4 id="155-最小栈-easy"><a href="#155-最小栈-easy" class="headerlink" title="155.最小栈(easy)"></a>155.最小栈(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.l = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.l.append(x)</span><br><span class="line">        self.minnum = min(self.l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.l.pop()</span><br><span class="line">        self.minnum =<span class="keyword">not</span> self.l <span class="keyword">or</span> min(self.l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.l[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.minnum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure></li><li><h4 id="160-相交链表-easy"><a href="#160-相交链表-easy" class="headerlink" title="160.相交链表(easy)"></a>160.相交链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l1=<span class="number">0</span></span><br><span class="line">        l2=<span class="number">0</span></span><br><span class="line">        node1=headA</span><br><span class="line">        node2=headB</span><br><span class="line">        <span class="keyword">while</span> headA: <span class="comment">#求第一个链表长度</span></span><br><span class="line">            l1+=<span class="number">1</span></span><br><span class="line">            headA=headA.next</span><br><span class="line">        <span class="keyword">while</span> headB: <span class="comment">#求第二个链表长度</span></span><br><span class="line">            l2+=<span class="number">1</span></span><br><span class="line">            headB=headB.next</span><br><span class="line">        s=l1-l2</span><br><span class="line">        <span class="keyword">while</span> s&gt;<span class="number">0</span>: <span class="comment">#对齐两个链表长度</span></span><br><span class="line">            node1=node1.next</span><br><span class="line">            s-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> s&lt;<span class="number">0</span>:</span><br><span class="line">            node2=node2.next</span><br><span class="line">            s+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> node1 <span class="keyword">and</span> node2:</span><br><span class="line">            <span class="keyword">if</span> node1==node2:</span><br><span class="line">                <span class="keyword">return</span> node1</span><br><span class="line">            node1=node1.next</span><br><span class="line">            node2=node2.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># while node1!=node2: #从头开始判断地址是否相同</span></span><br><span class="line">        <span class="comment">#     node1=node1.next</span></span><br><span class="line">        <span class="comment">#     node2=node2.next</span></span><br><span class="line">        <span class="comment"># return node1</span></span><br></pre></td></tr></table></figure></li><li><h4 id="169-多数元素-easy"><a href="#169-多数元素-easy" class="headerlink" title="169.多数元素(easy)"></a>169.多数元素(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = sorted(nums)</span><br><span class="line">        <span class="keyword">return</span> res[(len(nums)//<span class="number">2</span>)]</span><br></pre></td></tr></table></figure></li><li><h4 id="206-反转链表-easy"><a href="#206-反转链表-easy" class="headerlink" title="206.反转链表(easy)"></a>206.反转链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if head:</span></span><br><span class="line">        <span class="comment">#     pre=head</span></span><br><span class="line">        <span class="comment">#     q=head.next</span></span><br><span class="line">        <span class="comment">#     while pre.next:</span></span><br><span class="line">        <span class="comment">#         pre.next=q.next</span></span><br><span class="line">        <span class="comment">#         q.next=head</span></span><br><span class="line">        <span class="comment">#         head=q</span></span><br><span class="line">        <span class="comment">#         q=pre.next</span></span><br><span class="line">        <span class="comment"># return head</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre=head</span><br><span class="line">        q=head.next</span><br><span class="line">        <span class="keyword">while</span> pre.next:</span><br><span class="line">            pre.next=q.next</span><br><span class="line">            q.next=head</span><br><span class="line">            head=q</span><br><span class="line">            q=pre.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></li><li><h4 id="215-数组中的第K个最大元素-medium"><a href="#215-数组中的第K个最大元素-medium" class="headerlink" title="215.数组中的第K个最大元素(medium)"></a>215.数组中的第K个最大元素(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = sorted(nums,reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> s[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="226-翻转二叉树-easy"><a href="#226-翻转二叉树-easy" class="headerlink" title="226.翻转二叉树(easy)"></a>226.翻转二叉树(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        temp = root.left</span><br><span class="line">        root.left = root.right</span><br><span class="line">        root.right = temp</span><br><span class="line">        root.left = self.invertTree(root.left)</span><br><span class="line">        root.right = self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></li><li><h4 id="234-回文链表-easy"><a href="#234-回文链表-easy" class="headerlink" title="234.回文链表(easy)"></a>234.回文链表(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#第一种思路</span></span><br><span class="line">        <span class="comment">#再创建一个链表与head相反，然后逐个对比</span></span><br><span class="line">        <span class="comment">#超时 失败</span></span><br><span class="line">        <span class="comment">#第二种思路</span></span><br><span class="line">        <span class="comment">#用list存下链表所有值，逐个对比</span></span><br><span class="line">        <span class="comment">#超时 失败</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> head.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> head!=<span class="literal">None</span> <span class="keyword">and</span> head.next!=<span class="literal">None</span> <span class="keyword">and</span> head.next.next==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.val==head.next.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        c=[]</span><br><span class="line">        pre=head</span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            c.append(pre.val)</span><br><span class="line">            pre=pre.next</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        j=<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)/<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> c[i]!=c[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># if head==None or head.next==None:</span></span><br><span class="line">        <span class="comment">#     return True</span></span><br><span class="line">        <span class="comment"># if head!=None and head.next!=None and head.next.next==None:</span></span><br><span class="line">        <span class="comment">#     if head.val==head.next.val:</span></span><br><span class="line">        <span class="comment">#         return True</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line">        <span class="comment"># pre=head</span></span><br><span class="line">        <span class="comment"># node=None</span></span><br><span class="line">        <span class="comment"># node_head=None</span></span><br><span class="line">        <span class="comment"># while pre:</span></span><br><span class="line">        <span class="comment">#     node_head=ListNode(pre.val)</span></span><br><span class="line">        <span class="comment">#     node_head.next=node</span></span><br><span class="line">        <span class="comment">#     node=node_head</span></span><br><span class="line">        <span class="comment">#     pre=pre.next</span></span><br><span class="line">        <span class="comment"># while node_head and head:</span></span><br><span class="line">        <span class="comment">#     if node_head.val!=head.val:</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line">        <span class="comment"># return True</span></span><br></pre></td></tr></table></figure></li><li><h4 id="238-除自身以外数组的乘积-medium"><a href="#238-除自身以外数组的乘积-medium" class="headerlink" title="238.除自身以外数组的乘积(medium)"></a>238.除自身以外数组的乘积(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        res1=[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        res2 = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            res1[i]=nums[i<span class="number">-1</span>]*res1[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            res2[j]=nums[j+<span class="number">1</span>]*res2[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res1)):</span><br><span class="line">            res.append(res1[i]*res2[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for j in range(i):</span></span><br><span class="line">        <span class="comment">#         res[i]*=nums[j]</span></span><br><span class="line">        <span class="comment">#     for k in range(i+1,len(nums)):</span></span><br><span class="line">        <span class="comment">#         res[i]*=nums[k]</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure></li><li><h4 id="279-完全平方数-medium"><a href="#279-完全平方数-medium" class="headerlink" title="279.完全平方数(medium)"></a>279.完全平方数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#n = (4^a)*(8b+7) return 4</span></span><br><span class="line">        <span class="keyword">while</span> n%<span class="number">4</span>==<span class="number">0</span>:</span><br><span class="line">            n/=<span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">8</span>==<span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">        a=<span class="number">0</span></span><br><span class="line">        <span class="comment">#n=a**2 + b**2 return 1 or 2</span></span><br><span class="line">        <span class="keyword">while</span> a**<span class="number">2</span> &lt;=n:</span><br><span class="line">            b= int((n-a**<span class="number">2</span>)**<span class="number">0.5</span>)</span><br><span class="line">            <span class="keyword">if</span> a**<span class="number">2</span> + b**<span class="number">2</span> == n: </span><br><span class="line">                <span class="keyword">if</span> a&gt;<span class="number">0</span>:</span><br><span class="line">                    a=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> b&gt;<span class="number">0</span>:</span><br><span class="line">                    b=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> a+b</span><br><span class="line">            a+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><h4 id="283-移动零-easy"><a href="#283-移动零-easy" class="headerlink" title="283.移动零(easy)"></a>283.移动零(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                nums.insert(len(nums),<span class="number">0</span>)</span><br><span class="line">                nums.remove(i)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></li><li><h4 id="287-寻找重复数-medium"><a href="#287-寻找重复数-medium" class="headerlink" title="287.寻找重复数(medium)"></a>287.寻找重复数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        s= sorted(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s[i]^s[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> s[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><h4 id="297-二叉树的序列化与反序列化-hard"><a href="#297-二叉树的序列化与反序列化-hard" class="headerlink" title="297.二叉树的序列化与反序列化(hard)"></a>297.二叉树的序列化与反序列化(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'null '</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            <span class="keyword">return</span> str(root.val)+<span class="string">' '</span>+left+right</span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(data)</span>:</span></span><br><span class="line">            val = data.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> val == <span class="string">'null'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            node.left = dfs(data)</span><br><span class="line">            node.right = dfs(data)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(data)</span></span><br><span class="line">        dataList = data.split(<span class="string">' '</span>) </span><br><span class="line">        <span class="comment"># print(dataList)</span></span><br><span class="line">        <span class="keyword">return</span> dfs(dataList)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># ser = Codec()</span></span><br><span class="line"><span class="comment"># deser = Codec()</span></span><br><span class="line"><span class="comment"># ans = deser.deserialize(ser.serialize(root))</span></span><br></pre></td></tr></table></figure></li><li><h4 id="347-前K个高频元素-medium"><a href="#347-前K个高频元素-medium" class="headerlink" title="347.前K个高频元素(medium)"></a>347.前K个高频元素(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> Counter(nums).most_common(k):</span><br><span class="line">            res.append(i[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># res = Counter(nums)</span></span><br><span class="line">        <span class="comment"># result = []</span></span><br><span class="line">        <span class="comment"># for i in res.most_common(k):</span></span><br><span class="line">        <span class="comment">#     result.append(i[0])</span></span><br><span class="line">        <span class="comment"># return result</span></span><br></pre></td></tr></table></figure></li><li><h4 id="394-字符串解码-medium"><a href="#394-字符串解码-medium" class="headerlink" title="394.字符串解码(medium)"></a>394.字符串解码(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s :</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = num*<span class="number">10</span>+int(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">"["</span>:</span><br><span class="line">                stack.append((res,num))</span><br><span class="line">                res = <span class="string">""</span></span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">"]"</span>:</span><br><span class="line">                top = stack.pop()</span><br><span class="line">                res = top[<span class="number">0</span>]+res*top[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += c</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><h4 id="448-找到所有数组中消失的数字-easy"><a href="#448-找到所有数组中消失的数字-easy" class="headerlink" title="448.找到所有数组中消失的数字(easy)"></a>448.找到所有数组中消失的数字(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDisappearedNumbers</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># if len(nums)==0:</span></span><br><span class="line">        <span class="comment">#     return []</span></span><br><span class="line">        <span class="comment"># max_n = len(nums)</span></span><br><span class="line">        <span class="comment"># s = set([i for i in range(1, max_n+1)])</span></span><br><span class="line">        <span class="comment"># s = s.difference(set(nums))</span></span><br><span class="line">        <span class="comment"># return list(s)</span></span><br><span class="line">        <span class="comment"># c=[]</span></span><br><span class="line">        c=set(nums)</span><br><span class="line">        d=set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)+<span class="number">1</span>):</span><br><span class="line">                d.add(i)</span><br><span class="line">        result = d.difference(c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(result)</span><br></pre></td></tr></table></figure></li><li><h4 id="461-汉明距离-easy"><a href="#461-汉明距离-easy" class="headerlink" title="461.汉明距离(easy)"></a>461.汉明距离(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        a=bin(x)[<span class="number">2</span>:]</span><br><span class="line">        b=bin(y)[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">if</span> len(a)&gt;len(b):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)-len(b)):</span><br><span class="line">                b = <span class="string">"0"</span>+b</span><br><span class="line">        <span class="keyword">elif</span> len(a)&lt;len(b):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)-len(a)):</span><br><span class="line">                a = <span class="string">"0"</span>+a</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">            <span class="keyword">if</span> a[i]!=b[i]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></li><li><h4 id="560-和为K的子数组-medium"><a href="#560-和为K的子数组-medium" class="headerlink" title="560.和为K的子数组(medium)"></a>560.和为K的子数组(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m=&#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        sumN=<span class="number">0</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            sumN+=nums[i]</span><br><span class="line">            count+=m.get(sumN-k,<span class="number">0</span>)</span><br><span class="line">            m[sumN]=m.get(sumN,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></li><li><h4 id="617-合并二叉树-easy"><a href="#617-合并二叉树-easy" class="headerlink" title="617.合并二叉树(easy)"></a>617.合并二叉树(easy)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type t1: TreeNode</span></span><br><span class="line"><span class="string">        :type t2: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> t1 <span class="keyword">and</span> t2:</span><br><span class="line">            t1.val +=t2.val</span><br><span class="line">            t1.left = self.mergeTrees(t1.left,t2.left)</span><br><span class="line">            t1.right = self.mergeTrees(t1.right,t2.right)</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        <span class="keyword">return</span> t1 <span class="keyword">or</span> t2</span><br></pre></td></tr></table></figure></li><li><h4 id="647-回文子串-medium"><a href="#647-回文子串-medium" class="headerlink" title="647.回文子串(medium)"></a>647.回文子串(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># int count = len(s)</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(s)+<span class="number">1</span>):</span><br><span class="line">            i=<span class="number">0</span></span><br><span class="line">            k=j</span><br><span class="line">            <span class="keyword">while</span> k&lt;=len(s):</span><br><span class="line">                t=s[i:k]</span><br><span class="line">                <span class="keyword">if</span> t==t[::<span class="number">-1</span>]:</span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></li><li><h4 id="739-每日温度-medium"><a href="#739-每日温度-medium" class="headerlink" title="739.每日温度(medium)"></a>739.每日温度(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type T: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(T))]</span><br><span class="line">        stack=[]</span><br><span class="line">        <span class="comment"># print(s)</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(T):</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> T[stack[<span class="number">-1</span>]] &lt; v:</span><br><span class="line">                    res[stack[<span class="number">-1</span>]] = k - stack[<span class="number">-1</span>]</span><br><span class="line">                    stack.pop()</span><br><span class="line">            stack.append(k)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;1-两数之和-easy&quot;&gt;&lt;a href=&quot;#1-两数之和-easy&quot; class=&quot;headerlink&quot; title=&quot;1.两数之和(easy)&quot;&gt;&lt;/a&gt;1.两数之和(easy)&lt;/h4&gt;&lt;figure class=&quot;highlight p
      
    
    </summary>
    
    
      <category term="算法" scheme="elssm.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Composite Adversarial Attacks</title>
    <link href="elssm.github.io/2021/03/05/Composite-Adversarial-Attacks/"/>
    <id>elssm.github.io/2021/03/05/Composite-Adversarial-Attacks/</id>
    <published>2021-03-05T10:22:07.000Z</published>
    <updated>2021-04-13T09:38:18.219Z</updated>
    
    <content type="html"><![CDATA[<p>论文地址：<a href="https://arxiv.org/pdf/2012.05434.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/2012.05434.pdf</a><br>代码地址：<a href="https://github.com/vtddggg/CAA" target="_blank" rel="noopener">https://github.com/vtddggg/CAA</a></p><h4 id="What-is-adversarial-attack？"><a href="#What-is-adversarial-attack？" class="headerlink" title="What is adversarial attack？"></a>What is adversarial attack？</h4><p>对抗攻击是指通过对输入添加微小的扰动使得分类器分类错误，一般对用于深度学习的网络的攻击算法最为常见，对抗攻击的应用场景包括CV和NLP等。例如，通过对图片添加精心准备的扰动噪声使得分类器出错，或者通过对一个句子中的某些词进行同义词替换使得情感分类错误。</p><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>在实践中，攻击算法是由专家人工选择和调整的，用以破坏机器学习系统，然而，手动选择攻击者往往不是最优的，这容易导致错误的评估模型安全性。因此这篇文章提出了一种新的组合对抗攻击方法(CAA)，用于从32个攻击者候选池中自动搜索攻击算法以及超参数的最佳组合。</p><p>文中作者设计了一个搜索空间，将攻击策略表示为一个攻击序列，即：前一个攻击者的输出被用作后续攻击者的初始化输入。采用NSGA-II多目标遗传算法寻找复杂度最小的最强攻击策略。</p><h4 id="What-is-NSGA-II？"><a href="#What-is-NSGA-II？" class="headerlink" title="What is NSGA-II？"></a>What is NSGA-II？</h4><p>NSGA-II是目前最流行的多目标遗传算法之一，它降低了非劣排序遗传算法的复杂性，具有运算速度快，解集的收敛性好的优点，成为其他多目标优化算法性能的基准。<br>NSGA-II就是在第一代非支配排序遗传算法的基础上改进而来，其改进主要是针对如上所述的三个方面：</p><ul><li>提出了快速非支配排序算法，一方面降低了计算的复杂度，另一方面它将父代种群跟子代种群进行合并，使得下一代的种群从双倍的空间中进行选取，从而保留了最为优秀的所有个体</li><li>引进精英策略，保证某些优良的种群个体在进化过程中不会被丢弃，从而提高了优化结果的精度</li><li>采用拥挤度和拥挤度比较算子，不但克服了NSGA中需要人为指定共享参数的缺陷，而且将其作为种群中个体间的比较标准，使得准Pareto域中的个体能均匀地扩展到整个Pareto域，保证了种群的多样性。</li></ul><p>具体有关NSGA-II遗传算法的内容这里不多详述。有兴趣可以观看视频了解。<br>视频地址：<a href="https://www.bilibili.com/video/BV1q7411C77i?from=search&amp;seid=12093857430959589428" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1q7411C77i?from=search&amp;seid=12093857430959589428</a></p><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>深度神经网络很容易受到对抗性攻击，这些攻击的目的是通过产生难以察觉的干扰来欺骗一个训练良好的模型，这一严重的安全隐患很快就引起了机器学习社区的广泛关注，通过对对抗实例的深入研究，大量的攻击算法被提出用来验证对抗的鲁棒性。同时，也产生了一些开源的工具箱。</p><h4 id="对抗攻击实现工具"><a href="#对抗攻击实现工具" class="headerlink" title="对抗攻击实现工具"></a>对抗攻击实现工具</h4><p>目前来说，比较主流的工具有cleverhans，foolbox，advertorch。</p><div class="table-container"><table><thead><tr><th></th><th>cleverhans</th><th>foolbox</th><th>advertorch</th></tr></thead><tbody><tr><td>针对模型框架</td><td>tensorflow/keras/pytorch</td><td>tensorflow/pytorch</td><td>pytorch</td></tr><tr><td>产生速度</td><td>可以批量</td><td>无法批量</td><td>可以批量</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cleverhans:https://github.com/cleverhans-lab/cleverhans</span><br><span class="line">foolbox:https://github.com/bethgelab/foolbox</span><br><span class="line">advertorch:https://github.com/BorealisAI/advertorch</span><br></pre></td></tr></table></figure><h4 id="The-necessity-of-CAA"><a href="#The-necessity-of-CAA" class="headerlink" title="The necessity of CAA"></a>The necessity of CAA</h4><p>然而，即使开发了设计良好的工具箱，攻击一个模型仍然需要大量的用户体验或手动调整攻击的超参数，特别是当我们不知道目标模型的防御机制时，这种依赖用户的特性也使得对抗性攻击的工具化变得困难。另一方面，手动选择攻击者有一定的倾向性和次优性。这可能引起对模型安全性的错误评估。为了实现更全面，更强的攻击，我们首先提出了通过从一组攻击算法中搜索有效的攻击策略来实现自动化攻击过程。我们将这个过程称为复合对抗攻击(CAA)</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/1.png" alt="1"></p><p>上图是CIFAR-10对抗训练模式下CAA与其他攻击者的比较，其中CAA-n代表CAA攻击有几次重启，从上图可以发现CAA只需要少量的梯度评估就能获得最佳的攻击性能。<br>为了演示CAA的关键思想，图2中给出了一个示例。假设有两种可能的攻击方式，空间攻击和FGSM攻击，目标是选择其中一个或多个来组成一个更强的攻击策略。在图2(b)中，最简单的方法是选择最佳的单次攻击作为最终策略。然而，单个攻击者总是不够强大和一般化。一个更好的解决方案是找到多个攻击者，然后通过不断选择能够成功为模型提供工具的最佳输出来集成它们(如图2(c))，虽然这样可以获得较高的攻击成功率，但集成攻击只提供输出级的聚合，没有考虑不同攻击机制之间的互补性。<br>在我们的复合对抗攻击中，我们将攻击策略定义为攻击者的串行连接，其中前一个攻击者的输出作为后继攻击者的初始化输入。在图2（d）中，两个攻击者可以生成四种可能的排列。通过使用搜索算法来寻找最佳排列，我们发现空间攻击之后的FGSM攻击错误率比他们整体可以高出26%。</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/2.png" alt="2"></p><p>该策略的优点在于两个方面：1）通过引入身份攻击，CAA模型可以表示任意一种攻击。集合攻击也可以用CAA的策略集合来表示，因此，CAA是更为广义的公式。2） 一个强大的攻击可以通过渐进的步骤产生，早期的研究发现，一些接近决策边界的起始点比原始种子更适合于优化攻击。类似地，在CAA中，我们使用前面的攻击者创建一个距离原始种子足够远、距离边界足够近的示例。这样，随后的攻击更容易找到一个更强的对抗实例。<br>具体来说，CAA是通过一个包含多个选择和攻击顺序的搜索空间来实现操作。对于每一个攻击操作都有两个超参数，幅值$\epsilon$和迭代步骤t，采用NSGA-II遗传算法去寻找能够突破目标模型最好的攻击策略，具有最高的准确率和最低的复杂度。大量实验表明，CAA在两个用例中取得了很好的改进：1）CAA可以直接应用于感兴趣的目标模型上，以找到最佳攻击策略$CAA_{dic}$ 2）学习策略可以在不同的任务下保持较高的成功率转移到攻击多模型体系结构$CAA_{sub}$。我们对最近提出的11种关于L无穷、L2和无限制设置的防御机制的$CAA_{dic}$和$CAA_{sub}$进行了评估。结果表明，复合对抗攻击(CAA)在白盒场景中达到了很好的效果，大大降低了攻击时间开销。</p><h4 id="Preliminaries-and-Related-work"><a href="#Preliminaries-and-Related-work" class="headerlink" title="Preliminaries and Related work"></a>Preliminaries and Related work</h4><p><strong>符号定义</strong>：具体请看文章定义。<br><strong>常规对抗性实例</strong>：常规的对抗性例子是具有有限数量级的扰动，这通常是通过将扰动限定在某个范围内来实现的，有许多改进版本的FGSM使用基于动量的多步优化，或扰动的随机初始化。基于L2范式的攻击（如DDNL2和C&amp;W）。基于L1的攻击者保证扰动的稀疏性，如EAD。但是，L1攻击在实际攻击设置中并不常用。因此，文章没有实现在L1限制下的CAA<br><strong>无限制对抗实例</strong>：无限制对抗性实例是一种新型的不受范数有界小扰动限制的对抗性实例。在这种情况下，攻击者可能会在不更改语义的情况下显著更改输入。首先介绍了无限制对抗的概念，并提出了一个两人无限制攻防对抗的例子。近年来，有许多研究利用生成模型或空间变换来构造这种更强的无限制攻击。在本文中，我们还实现了最大搜索空间（总共19次攻击）的无限制CAA。我们发现，即使应用非常简单的基本攻击者来形成搜索空间，我们的CAA搜索的策略在不受限制的设置下仍然产生令人惊讶的攻击能力。<br><strong>自动机器学习</strong>：我们的方法受到自动机器学习及其子方向（如神经结构搜索（NAS）和超参数优化（HPO））的最新进展的启发。其中，搜索算法用于算法选择、特征预处理步骤和超参数的自动提取。另一个类似的方向是自动增强，它自动搜索改进的数据增强策略。这些自动化技术不仅使人们摆脱了繁琐的算法微调过程，而且大大提高了学习系统的效果和效率。在本文中，我们采用了AutoML中的一些搜索技术，证明了搜索更好的算法和参数也有助于对抗性攻击。<br>有关<strong>AutoML</strong>相关知识可移步这篇文章：<a href="https://zhuanlan.zhihu.com/p/112148211" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/112148211</a></p><h4 id="Composite-Adversarial-Attacks"><a href="#Composite-Adversarial-Attacks" class="headerlink" title="Composite Adversarial Attacks"></a>Composite Adversarial Attacks</h4><p><strong>通过重投影模块限制$l_p$范式</strong></p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/3.png" alt="3"></p><p>在文中problem formulation中公式2所提出的攻击策略是一种一般形式，它对全局扰动没有约束，当攻击序列变长时，每个攻击算法的计算扰动会进行累加，这就会导致对原始输入的最终扰动较大，为了解决这一问题，作者提出在两个连续攻击算法之间插入一个重投影模块，如上图3所示，重投影模块首先会判断该策略对以前的攻击者所累积的$\epsilon$是否大于全局的$\epsilon_{global}$，如果是，累计扰动将会被剪切或重新缩放，使得$l_p$-norm在$\epsilon_{global}$中有界，有了这种改进，可以在任意范数条件下使用复合对抗攻击。</p><h4 id="搜索目标"><a href="#搜索目标" class="headerlink" title="搜索目标"></a>搜索目标</h4><p>之前的工作通常以攻击成功率(ASR)或鲁棒准确率(RA)作为设计算法的目标。然而，这些目标都可以通过花费更多的时间来实现。例如通过随机重启或者多目标方式以获得更高的成功率，这样也就牺牲了运行效率。从而使得算法变得非常慢，甚至比一些黑盒攻击还要耗时。CAA强调一个好的并且强大的攻击者应该是有效且高效的，为了达到这个目标，作者设计了最小化两个术语的目标：强大的准确性和复杂性。第一个术语RA是目标模型在生成的对抗性例子上的准确性，这也反映了攻击者的实力。对于第二项复杂度，使用梯度评价的个数作为复杂度度量，对于普通攻击算法，梯度评估次数表示攻击算法在攻击过程中计算目标模型梯度的次数，一般等于优化步骤t。因此我们可以将总体目标函数表示为：<br><img src="/2021/03/05/Composite-Adversarial-Attacks/4.png" alt="4"><br>其中s(x)代表输入x后攻击策略的输出。N代表攻击策略的长度。$\alpha$是一个权衡攻击强度和复杂性的系数。之后可以应用一个搜索算法，通过最小化目标，从数千种可能的策略中找到最优的的攻击策略。</p><h4 id="搜索空间"><a href="#搜索空间" class="headerlink" title="搜索空间"></a>搜索空间</h4><p>搜索空间被分为两个部分 1）寻找攻击操作的选择和命令。2）寻找每一次攻击操作的幅值$\epsilon$和步数t。对于由N个基础攻击操作组成的攻击策略。攻击操作搜索形成了一个$||A||^N$可能性的问题空间。此外，每个操作也与他们的幅值和步数有关。我们将幅值$\epsilon$和步数t的范围大小离散为8个值(均匀间距)，这样就可以将复合对抗攻击搜索简化为一个离散优化问题。最后，整个搜索空间的总大小为$(8<em>8</em>||A||)^N$<br>在这篇文章中，将策略空间分为三种类型：$S_{l_\infty},S_{l_2}和S_{unrestricted}$,分别在$S_{l_\infty}和S_{l_2}$上实现了6种$S_{l_\infty}$攻击和6种$S_{l_2}$攻击。在不受限制的情况下使用了更大的搜索空间实现了19种攻击算法。此外，所有的$S_{l_\infty},S_{l_2}和S_{unrestricted}$都采用身份攻击来表示身份操作，攻击策略在各搜索空间的输出可视化如图4所示：</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/5.png" alt="5"></p><h4 id="搜索策略"><a href="#搜索策略" class="headerlink" title="搜索策略"></a>搜索策略</h4><p>搜索策略在寻找最好的攻击策略中起到了很重要的作用，在我们的问题设置中，搜索空间的规模相对较小，而且策略评估的成本比起其他任务（如NAS）要低很多，有关NAS的介绍请移步这篇文章，在此不做过多介绍。<br>一篇NAS的介绍：<a href="https://zhuanlan.zhihu.com/p/45133026" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45133026</a><br>这样就允许我们使用一些高性能的搜索算法，作者比较了三种广泛使用的方法，即：贝叶斯优化，强化学习和NSGA-II遗传算法。虽然贝叶斯优化和强化学习在自动学习领域被广泛认为是有效的，但在解决文章中的这个问题上，一是它们更加耗时，二是收敛的比较缓慢。相比之下，NSGA-II更快，因为在搜索期间不需要额外的模型优化过程。它只需要几次迭代的种群更新就可以快速地找到最优解。<br>具体来说，NSGA-II需要维护所有可能策略的有限集合和策略评估函数，NSGA-II算法通过三个步骤来搜索潜在攻击策略的空间。一个人口初始化步骤，使用随机策略生成人口$P_0$,一个包括攻击策略的交叉和变异的探索步骤，一种利用被评估策略的整个历史中隐藏的知识并找到最优策略的开发步骤。整个过程如下图算法所示：</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/6.png" alt="6"></p><h4 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h4><p>为了验证CAA的性能，在11个开源防御模型上对$S_{l_\infty},S_{l_2}和S_{unrestricted}$上的搜索攻击策略进行了评估。在CIFAR-10和ImageNet数据集上进行了$l_\infty和l_2$攻击实验。对Bird&amp;Bicycle数据集进行了无限制攻击。将鲁棒精确度记录为测量值，与最近排名前10位的攻击者进行比较，在实现过程中，取策略的所有中间结果并将其集合位相似的结果。<br>CAA的候选池包括32个攻击行为，其中有六个$l_\infty$攻击，六个$l_2$攻击，十九个无限制攻击和最后的身份攻击。具体实现的攻击算法总结如下图所示：</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/7.png" alt="7"></p><p><strong>数据配置</strong>：对于CIFAR-10，我们在一个小的子集上搜索最佳策略，该子集包含从训练集中随机选择的4000个示例。测试集中总共使用了10000个示例来评估搜索的策略。对于ImageNet，由于整个验证集比较大，因此作者随机从训练数据库和册书数据库中分别选取1000张图像进行策略搜索和1000张图像进行评估。对于Bird&amp;Bicycle数据集，使用所有250个测试图像评估，以及1000个随机选择的训练图像进行攻击策略搜索。<br><strong>实验总结</strong>：调查了4个案例 1）BestAttack，在候选池中寻找最佳单个攻击者。2）EnsAttack，搜索多个攻击者的集合。3）$CAA_{dic}$，直接搜索给定数据集的CAA策略。4）$CAA_{sub}$，通过攻击对抗性训练模型作为替代进行搜索，并转移到其他模型或任务中。<br>为了研究在黑盒和白盒环境下CAA的可转移性，后续又对不同策略搜索算法和攻击策略长度N的影响进行了研究。分析了非目标攻击和目标攻击搜索策略的区别。</p><p>表2给出了4种变量基于$l_\infty$的攻击结果。这些攻击都是在CIFAR-10数据集上实现的</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/8.png" alt="8"></p><p>这些攻击者梯度评估的总次数（复杂度）都大于1000，相比之下，$CAA_{sub}$具有更低的复杂度（800），并且以更高的错误率打破了模型。这也表明了即使是替代攻击策略也可能具有较高的时间效率和可靠性。</p><p>同样的，在ImageNet数据集上，CAA取得了更大的进步。特别的，$CAA_{sub}$攻击$l_\infty$对抗训练模型的准确率达到38.30%，比最新技术提高了2%左右。这意味着CAA更适合攻击复杂的分类任务。ImageNet分类有更多的类别和更大的图像输入大小。同样我们发现由基础攻击者生成的对抗示例在ImageNet上更加多样化。对于这样一个复杂的任务，攻击策略设计有更多的空间。<br>对于无限制攻击选择Bird&amp;Bicycle基准。并使用排行榜上排名前两名的防御模型LLR和TRADESv2进行评估。</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/9.png" alt="9"></p><p><strong>搜索策略分析</strong>：表2是对$S_{l_\infty},S_{l_2}和S_{unrestricted}$的最佳搜索策略的可视化，该策略是在CIFAR-10分类任务上通过攻击对抗性训练模型来搜索的。在所有的$S_{l_\infty},S_{l_2}$和无限制攻击场景中，CAA倾向于选择强攻击性。以$S_{l_\infty}$策略为例。CAA选择最强的MT-LinfAttack作为第一和第二位置的攻击，同时放弃较弱的攻击者，例如单此FGSM攻击。所以一个良好选择的候选攻击池对CAA的性能至关重要。另一个基础是CAA更喜欢一些组合了不同基础攻击者的政策。这意味着用ML-Linf和PGD-Linf攻击所形成的策略通常不会有太大的改进，因为这两个攻击之间的差异很小（他们的原理和目标函数相同），相比之下，在$S_{l_\infty}$的最佳策略下，CAA选择了更多样化的基于边界损失的CW-Linf攻击来辅助基于交叉熵损失的攻击者，从而提高了攻击性能。<br><strong>攻击可转移性</strong>：文章在两个场景下研究了CAA的可转移性。一个是在黑盒设定下，一个是在白盒设定下。黑盒设定下，由于无法获得目标模型的梯度，所以使用CAA来搜索替代模型的策略，并生成对抗的例子来攻击目标模型。在白盒设定下，梯度评估是被允许的，因此在替代任务或模型上的策略搜索被直接用在目标模型上生成对抗实例。<br><strong>CAA的黑盒可转移性</strong>：为了能够讨论是否CAA能够被用于搜索黑盒转移攻击，在对抗样例生成阶段，使用攻击策略s来攻击替代模型，然后在目标模型上对这些对抗性的例子进行测试。将目标模型的鲁棒性精度作为策略s的评价分数。除此之外，整个搜索过程保持不变，作者将这种变体命名为$CAA_{trans}$,在攻击可转移性实验中使用了三种不同架构的模型（VGG16，Inceptionv3和ResNet50），这三种模型都经过了标准的对抗性训练，在表4种记录了实验结果，其中第一列是实验设置，R—-&gt;V表示使用ResNet50作为替代模型攻击VGG16。</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/10.png" alt="10"></p><p>结果表明，自动搜索过程有助于发现一个黑盒可转移的攻击策略，这不仅限于白盒场景。在随后的实验中发现$CAA_{trans}$并没有采用一些强攻击，因为这种攻击可能具有较差的可转移性。相反，像FGSM或MI-Linf攻击往往被选择为策略中更好的可转移成分，从而解释了为什么$CAA_{trans}$能够提高攻击的可转移性。<br><strong>CAA的白盒可转移性</strong>：那么在白盒情况下是否有可能转移攻击策略，即在替代任务或模型上搜索的策略被用于攻击目标模型。实验发下，在CIFAR-10上搜索的策略仍然可以很好的传输到许多模型架构和数据集，因此，CAA并没有“过度拟合”数据集或模型架构，它也确实找到了有效的策略。然而，并不能保证攻击策略在防御系统之间转移。提高防御之间可转移的一个经验实践是在候选池中引入更强，更多样化的攻击算法。在表2中通过使用6个强攻击者在多个防御模型上都取得了很好的结果。<br><strong>策略长度N的分析</strong>：作者进行了一系列的实验来探索一个更长的策略，它可以采用更多和多样化的基础攻击者，是否表现出更强的攻击能力，选择了长度为1、2、3、5和7的5个策略。图5展示稳健精度随策略长度变化的曲线。</p><p><img src="/2021/03/05/Composite-Adversarial-Attacks/11.png" alt="11"></p><p>当N=1的时候，CAA往往能够找到最佳的基础攻击者，但是在这种情况下，性能是最差的，随着N的增加，攻击策略在$S_{l_\infty},S_{l_2}$和无限制攻击的设置下变得更强。同时也发现策略长度在$l_2$攻击设定下有最小的影响，因此对于$l_2$攻击更多的基本攻击意味着更多的优化步骤这也是合理的。相比之下，在无限制攻击下，N对性能影响很大，从图5(c)中我们可以发现，当N大于3时，准确度会迅速下降到0左右。<br><strong>不同的搜索方法</strong>：表5给出了四种优化方法的性能和搜索时间，随机搜索，有100个随机策略的试验和最好的选择，被视为一个基线。与基线相比，所有启发式算法都能找到更好的策略。虽然贝叶斯优化和强化学习被广泛认为是搜索大面积空间的有效方法，但在本问题中，它们更耗时且容易陷入局部最优。相比之下，NSGA-II以较低的3 GPU/d成本找到了更好的策略，获得了更好的性能。<br><strong>目标攻击 vs 非目标攻击</strong>：目标攻击是一种特殊的应用场景，攻击者欺骗模型输出他们想要的目标标签。相反，非目标攻击没有给出目标标签。对于目标攻击，CAA搜索具有较少随机初始化的策略，这表明没有随机初始化的攻击者更适合目标设置。此外，与边界损失相比，具有交叉熵损失的基础攻击者更受CAA的青睐。</p><h4 id="Couclusion"><a href="#Couclusion" class="headerlink" title="Couclusion"></a>Couclusion</h4><p>本文提出了一个自动学习攻击策略的过程，该策略由一系列基础攻击者组成，可以用来破坏机器学习系统。通过将CAA与10个最近的攻击者在11种不同防御上进行比较，发现CAA能够以更少的运行时间实现了更好的攻击成功率。经验证明，搜索更好的算法和超参数也有助于对抗攻击。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;论文地址：&lt;a href=&quot;https://arxiv.org/pdf/2012.05434.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/pdf/2012.05434.pdf&lt;/a&gt;&lt;br&gt;代码地址：&lt;a hr
      
    
    </summary>
    
    
      <category term="论文笔记" scheme="elssm.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
