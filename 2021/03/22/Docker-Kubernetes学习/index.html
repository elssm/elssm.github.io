<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Notes,">










<meta name="description" content="DockerDocker的概念Docker 是 一个打包、 分发和运行应用程序的平台。 它允许将你 的应用程序和应用程序所依赖的整个环境打包在一起。 这既可以是一些应用程序需 要的库， 也可以是一个被安装的操作系统所有可用的文件。  镜像：Docker镜像里包含了你打包的应用程序及其所依赖的环境，它包含应用程序可用的文件系统和其他元数据，如镜像运行时的可执行文件路径。 镜像仓库：Docker镜像仓">
<meta name="keywords" content="Notes">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker&amp;Kubernetes学习">
<meta property="og:url" content="elssm.github.io/2021/03/22/Docker-Kubernetes学习/index.html">
<meta property="og:site_name" content="ELSSM&#39;s Blog">
<meta property="og:description" content="DockerDocker的概念Docker 是 一个打包、 分发和运行应用程序的平台。 它允许将你 的应用程序和应用程序所依赖的整个环境打包在一起。 这既可以是一些应用程序需 要的库， 也可以是一个被安装的操作系统所有可用的文件。  镜像：Docker镜像里包含了你打包的应用程序及其所依赖的环境，它包含应用程序可用的文件系统和其他元数据，如镜像运行时的可执行文件路径。 镜像仓库：Docker镜像仓">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/1.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/5.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/6.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/7.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/9.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/8.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/19.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/20.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/21.jpg">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/22.jpg">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/23.jpg">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/24.jpg">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/25.jpg">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/26.jpg">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/27.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/28.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/29.jpg">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/2.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/3.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/4.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/10.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/11.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/12.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/13.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/14.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/15.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/16.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/17.png">
<meta property="og:image" content="/2021/03/22/Docker-Kubernetes学习/18.png">
<meta property="og:updated_time" content="2021-12-13T09:44:44.483Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker&amp;Kubernetes学习">
<meta name="twitter:description" content="DockerDocker的概念Docker 是 一个打包、 分发和运行应用程序的平台。 它允许将你 的应用程序和应用程序所依赖的整个环境打包在一起。 这既可以是一些应用程序需 要的库， 也可以是一个被安装的操作系统所有可用的文件。  镜像：Docker镜像里包含了你打包的应用程序及其所依赖的环境，它包含应用程序可用的文件系统和其他元数据，如镜像运行时的可执行文件路径。 镜像仓库：Docker镜像仓">
<meta name="twitter:image" content="/2021/03/22/Docker-Kubernetes学习/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="elssm.github.io/2021/03/22/Docker-Kubernetes学习/">





  <title>Docker&Kubernetes学习 | ELSSM's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ELSSM's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="elssm.github.io/2021/03/22/Docker-Kubernetes学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Elssm">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/author2.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELSSM's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Docker&Kubernetes学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-22T15:49:26+08:00">
                2021-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><h5 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a>Docker的概念</h5><p>Docker 是 一个打包、 分发和运行应用程序的平台。 它允许将你 的应用程序和应用程序所依赖的整个环境打包在一起。 这既可以是一些应用程序需 要的库， 也可以是一个被安装的操作系统所有可用的文件。</p>
<ul>
<li>镜像：Docker镜像里包含了你打包的应用程序及其所依赖的环境，它包含应用程序可用的文件系统和其他元数据，如镜像运行时的可执行文件路径。</li>
<li>镜像仓库：Docker镜像仓库用于存放Docker镜像，以及促进不同人和不同电脑之间共享这些镜像。</li>
<li>容器：Docker容器通常是一个Linux容器，它基于Docker镜像被创建，一个运行中的容器是一个运行在Docker主机上的进程，但它和主机，以及所有运行在主机上的其他进程都是隔离的，这些进程也是资源受限的，意味着它只能访问和使用分配给它的资源。</li>
</ul>
<h5 id="容器隔离机制"><a href="#容器隔离机制" class="headerlink" title="容器隔离机制"></a>容器隔离机制</h5><ul>
<li>Linux命名空间，它使每个进程只看到自己的系统视图(文件、进程、网络接口、主机名等)</li>
<li>Linux控制组（cgroups）：它限制了进程能使用的资源量（CPU、内存、网络带宽等）</li>
</ul>
<h5 id="Docker核心组件"><a href="#Docker核心组件" class="headerlink" title="Docker核心组件"></a>Docker核心组件</h5><ul>
<li>Docker客户端和服务器，也称为Docker引擎</li>
<li>Docker镜像</li>
<li>Registry</li>
<li>Docker容器</li>
</ul>
<h5 id="Docker技术组件"><a href="#Docker技术组件" class="headerlink" title="Docker技术组件"></a>Docker技术组件</h5><ul>
<li>一个原生的Linux容器格式，Docker中称为libcontainer</li>
<li>Linux内核的命名空间（namespace），用于隔离文件系统、进程和网络</li>
<li>文件系统隔离：每个容器都有自己的root文件系统</li>
<li>进程隔离：每个容器都运行在自己的进程环境中</li>
<li>网络隔离：容器间的虚拟网络接口和IP地址都是分开的</li>
<li>资源隔离和分组：使用cgroups将CPU和内存之类的资源独立分配给每个Docker容器</li>
<li>写时复制：文件系统都是通过写时复制创建的，这就意味着文件系统时分层的、快速的、而且占用的磁盘空间更小</li>
<li>日志：容器产生的STDOUT、STDERR和STDIN这些IO流都会被收集并计入日志，用来进行日志分析和故障拍错</li>
<li>交互式shell：用户可以创建一个伪tty终端，将其连接到STDIN，为容器提供一个交互式的shell</li>
</ul>
<h5 id="构建、分发和运行Docker镜像"><a href="#构建、分发和运行Docker镜像" class="headerlink" title="构建、分发和运行Docker镜像"></a>构建、分发和运行Docker镜像</h5><p><img src="/2021/03/22/Docker-Kubernetes学习/1.png" alt="1"></p>
<h5 id="Docker-Hello-world"><a href="#Docker-Hello-world" class="headerlink" title="Docker Hello-world"></a>Docker Hello-world</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search "hello-world"	#搜索一个名为 hello-world的镜像</span><br><span class="line">docker pull hello-world 	#拉取镜像</span><br><span class="line">docker run hello-world #运行镜像</span><br></pre></td></tr></table></figure>
<h5 id="Docker搭建应用"><a href="#Docker搭建应用" class="headerlink" title="Docker搭建应用"></a>Docker搭建应用</h5><p>应用包含一个名为<code>app.js</code>的文件，代码如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http =  <span class="built_in">require</span> (<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span> (<span class="string">'os'</span>);</span><br><span class="line"><span class="built_in">console</span>.log (<span class="string">"Kubia server starting ... "</span>);</span><br><span class="line"><span class="keyword">var</span> handler =<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log (<span class="string">"Received request from "</span> + request.connection.remoteAddress);</span><br><span class="line">	response.writeHead(<span class="number">200</span>);</span><br><span class="line">	response.end(<span class="string">"You've hit "</span> + os.hostname() + <span class="string">"\n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> www = http.createServer(handler); </span><br><span class="line">www.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<p>为镜像创建Dockerfile，在<code>app.js</code>同目录下，创建一个Dockerfile文件，内容如下</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">7</span> <span class="comment">#构建所基于的基础镜像</span></span><br><span class="line"><span class="keyword">ADD</span> app.js /app.js #把app.js文件从本地文件夹添加到镜像的根目录，保持app.js这个文件名</span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["node","app.js"] #当镜像被运行时所需要被执行的命令</span><br></pre></td></tr></table></figure>
<p>构建容器镜像，以下命令告诉Docker需要基于当前目录构建一个叫kubia的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t kubia .</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/22/Docker-Kubernetes学习/5.png" alt="5"></p>
<p>基于Dockerfile构建一个新的容器镜像具体流程如下图所示</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/6.png" alt="6"></p>
<p>运行容器镜像，下面这条命令告知Docker基于kubia镜像创建一个叫kubia- container的新容器，这个容器与命令行分离，意味着在后台运行，本机上的8080端口会被映射到容器内的8080端口，所以可以通过<code>localhost:8080</code>来访问这个应用，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kubia-container -p 8080:8080 -d kubia</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/22/Docker-Kubernetes学习/7.png" alt="7"></p>
<p>访问应用，发现应用把<code>934fe4c0ca9c</code>作为主机名返回，这个十六进制数就是Docker容器的ID</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl localhost:8080</span><br><span class="line">You've hit 934fe4c0ca9c</span><br></pre></td></tr></table></figure>
<p>假如说这个时候我们删除了一个容器id想要恢复的话可以使用docker start命令</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/9.png" alt="9"></p>
<p>在已有的容器内部运行shell</p>
<p>这条命令会在已有的kubia-container容器内部运行bash，bash进行会和主容器进程拥有相同的命名空间，这样可以从内部探索容器。</p>
<ul>
<li>-i，确保标准输入流保待开放。需要在 shell 中输入命令。</li>
<li>-t，分配 一 个伪终端(TTY)。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it kubia-container bash</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/22/Docker-Kubernetes学习/8.png" alt="8"></p>
<p>停止容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop kubia-container</span><br></pre></td></tr></table></figure>
<p>删除容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm kubia-container</span><br></pre></td></tr></table></figure>
<p>向镜像仓库推送镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag kubia xxx/kubia #xxx是自己的Docker Hub ID</span><br><span class="line">docker push xxx/kubia #向Docker Hub推送镜像</span><br></pre></td></tr></table></figure>
<p>在不同机器上运行镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -d xxx/kubia</span><br></pre></td></tr></table></figure>
<h5 id="Docker持续集成"><a href="#Docker持续集成" class="headerlink" title="Docker持续集成"></a>Docker持续集成</h5><p>为了演示Docker持续集成的能力，我们将使用Jenkins CI构建一个测试流水线，首先会构建一个运行Docker的Jenkins服务器，一旦Jenkins运行起来，将展示最基础的单容器测试运行，最后将展示多容器的测试场景。</p>
<p>Jenkins教程：<a href="https://www.jenkins.io/zh/doc/" target="_blank" rel="noopener">https://www.jenkins.io/zh/doc/</a></p>
<h6 id="构建Jenkins和Docker服务器"><a href="#构建Jenkins和Docker服务器" class="headerlink" title="构建Jenkins和Docker服务器"></a>构建Jenkins和Docker服务器</h6><p>第一步先准备一个文件夹</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir jenkins &amp;&amp; cd jenkins</span><br></pre></td></tr></table></figure>
<p>在jenkins目录中，制作Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM jenkins/jenkins:lts</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line">RUN apt-get -qq update &amp;&amp; apt-get install -qq sudo</span><br><span class="line">RUN apt-get install wget</span><br><span class="line">RUN echo "jenkins ALL=NOPASSWD: ALL" &gt;&gt; /etc/sudoers</span><br><span class="line">RUN wget http://get.docker.com/builds/Linux/x86_64/docker-latest.tgz</span><br><span class="line">RUN tar -xvzf docker-latest.tgz</span><br><span class="line">RUN mv docker/* /usr/bin/</span><br><span class="line"></span><br><span class="line">USER jenkins</span><br><span class="line">RUN /usr/local/bin/install-plugins.sh junit git git-client ssh-slaves greenballs chucknorris ws-cleanup</span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<p>我起的镜像名为<code>elssm/dockerjenkins</code>，大家可以随意起名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro jenkins % docker build -t elssm/dockerjenkins .</span><br><span class="line">[+] Building 99.9s (12/12) FINISHED                                             </span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 516B                                       0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                          0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                            0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/jenkins/jenkins:lts             1.1s</span><br><span class="line"> =&gt; [1/8] FROM docker.io/jenkins/jenkins:lts@sha256:4b17ea5e222f5fbfcf8d7  0.0s</span><br><span class="line"> =&gt; CACHED [2/8] RUN apt-get -qq update &amp;&amp; apt-get install -qq sudo        0.0s</span><br><span class="line"> =&gt; [3/8] RUN apt-get install wget                                         4.7s</span><br><span class="line"> =&gt; [4/8] RUN echo "jenkins ALL=NOPASSWD: ALL" &gt;&gt; /etc/sudoers             0.3s </span><br><span class="line"> =&gt; [5/8] RUN wget http://get.docker.com/builds/Linux/x86_64/docker-late  39.6s </span><br><span class="line"> =&gt; [6/8] RUN tar -xvzf docker-latest.tgz                                  1.3s </span><br><span class="line"> =&gt; [7/8] RUN mv docker/* /usr/bin/                                        0.6s </span><br><span class="line"> =&gt; [8/8] RUN /usr/local/bin/install-plugins.sh junit git git-client ssh  51.3s </span><br><span class="line"> =&gt; exporting to image                                                     0.9s </span><br><span class="line"> =&gt; =&gt; exporting layers                                                    0.8s </span><br><span class="line"> =&gt; =&gt; writing image sha256:92f0b567b6888b0d0f3b306b76a42bdda971dba8f2017  0.0s </span><br><span class="line"> =&gt; =&gt; naming to docker.io/elssm/dockerjenkins                             0.0s</span><br></pre></td></tr></table></figure>
<p>构建好镜像之后启动镜像创建容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --name jenkins --privileged -d elssm/dockerjenkins</span><br></pre></td></tr></table></figure>
<p>其中<code>--privileged</code>标志可以启动Docker的特权模式，这种模式允许我们以其宿主机的所有能力来运行容器，包括一些内核特性和设备访问。</p>
<p>这样容器jenkins就启动了，我们可以看一下启动后的日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro jenkins % docker logs jenkins</span><br><span class="line">Running from: /usr/share/jenkins/jenkins.war</span><br><span class="line">webroot: EnvVars.masterEnvVars.get("JENKINS_HOME")</span><br><span class="line">2021-10-09 05:45:14.310+0000 [id=1]	INFO	org.eclipse.jetty.util.log.Log#initialized: Logging initialized @854ms to org.eclipse.jetty.util.log.JavaUtilLog</span><br><span class="line">2021-10-09 05:45:14.447+0000 [id=1]	INFO	winstone.Logger#logInternal: Beginning extraction from war file</span><br><span class="line">2021-10-09 05:45:15.584+0000 [id=1]	WARNING	o.e.j.s.handler.ContextHandler#setContextPath: Empty contextPath</span><br><span class="line">2021-10-09 05:45:15.700+0000 [id=1]	INFO	org.eclipse.jetty.server.Server#doStart: jetty-9.4.43.v20210629; built: 2021-06-30T11:07:22.254Z; git: 526006ecfa3af7f1a27ef3a288e2bef7ea9dd7e8; jvm 11.0.12+7</span><br><span class="line">2021-10-09 05:45:16.102+0000 [id=1]	INFO	o.e.j.w.StandardDescriptorProcessor#visitServlet: NO JSP Support for /, did not find org.eclipse.jetty.jsp.JettyJspServlet</span><br><span class="line">2021-10-09 05:45:16.175+0000 [id=1]	INFO	o.e.j.s.s.DefaultSessionIdManager#doStart: DefaultSessionIdManager workerName=node0</span><br><span class="line">2021-10-09 05:45:16.175+0000 [id=1]	INFO	o.e.j.s.s.DefaultSessionIdManager#doStart: No SessionScavenger set, using defaults</span><br><span class="line">2021-10-09 05:45:16.177+0000 [id=1]	INFO	o.e.j.server.session.HouseKeeper#startScavenging: node0 Scavenging every 660000ms</span><br><span class="line">2021-10-09 05:45:16.938+0000 [id=1]	INFO	hudson.WebAppMain#contextInitialized: Jenkins home directory: /var/jenkins_home found at: EnvVars.masterEnvVars.get("JENKINS_HOME")</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>现在我们就可以通过本地的8080端口在浏览器中访问了，我这边打开之后发现是锁定的状态（大家的情况应该和我一样），如下图所示。因此需要输入密码解锁，密码路径已经告诉了我们。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/19.png" alt="19"></p>
<p>进入jenkins容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it jenkins bash</span><br></pre></td></tr></table></figure>
<p>获取密码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>
<p>进行一部分简单的设置之后我们就可以进入Jenkins的登陆页面了，输入用户名和密码，如果是默认的话用户名就是<code>admin</code>，密码就是上面<code>cat</code>拿到的密码。输入之后就进入主界面了，如下图所示。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/20.png" alt="20"></p>
<h6 id="创建新的Jenkins作业"><a href="#创建新的Jenkins作业" class="headerlink" title="创建新的Jenkins作业"></a>创建新的Jenkins作业</h6><p>现在Jenkins服务器已经运行，我们可以来创建一个Jenkins作业。具体操作如下</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/21.jpg" alt="21"></p>
<p>将新作业命名为<code>Docker_test_job</code>，作业类型为<code>Freestyle project</code>。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/22.jpg" alt="22"></p>
<p>接下来填写作业描述，在高级项目选项中选择<code>Use Custom workspace</code>，并指定<code>/tmp/jenkins-buildenv/${JOB_NAME}/workspace</code>作为目录。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/23.jpg" alt="23"></p>
<p>在<code>Source Code Management</code>区域，选择<code>Git</code>并指定测试仓库为<code>https://github.com/turnbullpress/docker-jenkins-sample.git</code>，该仓库包含了一些基于Ruby的RSpec测试</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/24.jpg" alt="24"></p>
<p>接下来下拉，找到<code>Build</code>选项，单击<code>Add Build Step</code>按钮增加一个构建的步骤，选择<code>Execute shell</code>，如下图所示。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/25.jpg" alt="25"></p>
<p>之后使用定义的脚本来启动和测试Docker，该脚本代码如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Build the image to be used for this run.</span><br><span class="line">IMAGE=$(docker build . | tail -1 | awk '&#123; print $NF &#125;')</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Build the directory to be mounted into Docker.</span><br><span class="line"></span><br><span class="line">MNT="$WORKSPACE/.."</span><br><span class="line"></span><br><span class="line">sleep 3</span><br><span class="line">cd /tmp/jenkins-buildenv/Docker_test_job/workspace/spec/test-report</span><br><span class="line">touch a.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Execute the build inside Docker.</span><br><span class="line">CONTAINER=$(docker run -d -v "$MNT:/opt/project" $IMAGE /bin/bash -c "cd /opt/project/workspace &amp;&amp; rake spec")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Attach to the container's streams so that we can see the output.</span><br><span class="line">sudo docker attach $CONTAINER</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> As soon as the process exits, get its return value.</span><br><span class="line">RC=$(sudo docker wait $CONTAINER)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Delete the container we've just used to free disk space.</span><br><span class="line">sudo docker rm $CONTAINER</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Exit with the same value that the process exited with.</span><br><span class="line">exit $RC</span><br></pre></td></tr></table></figure>
<p>那么上面的脚本具体做了些什么呢？首先它将使用包含刚刚指定的Git仓库的Dockerfile创建一个新的Docker镜像，这个Dockerfile提供了想要执行的测试环境。该Dockerfile代码如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER James Turnbull "james@example.com"</span><br><span class="line">ENV REFRESHED_AT 2016-06-01</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get -y install ruby rake</span><br><span class="line">RUN gem install --no-rdoc --no-ri rspec ci_reporter_rspec</span><br></pre></td></tr></table></figure>
<p>可以看到，Dockerfile构建了一个Ubuntu宿主机，安装了Ruby和RubyGems，之后安装了两个gem：rspec和ci_reporter_rspec。这样构建的镜像可以用于测试典型的基于Ruby且使用RSpec测试框架的应用程序。ci_reporter_rspec gem会把RSpec的输出转换为JUnit格式的XML输出，并交给Jenkins做解析。</p>
<p>回到之前的脚本，构建镜像之后，会创建一个包含Jenkins的工作空间的目录，会把这个目录挂载到Docker容器，并在这个目录里执行测试。然后我们从这个惊喜那个创建了容器，并且运行了测试，在容器里，把工作空间挂载到<code>/opt/project</code>目录，之后执行命令切换到这个目录，并执行rake spec来运行RSpec测试。容器启动之后，我们拿到了容器的ID。</p>
<p>现在使用<code>docker attach</code>命令进入容器，得到容器执行时输出的内容，然后使用<code>docker wait</code>命令，<code>docker wait</code>命令会一直阻塞，直到容器里的命令执行完成才会返回容器退出时的返回码，变量RC捕捉到容器退出时的返回码，最后，清理环境，删除刚刚创建的容器，并使用容器的返回码退出，这个返回码应该就是测试执行结果的返回码，Jenkins依赖这个返回码得知作业的测试结果时成功还是失败。对上面脚本的解释就到这里，让我们再回到Jenkins构建作业的步骤！！！</p>
<p>接下来，单机<code>Add post-build action</code>，加入一个<code>Publish JUint test result report</code>的动作，在<code>Test report XMLs</code>域，需要指定<code>spec/reports/*.xml</code>，这个目录是<code>ci_reporter gem</code>的XML输出的位置，找到这个目录会让jenkins处理测试的历史结果和输出结果。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/26.jpg" alt="26"></p>
<p>最后点击保存即可。</p>
<h6 id="运行Jenkins作业"><a href="#运行Jenkins作业" class="headerlink" title="运行Jenkins作业"></a>运行Jenkins作业</h6><p>点击<code>Build Now</code>即可。</p>
<h6 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h6><p>好家伙！我以为点击完<code>Build Now</code>之后就会顺利的看到结果，万万没想到出现了各种各样的错误</p>
<p>报错如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Step ‘Publish JUnit test result report’ failed: Test reports were found but none of them are new. Did leafNodes run? </span><br><span class="line">For example, /tmp/jenkins-buildenv/Docker_test_job/workspace/spec/test-report/*.xml is 4 min 43 sec old</span><br></pre></td></tr></table></figure>
<p>修改如下</p>
<p>在执行shell命令中添加如下代码，目的是不断更新这个文件的时间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sleep 3</span><br><span class="line">cd xml报告的路径</span><br><span class="line">touch a.xml</span><br></pre></td></tr></table></figure>
<p>报错如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to the Docker daemon at unix:/var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure>
<p>修改如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dockerd</span><br></pre></td></tr></table></figure>
<p>报错如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnutls_handshake() failed: The TLS connection was non-properly terminated.</span><br></pre></td></tr></table></figure>
<p>修改如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global  --unset https.https://github.com.proxy </span><br><span class="line">git config --global  --unset http.https://github.com.proxy</span><br></pre></td></tr></table></figure>
<p>报错如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Checks API] No suitable checks publisher found</span><br></pre></td></tr></table></figure>
<p>修改如下</p>
<p>暂时没有找到修改方法。。。心态崩了</p>
<p>如下图是我<code>Build</code>的心路历程，到最后也没有看到那一抹绿！！！</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/27.png" alt="27"></p>
<p>最终我的执行结果如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Started by user admin</span><br><span class="line">Running as SYSTEM</span><br><span class="line">Building in workspace /tmp/jenkins-buildenv/Docker_test_job/workspace</span><br><span class="line">The recommended git tool is: NONE</span><br><span class="line">No credentials specified</span><br><span class="line"><span class="meta"> &gt;</span> git rev-parse --resolve-git-dir /tmp/jenkins-buildenv/Docker_test_job/workspace/.git # timeout=10</span><br><span class="line">Fetching changes from the remote Git repository</span><br><span class="line"><span class="meta"> &gt;</span> git config remote.origin.url https://github.com/turnbullpress/docker-jenkins-sample.git # timeout=10</span><br><span class="line">Fetching upstream changes from https://github.com/turnbullpress/docker-jenkins-sample.git</span><br><span class="line"><span class="meta"> &gt;</span> git --version # timeout=10</span><br><span class="line"><span class="meta"> &gt;</span> git --version # 'git version 2.30.2'</span><br><span class="line"><span class="meta"> &gt;</span> git fetch --tags --force --progress -- https://github.com/turnbullpress/docker-jenkins-sample.git +refs/heads/*:refs/remotes/origin/* # timeout=10</span><br><span class="line"><span class="meta"> &gt;</span> git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10</span><br><span class="line">Checking out Revision 7d027a4cdeee1b5da4f9d65d64bceb3692d4d571 (refs/remotes/origin/master)</span><br><span class="line"><span class="meta"> &gt;</span> git config core.sparsecheckout # timeout=10</span><br><span class="line"><span class="meta"> &gt;</span> git checkout -f 7d027a4cdeee1b5da4f9d65d64bceb3692d4d571 # timeout=10</span><br><span class="line">Commit message: "Update Dockerfile"</span><br><span class="line"><span class="meta"> &gt;</span> git rev-list --no-walk 7d027a4cdeee1b5da4f9d65d64bceb3692d4d571 # timeout=10</span><br><span class="line">[workspace] $ /bin/sh -xe /tmp/jenkins4474819640520934216.sh</span><br><span class="line">+ sudo docker build .</span><br><span class="line">+ tail -1</span><br><span class="line">+ awk &#123; print $NF &#125;</span><br><span class="line">+ IMAGE=d9be83fd0aa7</span><br><span class="line">+ MNT=/tmp/jenkins-buildenv/Docker_test_job/workspace/..</span><br><span class="line">+ sleep 3</span><br><span class="line">+ cd /tmp/jenkins-buildenv/Docker_test_job/workspace/spec/test-report</span><br><span class="line">+ touch a.xml</span><br><span class="line">+ docker run -d -v /tmp/jenkins-buildenv/Docker_test_job/workspace/..:/opt/project d9be83fd0aa7 /bin/bash -c cd /opt/project/workspace &amp;&amp; rake spec</span><br><span class="line">+ CONTAINER=fcc26e706d258f6f3ab93f2fcf7ba374a4d60d38ae065c7fb28dcb65eaf97d2e</span><br><span class="line">+ sudo docker attach fcc26e706d258f6f3ab93f2fcf7ba374a4d60d38ae065c7fb28dcb65eaf97d2e</span><br><span class="line">rm -rf spec/reports</span><br><span class="line">/usr/bin/ruby2.3 -I/var/lib/gems/2.3.0/gems/rspec-support-3.10.2/lib:/var/lib/gems/2.3.0/gems/rspec-core-3.10.1/lib /var/lib/gems/2.3.0/gems/rspec-core-3.10.1/exe/rspec --pattern spec/\*_spec.rb --colour --format progress</span><br><span class="line">.....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</span><br><span class="line"></span><br><span class="line">Finished in 1.13 seconds (files took 0.28521 seconds to load)</span><br><span class="line">501 examples, 0 failures</span><br><span class="line"></span><br><span class="line">+ sudo docker wait fcc26e706d258f6f3ab93f2fcf7ba374a4d60d38ae065c7fb28dcb65eaf97d2e</span><br><span class="line">+ RC=0</span><br><span class="line">+ sudo docker rm fcc26e706d258f6f3ab93f2fcf7ba374a4d60d38ae065c7fb28dcb65eaf97d2e</span><br><span class="line">fcc26e706d258f6f3ab93f2fcf7ba374a4d60d38ae065c7fb28dcb65eaf97d2e</span><br><span class="line">+ exit 0</span><br><span class="line">Recording test results</span><br><span class="line">[Checks API] No suitable checks publisher found.</span><br><span class="line">Build step 'Publish JUnit test result report' changed build result to UNSTABLE</span><br><span class="line">Finished: UNSTABLE</span><br></pre></td></tr></table></figure>
<h5 id="Docker进阶"><a href="#Docker进阶" class="headerlink" title="Docker进阶"></a>Docker进阶</h5><ul>
<li><p>Docker容器数据卷</p>
<p>需求：容器的持久化和同步操作，容器间也是可以数据共享的</p>
<p>容器之间可以有一个数据共享的技术，Docker容器中产生的数据同步到本地</p>
<p>将我们容器内的目录，挂载到linux上面</p>
</li>
<li><p>具名和匿名挂载</p>
<p>匿名：在<code>-v</code>只写了容器内的路径，没有写容器外的路径</p>
<p>具名：通过<code>-v</code>  卷名:容器内路径</p>
<p>指定路径挂载：<code>-v</code> /宿主机路径：容器内路径</p>
</li>
<li><p>DockerFile </p>
<p>用来构建docker镜像的构建文件，命令脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建dockerfile文件</span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME ["volume01","volume02"]</span><br><span class="line"></span><br><span class="line">CMD echo "----end----"</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>构建称为一个镜像</span><br><span class="line">docker build -f dockerfile -t elssm/centos .</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>运行镜像</span><br><span class="line">docker run</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>发布镜像</span><br><span class="line">docker push</span><br></pre></td></tr></table></figure>
<p>DockerFile：构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行</p>
<p>Docker容器：容器就是镜像运行起来提供服务的</p>
</li>
<li><p>DockerFile的指令解析</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM #基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER #镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN #镜像构建的时候需要运行的命令</span><br><span class="line">ADD #步骤，添加内容</span><br><span class="line">WORKDIR #镜像的工作目录</span><br><span class="line">VOLUME #挂载的目录</span><br><span class="line">EXPOSE #指定暴露端口</span><br><span class="line">CMD #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT #指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD #当构建一个被继承DockerFile这个时候就会运行ONBUILD的指令</span><br><span class="line">COPY：#类似ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENV #构建的时候设置环境变量</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个自己的centos</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>编写Dockerfile的文件</span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER elssm&lt;329847986@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim </span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo "---end---"</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>通过这个文件构建镜像</span><br><span class="line">docker build -f dockerfile -t name:0.1 .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>测试运行</span><br><span class="line">docker run -it image</span><br></pre></td></tr></table></figure>
</li>
<li><p>实战Tomcat镜像</p>
<ul>
<li><p>准备镜像文件tomcat压缩包，jdk的压缩包</p>
</li>
<li><p>编写dockerfile文件</p>
</li>
</ul>
</li>
<li><p>数据卷容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>容器间数据同步</span><br><span class="line">-- volumes -from</span><br></pre></td></tr></table></figure>
</li>
<li><p>Docker网络</p>
<p>原理：我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是veth-pair技术</p>
</li>
<li><p>veth-pair：就是一对虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连，正因为有这个特性，veth-pair充当一个桥梁，连接各种虚拟 网络设备</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>查看docker下的所有network</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看详细信息</span><br><span class="line">docker network inspect bridge_ID</span><br></pre></td></tr></table></figure>
<p><code>--link</code>可以解决docker下网络联通问题</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>下载tomcat镜像</span><br><span class="line">docker pull tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>docker下启动两个tomcat</span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat02 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>启动tomcat03并绑定tomcat02</span><br><span class="line">docker run -d -P --name tomcat03 --link tomcat02 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>进入tomcat03并查看tomcat03配置文件</span><br><span class="line">docker exec -it tomcat03 cat /etc/hosts</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义网络</p>
<p>查看所有的docker网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>
<p>网络模式</p>
<ul>
<li>bridge：桥接模式</li>
<li>none：不配置网络</li>
<li>host：和宿主机共享网络</li>
<li>container：容器内网络连通</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>我们可以自定义一个网络</span><br><span class="line"><span class="meta">#</span> --driver bridge</span><br><span class="line"><span class="meta">#</span> --subnet 192.168.0.0/16</span><br><span class="line"><span class="meta">#</span> --gateway 192.168.0.1</span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看自己创建的网络</span><br><span class="line">docker network inspect mynet</span><br></pre></td></tr></table></figure>
<p>自定义的网络docker都已经帮我们维护好了对应的关系</p>
<p>不同的集群使用不同的网络，保证集群是安全和健康的</p>
</li>
<li><p>网络连通</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>测试打通tomcat01 - mynet</span><br><span class="line">docker network connect mynet tomcat01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>连通之后就是将tomcat01放到了mynet网络下</span><br><span class="line"><span class="meta">#</span>一个容器两个ip地址</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Docker构建应用"><a href="#Docker构建应用" class="headerlink" title="Docker构建应用"></a>Docker构建应用</h5><p>第一个应用是使用Jekyll框架的自定义网站，我们会构建两个镜像</p>
<ul>
<li>一个镜像安装了Jekyll及其他用于构建Jekyll网站的必要的软件</li>
<li>一个镜像通过Apache来让Jekyll网站工作起来</li>
</ul>
<p>首先构建Jekyll基础镜像，本地创建Jekyll工作目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir jekyll &amp;&amp; cd jekyll</span><br></pre></td></tr></table></figure>
<p>Dockerfile文件如下。镜像基于Ubuntu18.04，并且安装了Ruby和用于支持Jekyll的包，然后使用VOLUME指定创建了两个卷。将工作目录设置到<code>/data/</code>，并通过ENTRYPOINT指定自动构建的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install ruby ruby-dev libffi-dev build-essential nodejs</span><br><span class="line">RUN gem install --no-rdoc --no-ri jekyll -v 2.5.3</span><br><span class="line"></span><br><span class="line">VOLUME /data</span><br><span class="line">VOLUME /var/www/html</span><br><span class="line">WORKDIR /data</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;jekyll&quot;, &quot;build&quot;, &quot;--destination=/var/www/html&quot; ]</span><br></pre></td></tr></table></figure>
<p>构建Jekyll基础镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/jekyll .</span><br></pre></td></tr></table></figure>
<p>接下来构建第二个镜像，一个用来架构新网站的Apache服务器，本地创建Apache工作目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir apache &amp;&amp; cd apache</span><br></pre></td></tr></table></figure>
<p>Dockerfile文件如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install apache2</span><br><span class="line"></span><br><span class="line">VOLUME [ "/var/www/html" ]</span><br><span class="line">WORKDIR /var/www/html</span><br><span class="line"></span><br><span class="line">ENV APACHE_RUN_USER www-data</span><br><span class="line">ENV APACHE_RUN_GROUP www-data</span><br><span class="line">ENV APACHE_LOG_DIR /var/log/apache2</span><br><span class="line">ENV APACHE_PID_FILE /var/run/apache2.pid</span><br><span class="line">ENV APACHE_RUN_DIR /var/run/apache2</span><br><span class="line">ENV APACHE_LOCK_DIR /var/lock/apache2</span><br><span class="line"></span><br><span class="line">RUN mkdir -p $APACHE_RUN_DIR $APACHE_LOCK_DIR $APACHE_LOG_DIR</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ "/usr/sbin/apachectl" ]</span><br><span class="line">CMD ["-D", "FOREGROUND"]</span><br></pre></td></tr></table></figure>
<p>构建Jekyll Apache镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t elssm/apache .</span><br></pre></td></tr></table></figure>
<p>启动Jekyll网站</p>
<p>启动之前先在本地准备一些博客的源代码，代码地址为<a href="https://github.com/turnbullpress/james_blog" target="_blank" rel="noopener">https://github.com/turnbullpress/james_blog</a></p>
<p>我将源代码放在我的用户目录下，源代码重命名为<code>elssm_blog</code>，下载好之后执行下面命令，这段命令启动了一个叫做elssm_blog的新容器，把我本地的<code>elssm_blog</code>目录作为<code>/data/</code>卷挂载到容器里，容器已经拿到网站的源代码，并将其构建到已编译的网站，存放到<code>/var/www/html/</code>目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % docker run -v ~/elssm_blog:/data/ --name elssm_blog elssm/jekyll</span><br><span class="line">Configuration file: /data/_config.yml</span><br><span class="line">            Source: /data</span><br><span class="line">       Destination: /var/www/html</span><br><span class="line">      Generating... </span><br><span class="line">                    done.</span><br></pre></td></tr></table></figure>
<p>如果想在另一个容器里使用<code>/var/www/html/</code>卷里编译好的网站，可以创建一个新的链接到这个卷的容器，如下命令。其中<code>--volumes-from</code>标志把指定容器里的所有卷都加入新创建的容器里，这意味着Apache容器可以让问之前创建的elssm_blog容器里<code>/var/www/html</code>卷中存放的编译好的Jekyll网站，即便elssm_blog容器没有运行，Apache容器也可以访问这个卷，前提是容器本身必须存在。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --volumes-from elssm_blog elssm/apache</span><br></pre></td></tr></table></figure>
<p>接下来我们查看一下容器把80端口映射到本本地哪个端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % docker port 4d91e0f44a9a 80</span><br><span class="line">0.0.0.0:55000</span><br></pre></td></tr></table></figure>
<p>通过打开<code>localhost:55000</code>浏览该网站。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/28.png" alt="28"></p>
<p>更新Jekyll网站</p>
<p>我们试着修改本地源代码中的<code>_config.yml</code>文件，将title域改为<code>ELSSM&#39;s Blog</code>。</p>
<p>接着更新网站</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start elssm_blog</span><br></pre></td></tr></table></figure>
<p>查看一下容器的日志，发现Jekyll编译过程第二次被运行，并且网站已经被更新。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro elssm_blog % docker logs elssm_blog</span><br><span class="line">Configuration file: /data/_config.yml</span><br><span class="line">            Source: /data</span><br><span class="line">       Destination: /var/www/html</span><br><span class="line">      Generating... </span><br><span class="line">                    done.</span><br><span class="line"> Auto-regeneration: disabled. Use --watch to enable.</span><br><span class="line">Configuration file: /data/_config.yml</span><br><span class="line">            Source: /data</span><br><span class="line">       Destination: /var/www/html</span><br><span class="line">      Generating... </span><br><span class="line">                    done.</span><br></pre></td></tr></table></figure>
<p>再次刷新查看网站。由于共享的卷会自动更新，这一切都不需要更新或者重启Apache容器。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/29.jpg" alt="29"></p>
<h4 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h4><h5 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h5><ul>
<li><p>Infrastructure as a Service（阿里云）</p>
</li>
<li><p>Platform as a service（新浪云）</p>
</li>
<li><p>Software as a Service（Office 365）</p>
</li>
</ul>
<h5 id="资源管理器"><a href="#资源管理器" class="headerlink" title="资源管理器"></a>资源管理器</h5><ul>
<li>Apache MESOS</li>
<li>docker SWARM</li>
<li>Kubernetes<ul>
<li>轻量级</li>
<li>开源</li>
<li>弹性伸缩</li>
<li>负载均衡</li>
</ul>
</li>
</ul>
<h5 id="Kubernetes简介"><a href="#Kubernetes简介" class="headerlink" title="Kubernetes简介"></a>Kubernetes简介</h5><p>Kubernetes是一个软件系统，它允许你在其上很容易地部署和管理容器化的应用。 它依赖于Linux容器的特性来运行异构应用， 而无须知道这些应用的内部详情， 也不需要手动将这些应用部署到每台机器。</p>
<p>Kubernetes 使你在数以千计的电脑节点上运行软件时就像所有这些节点是单个大节点一样。它将底层基础设施抽象，这样做同时简化了应用的开发、部署，以及对开发和运维团队的管理。</p>
<h5 id="Kubernetes核心功能"><a href="#Kubernetes核心功能" class="headerlink" title="Kubernetes核心功能"></a>Kubernetes核心功能</h5><p>如下图为一个最简单的Kubernetes系统图。整个系统由一个主节点和若干个工作节点组成 。 开发者把一个应用列表提交到主节点， Kubemetes 会将它们部署到集群的工作节点。组件被部署在哪个节点对于开发者和系统管理员来说都不用关心。除此之外，开发者还能指定一些应用必须一起运行，这样Kubernetes将会在一个工作节点上部署它们，而其他的将被分散部署到集群中。不管怎样部署，它们都能以相同的方式互相通信。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/2.png" alt="2"></p>
<h5 id="Kubernetes集群架构"><a href="#Kubernetes集群架构" class="headerlink" title="Kubernetes集群架构"></a>Kubernetes集群架构</h5><p>在硬件级别，一个Kubernetes集群由很多节点组成，这些节点被分成以下两种类型</p>
<ul>
<li>主节点：它承载着Kubernetes控制和管理整个集群系统的控制面板<ul>
<li>Kubernates API服务器：其他控制面板组件都要和它进行通信</li>
<li>Scheculer：调度你的应用（为应用的每个可部署组件分配一个工作节点）</li>
<li>Controller Manager：执行集群级别的功能，如复制组件、持续跟踪工作节点、处理节点失败等</li>
<li>ETCD：一个可靠的分布式数据存储，能持久化存储集群配置</li>
</ul>
</li>
<li>工作节点：它们运行用户实际部署的应用<ul>
<li>Docker、rtk或其他容器类型</li>
<li>Kubelet：与API服务器通信，并管理它所在节点的容器</li>
<li>Kubernetes Service Proxy：负责组建之间的负载均衡网络流量</li>
</ul>
</li>
</ul>
<p><img src="/2021/03/22/Docker-Kubernetes学习/3.png" alt="3"></p>
<h5 id="Kubernetes运行应用"><a href="#Kubernetes运行应用" class="headerlink" title="Kubernetes运行应用"></a>Kubernetes运行应用</h5><p><img src="/2021/03/22/Docker-Kubernetes学习/4.png" alt="4"></p>
<p>如上图所示，在应用描述符中列出了四个容器，并将这些容器分成了3组，这些集合被称为pod，其中前两个pod只包含了一个容器，最后一个包含两个，意味着这两个容器都需要协作运行，每个pod旁边的数字表示需要并行运行的每个pod的副本数量，在向 Kubernetes 提交描述符之后，它将 把每个 pod的指定副本数量调度到可用的工作节点上。 节点上的 Kubelets将告知 Docker 从镜像仓库中拉取 容器镜像井运 行容器 。</p>
<h5 id="安装kubernetes"><a href="#安装kubernetes" class="headerlink" title="安装kubernetes"></a>安装kubernetes</h5><p>这里我使用的是Docker for Mac，具体安装方法可以参考下面链接</p>
<p><a href="https://developer.aliyun.com/article/508460" target="_blank" rel="noopener">https://developer.aliyun.com/article/508460</a></p>
<p>安装完成之后验证Kubernetes是否安装成功</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/10.png" alt="10"></p>
<h5 id="Kubernetes的优势"><a href="#Kubernetes的优势" class="headerlink" title="Kubernetes的优势"></a>Kubernetes的优势</h5><ul>
<li><p>简化应用程序部署</p>
</li>
<li><p>更好的利用硬件</p>
</li>
<li><p>健康检查和自修复</p>
</li>
<li>自动扩容</li>
</ul>
<h5 id="Kubernetes组件说明"><a href="#Kubernetes组件说明" class="headerlink" title="Kubernetes组件说明"></a>Kubernetes组件说明</h5><ul>
<li>APISERVER：所有服务访问统一接口</li>
<li>ControllerManager：维护副本期望数据</li>
<li>Scheduler：负责介绍任务，选择合适的节点进行分配任务</li>
<li>ETCD：键值对数据库，存储K8S集群所有重要信息（持久化）</li>
<li>Kubelet：直接跟容器引擎交互实现容器的生命周期管理</li>
<li>Kube-proxy：负责写入规则至IPTABLES，IPVS实现服务映射访问</li>
<li>COREDNS：可以为集群中的SVC创建一个域名IP的对应关系解析</li>
<li>DASHBOARD：给K8S集群提供一个B/S结构访问体系</li>
<li>INGRESS CONTROLLER：官方只能实现四层代理，INGRESS可以实现七层代理</li>
<li>FEDERATION：提供一个可以跨集群中心多K8S统一管理功能</li>
<li>PROMETHEUS：提供K8S集群的监控能力</li>
<li>ELK：提供K8S集群日志统一分析接入平台</li>
</ul>
<h5 id="pod的介绍"><a href="#pod的介绍" class="headerlink" title="pod的介绍"></a>pod的介绍</h5><p>一个pod是一组紧密相关的容器，它们总是一起运行在同一个工作节点上，以 及同一个 Linux 命名空间中。每个 pod就像一个独立的逻辑机器，拥有自己的 IP、 主机名、进程等，运行一个独立的应用程序 。应用程序可以是单个进程，运行在单个容器中，也可以是一个主应用进程或者其他支持进程，每个进程都在自己的容器中运行 。一 个pod的所有容器都运行在同一个逻辑机器上，而其他 pod 中的容器， 即使运行在同一个工作节点上，也会出现在不同的节点上 。</p>
<p>如下图所示是容器、pod以及物理工作节点之间的关系。从图上我们可以看出，每个pod都有自己的IP，并包含一个或多个容器，每个容器都运行一个应用进程，pod分布在不同的工作节点上。</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/11.png" alt="11"></p>
<p>部署一个Node.js应用，可以使用<code>kubectl run</code>命令，该命令可以创建所有必要的组件而无需 ISON 或YAML文件，这样的话，我们就不需要深入了解每 个组件对象的结构。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl run kubia --image=luksa/kubia --port=8080</span><br><span class="line">pod/kubia created</span><br></pre></td></tr></table></figure>
<ul>
<li>—image=luksa/kubia显示的是指定要运行的容器镜像</li>
<li>--port=8080选项告诉Kubernetes应用正在监昕 8080端口</li>
</ul>
<h6 id="列出pod"><a href="#列出pod" class="headerlink" title="列出pod"></a>列出pod</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get pods</span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia   1/1     Running   0          8s</span><br></pre></td></tr></table></figure>
<p>在Kubernetes中运行容器镜像所必需的步骤</p>
<ul>
<li>构建镜像并将其推送到Docker Hub</li>
<li>当运行kubectl命令时，它通过向 Kubernetes API服务器发送一个REST HTTP请求，在集群中创建一个新的 ReplicationController对象 。 然后，ReplicationController创建了一个新的pod，调度器将其调度到一个工作节点上。Kubelet看到pod被调度到节点上，就告知 Docker 从镜像中心中拉取指定的镜像，因为本地没有该镜像。下载镜像后，Docker创建并运行容器。</li>
</ul>
<h6 id="创建一个服务对象"><a href="#创建一个服务对象" class="headerlink" title="创建一个服务对象"></a>创建一个服务对象</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl expose pod kubia --type=LoadBalancer --name kubia-http</span><br><span class="line">service/kubia-http exposed</span><br></pre></td></tr></table></figure>
<h6 id="列出服务"><a href="#列出服务" class="headerlink" title="列出服务"></a>列出服务</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get services</span><br><span class="line">NAME         TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP      10.96.0.1        &lt;none&gt;        443/TCP          41m</span><br><span class="line">kubia-http   LoadBalancer   10.110.166.212   localhost     8080:32054/TCP   14s</span><br></pre></td></tr></table></figure>
<p>这里我们会发现应用将pod名称作为它的主机名。因为每个pod都像一个独立的机器，具有自己的IP地址和主机名，尽管应用程序运行在工作节点的操作系统中，但对应用程序来说，它似乎是在一个独立的机器上运行，而这台机器本身就是应用程序的专用机器，没有其他的进程一同运行。</p>
<p>访问本地<code>8080</code>端口向pod发送请求</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">You've hit kubia</span><br></pre></td></tr></table></figure>
<h6 id="Pod概念"><a href="#Pod概念" class="headerlink" title="Pod概念"></a>Pod概念</h6><ul>
<li><p>自主式Pod</p>
</li>
<li><p>控制器管理的Pod </p>
<p>ReplicationController：用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代，而如果异常多出来的容器也会自动回收。</p>
<p>ReplicaSet：和ReplicationController没有本质不同，支持集合式的selector</p>
<p>Deployment：自动管理ReplicaSet，支持滚动更新</p>
<p>Horizontal Pod Autoscaling：仅适用于Deployment和ReplicaSet</p>
<p>StatefullSet：为了解决有状态服务的问题，应用场景包括：</p>
<ul>
<li>稳定的持久化存储</li>
<li>稳定的网络标志</li>
<li>有序部署，有序扩展</li>
<li>有序收缩，有序删除</li>
</ul>
<p>DaemonSet：确保全部（或者一些）Node上运行一个Pod的副本，当有Node加入集群时，也会为他们新增一个Pod，当有Node从集群中移除时，这些Pod也会被回收，删除DaemonSet将会删除它创建的所有Pod，使用DaemonSet的一些典型用法：</p>
<ul>
<li>运行集群存储daemon，例如在每个Node上运行glusterd，ceph</li>
<li>在每个Node上运行日志收集daemon，例如fluentd，logstash</li>
<li>在每个Node上运行监控daemon，例如Prometheus，Node Exporter</li>
</ul>
<p>Job：负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束</p>
<p>Cron Job：管理基于时间的Job，即在给定时间点只运行一次，周期性地在给定时间点运行</p>
</li>
</ul>
<h6 id="以YAML或JSON描述文件创建pod"><a href="#以YAML或JSON描述文件创建pod" class="headerlink" title="以YAML或JSON描述文件创建pod"></a>以YAML或JSON描述文件创建pod</h6><p>首先我们呢将使用<code>-o yaml</code>选项的<code>kubectl get</code>命令来获取pod的整个YAML定义</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod kubia -o yaml</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1  #YAML描述文件所使用的Kubernetes API版本</span><br><span class="line">kind: Pod				#Kubernetes对象/资源类型</span><br><span class="line"><span class="meta">#</span>pod元数据（名称、标签和注解等等）</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: "2021-10-05T10:51:49Z"</span><br><span class="line">  labels:</span><br><span class="line">    run: kubia</span><br><span class="line">  managedFields:</span><br><span class="line">  - apiVersion: v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:metadata:</span><br><span class="line">        f:labels:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          f:run: &#123;&#125;</span><br><span class="line">      f:spec:</span><br><span class="line">        f:containers:</span><br><span class="line">          k:&#123;"name":"kubia"&#125;:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:image: &#123;&#125;</span><br><span class="line">            f:imagePullPolicy: &#123;&#125;</span><br><span class="line">            f:name: &#123;&#125;</span><br><span class="line">            f:ports:</span><br><span class="line">              .: &#123;&#125;</span><br><span class="line">              k:&#123;"containerPort":8080,"protocol":"TCP"&#125;:</span><br><span class="line">                .: &#123;&#125;</span><br><span class="line">                f:containerPort: &#123;&#125;</span><br><span class="line">                f:protocol: &#123;&#125;</span><br><span class="line">            f:resources: &#123;&#125;</span><br><span class="line">            f:terminationMessagePath: &#123;&#125;</span><br><span class="line">            f:terminationMessagePolicy: &#123;&#125;</span><br><span class="line">        f:dnsPolicy: &#123;&#125;</span><br><span class="line">        f:enableServiceLinks: &#123;&#125;</span><br><span class="line">        f:restartPolicy: &#123;&#125;</span><br><span class="line">        f:schedulerName: &#123;&#125;</span><br><span class="line">        f:securityContext: &#123;&#125;</span><br><span class="line">        f:terminationGracePeriodSeconds: &#123;&#125;</span><br><span class="line">    manager: kubectl-run</span><br><span class="line">    operation: Update</span><br><span class="line">    time: "2021-10-05T10:51:49Z"</span><br><span class="line">  - apiVersion: v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:status:</span><br><span class="line">        f:conditions:</span><br><span class="line">          k:&#123;"type":"ContainersReady"&#125;:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:lastProbeTime: &#123;&#125;</span><br><span class="line">            f:lastTransitionTime: &#123;&#125;</span><br><span class="line">            f:status: &#123;&#125;</span><br><span class="line">            f:type: &#123;&#125;</span><br><span class="line">          k:&#123;"type":"Initialized"&#125;:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:lastProbeTime: &#123;&#125;</span><br><span class="line">            f:lastTransitionTime: &#123;&#125;</span><br><span class="line">            f:status: &#123;&#125;</span><br><span class="line">            f:type: &#123;&#125;</span><br><span class="line">          k:&#123;"type":"Ready"&#125;:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:lastProbeTime: &#123;&#125;</span><br><span class="line">            f:lastTransitionTime: &#123;&#125;</span><br><span class="line">            f:status: &#123;&#125;</span><br><span class="line">            f:type: &#123;&#125;</span><br><span class="line">        f:containerStatuses: &#123;&#125;</span><br><span class="line">        f:hostIP: &#123;&#125;</span><br><span class="line">        f:phase: &#123;&#125;</span><br><span class="line">        f:podIP: &#123;&#125;</span><br><span class="line">        f:podIPs:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          k:&#123;"ip":"10.1.0.25"&#125;:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:ip: &#123;&#125;</span><br><span class="line">        f:startTime: &#123;&#125;</span><br><span class="line">    manager: kubelet</span><br><span class="line">    operation: Update</span><br><span class="line">    time: "2021-10-05T10:51:53Z"</span><br><span class="line">  name: kubia</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: "306747"</span><br><span class="line">  selfLink: /api/v1/namespaces/default/pods/kubia</span><br><span class="line">  uid: 33b49309-91a2-4c54-ac70-e9d23b7de098</span><br><span class="line"><span class="meta">#</span>pod规格/内容（pod的容器列表、volume等）</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: luksa/kubia</span><br><span class="line">    imagePullPolicy: Always</span><br><span class="line">    name: kubia</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      protocol: TCP</span><br><span class="line">    resources: &#123;&#125;</span><br><span class="line">    terminationMessagePath: /dev/termination-log</span><br><span class="line">    terminationMessagePolicy: File</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">      name: default-token-tkf72</span><br><span class="line">      readOnly: true</span><br><span class="line">  dnsPolicy: ClusterFirst</span><br><span class="line">  enableServiceLinks: true</span><br><span class="line">  nodeName: docker-desktop</span><br><span class="line">  preemptionPolicy: PreemptLowerPriority</span><br><span class="line">  priority: 0</span><br><span class="line">  restartPolicy: Always</span><br><span class="line">  schedulerName: default-scheduler</span><br><span class="line">  securityContext: &#123;&#125;</span><br><span class="line">  serviceAccount: default</span><br><span class="line">  serviceAccountName: default</span><br><span class="line">  terminationGracePeriodSeconds: 30</span><br><span class="line">  tolerations:</span><br><span class="line">  - effect: NoExecute</span><br><span class="line">    key: node.kubernetes.io/not-ready</span><br><span class="line">    operator: Exists</span><br><span class="line">    tolerationSeconds: 300</span><br><span class="line">  - effect: NoExecute</span><br><span class="line">    key: node.kubernetes.io/unreachable</span><br><span class="line">    operator: Exists</span><br><span class="line">    tolerationSeconds: 300</span><br><span class="line">  volumes:</span><br><span class="line">  - name: default-token-tkf72</span><br><span class="line">    secret:</span><br><span class="line">      defaultMode: 420</span><br><span class="line">      secretName: default-token-tkf72</span><br><span class="line"><span class="meta">#</span>pod及其内部容器的详细状态</span><br><span class="line">status:</span><br><span class="line">  conditions:</span><br><span class="line">  - lastProbeTime: null</span><br><span class="line">    lastTransitionTime: "2021-10-05T10:51:49Z"</span><br><span class="line">    status: "True"</span><br><span class="line">    type: Initialized</span><br><span class="line">  - lastProbeTime: null</span><br><span class="line">    lastTransitionTime: "2021-10-05T10:51:53Z"</span><br><span class="line">    status: "True"</span><br><span class="line">    type: Ready</span><br><span class="line">  - lastProbeTime: null</span><br><span class="line">    lastTransitionTime: "2021-10-05T10:51:53Z"</span><br><span class="line">    status: "True"</span><br><span class="line">    type: ContainersReady</span><br><span class="line">  - lastProbeTime: null</span><br><span class="line">    lastTransitionTime: "2021-10-05T10:51:49Z"</span><br><span class="line">    status: "True"</span><br><span class="line">    type: PodScheduled</span><br><span class="line">  containerStatuses:</span><br><span class="line">  - containerID: docker://aa350eb6e6d5422df108a341e9f11afd74773b3ebdc2587f7605c93464543298</span><br><span class="line">    image: luksa/kubia:latest</span><br><span class="line">    imageID: docker-pullable://luksa/kubia@sha256:3f28e304dc0f63dc30f273a4202096f0fa0d08510bd2ee7e1032ce600616de24</span><br><span class="line">    lastState: &#123;&#125;</span><br><span class="line">    name: kubia</span><br><span class="line">    ready: true</span><br><span class="line">    restartCount: 0</span><br><span class="line">    started: true</span><br><span class="line">    state:</span><br><span class="line">      running:</span><br><span class="line">        startedAt: "2021-10-05T10:51:53Z"</span><br><span class="line">  hostIP: 192.168.65.3</span><br><span class="line">  phase: Running</span><br><span class="line">  podIP: 10.1.0.25</span><br><span class="line">  podIPs:</span><br><span class="line">  - ip: 10.1.0.25</span><br><span class="line">  qosClass: BestEffort</span><br><span class="line">  startTime: "2021-10-05T10:51:49Z"</span><br></pre></td></tr></table></figure>
<p>为pod创建一个简单的YAML描述文件，名为<code>kubia-manual.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment">#描述文件遵循v1版本的Kubernetes API</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>				<span class="comment">#描述一个pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-manual</span>    <span class="comment">#pod的名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia</span> <span class="comment">#创建容器所用的镜像</span></span><br><span class="line">	  <span class="attr">name:</span> <span class="string">kubia</span>        <span class="comment">#容器的名称</span></span><br><span class="line">		<span class="attr">ports:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span>   <span class="comment">#应用监听的端口</span></span><br><span class="line">		<span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意一下<code>yaml</code>语法对格式是非常严格的，这里不可以有制表符，否则就会报如下相关错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: error parsing kubia-manual.yaml: error converting YAML to JSON: yaml: line 4: found character that cannot start any token</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: error parsing kubia-manual.yaml: error converting YAML to JSON: yaml: line 8: found a tab character that violates indentation</span><br></pre></td></tr></table></figure>
<p>接下来使用<code>kubectl create</code>从YAML文件创建pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-manual.yaml</span><br></pre></td></tr></table></figure>
<p>得到运行中pod的完整定义</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod kubia-manual -o yaml</span><br></pre></td></tr></table></figure>
<p>也可以返回JSON格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod kubia-manual -o json</span><br></pre></td></tr></table></figure>
<h6 id="利用kubectl-logs命令获取pod日志"><a href="#利用kubectl-logs命令获取pod日志" class="headerlink" title="利用kubectl logs命令获取pod日志"></a>利用kubectl logs命令获取pod日志</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs kubia-manual</span><br></pre></td></tr></table></figure>
<p>如果我们的pod包含多个容器，在运行kubectl logs命令时则必须通过包含<code>-c &lt;容器名称&gt;</code>选项来显式指定容器名称。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs kubia-manual -c kubia</span><br></pre></td></tr></table></figure>
<h6 id="向pod发送请求"><a href="#向pod发送请求" class="headerlink" title="向pod发送请求"></a>向pod发送请求</h6><p>将本地网络端口转发到pod中的端口</p>
<p>如果想要在不通过service的情况下与某个特定的pod 进行通信(出于调试或其他原因)， Kubernetes将允许我们配置端口转发到该pod。 可以通过<code>kubectl port-forward</code>命令完成上述操作。 例如以下命令会将机器的本地端口 8888转发 到我们的kubia-manual pod的端口8080</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl port-forward kubia-manual 8888:8080</span><br><span class="line">Forwarding from 127.0.0.1:8888 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8888 -&gt; 8080</span><br></pre></td></tr></table></figure>
<p>这个时候端口转发就在运行中，我们可以通过curl命令向pod发送一个HTTP请求</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % curl localhost:8888 </span><br><span class="line">You've hit kubia-manual</span><br></pre></td></tr></table></figure>
<p>下图描述了使用<code>kubectl port-forward</code>和<code>curl</code>时的简单视图</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/12.png" alt="12"></p>
<h6 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h6><p>标签是一种简单却功能强大的Kubernetes特性，不仅可以组织pod, 也可以组织所有其他的Kubernetes资源。详细来讲，标签是可以附加到资源的任意键值对，用以选择具有该确切标签的资源(这是通过标答选择器完成的 )。只要标签的key在资源内是唯一的，一个资源便可以拥有多个标签。通常在我们创建资源时就会将标签附加到资源上，但之后我们也可以再添加其他标签，或者修改现有标签的值，而无需重新创建资源。</p>
<p>例如在微服务中，通过给pod添加标签，可以得到一个更组织化的系统。此时每个pod都标有两个标签</p>
<ul>
<li>app：指定pod属于哪个应用、组件或微服务</li>
<li>rel：显示在pod中运行的应用程序版本是stable、beta还是canary</li>
</ul>
<p>如下图所示，显示了使用pod标签组织微服务架构中的pod</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/13.png" alt="13"></p>
<h6 id="创建pod时指定标签"><a href="#创建pod时指定标签" class="headerlink" title="创建pod时指定标签"></a>创建pod时指定标签</h6><p>首先创建一个名为<code>kubia-manual-with-labels.yaml</code>的文件</p>
<p>代码如下，其中两个标签被附加到pod上</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>				</span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-manual-v2</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">creation_method:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia</span>        </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span>   </span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>接下来创建该pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-manual-with-labels.yaml</span><br></pre></td></tr></table></figure>
<p>使用<code>--show-labels</code>查看标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --show-labels</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/22/Docker-Kubernetes学习/14.png" alt="14"></p>
<p>如果你只对某些标签感兴趣， 可以使用 -L 选项指定它们并将它们分别显示在 自己的列中， 而不是列出所有标签。 接下来我们再次列出所有 pod, 并将附加到 pod名为<code>kubia-manual-v2</code>上的两个标签的列展示如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -L creation_method,env</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/22/Docker-Kubernetes学习/15.png" alt="15"></p>
<h6 id="修改现有pod的标签"><a href="#修改现有pod的标签" class="headerlink" title="修改现有pod的标签"></a>修改现有pod的标签</h6><p>标签也可以在现有 pod 上进行添加和修改。由于pod名为<code>kubia-manual</code>也是手动创建的 所以我们可以为其添加 <code>creation_method=manual</code>标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod kubia-manual creation_method=manual</span><br></pre></td></tr></table></figure>
<p>更改现有标签的值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod kubia-manual-v2 env=debug --overwrite</span><br></pre></td></tr></table></figure>
<p>再次列出pod以查看更新后的标签</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/16.png" alt="16"></p>
<h6 id="使用标签选择器列出pod"><a href="#使用标签选择器列出pod" class="headerlink" title="使用标签选择器列出pod"></a>使用标签选择器列出pod</h6><p>列出标签<code>creation_method</code>的值为manual的pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -l creation_method=manual</span><br></pre></td></tr></table></figure>
<p>列出包含env标签的所有pod 无论其值如何</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -l env</span><br></pre></td></tr></table></figure>
<p>列出没有env标签的pod</p>
<p>注意这里要使用单引号来包含<code>!env</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -l '!env'</span><br></pre></td></tr></table></figure>
<h6 id="发现其他命名空间及其pod"><a href="#发现其他命名空间及其pod" class="headerlink" title="发现其他命名空间及其pod"></a>发现其他命名空间及其pod</h6><p>列出集群中所有的命名空间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ns</span><br></pre></td></tr></table></figure>
<p>这里需要声明的是，到目前为止，我们只在<code>default</code>命名空间中进行操作，当使用<code>kubecel get</code>命令列出资源时，我们从未明确指定命名空间，因此kubectl总是默认为default命名空间</p>
<p><img src="/2021/03/22/Docker-Kubernetes学习/17.png" alt="17"></p>
<p>列出指定命名空间的pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod --namespace kube-system</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/22/Docker-Kubernetes学习/18.png" alt="18"></p>
<h6 id="创建一个命名空间"><a href="#创建一个命名空间" class="headerlink" title="创建一个命名空间"></a>创建一个命名空间</h6><p>我们还是使用YAML文件来创建一个命名空间</p>
<p>创建一个名为<code>custom-namespace.yaml</code>的文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-namespace</span></span><br></pre></td></tr></table></figure>
<p>使用create命令创建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f custom-namespace.yaml</span><br></pre></td></tr></table></figure>
<p>如果想要在刚创建的命名 空 间中创建资源，可以选择在<code>metadata</code>字段中添加 一个 <code>namespace : custom-namespace</code> 属性，也可以在使用<code>kubectl create</code> 命令创建资源时指定命名空间 :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-manual.yaml -n custom-namespace</span><br></pre></td></tr></table></figure>
<p>这个时候我们就得到了两个同名的pod(kubia-manual)，其中一个在<code>default</code>命名空间中，一个在<code>custom-namespace</code>中</p>
<h6 id="删除pod"><a href="#删除pod" class="headerlink" title="删除pod"></a>删除pod</h6><p>按照名称删除pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod kubia-manual</span><br></pre></td></tr></table></figure>
<p>使用标签选择器删除pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod -l creation_method=manual</span><br></pre></td></tr></table></figure>
<p>通过删除整个命名空间来删除pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete ns custom-namespace</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Notes/" rel="tag"># Notes</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/21/Go语言实现向kafka中发送数据/" rel="next" title="Go语言实现向kafka中发送数据">
                <i class="fa fa-chevron-left"></i> Go语言实现向kafka中发送数据
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/26/初学influxdb/" rel="prev" title="初学influxdb">
                初学influxdb <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/author2.png" alt="Elssm">
            
              <p class="site-author-name" itemprop="name">Elssm</p>
              <p class="site-description motion-element" itemprop="description">Web/Cloud/ML Security  Adversarial Training</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/elssm" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://leetcode.cn/u/elssm/" target="_blank" title="Leetcode">
                      
                        <i class="fa fa-fw fa-globe"></i>Leetcode</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker"><span class="nav-number">1.</span> <span class="nav-text">Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker的概念"><span class="nav-number">1.1.</span> <span class="nav-text">Docker的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#容器隔离机制"><span class="nav-number">1.2.</span> <span class="nav-text">容器隔离机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker核心组件"><span class="nav-number">1.3.</span> <span class="nav-text">Docker核心组件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker技术组件"><span class="nav-number">1.4.</span> <span class="nav-text">Docker技术组件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构建、分发和运行Docker镜像"><span class="nav-number">1.5.</span> <span class="nav-text">构建、分发和运行Docker镜像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker-Hello-world"><span class="nav-number">1.6.</span> <span class="nav-text">Docker Hello-world</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker搭建应用"><span class="nav-number">1.7.</span> <span class="nav-text">Docker搭建应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker持续集成"><span class="nav-number">1.8.</span> <span class="nav-text">Docker持续集成</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#构建Jenkins和Docker服务器"><span class="nav-number">1.8.1.</span> <span class="nav-text">构建Jenkins和Docker服务器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建新的Jenkins作业"><span class="nav-number">1.8.2.</span> <span class="nav-text">创建新的Jenkins作业</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#运行Jenkins作业"><span class="nav-number">1.8.3.</span> <span class="nav-text">运行Jenkins作业</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#遇到的问题"><span class="nav-number">1.8.4.</span> <span class="nav-text">遇到的问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker进阶"><span class="nav-number">1.9.</span> <span class="nav-text">Docker进阶</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Docker构建应用"><span class="nav-number">1.10.</span> <span class="nav-text">Docker构建应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kubernetes"><span class="nav-number">2.</span> <span class="nav-text">Kubernetes</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#发展历程"><span class="nav-number">2.1.</span> <span class="nav-text">发展历程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#资源管理器"><span class="nav-number">2.2.</span> <span class="nav-text">资源管理器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kubernetes简介"><span class="nav-number">2.3.</span> <span class="nav-text">Kubernetes简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kubernetes核心功能"><span class="nav-number">2.4.</span> <span class="nav-text">Kubernetes核心功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kubernetes集群架构"><span class="nav-number">2.5.</span> <span class="nav-text">Kubernetes集群架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kubernetes运行应用"><span class="nav-number">2.6.</span> <span class="nav-text">Kubernetes运行应用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安装kubernetes"><span class="nav-number">2.7.</span> <span class="nav-text">安装kubernetes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kubernetes的优势"><span class="nav-number">2.8.</span> <span class="nav-text">Kubernetes的优势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kubernetes组件说明"><span class="nav-number">2.9.</span> <span class="nav-text">Kubernetes组件说明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pod的介绍"><span class="nav-number">2.10.</span> <span class="nav-text">pod的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#列出pod"><span class="nav-number">2.10.1.</span> <span class="nav-text">列出pod</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建一个服务对象"><span class="nav-number">2.10.2.</span> <span class="nav-text">创建一个服务对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#列出服务"><span class="nav-number">2.10.3.</span> <span class="nav-text">列出服务</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Pod概念"><span class="nav-number">2.10.4.</span> <span class="nav-text">Pod概念</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#以YAML或JSON描述文件创建pod"><span class="nav-number">2.10.5.</span> <span class="nav-text">以YAML或JSON描述文件创建pod</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#利用kubectl-logs命令获取pod日志"><span class="nav-number">2.10.6.</span> <span class="nav-text">利用kubectl logs命令获取pod日志</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#向pod发送请求"><span class="nav-number">2.10.7.</span> <span class="nav-text">向pod发送请求</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#标签"><span class="nav-number">2.10.8.</span> <span class="nav-text">标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建pod时指定标签"><span class="nav-number">2.10.9.</span> <span class="nav-text">创建pod时指定标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#修改现有pod的标签"><span class="nav-number">2.10.10.</span> <span class="nav-text">修改现有pod的标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#使用标签选择器列出pod"><span class="nav-number">2.10.11.</span> <span class="nav-text">使用标签选择器列出pod</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#发现其他命名空间及其pod"><span class="nav-number">2.10.12.</span> <span class="nav-text">发现其他命名空间及其pod</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#创建一个命名空间"><span class="nav-number">2.10.13.</span> <span class="nav-text">创建一个命名空间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#删除pod"><span class="nav-number">2.10.14.</span> <span class="nav-text">删除pod</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Elssm</span>

  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div>



<span id="busuanzi_container_site_pv" class="theme-info">
&nbsp;&nbsp;|&nbsp;&nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span id="busuanzi_container_site_uv" class="theme-info">
&nbsp;&nbsp;|&nbsp;&nbsp;本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
