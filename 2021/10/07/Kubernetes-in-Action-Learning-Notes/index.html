<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Notes,">










<meta name="description" content="前言对于《Kubernetes in action》这本书前三章节相关的笔记，我都记录在下面这个链接了，有需求的可以看看。 http://elssm.top/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/ 存活探针Kubernetes可以通过存活探针(liveness probe)检查容器是否还在运行，可以为pod中的每个容器单独指定存活探针。如果探">
<meta name="keywords" content="Notes">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes in Action Learning Notes">
<meta property="og:url" content="elssm.github.io/2021/10/07/Kubernetes-in-Action-Learning-Notes/index.html">
<meta property="og:site_name" content="ELSSM">
<meta property="og:description" content="前言对于《Kubernetes in action》这本书前三章节相关的笔记，我都记录在下面这个链接了，有需求的可以看看。 http://elssm.top/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/ 存活探针Kubernetes可以通过存活探针(liveness probe)检查容器是否还在运行，可以为pod中的每个容器单独指定存活探针。如果探">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/2021/10/07/Kubernetes-in-Action-Learning-Notes/1.png">
<meta property="og:image" content="/2021/10/07/Kubernetes-in-Action-Learning-Notes/2.png">
<meta property="og:image" content="/2021/10/07/Kubernetes-in-Action-Learning-Notes/3.png">
<meta property="og:image" content="/2021/10/07/Kubernetes-in-Action-Learning-Notes/4.png">
<meta property="og:image" content="/2021/10/07/Kubernetes-in-Action-Learning-Notes/5.png">
<meta property="og:image" content="/2021/10/07/Kubernetes-in-Action-Learning-Notes/6.png">
<meta property="og:image" content="/2021/10/07/Kubernetes-in-Action-Learning-Notes/7.png">
<meta property="og:updated_time" content="2021-12-13T09:47:14.657Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kubernetes in Action Learning Notes">
<meta name="twitter:description" content="前言对于《Kubernetes in action》这本书前三章节相关的笔记，我都记录在下面这个链接了，有需求的可以看看。 http://elssm.top/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/ 存活探针Kubernetes可以通过存活探针(liveness probe)检查容器是否还在运行，可以为pod中的每个容器单独指定存活探针。如果探">
<meta name="twitter:image" content="/2021/10/07/Kubernetes-in-Action-Learning-Notes/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="elssm.github.io/2021/10/07/Kubernetes-in-Action-Learning-Notes/">





  <title>Kubernetes in Action Learning Notes | ELSSM</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ELSSM</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="elssm.github.io/2021/10/07/Kubernetes-in-Action-Learning-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="elssm">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/author1.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ELSSM">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kubernetes in Action Learning Notes</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-07T10:10:06+08:00">
                2021-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于《Kubernetes in action》这本书前三章节相关的笔记，我都记录在下面这个链接了，有需求的可以看看。</p>
<p><a href="http://elssm.top/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">http://elssm.top/2021/03/22/Docker-Kubernetes%E5%AD%A6%E4%B9%A0/</a></p>
<h4 id="存活探针"><a href="#存活探针" class="headerlink" title="存活探针"></a>存活探针</h4><p>Kubernetes可以通过存活探针(liveness probe)检查容器是否还在运行，可以为pod中的每个容器单独指定存活探针。如果探测失败，Kubernetes将定期执行探针并重新启动容器。</p>
<h5 id="Kubernetes三种探测容器的机制"><a href="#Kubernetes三种探测容器的机制" class="headerlink" title="Kubernetes三种探测容器的机制"></a>Kubernetes三种探测容器的机制</h5><ul>
<li>HTTP GET探针对容器的IP地址执行HTTP GET请求。如果HTTP响应状态码事<code>2xx</code>或<code>3xx</code>，则认为探测成功，如果服务器返回错误响应状态码或是没有收到响应，则认为探测事失败的，这个时候容器将会被重新启动。</li>
<li>TCP套接字探针尝试与容器指定端口建立TCP连接，如果连接建立成功，则探测成功，否则，容器重新启动。</li>
<li>Exec探针在容器内执行任意命令，并检查命令的退出状态码，如果状态码是0，则探测成功。所有其他的状态码都会被认为失败。</li>
</ul>
<h5 id="创建基于HTTP的存活探针"><a href="#创建基于HTTP的存活探针" class="headerlink" title="创建基于HTTP的存活探针"></a>创建基于HTTP的存活探针</h5><p>老规矩，先来创建一个名为<code>kubia-liveness-probe.yaml</code>的文件，该pod的描述文件定义了一个<code>httpGet</code>存活探针，该探针告诉Kubernetes定期在端口8080路径上执行HTTP GET请求，以确定该容器是否健康。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-liveness</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia-unhealthy</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>接下来使用<code>kubectl create</code>从YAML文件创建pod</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-liveness-probe.yaml</span><br></pre></td></tr></table></figure>
<p>大约过几分钟后，我们通过<code>kubectl get</code>可以看到，pod的容器已经被重启了一次，如果继续等下去，容器将会再次重启，无限循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pod kubia-liveness</span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-liveness   1/1     Running   1          5m1s</span><br></pre></td></tr></table></figure>
<p>通过<code>kubectl describe</code>可以看到重启容器后的相关描述</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl describe pod kubia-liveness</span><br><span class="line">Name:         kubia-liveness</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         docker-desktop/192.168.65.4</span><br><span class="line">Start Time:   Thu, 07 Oct 2021 10:42:42 +0800</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           10.1.0.33</span><br><span class="line">IPs:</span><br><span class="line">  IP:  10.1.0.33</span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://983b1e5ec9db6185dd66335def1b0b4ed3edd2eb1a6c4d4cd934fc697b450f67</span><br><span class="line">    Image:          luksa/kubia-unhealthy</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia-unhealthy@sha256:5c746a42612be61209417d913030d97555cff0b8225092908c57634ad7c235f7</span><br><span class="line">    Port:           &lt;none&gt;</span><br><span class="line">    Host Port:      &lt;none&gt;</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Thu, 07 Oct 2021 10:49:03 +0800</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       Error</span><br><span class="line">      Exit Code:    137</span><br><span class="line">      Started:      Thu, 07 Oct 2021 10:47:14 +0800</span><br><span class="line">      Finished:     Thu, 07 Oct 2021 10:49:02 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  2</span><br><span class="line">    Liveness:       http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3</span><br><span class="line">    Environment:    &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>从上述返回的结果中我们可以看到容器此时是正在运行着的，但之前由于<code>Terminated</code>而退出，退出代码为137，137表示该进程由外部信号中断，137是两个数字的总和：128+x，其中x是终止进程的信号编号，在这个例子中，x等于9，这是SIGKILL的信号编号，意味着这个进程被强行终止。</p>
<h4 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h4><h5 id="ReplicationController介绍"><a href="#ReplicationController介绍" class="headerlink" title="ReplicationController介绍"></a>ReplicationController介绍</h5><p>ReplicationController是一种Kubernetes资源，可确保它的pod始终保持运行状态，如果pod因任何原因消失，则ReplicationController会注意到缺少了pod并创建替代pod。如下图所示，当节点出现故障时，只有ReplicationController管理的pod才能被重新创建。对于podA而言，则会完全丢失，因为没有东西负责重建它。</p>
<p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/1.png" alt="1"></p>
<p>ReplicationController会持续监控正在运行的pod列表，并保证相应“类型”的pod的数目与期望相符，如果正在运行的pod太少，它会根据pod模版创建新的副本。如果正在运行的pod太多，它会删除多余的副本。</p>
<h5 id="ReplicationController协调流程"><a href="#ReplicationController协调流程" class="headerlink" title="ReplicationController协调流程"></a>ReplicationController协调流程</h5><p>ReplicationController的工作是确保pod的数量始终与其标签选择器匹配。 如果不匹配， 则ReplicationController将根据所需， 采取适当的操作来协调pod的数量。如下图是一个ReplicationController的协调流程</p>
<p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/2.png" alt="2"></p>
<h5 id="ReplicationController组成"><a href="#ReplicationController组成" class="headerlink" title="ReplicationController组成"></a>ReplicationController组成</h5><ul>
<li>label selector（标签选择器）：用于确定ReplicationController作用域中有哪些pod</li>
<li>replica count（副本个数）：指定应运行的pod数量</li>
<li>pod template（pod模版）：用于创建新的pod</li>
</ul>
<h5 id="创建ReplicationController"><a href="#创建ReplicationController" class="headerlink" title="创建ReplicationController"></a>创建ReplicationController</h5><p>首先创建一个名为<code>kubia-rc.yaml</code>的YAML文件，代码描述如下。当上传文件道API服务器时，Kubernetes会创建一个名为kubia的ReplicationController，它确保符合标签选择器<code>app=kubia</code>的pod实例始终是三个，当没有足够的pod时，它根据提供的pod模版创建新的pod。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure>
<p>使用<code>kubectl create</code>命令创建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-rc.yaml</span><br></pre></td></tr></table></figure>
<p>由于没有任何pod有<code>app=kubia</code>标签，因此ReplicationController会根据pod模版启动三个新的pod。使用<code>kubectl get</code>查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods               </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-gjcxj   1/1     Running   0          6s</span><br><span class="line">kubia-pd5r5   1/1     Running   0          6s</span><br><span class="line">kubia-tgjsn   1/1     Running   0          6s</span><br></pre></td></tr></table></figure>
<p>这个时候如果我们删除了一个pod，看看会发生什么。这个时候被删除的pod状态处于终止状态，而新的pod处于创建状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get pods                  </span><br><span class="line">NAME          READY   STATUS              RESTARTS   AGE</span><br><span class="line">kubia-bcbz5   0/1     ContainerCreating   0          2s</span><br><span class="line">kubia-gjcxj   1/1     Terminating         0          36s</span><br><span class="line">kubia-pd5r5   1/1     Running             0          36s</span><br><span class="line">kubia-tgjsn   1/1     Running             0          36s</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods              </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-bcbz5   1/1     Running   0          2m29s</span><br><span class="line">kubia-pd5r5   1/1     Running   0          3m3s</span><br><span class="line">kubia-tgjsn   1/1     Running   0          3m3s</span><br></pre></td></tr></table></figure>
<p>通过<code>kubectl get</code>查看ReplicationController的信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get rc</span><br><span class="line">NAME    DESIRED   CURRENT   READY   AGE</span><br><span class="line">kubia   3         3         3       3m31s</span><br></pre></td></tr></table></figure>
<p>通过<code>kubectl describe</code>查看ReplicationController详细信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl describe rc kubia</span><br><span class="line">Name:         kubia</span><br><span class="line">Namespace:    default</span><br><span class="line">Selector:     app=kubia</span><br><span class="line">Labels:       app=kubia</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Replicas:     3 current / 3 desired</span><br><span class="line">Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=kubia</span><br><span class="line">  Containers:</span><br><span class="line">   kubia:</span><br><span class="line">    Image:        luksa/kubia</span><br><span class="line">    Port:         8080/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age    From                    Message</span><br><span class="line">  ----    ------            ----   ----                    -------</span><br><span class="line">  Normal  SuccessfulCreate  5m1s   replication-controller  Created pod: kubia-tgjsn</span><br><span class="line">  Normal  SuccessfulCreate  5m1s   replication-controller  Created pod: kubia-gjcxj</span><br><span class="line">  Normal  SuccessfulCreate  5m1s   replication-controller  Created pod: kubia-pd5r5</span><br><span class="line">  Normal  SuccessfulCreate  4m27s  replication-controller  Created pod: kubia-bcbz5</span><br></pre></td></tr></table></figure>
<p>获取当前ReplicationController管理的pod的标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods --show-labels</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE     LABELS</span><br><span class="line">kubia-bcbz5   1/1     Running   0          7m48s   app=kubia</span><br><span class="line">kubia-pd5r5   1/1     Running   0          8m22s   app=kubia</span><br><span class="line">kubia-tgjsn   1/1     Running   0          8m22s   app=kubia</span><br></pre></td></tr></table></figure>
<p>给ReplicationController管理的pod加标签，在这里我们给名为<code>kubia-bcbz5</code>的pod添加了一个<code>type=special</code>的标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod kubia-bcbz5 type=special</span><br></pre></td></tr></table></figure>
<p>这个时候我们再次查看pod的标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods --show-labels            </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">kubia-bcbz5   1/1     Running   0          11m   app=kubia,type=special</span><br><span class="line">kubia-pd5r5   1/1     Running   0          11m   app=kubia</span><br><span class="line">kubia-tgjsn   1/1     Running   0          11m   app=kubia</span><br></pre></td></tr></table></figure>
<p>更改已托管的pod的标签，这里我们还是更改名为<code>kubia-bcbz5</code>的pod的标签，这一步操作会使得该pod不再与ReplicationController的标签选择器相匹配。因此这个时候ReplicationController会重新启动一个新的pod。在这里我们使用了<code>--overwrite</code>参数是为了覆盖标签。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label pod kubia-bcbz5 app=foo --overwrite</span><br></pre></td></tr></table></figure>
<p>这个时候我们再次列出所有pod，会发现多了一个pod，最后一个是新创建出来的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods -L app</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE     APP</span><br><span class="line">kubia-bcbz5   1/1     Running   0          14m     foo</span><br><span class="line">kubia-pd5r5   1/1     Running   0          15m     kubia</span><br><span class="line">kubia-tgjsn   1/1     Running   0          15m     kubia</span><br><span class="line">kubia-zxcjw   1/1     Running   0          2m27s   kubia</span><br></pre></td></tr></table></figure>
<p>下图展示了当我们更改pod的标签时，ReplicationController发生的一些操作。</p>
<p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/3.png" alt="3"></p>
<h5 id="ReplicationController扩容"><a href="#ReplicationController扩容" class="headerlink" title="ReplicationController扩容"></a>ReplicationController扩容</h5><h6 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h6><p>通过<code>kubectl scale</code>命令扩容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rc kubia --replicas=10</span><br></pre></td></tr></table></figure>
<h6 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h6><p>通过编辑定义来扩容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit rc kubia</span><br></pre></td></tr></table></figure>
<p>之后将replicas的值从3改为10即可。再次使用<code>kubectl get</code>查看，发现扩展成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get rc</span><br><span class="line">NAME    DESIRED   CURRENT   READY   AGE</span><br><span class="line">kubia   10        10        5       27m</span><br></pre></td></tr></table></figure>
<h5 id="删除ReplicationController"><a href="#删除ReplicationController" class="headerlink" title="删除ReplicationController"></a>删除ReplicationController</h5><p>当使用<code>kubectl delete</code>删除ReplicationController时，pod也会被删除。当然我们也可以只删除ReplicationController，从而保持pod运行。通过增加<code>--cascade=false</code>选项来保持pod的运行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete rc kubia --cascade=false</span><br></pre></td></tr></table></figure>
<h4 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h4><p>ReplicaSet的行为和ReplicationController完全相同，但是pod选择器的表达能力更强</p>
<h5 id="定义ReplicaSet"><a href="#定义ReplicaSet" class="headerlink" title="定义ReplicaSet"></a>定义ReplicaSet</h5><p>首先创建一个名为<code>kubia-replicaset.yaml</code>的YAML文件</p>
<p>这里需要注意的是ReplicaSet不是<code>v1 API</code>的一部分，它属于<code>apps API</code>组的<code>v1</code>版本。其次是在选择其中，不需要再selector属性中直接列出pod需要的标签，而是在<code>selector.matchLabels</code>下指定它们。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels</span><br><span class="line">      app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure>
<p>在上一节的删除ReplicationController中，我们没有删除pod。因此在创建ReplicaSet的时候不会创建任何新的pod，ReplicaSet会把现有的三个pod归为自己来管理。</p>
<h5 id="创建和检查ReplicaSet"><a href="#创建和检查ReplicaSet" class="headerlink" title="创建和检查ReplicaSet"></a>创建和检查ReplicaSet</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-replicaset.yaml</span><br></pre></td></tr></table></figure>
<p>使用<code>kubectl get</code>来获取当前的ReplicaSet</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get rs</span><br></pre></td></tr></table></figure>
<p>使用<code>kubectl describe</code>来检查当前的ReplicaSet</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe rs</span><br></pre></td></tr></table></figure>
<p>这个时候如果我们使用<code>kubectl get</code>来列出当前的pod，则会发现还是之前的那三个pod，而ReplicaSet并没有创建新的pod</p>
<h5 id="删除ReplicaSet"><a href="#删除ReplicaSet" class="headerlink" title="删除ReplicaSet"></a>删除ReplicaSet</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete rs kubia</span><br></pre></td></tr></table></figure>
<h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><p>DaemonSet确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p>
<p>DaemonSet 的一些典型用法：</p>
<ul>
<li>在每个节点上运行集群守护进程</li>
<li>在每个节点上运行日志收集守护进程</li>
<li>在每个节点上运行监控守护进程</li>
</ul>
<p>一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU要求。</p>
<p>DaemonSet将pod部署到集群中的所有节点上，除非指定这些pod只在部分节点上运行，这是通过pod模版中的nodeSelector属性指定的，这是DaemonSet定义的一部分。</p>
<h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><p>假设有一个名为ssd-monitor的守护进程，它需要在包含固态驱动器(SSD)的所有节点上运行，我们需要创建一个DaemonSet，它在标记为具有SSD的所有节点上运行这个守护进程，如下图所示</p>
<p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/4.png" alt="4"></p>
<p>第一步还是创建一个DaemonSet的YAML文件，这样会创建一个运行ssd-monitor监控器进程的DaemonSet，该进程每5s会将”SSD OK”打印到标准输出。YAML文件名为<code>ssd-monitor-daemonset.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ssd-monitor</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">ssd-monitor</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">ssd-monitor</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">disk:</span> <span class="string">ssd</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/ssd-monitor</span></span><br></pre></td></tr></table></figure>
<p>通过<code>kubectl create</code>创建DaemonSet</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f ssd-monitor-daemonset.yaml</span><br></pre></td></tr></table></figure>
<p>通过<code>kubectl get</code>查看DaemonSet</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ds</span><br></pre></td></tr></table></figure>
<p>这个时候我们获取pod信息发现没有pod相关信息，这是因为我们没有给节点打上<code>disk=ssd</code>的标签，和上面那个图描述的一样，如果节点没有<code>disk=ssd</code>这个标签，则DaemonSet不会为该节点部署pod，因此我们需要为节点添加标签，这里我使用的节点为<code>docker-desktop</code>，当然你也可以通过<code>kubectl get node</code>获取你的节点信息。</p>
<p>现在给节点添加<code>disk=ssd</code>标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node docker-desktop disk=ssd</span><br></pre></td></tr></table></figure>
<p>查看是否成功为节点打上标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get node --show-labels              </span><br><span class="line">NAME             STATUS   ROLES                  AGE   VERSION   LABELS</span><br><span class="line">docker-desktop   Ready    control-plane,master   43h   v1.21.3   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,disk=ssd,kubernetes.io/arch=amd64,kubernetes.io/hostname=docker-desktop,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node-role.kubernetes.io/master=,node.kubernetes.io/exclude-from-external-load-balancers=</span><br></pre></td></tr></table></figure>
<p>现在重新获取节点信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods</span><br><span class="line">NAME                READY   STATUS    RESTARTS   AGE</span><br><span class="line">ssd-monitor-6gmhm   1/1     Running   0          78s</span><br></pre></td></tr></table></figure>
<p>假如说这个时候我们修改了节点的标签，看看会发生什么，如下面命令所示，我们将<code>disk=ssd</code>改为了<code>disk=hdd</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node docker-desktop disk=hdd --overwrite</span><br></pre></td></tr></table></figure>
<p>这个时候我们再次查看pod，发现pod正在被终止</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods                                      </span><br><span class="line">NAME                READY   STATUS        RESTARTS   AGE</span><br><span class="line">ssd-monitor-6gmhm   1/1     Terminating   0          3m59s</span><br></pre></td></tr></table></figure>
<p>删除节点标签，如果我们要删除某个节点的标签，命令如下，其中disk为标签的键，后面的减号代表删除该标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node docker-desktop disk-</span><br></pre></td></tr></table></figure>
<h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>Job 会创建一个或者多个 Pods，并将继续重试 Pods 的执行，直到指定数量的 Pods 成功终止。 随着 Pods 成功结束，Job 跟踪记录成功完成的 Pods 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pods。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p>
<p>一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。</p>
<p>你也可以使用 Job 以并行的方式运行多个 Pod。</p>
<h5 id="定义Job资源"><a href="#定义Job资源" class="headerlink" title="定义Job资源"></a>定义Job资源</h5><p>老规矩，还是创建一个名为<code>exporter.yaml</code>的YAML文件。该文件定义了一个Job类型的资源，它将运行<code>luksa/batch-job</code>镜像，该镜像调用一个运行120秒的进程，然后退出。在pod配置的属性restartPolicy默认为Always，然而Job pod不能使用默认策略，因为它们不是要无限期的运行下去，因此需要明确指定restartPolicy为<code>OnFailure</code>还是<code>Never</code>，这一设置防止容器在完成任务时重新启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: batch-job</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: batch-job</span><br><span class="line">    spec:</span><br><span class="line">      restartPolicy: OnFailure</span><br><span class="line">      containers:</span><br><span class="line">      - name: main</span><br><span class="line">        image: luksa/batch-job</span><br></pre></td></tr></table></figure>
<p>创建该job</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f exporter.yaml</span><br></pre></td></tr></table></figure>
<p>获取job信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get jobs</span><br><span class="line">NAME        COMPLETIONS   DURATION   AGE</span><br><span class="line">batch-job   0/1           8s         8s</span><br></pre></td></tr></table></figure>
<p>获取pod信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods</span><br><span class="line">NAME              READY   STATUS    RESTARTS   AGE</span><br><span class="line">batch-job-q8c44   1/1     Running   0          18s</span><br></pre></td></tr></table></figure>
<p>两分钟之后，我们再次获取pod信息，会发现该pod的状态被标记为已完成。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods</span><br><span class="line">NAME              READY   STATUS      RESTARTS   AGE</span><br><span class="line">batch-job-q8c44   0/1     Completed   0          2m15s</span><br></pre></td></tr></table></figure>
<p>pod完成后并没有被删除，这样方便我们查阅该pod 的日志，如下命令所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl logs batch-job-q8c44</span><br><span class="line">Fri Oct  8 10:07:58 UTC 2021 Batch job starting</span><br><span class="line">Fri Oct  8 10:09:58 UTC 2021 Finished succesfully</span><br></pre></td></tr></table></figure>
<h5 id="在Job中运行多个pod实例"><a href="#在Job中运行多个pod实例" class="headerlink" title="在Job中运行多个pod实例"></a>在Job中运行多个pod实例</h5><p>顺序运行：设置<code>completions</code>的值为多少，该job就会创建多少个pod，然后顺序运行。</p>
<p>并行运行：设置<code>parallelism</code>的值为多少，该job就会一次并行运行多少个pod，并行运行中也要设置<code>completions</code>的值</p>
<h5 id="限制job-pod完成任务的时间"><a href="#限制job-pod完成任务的时间" class="headerlink" title="限制job pod完成任务的时间"></a>限制job pod完成任务的时间</h5><p>通过在pod配置中设置<code>activeDeadlineSeconds</code>属性，可以限制pod的时间，如果pod运行时间超过此时间，系统将尝试终止pod，并将Job标记为失败。</p>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>Kubernetes服务是一种为一组功能相同的pod提供单一不变的接入点的资源。当服务存在时，它的IP地址和端口不会改变，客户端通过IP地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个pod上，通过这种方式，客户端不需要知道每个单独的提供服务的pod的地址，这样这些pod就可以在集群中随时被创建或移除。如下图展示的是一个客户端访问前端，前端访问后端服务的例子。</p>
<p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/5.png" alt="5"></p>
<h5 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h5><p>在创建服务之前，我们先通过创建ReplicationController运行三个包含Node.js应用的pod。还是使用的是之前创建的<code>kubia-rc.yaml</code>文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-rc.yaml</span><br></pre></td></tr></table></figure>
<p>通过<code>kubectl get</code>命令检测pod是否成功启动，并查看这三个pod的标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get pods --show-labels</span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">kubia-hvlfd   1/1     Running   0          14s   app=kubia</span><br><span class="line">kubia-n6nfn   1/1     Running   0          14s   app=kubia</span><br><span class="line">kubia-ndbnt   1/1     Running   0          14s   app=kubia</span><br></pre></td></tr></table></figure>
<p>这个时候通过YAML描述文件来创建服务，该YAML文件的名为<code>kubia-svc.yaml</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port:80 #该服务的可用端口</span><br><span class="line">    targetPort: 8080  #服务将连接转发到的容器端口</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia #具有app=kubia标签的pod都属于该服务</span><br></pre></td></tr></table></figure>
<p>通过<code>kubectl create</code>发布文件创建服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-svc.yaml</span><br></pre></td></tr></table></figure>
<p>列出所有的服务资源，如下命令，可以看到第二个是我们创建的服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP   44h</span><br><span class="line">kubia        ClusterIP   10.111.239.153   &lt;none&gt;        80/TCP    24s</span><br></pre></td></tr></table></figure>
<h5 id="从内部集群测试服务"><a href="#从内部集群测试服务" class="headerlink" title="从内部集群测试服务"></a>从内部集群测试服务</h5><ul>
<li>创建一个pod，它将请求发送到服务的集群IP并记录响应，可以通过查看pod日志检查服务的响应。</li>
<li>使用ssh远程登录到其中一个Kubernetes节点上，然后使用curl命令。</li>
<li>可以通过<code>kubectl exec</code>命令在一个已经存在的pod中执行curl命令。</li>
</ul>
<p>我们使用最后一种方式来进行测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec kubia-hvlfd -- curl -s http://10.111.239.153</span><br><span class="line">You've hit kubia-ndbnt</span><br></pre></td></tr></table></figure>
<p>我们来解释一下上述命令执行了哪些操作。首先是在一个pod容器上，利用Kubernetes去执行curl命令，curl命令向一个后端有三个pod服务的IP发送了HTTP请求，这个时候Kubernetes服务代理拦截该连接，在三个pod中任意选择了一个pod，然后将请求转发给它。<code>Node.js</code>在pod中运行处理请求，并返回带有pod名称的HTTP响应，接着curl命令向标准输出打印返回值，该返回值被<code>kubectl</code>截取并打印到主机的标准输出。</p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>Kubernetes还为客户端提供了发现服务的IP和端口的方式</p>
<h5 id="通过环境变量发现服务"><a href="#通过环境变量发现服务" class="headerlink" title="通过环境变量发现服务"></a>通过环境变量发现服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl exec kubia-695cf env</span><br><span class="line">kubectl exec [POD] [COMMAND] is DEPRECATED and will be removed in a future version. Use kubectl exec [POD] -- [COMMAND] instead.</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kubia-695cf</span><br><span class="line">KUBIA_SERVICE_HOST=10.111.239.153</span><br><span class="line">KUBIA_SERVICE_PORT=80</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br></pre></td></tr></table></figure>
<h5 id="通过DNS发现服务"><a href="#通过DNS发现服务" class="headerlink" title="通过DNS发现服务"></a>通过DNS发现服务</h5><p>运行一个DNS服务的pod，在集群中的其他pod都被配置成使用其作为DNS，运行在pod上的进程DNS查询都会被Kubernetes自身的DNS服务器响应，该服务器知道系统中运行的所有服务。</p>
<h4 id="将服务暴露给外部客户端"><a href="#将服务暴露给外部客户端" class="headerlink" title="将服务暴露给外部客户端"></a>将服务暴露给外部客户端</h4><ul>
<li>将服务的类型设置成<code>NodePort</code>：每个集群节点都会在节点上打开一个端口，对于<code>NodePort</code>服务，每个集群节点在节点本身上打开一个端口，并将在该端口上接收到的流量重定向到基础服务，该服务仅在内部集群IP和端口上才能访问，但也可通过所有节点上的专用端口访问。</li>
<li>将服务的类型设置成<code>LoadBalance</code>：这是<code>NodePort</code>类型的一种扩展，这使得服务可以通过一个专用的负载均衡器来访问，这是由Kubernetes中正在运行的云基础设施提供的，负载均衡器将流量重定向到跨所有节点的节点端口，客户端通过负载均衡器的IP连接到服务。</li>
<li>创建一个Ingress资源：这是一个完全不同的机制，通过一个IP地址公开多个服务，它运行在HTTP层，因此可以提供比工作在第四层的服务更多的功能。</li>
</ul>
<h5 id="创建NodePort类型的服务"><a href="#创建NodePort类型的服务" class="headerlink" title="创建NodePort类型的服务"></a>创建NodePort类型的服务</h5><p>创建一个名为<code>kubia-svc-nodeport.yaml</code>的YAML文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-nodeport</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort #为NodePort设置服务类型</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80  #服务集群IP的端口号</span><br><span class="line">    targetPort: 8080  #背后pod的目标端口号</span><br><span class="line">    nodePort: 30123   #通过集群节点的30123端口可以访问该服务</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure>
<p>创建该服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-svc-nodeport.yaml</span><br></pre></td></tr></table></figure>
<p>查看该服务的基础信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % kubectl get svc kubia-nodeport</span><br><span class="line">NAME             TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubia-nodeport   NodePort   10.107.251.184   &lt;none&gt;        80:30123/TCP   92s</span><br></pre></td></tr></table></figure>
<p>因为我是通过Docker-desktop for mac在本地搭建环境，所以可以通过<code>localhost:30123</code>进行访问</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % curl localhost:30123</span><br><span class="line">You've hit kubia-695cf</span><br></pre></td></tr></table></figure>
<p>如下图显示了服务暴露在两个集群节点的端口30123上。到达任何一个端口的传入连接将被重定向到一个随机选择的pod，该pod是否位于接收到连接的节点上是不确定的。</p>
<p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/6.png" alt="6"></p>
<h5 id="创建LoadBalance服务"><a href="#创建LoadBalance服务" class="headerlink" title="创建LoadBalance服务"></a>创建LoadBalance服务</h5><p>创建一个名为<code>kubia-svc-loadbalancer.yaml</code>的YAML文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-loadbalancer</span><br><span class="line">spec:</span><br><span class="line">  type: LoadBalancer </span><br><span class="line">  ports:</span><br><span class="line">  - port: 80  </span><br><span class="line">    targetPort: 8080  </span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure>
<p>创建该服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f kubia-svc-loadbalancer.yaml</span><br></pre></td></tr></table></figure>
<p>如下图所示为外部客户端连接一个LoadBalancer服务</p>
<p><img src="/2021/10/07/Kubernetes-in-Action-Learning-Notes/7.png" alt="7"></p>
<h4 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h4><p>就绪探测器会定期调用，并确定特定的pod是否接受客户端的请求，当容器的准备就绪探测返回成功时，表示容器已经准备好接收请求。</p>
<h5 id="就绪探针类型"><a href="#就绪探针类型" class="headerlink" title="就绪探针类型"></a>就绪探针类型</h5><ul>
<li>Exec探针，执行进程的地方。容器的状态由进程的退出状态代码确定</li>
<li>HTTP GET探针，向容器发送HTTP GET请求，通过响应的HTTP状态码判断容器是否准备好</li>
<li>TCP socket探针，打开一个TCP连接到容器的指定端口，如果连接已建立，则认为容器已准备就绪</li>
</ul>
<h4 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h4><p>Kubernetes的卷时pod的一个组成部分，因此像容器一样在pod的规范中就定义了，它们不是独立的Kubernetes对象，也不能单出创建或删除，pod中的所有容器都可以使用卷，但必须先将它挂载在每个需要访问它的容器中，在每个容器中，都可以在其文件系统的任意位置挂载卷。</p>
<h5 id="卷类型"><a href="#卷类型" class="headerlink" title="卷类型"></a>卷类型</h5><ul>
<li>emptyDir：用于存储临时数据的简单空目录</li>
<li>hostPath：用于将目录从工作节点的文件系统挂载到pod中</li>
<li>gitRepo：通过检出Git仓库的内容来初始化的卷</li>
<li>nfs：挂载到pod中的NFS共享卷</li>
<li>gcePersistentDisk：Google高效能型存储磁盘卷</li>
<li>cinder、cephfs、iscsi、flocker、glusterfs、quobyte、rbd、flexVolume、vsphere-Volume、photonPersistentDisk、scaleIO用于挂载其他类型的网络存储</li>
<li>configMap、secret、downwordAPI：用于将Kubernetes部分资源和集群信息公开给pod的特殊类型的卷</li>
<li>persistentVolumeClaim：一种使用预置或者动态配置的持久存储类型</li>
</ul>
<h5 id="在pod中使用emptyDir卷"><a href="#在pod中使用emptyDir卷" class="headerlink" title="在pod中使用emptyDir卷"></a>在pod中使用emptyDir卷</h5><p>现在有两个镜像需要运行在pod上，首先创建一个名为<code>fortune-pod.yaml</code>的文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/fortune</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">html-generator</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/htdocs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>pod包含两个容器和一个挂载在两个容器中的共用的卷，但在不同的路径上。当<code>html-generator</code>容器启动时，它每10秒启动一次fortune命令输出到<code>var/htdocs/index.html</code>文件，因为卷是在<code>/var/htdocs</code>上挂载的，所以<code>index.html</code>文件被写入卷中，而不是容器的顶层，一旦<code>web-server</code>容器启动，他就开始为<code>/usr/share/nginx/html</code>目录中的任意HTML文件提供服务，因为我们将卷挂载在那个确切的位置，Nginx将为运行fortune循环的容器输出的<code>index.html</code>文件提供服务，最终的效果是，一个客户端向pod上的80端口发送一个HTTP请求，将接收当前的fortune消息作为响应。</p>
<p>为了查看fortune消息，需要启动对pod的访问，可以尝试将端口从本地机器转发到pod来实现</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro DockerTest % kubectl port-forward fortune 8080:80</span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 80</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 80</span><br></pre></td></tr></table></figure>
<p>使用<code>curl</code>命令访问Nginx服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">All things that are, are with more spirit chased than enjoyed.</span><br><span class="line">		-- Shakespeare, "Merchant of Venice"</span><br><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">A horse!  A horse!  My kingdom for a horse!</span><br><span class="line">		-- Wm. Shakespeare, "Richard III"</span><br><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">Avoid gunfire in the bathroom tonight.</span><br><span class="line">caoyifan@MacBookPro ~ % curl localhost:8080</span><br><span class="line">For courage mounteth with occasion.</span><br><span class="line">		-- William Shakespeare, "King John"</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Notes/" rel="tag"># Notes</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/05/Linux系统编程-二/" rel="next" title="Linux系统编程(二)">
                <i class="fa fa-chevron-left"></i> Linux系统编程(二)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/10/11/Docker构建多容器应用栈/" rel="prev" title="Docker构建多容器应用栈">
                Docker构建多容器应用栈 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/author1.png" alt="elssm">
            
              <p class="site-author-name" itemprop="name">elssm</p>
              <p class="site-description motion-element" itemprop="description">web安全 对抗攻击 go/python</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/elssm" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://elssm.lofter.com" target="_blank" title="Lofter">
                      
                        <i class="fa fa-fw fa-globe"></i>Lofter</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存活探针"><span class="nav-number">2.</span> <span class="nav-text">存活探针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Kubernetes三种探测容器的机制"><span class="nav-number">2.1.</span> <span class="nav-text">Kubernetes三种探测容器的机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建基于HTTP的存活探针"><span class="nav-number">2.2.</span> <span class="nav-text">创建基于HTTP的存活探针</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReplicationController"><span class="nav-number">3.</span> <span class="nav-text">ReplicationController</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ReplicationController介绍"><span class="nav-number">3.1.</span> <span class="nav-text">ReplicationController介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReplicationController协调流程"><span class="nav-number">3.2.</span> <span class="nav-text">ReplicationController协调流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReplicationController组成"><span class="nav-number">3.3.</span> <span class="nav-text">ReplicationController组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建ReplicationController"><span class="nav-number">3.4.</span> <span class="nav-text">创建ReplicationController</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ReplicationController扩容"><span class="nav-number">3.5.</span> <span class="nav-text">ReplicationController扩容</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#第一种方法"><span class="nav-number">3.5.1.</span> <span class="nav-text">第一种方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#第二种方法"><span class="nav-number">3.5.2.</span> <span class="nav-text">第二种方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除ReplicationController"><span class="nav-number">3.6.</span> <span class="nav-text">删除ReplicationController</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReplicaSet"><span class="nav-number">4.</span> <span class="nav-text">ReplicaSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义ReplicaSet"><span class="nav-number">4.1.</span> <span class="nav-text">定义ReplicaSet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建和检查ReplicaSet"><span class="nav-number">4.2.</span> <span class="nav-text">创建和检查ReplicaSet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除ReplicaSet"><span class="nav-number">4.3.</span> <span class="nav-text">删除ReplicaSet</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DaemonSet"><span class="nav-number">5.</span> <span class="nav-text">DaemonSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一个例子"><span class="nav-number">5.1.</span> <span class="nav-text">一个例子</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Job"><span class="nav-number">6.</span> <span class="nav-text">Job</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#定义Job资源"><span class="nav-number">6.1.</span> <span class="nav-text">定义Job资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在Job中运行多个pod实例"><span class="nav-number">6.2.</span> <span class="nav-text">在Job中运行多个pod实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#限制job-pod完成任务的时间"><span class="nav-number">6.3.</span> <span class="nav-text">限制job pod完成任务的时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务"><span class="nav-number">7.</span> <span class="nav-text">服务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建服务"><span class="nav-number">7.1.</span> <span class="nav-text">创建服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从内部集群测试服务"><span class="nav-number">7.2.</span> <span class="nav-text">从内部集群测试服务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务发现"><span class="nav-number">8.</span> <span class="nav-text">服务发现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#通过环境变量发现服务"><span class="nav-number">8.1.</span> <span class="nav-text">通过环境变量发现服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通过DNS发现服务"><span class="nav-number">8.2.</span> <span class="nav-text">通过DNS发现服务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将服务暴露给外部客户端"><span class="nav-number">9.</span> <span class="nav-text">将服务暴露给外部客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建NodePort类型的服务"><span class="nav-number">9.1.</span> <span class="nav-text">创建NodePort类型的服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建LoadBalance服务"><span class="nav-number">9.2.</span> <span class="nav-text">创建LoadBalance服务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#就绪探针"><span class="nav-number">10.</span> <span class="nav-text">就绪探针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#就绪探针类型"><span class="nav-number">10.1.</span> <span class="nav-text">就绪探针类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#卷"><span class="nav-number">11.</span> <span class="nav-text">卷</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#卷类型"><span class="nav-number">11.1.</span> <span class="nav-text">卷类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在pod中使用emptyDir卷"><span class="nav-number">11.2.</span> <span class="nav-text">在pod中使用emptyDir卷</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">elssm</span>

  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div>



<span id="busuanzi_container_site_pv" class="theme-info">
&nbsp;&nbsp;|&nbsp;&nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span id="busuanzi_container_site_uv" class="theme-info">
&nbsp;&nbsp;|&nbsp;&nbsp;本站访客数<span id="busuanzi_value_site_uv"></span>人次
  </span>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
